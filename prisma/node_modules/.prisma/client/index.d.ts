
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model langue
 * 
 */
export type langue = $Result.DefaultSelection<Prisma.$languePayload>
/**
 * Model translation
 * 
 */
export type translation = $Result.DefaultSelection<Prisma.$translationPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model shiny_hunting_method
 * 
 */
export type shiny_hunting_method = $Result.DefaultSelection<Prisma.$shiny_hunting_methodPayload>
/**
 * Model pokeball
 * 
 */
export type pokeball = $Result.DefaultSelection<Prisma.$pokeballPayload>
/**
 * Model generation
 * 
 */
export type generation = $Result.DefaultSelection<Prisma.$generationPayload>
/**
 * Model game
 * 
 */
export type game = $Result.DefaultSelection<Prisma.$gamePayload>
/**
 * Model game_group_game
 * 
 */
export type game_group_game = $Result.DefaultSelection<Prisma.$game_group_gamePayload>
/**
 * Model group_game
 * 
 */
export type group_game = $Result.DefaultSelection<Prisma.$group_gamePayload>
/**
 * Model capsule_game_capacity_info
 * 
 */
export type capsule_game_capacity_info = $Result.DefaultSelection<Prisma.$capsule_game_capacity_infoPayload>
/**
 * Model pokemon_category
 * 
 */
export type pokemon_category = $Result.DefaultSelection<Prisma.$pokemon_categoryPayload>
/**
 * Model pokemon
 * 
 */
export type pokemon = $Result.DefaultSelection<Prisma.$pokemonPayload>
/**
 * Model gender
 * 
 */
export type gender = $Result.DefaultSelection<Prisma.$genderPayload>
/**
 * Model form
 * 
 */
export type form = $Result.DefaultSelection<Prisma.$formPayload>
/**
 * Model pokemon_form_gender
 * 
 */
export type pokemon_form_gender = $Result.DefaultSelection<Prisma.$pokemon_form_genderPayload>
/**
 * Model pokemon_form
 * 
 */
export type pokemon_form = $Result.DefaultSelection<Prisma.$pokemon_formPayload>
/**
 * Model owned_pokemon
 * 
 */
export type owned_pokemon = $Result.DefaultSelection<Prisma.$owned_pokemonPayload>
/**
 * Model owned_pokemon_detail
 * 
 */
export type owned_pokemon_detail = $Result.DefaultSelection<Prisma.$owned_pokemon_detailPayload>
/**
 * Model ability
 * 
 */
export type ability = $Result.DefaultSelection<Prisma.$abilityPayload>
/**
 * Model ability_info
 * 
 */
export type ability_info = $Result.DefaultSelection<Prisma.$ability_infoPayload>
/**
 * Model pokemon_info
 * 
 */
export type pokemon_info = $Result.DefaultSelection<Prisma.$pokemon_infoPayload>
/**
 * Model ability_order
 * 
 */
export type ability_order = $Result.DefaultSelection<Prisma.$ability_orderPayload>
/**
 * Model evolution_method
 * 
 */
export type evolution_method = $Result.DefaultSelection<Prisma.$evolution_methodPayload>
/**
 * Model evolution
 * 
 */
export type evolution = $Result.DefaultSelection<Prisma.$evolutionPayload>
/**
 * Model evolution_info
 * 
 */
export type evolution_info = $Result.DefaultSelection<Prisma.$evolution_infoPayload>
/**
 * Model egg_group
 * 
 */
export type egg_group = $Result.DefaultSelection<Prisma.$egg_groupPayload>
/**
 * Model egg_group_order
 * 
 */
export type egg_group_order = $Result.DefaultSelection<Prisma.$egg_group_orderPayload>
/**
 * Model type
 * 
 */
export type type = $Result.DefaultSelection<Prisma.$typePayload>
/**
 * Model type_order
 * 
 */
export type type_order = $Result.DefaultSelection<Prisma.$type_orderPayload>
/**
 * Model national_number
 * 
 */
export type national_number = $Result.DefaultSelection<Prisma.$national_numberPayload>
/**
 * Model land
 * 
 */
export type land = $Result.DefaultSelection<Prisma.$landPayload>
/**
 * Model capacity
 * 
 */
export type capacity = $Result.DefaultSelection<Prisma.$capacityPayload>
/**
 * Model capacity_effect
 * 
 */
export type capacity_effect = $Result.DefaultSelection<Prisma.$capacity_effectPayload>
/**
 * Model capacity_category
 * 
 */
export type capacity_category = $Result.DefaultSelection<Prisma.$capacity_categoryPayload>
/**
 * Model capsule
 * 
 */
export type capsule = $Result.DefaultSelection<Prisma.$capsulePayload>
/**
 * Model detail
 * 
 */
export type detail = $Result.DefaultSelection<Prisma.$detailPayload>
/**
 * Model effect_outside_fight
 * 
 */
export type effect_outside_fight = $Result.DefaultSelection<Prisma.$effect_outside_fightPayload>
/**
 * Model influence
 * 
 */
export type influence = $Result.DefaultSelection<Prisma.$influencePayload>
/**
 * Model location
 * 
 */
export type location = $Result.DefaultSelection<Prisma.$locationPayload>
/**
 * Model zone
 * 
 */
export type zone = $Result.DefaultSelection<Prisma.$zonePayload>
/**
 * Model location_zone
 * 
 */
export type location_zone = $Result.DefaultSelection<Prisma.$location_zonePayload>
/**
 * Model meteo
 * 
 */
export type meteo = $Result.DefaultSelection<Prisma.$meteoPayload>
/**
 * Model pokemon_obtation
 * 
 */
export type pokemon_obtation = $Result.DefaultSelection<Prisma.$pokemon_obtationPayload>
/**
 * Model rate
 * 
 */
export type rate = $Result.DefaultSelection<Prisma.$ratePayload>
/**
 * Model shiny_hunting_method_game
 * 
 */
export type shiny_hunting_method_game = $Result.DefaultSelection<Prisma.$shiny_hunting_method_gamePayload>
/**
 * Model shiny_hunting_method_rate
 * 
 */
export type shiny_hunting_method_rate = $Result.DefaultSelection<Prisma.$shiny_hunting_method_ratePayload>
/**
 * Model skill_obtation_type
 * 
 */
export type skill_obtation_type = $Result.DefaultSelection<Prisma.$skill_obtation_typePayload>
/**
 * Model statistic
 * 
 */
export type statistic = $Result.DefaultSelection<Prisma.$statisticPayload>
/**
 * Model statistic_group_game
 * 
 */
export type statistic_group_game = $Result.DefaultSelection<Prisma.$statistic_group_gamePayload>
/**
 * Model target
 * 
 */
export type target = $Result.DefaultSelection<Prisma.$targetPayload>
/**
 * Model capacity_info
 * 
 */
export type capacity_info = $Result.DefaultSelection<Prisma.$capacity_infoPayload>
/**
 * Model capacity_info_influence
 * 
 */
export type capacity_info_influence = $Result.DefaultSelection<Prisma.$capacity_info_influencePayload>
/**
 * Model pokemon_game_location
 * 
 */
export type pokemon_game_location = $Result.DefaultSelection<Prisma.$pokemon_game_locationPayload>
/**
 * Model skill_obtation
 * 
 */
export type skill_obtation = $Result.DefaultSelection<Prisma.$skill_obtationPayload>
/**
 * Model refresh_token
 * 
 */
export type refresh_token = $Result.DefaultSelection<Prisma.$refresh_tokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const role: {
  PUBLIC: 'PUBLIC',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type role = (typeof role)[keyof typeof role]


export const reference_table: {
  TYPE: 'TYPE',
  POKEMON_CATEGORY: 'POKEMON_CATEGORY',
  GAME: 'GAME',
  POKEMON: 'POKEMON',
  CAPACITY: 'CAPACITY',
  CATEGORY_CAPACITY: 'CATEGORY_CAPACITY',
  INFLUENCE: 'INFLUENCE',
  SKILL_OBTENTION_TYPE: 'SKILL_OBTENTION_TYPE',
  CAPSULE: 'CAPSULE',
  EFFECT_OUTSIDE_FIGHT: 'EFFECT_OUTSIDE_FIGHT',
  CAPACITY_EFFECT: 'CAPACITY_EFFECT',
  TARGET: 'TARGET',
  POKEMON_OBTENTION: 'POKEMON_OBTENTION',
  METEO: 'METEO',
  SHINY_HUNTING_METHOD: 'SHINY_HUNTING_METHOD',
  DETAIL: 'DETAIL',
  POKEBALL: 'POKEBALL',
  EGG_GROUP: 'EGG_GROUP',
  EVOLUTION_METHOD: 'EVOLUTION_METHOD',
  ZONE: 'ZONE',
  LOCATION: 'LOCATION',
  LAND: 'LAND',
  EVOLUTION_INFO: 'EVOLUTION_INFO',
  ABILITY: 'ABILITY',
  GROUP_GAME: 'GROUP_GAME',
  FORM: 'FORM',
  GENDER: 'GENDER'
};

export type reference_table = (typeof reference_table)[keyof typeof reference_table]

}

export type role = $Enums.role

export const role: typeof $Enums.role

export type reference_table = $Enums.reference_table

export const reference_table: typeof $Enums.reference_table

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Langues
 * const langues = await prisma.langue.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Langues
   * const langues = await prisma.langue.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.langue`: Exposes CRUD operations for the **langue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Langues
    * const langues = await prisma.langue.findMany()
    * ```
    */
  get langue(): Prisma.langueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.translation`: Exposes CRUD operations for the **translation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Translations
    * const translations = await prisma.translation.findMany()
    * ```
    */
  get translation(): Prisma.translationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shiny_hunting_method`: Exposes CRUD operations for the **shiny_hunting_method** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shiny_hunting_methods
    * const shiny_hunting_methods = await prisma.shiny_hunting_method.findMany()
    * ```
    */
  get shiny_hunting_method(): Prisma.shiny_hunting_methodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokeball`: Exposes CRUD operations for the **pokeball** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pokeballs
    * const pokeballs = await prisma.pokeball.findMany()
    * ```
    */
  get pokeball(): Prisma.pokeballDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.generation`: Exposes CRUD operations for the **generation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Generations
    * const generations = await prisma.generation.findMany()
    * ```
    */
  get generation(): Prisma.generationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.gameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game_group_game`: Exposes CRUD operations for the **game_group_game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Game_group_games
    * const game_group_games = await prisma.game_group_game.findMany()
    * ```
    */
  get game_group_game(): Prisma.game_group_gameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group_game`: Exposes CRUD operations for the **group_game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Group_games
    * const group_games = await prisma.group_game.findMany()
    * ```
    */
  get group_game(): Prisma.group_gameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capsule_game_capacity_info`: Exposes CRUD operations for the **capsule_game_capacity_info** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Capsule_game_capacity_infos
    * const capsule_game_capacity_infos = await prisma.capsule_game_capacity_info.findMany()
    * ```
    */
  get capsule_game_capacity_info(): Prisma.capsule_game_capacity_infoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemon_category`: Exposes CRUD operations for the **pokemon_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pokemon_categories
    * const pokemon_categories = await prisma.pokemon_category.findMany()
    * ```
    */
  get pokemon_category(): Prisma.pokemon_categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemon`: Exposes CRUD operations for the **pokemon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pokemon
    * const pokemon = await prisma.pokemon.findMany()
    * ```
    */
  get pokemon(): Prisma.pokemonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gender`: Exposes CRUD operations for the **gender** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genders
    * const genders = await prisma.gender.findMany()
    * ```
    */
  get gender(): Prisma.genderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.form`: Exposes CRUD operations for the **form** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Forms
    * const forms = await prisma.form.findMany()
    * ```
    */
  get form(): Prisma.formDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemon_form_gender`: Exposes CRUD operations for the **pokemon_form_gender** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pokemon_form_genders
    * const pokemon_form_genders = await prisma.pokemon_form_gender.findMany()
    * ```
    */
  get pokemon_form_gender(): Prisma.pokemon_form_genderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemon_form`: Exposes CRUD operations for the **pokemon_form** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pokemon_forms
    * const pokemon_forms = await prisma.pokemon_form.findMany()
    * ```
    */
  get pokemon_form(): Prisma.pokemon_formDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.owned_pokemon`: Exposes CRUD operations for the **owned_pokemon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Owned_pokemon
    * const owned_pokemon = await prisma.owned_pokemon.findMany()
    * ```
    */
  get owned_pokemon(): Prisma.owned_pokemonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.owned_pokemon_detail`: Exposes CRUD operations for the **owned_pokemon_detail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Owned_pokemon_details
    * const owned_pokemon_details = await prisma.owned_pokemon_detail.findMany()
    * ```
    */
  get owned_pokemon_detail(): Prisma.owned_pokemon_detailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ability`: Exposes CRUD operations for the **ability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Abilities
    * const abilities = await prisma.ability.findMany()
    * ```
    */
  get ability(): Prisma.abilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ability_info`: Exposes CRUD operations for the **ability_info** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ability_infos
    * const ability_infos = await prisma.ability_info.findMany()
    * ```
    */
  get ability_info(): Prisma.ability_infoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemon_info`: Exposes CRUD operations for the **pokemon_info** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pokemon_infos
    * const pokemon_infos = await prisma.pokemon_info.findMany()
    * ```
    */
  get pokemon_info(): Prisma.pokemon_infoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ability_order`: Exposes CRUD operations for the **ability_order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ability_orders
    * const ability_orders = await prisma.ability_order.findMany()
    * ```
    */
  get ability_order(): Prisma.ability_orderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evolution_method`: Exposes CRUD operations for the **evolution_method** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evolution_methods
    * const evolution_methods = await prisma.evolution_method.findMany()
    * ```
    */
  get evolution_method(): Prisma.evolution_methodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evolution`: Exposes CRUD operations for the **evolution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evolutions
    * const evolutions = await prisma.evolution.findMany()
    * ```
    */
  get evolution(): Prisma.evolutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evolution_info`: Exposes CRUD operations for the **evolution_info** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evolution_infos
    * const evolution_infos = await prisma.evolution_info.findMany()
    * ```
    */
  get evolution_info(): Prisma.evolution_infoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.egg_group`: Exposes CRUD operations for the **egg_group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Egg_groups
    * const egg_groups = await prisma.egg_group.findMany()
    * ```
    */
  get egg_group(): Prisma.egg_groupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.egg_group_order`: Exposes CRUD operations for the **egg_group_order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Egg_group_orders
    * const egg_group_orders = await prisma.egg_group_order.findMany()
    * ```
    */
  get egg_group_order(): Prisma.egg_group_orderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.type`: Exposes CRUD operations for the **type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Types
    * const types = await prisma.type.findMany()
    * ```
    */
  get type(): Prisma.typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.type_order`: Exposes CRUD operations for the **type_order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Type_orders
    * const type_orders = await prisma.type_order.findMany()
    * ```
    */
  get type_order(): Prisma.type_orderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.national_number`: Exposes CRUD operations for the **national_number** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more National_numbers
    * const national_numbers = await prisma.national_number.findMany()
    * ```
    */
  get national_number(): Prisma.national_numberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.land`: Exposes CRUD operations for the **land** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lands
    * const lands = await prisma.land.findMany()
    * ```
    */
  get land(): Prisma.landDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capacity`: Exposes CRUD operations for the **capacity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Capacities
    * const capacities = await prisma.capacity.findMany()
    * ```
    */
  get capacity(): Prisma.capacityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capacity_effect`: Exposes CRUD operations for the **capacity_effect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Capacity_effects
    * const capacity_effects = await prisma.capacity_effect.findMany()
    * ```
    */
  get capacity_effect(): Prisma.capacity_effectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capacity_category`: Exposes CRUD operations for the **capacity_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Capacity_categories
    * const capacity_categories = await prisma.capacity_category.findMany()
    * ```
    */
  get capacity_category(): Prisma.capacity_categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capsule`: Exposes CRUD operations for the **capsule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Capsules
    * const capsules = await prisma.capsule.findMany()
    * ```
    */
  get capsule(): Prisma.capsuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.detail`: Exposes CRUD operations for the **detail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Details
    * const details = await prisma.detail.findMany()
    * ```
    */
  get detail(): Prisma.detailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.effect_outside_fight`: Exposes CRUD operations for the **effect_outside_fight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Effect_outside_fights
    * const effect_outside_fights = await prisma.effect_outside_fight.findMany()
    * ```
    */
  get effect_outside_fight(): Prisma.effect_outside_fightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.influence`: Exposes CRUD operations for the **influence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Influences
    * const influences = await prisma.influence.findMany()
    * ```
    */
  get influence(): Prisma.influenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.locationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.zoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location_zone`: Exposes CRUD operations for the **location_zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Location_zones
    * const location_zones = await prisma.location_zone.findMany()
    * ```
    */
  get location_zone(): Prisma.location_zoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meteo`: Exposes CRUD operations for the **meteo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meteos
    * const meteos = await prisma.meteo.findMany()
    * ```
    */
  get meteo(): Prisma.meteoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemon_obtation`: Exposes CRUD operations for the **pokemon_obtation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pokemon_obtations
    * const pokemon_obtations = await prisma.pokemon_obtation.findMany()
    * ```
    */
  get pokemon_obtation(): Prisma.pokemon_obtationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rate`: Exposes CRUD operations for the **rate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rates
    * const rates = await prisma.rate.findMany()
    * ```
    */
  get rate(): Prisma.rateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shiny_hunting_method_game`: Exposes CRUD operations for the **shiny_hunting_method_game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shiny_hunting_method_games
    * const shiny_hunting_method_games = await prisma.shiny_hunting_method_game.findMany()
    * ```
    */
  get shiny_hunting_method_game(): Prisma.shiny_hunting_method_gameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shiny_hunting_method_rate`: Exposes CRUD operations for the **shiny_hunting_method_rate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shiny_hunting_method_rates
    * const shiny_hunting_method_rates = await prisma.shiny_hunting_method_rate.findMany()
    * ```
    */
  get shiny_hunting_method_rate(): Prisma.shiny_hunting_method_rateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skill_obtation_type`: Exposes CRUD operations for the **skill_obtation_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skill_obtation_types
    * const skill_obtation_types = await prisma.skill_obtation_type.findMany()
    * ```
    */
  get skill_obtation_type(): Prisma.skill_obtation_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.statistic`: Exposes CRUD operations for the **statistic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Statistics
    * const statistics = await prisma.statistic.findMany()
    * ```
    */
  get statistic(): Prisma.statisticDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.statistic_group_game`: Exposes CRUD operations for the **statistic_group_game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Statistic_group_games
    * const statistic_group_games = await prisma.statistic_group_game.findMany()
    * ```
    */
  get statistic_group_game(): Prisma.statistic_group_gameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.target`: Exposes CRUD operations for the **target** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Targets
    * const targets = await prisma.target.findMany()
    * ```
    */
  get target(): Prisma.targetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capacity_info`: Exposes CRUD operations for the **capacity_info** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Capacity_infos
    * const capacity_infos = await prisma.capacity_info.findMany()
    * ```
    */
  get capacity_info(): Prisma.capacity_infoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capacity_info_influence`: Exposes CRUD operations for the **capacity_info_influence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Capacity_info_influences
    * const capacity_info_influences = await prisma.capacity_info_influence.findMany()
    * ```
    */
  get capacity_info_influence(): Prisma.capacity_info_influenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemon_game_location`: Exposes CRUD operations for the **pokemon_game_location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pokemon_game_locations
    * const pokemon_game_locations = await prisma.pokemon_game_location.findMany()
    * ```
    */
  get pokemon_game_location(): Prisma.pokemon_game_locationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skill_obtation`: Exposes CRUD operations for the **skill_obtation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skill_obtations
    * const skill_obtations = await prisma.skill_obtation.findMany()
    * ```
    */
  get skill_obtation(): Prisma.skill_obtationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refresh_token`: Exposes CRUD operations for the **refresh_token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refresh_tokens
    * const refresh_tokens = await prisma.refresh_token.findMany()
    * ```
    */
  get refresh_token(): Prisma.refresh_tokenDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    langue: 'langue',
    translation: 'translation',
    user: 'user',
    shiny_hunting_method: 'shiny_hunting_method',
    pokeball: 'pokeball',
    generation: 'generation',
    game: 'game',
    game_group_game: 'game_group_game',
    group_game: 'group_game',
    capsule_game_capacity_info: 'capsule_game_capacity_info',
    pokemon_category: 'pokemon_category',
    pokemon: 'pokemon',
    gender: 'gender',
    form: 'form',
    pokemon_form_gender: 'pokemon_form_gender',
    pokemon_form: 'pokemon_form',
    owned_pokemon: 'owned_pokemon',
    owned_pokemon_detail: 'owned_pokemon_detail',
    ability: 'ability',
    ability_info: 'ability_info',
    pokemon_info: 'pokemon_info',
    ability_order: 'ability_order',
    evolution_method: 'evolution_method',
    evolution: 'evolution',
    evolution_info: 'evolution_info',
    egg_group: 'egg_group',
    egg_group_order: 'egg_group_order',
    type: 'type',
    type_order: 'type_order',
    national_number: 'national_number',
    land: 'land',
    capacity: 'capacity',
    capacity_effect: 'capacity_effect',
    capacity_category: 'capacity_category',
    capsule: 'capsule',
    detail: 'detail',
    effect_outside_fight: 'effect_outside_fight',
    influence: 'influence',
    location: 'location',
    zone: 'zone',
    location_zone: 'location_zone',
    meteo: 'meteo',
    pokemon_obtation: 'pokemon_obtation',
    rate: 'rate',
    shiny_hunting_method_game: 'shiny_hunting_method_game',
    shiny_hunting_method_rate: 'shiny_hunting_method_rate',
    skill_obtation_type: 'skill_obtation_type',
    statistic: 'statistic',
    statistic_group_game: 'statistic_group_game',
    target: 'target',
    capacity_info: 'capacity_info',
    capacity_info_influence: 'capacity_info_influence',
    pokemon_game_location: 'pokemon_game_location',
    skill_obtation: 'skill_obtation',
    refresh_token: 'refresh_token'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "langue" | "translation" | "user" | "shiny_hunting_method" | "pokeball" | "generation" | "game" | "game_group_game" | "group_game" | "capsule_game_capacity_info" | "pokemon_category" | "pokemon" | "gender" | "form" | "pokemon_form_gender" | "pokemon_form" | "owned_pokemon" | "owned_pokemon_detail" | "ability" | "ability_info" | "pokemon_info" | "ability_order" | "evolution_method" | "evolution" | "evolution_info" | "egg_group" | "egg_group_order" | "type" | "type_order" | "national_number" | "land" | "capacity" | "capacity_effect" | "capacity_category" | "capsule" | "detail" | "effect_outside_fight" | "influence" | "location" | "zone" | "location_zone" | "meteo" | "pokemon_obtation" | "rate" | "shiny_hunting_method_game" | "shiny_hunting_method_rate" | "skill_obtation_type" | "statistic" | "statistic_group_game" | "target" | "capacity_info" | "capacity_info_influence" | "pokemon_game_location" | "skill_obtation" | "refresh_token"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      langue: {
        payload: Prisma.$languePayload<ExtArgs>
        fields: Prisma.langueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.langueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.langueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languePayload>
          }
          findFirst: {
            args: Prisma.langueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.langueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languePayload>
          }
          findMany: {
            args: Prisma.langueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languePayload>[]
          }
          create: {
            args: Prisma.langueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languePayload>
          }
          createMany: {
            args: Prisma.langueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.langueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languePayload>
          }
          update: {
            args: Prisma.langueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languePayload>
          }
          deleteMany: {
            args: Prisma.langueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.langueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.langueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languePayload>
          }
          aggregate: {
            args: Prisma.LangueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLangue>
          }
          groupBy: {
            args: Prisma.langueGroupByArgs<ExtArgs>
            result: $Utils.Optional<LangueGroupByOutputType>[]
          }
          count: {
            args: Prisma.langueCountArgs<ExtArgs>
            result: $Utils.Optional<LangueCountAggregateOutputType> | number
          }
        }
      }
      translation: {
        payload: Prisma.$translationPayload<ExtArgs>
        fields: Prisma.translationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.translationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$translationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.translationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$translationPayload>
          }
          findFirst: {
            args: Prisma.translationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$translationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.translationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$translationPayload>
          }
          findMany: {
            args: Prisma.translationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$translationPayload>[]
          }
          create: {
            args: Prisma.translationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$translationPayload>
          }
          createMany: {
            args: Prisma.translationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.translationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$translationPayload>
          }
          update: {
            args: Prisma.translationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$translationPayload>
          }
          deleteMany: {
            args: Prisma.translationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.translationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.translationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$translationPayload>
          }
          aggregate: {
            args: Prisma.TranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranslation>
          }
          groupBy: {
            args: Prisma.translationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.translationCountArgs<ExtArgs>
            result: $Utils.Optional<TranslationCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      shiny_hunting_method: {
        payload: Prisma.$shiny_hunting_methodPayload<ExtArgs>
        fields: Prisma.shiny_hunting_methodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.shiny_hunting_methodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_methodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.shiny_hunting_methodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_methodPayload>
          }
          findFirst: {
            args: Prisma.shiny_hunting_methodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_methodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.shiny_hunting_methodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_methodPayload>
          }
          findMany: {
            args: Prisma.shiny_hunting_methodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_methodPayload>[]
          }
          create: {
            args: Prisma.shiny_hunting_methodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_methodPayload>
          }
          createMany: {
            args: Prisma.shiny_hunting_methodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.shiny_hunting_methodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_methodPayload>
          }
          update: {
            args: Prisma.shiny_hunting_methodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_methodPayload>
          }
          deleteMany: {
            args: Prisma.shiny_hunting_methodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.shiny_hunting_methodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.shiny_hunting_methodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_methodPayload>
          }
          aggregate: {
            args: Prisma.Shiny_hunting_methodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiny_hunting_method>
          }
          groupBy: {
            args: Prisma.shiny_hunting_methodGroupByArgs<ExtArgs>
            result: $Utils.Optional<Shiny_hunting_methodGroupByOutputType>[]
          }
          count: {
            args: Prisma.shiny_hunting_methodCountArgs<ExtArgs>
            result: $Utils.Optional<Shiny_hunting_methodCountAggregateOutputType> | number
          }
        }
      }
      pokeball: {
        payload: Prisma.$pokeballPayload<ExtArgs>
        fields: Prisma.pokeballFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pokeballFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokeballPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pokeballFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokeballPayload>
          }
          findFirst: {
            args: Prisma.pokeballFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokeballPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pokeballFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokeballPayload>
          }
          findMany: {
            args: Prisma.pokeballFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokeballPayload>[]
          }
          create: {
            args: Prisma.pokeballCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokeballPayload>
          }
          createMany: {
            args: Prisma.pokeballCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pokeballDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokeballPayload>
          }
          update: {
            args: Prisma.pokeballUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokeballPayload>
          }
          deleteMany: {
            args: Prisma.pokeballDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pokeballUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pokeballUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokeballPayload>
          }
          aggregate: {
            args: Prisma.PokeballAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokeball>
          }
          groupBy: {
            args: Prisma.pokeballGroupByArgs<ExtArgs>
            result: $Utils.Optional<PokeballGroupByOutputType>[]
          }
          count: {
            args: Prisma.pokeballCountArgs<ExtArgs>
            result: $Utils.Optional<PokeballCountAggregateOutputType> | number
          }
        }
      }
      generation: {
        payload: Prisma.$generationPayload<ExtArgs>
        fields: Prisma.generationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.generationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.generationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generationPayload>
          }
          findFirst: {
            args: Prisma.generationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.generationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generationPayload>
          }
          findMany: {
            args: Prisma.generationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generationPayload>[]
          }
          create: {
            args: Prisma.generationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generationPayload>
          }
          createMany: {
            args: Prisma.generationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.generationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generationPayload>
          }
          update: {
            args: Prisma.generationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generationPayload>
          }
          deleteMany: {
            args: Prisma.generationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.generationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.generationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generationPayload>
          }
          aggregate: {
            args: Prisma.GenerationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeneration>
          }
          groupBy: {
            args: Prisma.generationGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenerationGroupByOutputType>[]
          }
          count: {
            args: Prisma.generationCountArgs<ExtArgs>
            result: $Utils.Optional<GenerationCountAggregateOutputType> | number
          }
        }
      }
      game: {
        payload: Prisma.$gamePayload<ExtArgs>
        fields: Prisma.gameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload>
          }
          findFirst: {
            args: Prisma.gameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload>
          }
          findMany: {
            args: Prisma.gameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload>[]
          }
          create: {
            args: Prisma.gameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload>
          }
          createMany: {
            args: Prisma.gameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.gameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload>
          }
          update: {
            args: Prisma.gameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload>
          }
          deleteMany: {
            args: Prisma.gameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.gameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.gameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.gameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      game_group_game: {
        payload: Prisma.$game_group_gamePayload<ExtArgs>
        fields: Prisma.game_group_gameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.game_group_gameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_group_gamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.game_group_gameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_group_gamePayload>
          }
          findFirst: {
            args: Prisma.game_group_gameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_group_gamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.game_group_gameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_group_gamePayload>
          }
          findMany: {
            args: Prisma.game_group_gameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_group_gamePayload>[]
          }
          create: {
            args: Prisma.game_group_gameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_group_gamePayload>
          }
          createMany: {
            args: Prisma.game_group_gameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.game_group_gameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_group_gamePayload>
          }
          update: {
            args: Prisma.game_group_gameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_group_gamePayload>
          }
          deleteMany: {
            args: Prisma.game_group_gameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.game_group_gameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.game_group_gameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_group_gamePayload>
          }
          aggregate: {
            args: Prisma.Game_group_gameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame_group_game>
          }
          groupBy: {
            args: Prisma.game_group_gameGroupByArgs<ExtArgs>
            result: $Utils.Optional<Game_group_gameGroupByOutputType>[]
          }
          count: {
            args: Prisma.game_group_gameCountArgs<ExtArgs>
            result: $Utils.Optional<Game_group_gameCountAggregateOutputType> | number
          }
        }
      }
      group_game: {
        payload: Prisma.$group_gamePayload<ExtArgs>
        fields: Prisma.group_gameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.group_gameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_gamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.group_gameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_gamePayload>
          }
          findFirst: {
            args: Prisma.group_gameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_gamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.group_gameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_gamePayload>
          }
          findMany: {
            args: Prisma.group_gameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_gamePayload>[]
          }
          create: {
            args: Prisma.group_gameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_gamePayload>
          }
          createMany: {
            args: Prisma.group_gameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.group_gameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_gamePayload>
          }
          update: {
            args: Prisma.group_gameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_gamePayload>
          }
          deleteMany: {
            args: Prisma.group_gameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.group_gameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.group_gameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_gamePayload>
          }
          aggregate: {
            args: Prisma.Group_gameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup_game>
          }
          groupBy: {
            args: Prisma.group_gameGroupByArgs<ExtArgs>
            result: $Utils.Optional<Group_gameGroupByOutputType>[]
          }
          count: {
            args: Prisma.group_gameCountArgs<ExtArgs>
            result: $Utils.Optional<Group_gameCountAggregateOutputType> | number
          }
        }
      }
      capsule_game_capacity_info: {
        payload: Prisma.$capsule_game_capacity_infoPayload<ExtArgs>
        fields: Prisma.capsule_game_capacity_infoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.capsule_game_capacity_infoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsule_game_capacity_infoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.capsule_game_capacity_infoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsule_game_capacity_infoPayload>
          }
          findFirst: {
            args: Prisma.capsule_game_capacity_infoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsule_game_capacity_infoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.capsule_game_capacity_infoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsule_game_capacity_infoPayload>
          }
          findMany: {
            args: Prisma.capsule_game_capacity_infoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsule_game_capacity_infoPayload>[]
          }
          create: {
            args: Prisma.capsule_game_capacity_infoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsule_game_capacity_infoPayload>
          }
          createMany: {
            args: Prisma.capsule_game_capacity_infoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.capsule_game_capacity_infoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsule_game_capacity_infoPayload>
          }
          update: {
            args: Prisma.capsule_game_capacity_infoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsule_game_capacity_infoPayload>
          }
          deleteMany: {
            args: Prisma.capsule_game_capacity_infoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.capsule_game_capacity_infoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.capsule_game_capacity_infoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsule_game_capacity_infoPayload>
          }
          aggregate: {
            args: Prisma.Capsule_game_capacity_infoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapsule_game_capacity_info>
          }
          groupBy: {
            args: Prisma.capsule_game_capacity_infoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Capsule_game_capacity_infoGroupByOutputType>[]
          }
          count: {
            args: Prisma.capsule_game_capacity_infoCountArgs<ExtArgs>
            result: $Utils.Optional<Capsule_game_capacity_infoCountAggregateOutputType> | number
          }
        }
      }
      pokemon_category: {
        payload: Prisma.$pokemon_categoryPayload<ExtArgs>
        fields: Prisma.pokemon_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pokemon_categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pokemon_categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_categoryPayload>
          }
          findFirst: {
            args: Prisma.pokemon_categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pokemon_categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_categoryPayload>
          }
          findMany: {
            args: Prisma.pokemon_categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_categoryPayload>[]
          }
          create: {
            args: Prisma.pokemon_categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_categoryPayload>
          }
          createMany: {
            args: Prisma.pokemon_categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pokemon_categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_categoryPayload>
          }
          update: {
            args: Prisma.pokemon_categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_categoryPayload>
          }
          deleteMany: {
            args: Prisma.pokemon_categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pokemon_categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pokemon_categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_categoryPayload>
          }
          aggregate: {
            args: Prisma.Pokemon_categoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemon_category>
          }
          groupBy: {
            args: Prisma.pokemon_categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pokemon_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.pokemon_categoryCountArgs<ExtArgs>
            result: $Utils.Optional<Pokemon_categoryCountAggregateOutputType> | number
          }
        }
      }
      pokemon: {
        payload: Prisma.$pokemonPayload<ExtArgs>
        fields: Prisma.pokemonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pokemonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pokemonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemonPayload>
          }
          findFirst: {
            args: Prisma.pokemonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pokemonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemonPayload>
          }
          findMany: {
            args: Prisma.pokemonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemonPayload>[]
          }
          create: {
            args: Prisma.pokemonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemonPayload>
          }
          createMany: {
            args: Prisma.pokemonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pokemonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemonPayload>
          }
          update: {
            args: Prisma.pokemonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemonPayload>
          }
          deleteMany: {
            args: Prisma.pokemonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pokemonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pokemonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemonPayload>
          }
          aggregate: {
            args: Prisma.PokemonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemon>
          }
          groupBy: {
            args: Prisma.pokemonGroupByArgs<ExtArgs>
            result: $Utils.Optional<PokemonGroupByOutputType>[]
          }
          count: {
            args: Prisma.pokemonCountArgs<ExtArgs>
            result: $Utils.Optional<PokemonCountAggregateOutputType> | number
          }
        }
      }
      gender: {
        payload: Prisma.$genderPayload<ExtArgs>
        fields: Prisma.genderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.genderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.genderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genderPayload>
          }
          findFirst: {
            args: Prisma.genderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.genderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genderPayload>
          }
          findMany: {
            args: Prisma.genderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genderPayload>[]
          }
          create: {
            args: Prisma.genderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genderPayload>
          }
          createMany: {
            args: Prisma.genderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.genderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genderPayload>
          }
          update: {
            args: Prisma.genderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genderPayload>
          }
          deleteMany: {
            args: Prisma.genderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.genderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.genderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genderPayload>
          }
          aggregate: {
            args: Prisma.GenderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGender>
          }
          groupBy: {
            args: Prisma.genderGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenderGroupByOutputType>[]
          }
          count: {
            args: Prisma.genderCountArgs<ExtArgs>
            result: $Utils.Optional<GenderCountAggregateOutputType> | number
          }
        }
      }
      form: {
        payload: Prisma.$formPayload<ExtArgs>
        fields: Prisma.formFieldRefs
        operations: {
          findUnique: {
            args: Prisma.formFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.formFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formPayload>
          }
          findFirst: {
            args: Prisma.formFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.formFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formPayload>
          }
          findMany: {
            args: Prisma.formFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formPayload>[]
          }
          create: {
            args: Prisma.formCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formPayload>
          }
          createMany: {
            args: Prisma.formCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.formDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formPayload>
          }
          update: {
            args: Prisma.formUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formPayload>
          }
          deleteMany: {
            args: Prisma.formDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.formUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.formUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formPayload>
          }
          aggregate: {
            args: Prisma.FormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForm>
          }
          groupBy: {
            args: Prisma.formGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormGroupByOutputType>[]
          }
          count: {
            args: Prisma.formCountArgs<ExtArgs>
            result: $Utils.Optional<FormCountAggregateOutputType> | number
          }
        }
      }
      pokemon_form_gender: {
        payload: Prisma.$pokemon_form_genderPayload<ExtArgs>
        fields: Prisma.pokemon_form_genderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pokemon_form_genderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_form_genderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pokemon_form_genderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_form_genderPayload>
          }
          findFirst: {
            args: Prisma.pokemon_form_genderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_form_genderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pokemon_form_genderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_form_genderPayload>
          }
          findMany: {
            args: Prisma.pokemon_form_genderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_form_genderPayload>[]
          }
          create: {
            args: Prisma.pokemon_form_genderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_form_genderPayload>
          }
          createMany: {
            args: Prisma.pokemon_form_genderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pokemon_form_genderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_form_genderPayload>
          }
          update: {
            args: Prisma.pokemon_form_genderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_form_genderPayload>
          }
          deleteMany: {
            args: Prisma.pokemon_form_genderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pokemon_form_genderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pokemon_form_genderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_form_genderPayload>
          }
          aggregate: {
            args: Prisma.Pokemon_form_genderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemon_form_gender>
          }
          groupBy: {
            args: Prisma.pokemon_form_genderGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pokemon_form_genderGroupByOutputType>[]
          }
          count: {
            args: Prisma.pokemon_form_genderCountArgs<ExtArgs>
            result: $Utils.Optional<Pokemon_form_genderCountAggregateOutputType> | number
          }
        }
      }
      pokemon_form: {
        payload: Prisma.$pokemon_formPayload<ExtArgs>
        fields: Prisma.pokemon_formFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pokemon_formFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_formPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pokemon_formFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_formPayload>
          }
          findFirst: {
            args: Prisma.pokemon_formFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_formPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pokemon_formFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_formPayload>
          }
          findMany: {
            args: Prisma.pokemon_formFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_formPayload>[]
          }
          create: {
            args: Prisma.pokemon_formCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_formPayload>
          }
          createMany: {
            args: Prisma.pokemon_formCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pokemon_formDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_formPayload>
          }
          update: {
            args: Prisma.pokemon_formUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_formPayload>
          }
          deleteMany: {
            args: Prisma.pokemon_formDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pokemon_formUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pokemon_formUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_formPayload>
          }
          aggregate: {
            args: Prisma.Pokemon_formAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemon_form>
          }
          groupBy: {
            args: Prisma.pokemon_formGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pokemon_formGroupByOutputType>[]
          }
          count: {
            args: Prisma.pokemon_formCountArgs<ExtArgs>
            result: $Utils.Optional<Pokemon_formCountAggregateOutputType> | number
          }
        }
      }
      owned_pokemon: {
        payload: Prisma.$owned_pokemonPayload<ExtArgs>
        fields: Prisma.owned_pokemonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.owned_pokemonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.owned_pokemonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemonPayload>
          }
          findFirst: {
            args: Prisma.owned_pokemonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.owned_pokemonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemonPayload>
          }
          findMany: {
            args: Prisma.owned_pokemonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemonPayload>[]
          }
          create: {
            args: Prisma.owned_pokemonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemonPayload>
          }
          createMany: {
            args: Prisma.owned_pokemonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.owned_pokemonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemonPayload>
          }
          update: {
            args: Prisma.owned_pokemonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemonPayload>
          }
          deleteMany: {
            args: Prisma.owned_pokemonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.owned_pokemonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.owned_pokemonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemonPayload>
          }
          aggregate: {
            args: Prisma.Owned_pokemonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwned_pokemon>
          }
          groupBy: {
            args: Prisma.owned_pokemonGroupByArgs<ExtArgs>
            result: $Utils.Optional<Owned_pokemonGroupByOutputType>[]
          }
          count: {
            args: Prisma.owned_pokemonCountArgs<ExtArgs>
            result: $Utils.Optional<Owned_pokemonCountAggregateOutputType> | number
          }
        }
      }
      owned_pokemon_detail: {
        payload: Prisma.$owned_pokemon_detailPayload<ExtArgs>
        fields: Prisma.owned_pokemon_detailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.owned_pokemon_detailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemon_detailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.owned_pokemon_detailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemon_detailPayload>
          }
          findFirst: {
            args: Prisma.owned_pokemon_detailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemon_detailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.owned_pokemon_detailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemon_detailPayload>
          }
          findMany: {
            args: Prisma.owned_pokemon_detailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemon_detailPayload>[]
          }
          create: {
            args: Prisma.owned_pokemon_detailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemon_detailPayload>
          }
          createMany: {
            args: Prisma.owned_pokemon_detailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.owned_pokemon_detailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemon_detailPayload>
          }
          update: {
            args: Prisma.owned_pokemon_detailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemon_detailPayload>
          }
          deleteMany: {
            args: Prisma.owned_pokemon_detailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.owned_pokemon_detailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.owned_pokemon_detailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$owned_pokemon_detailPayload>
          }
          aggregate: {
            args: Prisma.Owned_pokemon_detailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwned_pokemon_detail>
          }
          groupBy: {
            args: Prisma.owned_pokemon_detailGroupByArgs<ExtArgs>
            result: $Utils.Optional<Owned_pokemon_detailGroupByOutputType>[]
          }
          count: {
            args: Prisma.owned_pokemon_detailCountArgs<ExtArgs>
            result: $Utils.Optional<Owned_pokemon_detailCountAggregateOutputType> | number
          }
        }
      }
      ability: {
        payload: Prisma.$abilityPayload<ExtArgs>
        fields: Prisma.abilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.abilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$abilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.abilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$abilityPayload>
          }
          findFirst: {
            args: Prisma.abilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$abilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.abilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$abilityPayload>
          }
          findMany: {
            args: Prisma.abilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$abilityPayload>[]
          }
          create: {
            args: Prisma.abilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$abilityPayload>
          }
          createMany: {
            args: Prisma.abilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.abilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$abilityPayload>
          }
          update: {
            args: Prisma.abilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$abilityPayload>
          }
          deleteMany: {
            args: Prisma.abilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.abilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.abilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$abilityPayload>
          }
          aggregate: {
            args: Prisma.AbilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbility>
          }
          groupBy: {
            args: Prisma.abilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AbilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.abilityCountArgs<ExtArgs>
            result: $Utils.Optional<AbilityCountAggregateOutputType> | number
          }
        }
      }
      ability_info: {
        payload: Prisma.$ability_infoPayload<ExtArgs>
        fields: Prisma.ability_infoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ability_infoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_infoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ability_infoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_infoPayload>
          }
          findFirst: {
            args: Prisma.ability_infoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_infoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ability_infoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_infoPayload>
          }
          findMany: {
            args: Prisma.ability_infoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_infoPayload>[]
          }
          create: {
            args: Prisma.ability_infoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_infoPayload>
          }
          createMany: {
            args: Prisma.ability_infoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ability_infoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_infoPayload>
          }
          update: {
            args: Prisma.ability_infoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_infoPayload>
          }
          deleteMany: {
            args: Prisma.ability_infoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ability_infoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ability_infoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_infoPayload>
          }
          aggregate: {
            args: Prisma.Ability_infoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbility_info>
          }
          groupBy: {
            args: Prisma.ability_infoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ability_infoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ability_infoCountArgs<ExtArgs>
            result: $Utils.Optional<Ability_infoCountAggregateOutputType> | number
          }
        }
      }
      pokemon_info: {
        payload: Prisma.$pokemon_infoPayload<ExtArgs>
        fields: Prisma.pokemon_infoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pokemon_infoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_infoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pokemon_infoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_infoPayload>
          }
          findFirst: {
            args: Prisma.pokemon_infoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_infoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pokemon_infoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_infoPayload>
          }
          findMany: {
            args: Prisma.pokemon_infoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_infoPayload>[]
          }
          create: {
            args: Prisma.pokemon_infoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_infoPayload>
          }
          createMany: {
            args: Prisma.pokemon_infoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pokemon_infoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_infoPayload>
          }
          update: {
            args: Prisma.pokemon_infoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_infoPayload>
          }
          deleteMany: {
            args: Prisma.pokemon_infoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pokemon_infoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pokemon_infoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_infoPayload>
          }
          aggregate: {
            args: Prisma.Pokemon_infoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemon_info>
          }
          groupBy: {
            args: Prisma.pokemon_infoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pokemon_infoGroupByOutputType>[]
          }
          count: {
            args: Prisma.pokemon_infoCountArgs<ExtArgs>
            result: $Utils.Optional<Pokemon_infoCountAggregateOutputType> | number
          }
        }
      }
      ability_order: {
        payload: Prisma.$ability_orderPayload<ExtArgs>
        fields: Prisma.ability_orderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ability_orderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_orderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ability_orderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_orderPayload>
          }
          findFirst: {
            args: Prisma.ability_orderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_orderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ability_orderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_orderPayload>
          }
          findMany: {
            args: Prisma.ability_orderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_orderPayload>[]
          }
          create: {
            args: Prisma.ability_orderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_orderPayload>
          }
          createMany: {
            args: Prisma.ability_orderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ability_orderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_orderPayload>
          }
          update: {
            args: Prisma.ability_orderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_orderPayload>
          }
          deleteMany: {
            args: Prisma.ability_orderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ability_orderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ability_orderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ability_orderPayload>
          }
          aggregate: {
            args: Prisma.Ability_orderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbility_order>
          }
          groupBy: {
            args: Prisma.ability_orderGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ability_orderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ability_orderCountArgs<ExtArgs>
            result: $Utils.Optional<Ability_orderCountAggregateOutputType> | number
          }
        }
      }
      evolution_method: {
        payload: Prisma.$evolution_methodPayload<ExtArgs>
        fields: Prisma.evolution_methodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.evolution_methodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_methodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.evolution_methodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_methodPayload>
          }
          findFirst: {
            args: Prisma.evolution_methodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_methodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.evolution_methodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_methodPayload>
          }
          findMany: {
            args: Prisma.evolution_methodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_methodPayload>[]
          }
          create: {
            args: Prisma.evolution_methodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_methodPayload>
          }
          createMany: {
            args: Prisma.evolution_methodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.evolution_methodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_methodPayload>
          }
          update: {
            args: Prisma.evolution_methodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_methodPayload>
          }
          deleteMany: {
            args: Prisma.evolution_methodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.evolution_methodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.evolution_methodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_methodPayload>
          }
          aggregate: {
            args: Prisma.Evolution_methodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvolution_method>
          }
          groupBy: {
            args: Prisma.evolution_methodGroupByArgs<ExtArgs>
            result: $Utils.Optional<Evolution_methodGroupByOutputType>[]
          }
          count: {
            args: Prisma.evolution_methodCountArgs<ExtArgs>
            result: $Utils.Optional<Evolution_methodCountAggregateOutputType> | number
          }
        }
      }
      evolution: {
        payload: Prisma.$evolutionPayload<ExtArgs>
        fields: Prisma.evolutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.evolutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.evolutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolutionPayload>
          }
          findFirst: {
            args: Prisma.evolutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.evolutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolutionPayload>
          }
          findMany: {
            args: Prisma.evolutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolutionPayload>[]
          }
          create: {
            args: Prisma.evolutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolutionPayload>
          }
          createMany: {
            args: Prisma.evolutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.evolutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolutionPayload>
          }
          update: {
            args: Prisma.evolutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolutionPayload>
          }
          deleteMany: {
            args: Prisma.evolutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.evolutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.evolutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolutionPayload>
          }
          aggregate: {
            args: Prisma.EvolutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvolution>
          }
          groupBy: {
            args: Prisma.evolutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvolutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.evolutionCountArgs<ExtArgs>
            result: $Utils.Optional<EvolutionCountAggregateOutputType> | number
          }
        }
      }
      evolution_info: {
        payload: Prisma.$evolution_infoPayload<ExtArgs>
        fields: Prisma.evolution_infoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.evolution_infoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_infoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.evolution_infoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_infoPayload>
          }
          findFirst: {
            args: Prisma.evolution_infoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_infoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.evolution_infoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_infoPayload>
          }
          findMany: {
            args: Prisma.evolution_infoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_infoPayload>[]
          }
          create: {
            args: Prisma.evolution_infoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_infoPayload>
          }
          createMany: {
            args: Prisma.evolution_infoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.evolution_infoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_infoPayload>
          }
          update: {
            args: Prisma.evolution_infoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_infoPayload>
          }
          deleteMany: {
            args: Prisma.evolution_infoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.evolution_infoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.evolution_infoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evolution_infoPayload>
          }
          aggregate: {
            args: Prisma.Evolution_infoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvolution_info>
          }
          groupBy: {
            args: Prisma.evolution_infoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Evolution_infoGroupByOutputType>[]
          }
          count: {
            args: Prisma.evolution_infoCountArgs<ExtArgs>
            result: $Utils.Optional<Evolution_infoCountAggregateOutputType> | number
          }
        }
      }
      egg_group: {
        payload: Prisma.$egg_groupPayload<ExtArgs>
        fields: Prisma.egg_groupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.egg_groupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_groupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.egg_groupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_groupPayload>
          }
          findFirst: {
            args: Prisma.egg_groupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_groupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.egg_groupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_groupPayload>
          }
          findMany: {
            args: Prisma.egg_groupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_groupPayload>[]
          }
          create: {
            args: Prisma.egg_groupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_groupPayload>
          }
          createMany: {
            args: Prisma.egg_groupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.egg_groupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_groupPayload>
          }
          update: {
            args: Prisma.egg_groupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_groupPayload>
          }
          deleteMany: {
            args: Prisma.egg_groupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.egg_groupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.egg_groupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_groupPayload>
          }
          aggregate: {
            args: Prisma.Egg_groupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEgg_group>
          }
          groupBy: {
            args: Prisma.egg_groupGroupByArgs<ExtArgs>
            result: $Utils.Optional<Egg_groupGroupByOutputType>[]
          }
          count: {
            args: Prisma.egg_groupCountArgs<ExtArgs>
            result: $Utils.Optional<Egg_groupCountAggregateOutputType> | number
          }
        }
      }
      egg_group_order: {
        payload: Prisma.$egg_group_orderPayload<ExtArgs>
        fields: Prisma.egg_group_orderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.egg_group_orderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_group_orderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.egg_group_orderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_group_orderPayload>
          }
          findFirst: {
            args: Prisma.egg_group_orderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_group_orderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.egg_group_orderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_group_orderPayload>
          }
          findMany: {
            args: Prisma.egg_group_orderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_group_orderPayload>[]
          }
          create: {
            args: Prisma.egg_group_orderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_group_orderPayload>
          }
          createMany: {
            args: Prisma.egg_group_orderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.egg_group_orderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_group_orderPayload>
          }
          update: {
            args: Prisma.egg_group_orderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_group_orderPayload>
          }
          deleteMany: {
            args: Prisma.egg_group_orderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.egg_group_orderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.egg_group_orderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$egg_group_orderPayload>
          }
          aggregate: {
            args: Prisma.Egg_group_orderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEgg_group_order>
          }
          groupBy: {
            args: Prisma.egg_group_orderGroupByArgs<ExtArgs>
            result: $Utils.Optional<Egg_group_orderGroupByOutputType>[]
          }
          count: {
            args: Prisma.egg_group_orderCountArgs<ExtArgs>
            result: $Utils.Optional<Egg_group_orderCountAggregateOutputType> | number
          }
        }
      }
      type: {
        payload: Prisma.$typePayload<ExtArgs>
        fields: Prisma.typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typePayload>
          }
          findFirst: {
            args: Prisma.typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typePayload>
          }
          findMany: {
            args: Prisma.typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typePayload>[]
          }
          create: {
            args: Prisma.typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typePayload>
          }
          createMany: {
            args: Prisma.typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typePayload>
          }
          update: {
            args: Prisma.typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typePayload>
          }
          deleteMany: {
            args: Prisma.typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typePayload>
          }
          aggregate: {
            args: Prisma.TypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateType>
          }
          groupBy: {
            args: Prisma.typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.typeCountArgs<ExtArgs>
            result: $Utils.Optional<TypeCountAggregateOutputType> | number
          }
        }
      }
      type_order: {
        payload: Prisma.$type_orderPayload<ExtArgs>
        fields: Prisma.type_orderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.type_orderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_orderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.type_orderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_orderPayload>
          }
          findFirst: {
            args: Prisma.type_orderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_orderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.type_orderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_orderPayload>
          }
          findMany: {
            args: Prisma.type_orderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_orderPayload>[]
          }
          create: {
            args: Prisma.type_orderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_orderPayload>
          }
          createMany: {
            args: Prisma.type_orderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.type_orderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_orderPayload>
          }
          update: {
            args: Prisma.type_orderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_orderPayload>
          }
          deleteMany: {
            args: Prisma.type_orderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.type_orderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.type_orderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_orderPayload>
          }
          aggregate: {
            args: Prisma.Type_orderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateType_order>
          }
          groupBy: {
            args: Prisma.type_orderGroupByArgs<ExtArgs>
            result: $Utils.Optional<Type_orderGroupByOutputType>[]
          }
          count: {
            args: Prisma.type_orderCountArgs<ExtArgs>
            result: $Utils.Optional<Type_orderCountAggregateOutputType> | number
          }
        }
      }
      national_number: {
        payload: Prisma.$national_numberPayload<ExtArgs>
        fields: Prisma.national_numberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.national_numberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$national_numberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.national_numberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$national_numberPayload>
          }
          findFirst: {
            args: Prisma.national_numberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$national_numberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.national_numberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$national_numberPayload>
          }
          findMany: {
            args: Prisma.national_numberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$national_numberPayload>[]
          }
          create: {
            args: Prisma.national_numberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$national_numberPayload>
          }
          createMany: {
            args: Prisma.national_numberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.national_numberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$national_numberPayload>
          }
          update: {
            args: Prisma.national_numberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$national_numberPayload>
          }
          deleteMany: {
            args: Prisma.national_numberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.national_numberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.national_numberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$national_numberPayload>
          }
          aggregate: {
            args: Prisma.National_numberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNational_number>
          }
          groupBy: {
            args: Prisma.national_numberGroupByArgs<ExtArgs>
            result: $Utils.Optional<National_numberGroupByOutputType>[]
          }
          count: {
            args: Prisma.national_numberCountArgs<ExtArgs>
            result: $Utils.Optional<National_numberCountAggregateOutputType> | number
          }
        }
      }
      land: {
        payload: Prisma.$landPayload<ExtArgs>
        fields: Prisma.landFieldRefs
        operations: {
          findUnique: {
            args: Prisma.landFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.landFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landPayload>
          }
          findFirst: {
            args: Prisma.landFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.landFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landPayload>
          }
          findMany: {
            args: Prisma.landFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landPayload>[]
          }
          create: {
            args: Prisma.landCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landPayload>
          }
          createMany: {
            args: Prisma.landCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.landDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landPayload>
          }
          update: {
            args: Prisma.landUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landPayload>
          }
          deleteMany: {
            args: Prisma.landDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.landUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.landUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landPayload>
          }
          aggregate: {
            args: Prisma.LandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLand>
          }
          groupBy: {
            args: Prisma.landGroupByArgs<ExtArgs>
            result: $Utils.Optional<LandGroupByOutputType>[]
          }
          count: {
            args: Prisma.landCountArgs<ExtArgs>
            result: $Utils.Optional<LandCountAggregateOutputType> | number
          }
        }
      }
      capacity: {
        payload: Prisma.$capacityPayload<ExtArgs>
        fields: Prisma.capacityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.capacityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.capacityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacityPayload>
          }
          findFirst: {
            args: Prisma.capacityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.capacityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacityPayload>
          }
          findMany: {
            args: Prisma.capacityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacityPayload>[]
          }
          create: {
            args: Prisma.capacityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacityPayload>
          }
          createMany: {
            args: Prisma.capacityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.capacityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacityPayload>
          }
          update: {
            args: Prisma.capacityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacityPayload>
          }
          deleteMany: {
            args: Prisma.capacityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.capacityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.capacityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacityPayload>
          }
          aggregate: {
            args: Prisma.CapacityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapacity>
          }
          groupBy: {
            args: Prisma.capacityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CapacityGroupByOutputType>[]
          }
          count: {
            args: Prisma.capacityCountArgs<ExtArgs>
            result: $Utils.Optional<CapacityCountAggregateOutputType> | number
          }
        }
      }
      capacity_effect: {
        payload: Prisma.$capacity_effectPayload<ExtArgs>
        fields: Prisma.capacity_effectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.capacity_effectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_effectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.capacity_effectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_effectPayload>
          }
          findFirst: {
            args: Prisma.capacity_effectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_effectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.capacity_effectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_effectPayload>
          }
          findMany: {
            args: Prisma.capacity_effectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_effectPayload>[]
          }
          create: {
            args: Prisma.capacity_effectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_effectPayload>
          }
          createMany: {
            args: Prisma.capacity_effectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.capacity_effectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_effectPayload>
          }
          update: {
            args: Prisma.capacity_effectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_effectPayload>
          }
          deleteMany: {
            args: Prisma.capacity_effectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.capacity_effectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.capacity_effectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_effectPayload>
          }
          aggregate: {
            args: Prisma.Capacity_effectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapacity_effect>
          }
          groupBy: {
            args: Prisma.capacity_effectGroupByArgs<ExtArgs>
            result: $Utils.Optional<Capacity_effectGroupByOutputType>[]
          }
          count: {
            args: Prisma.capacity_effectCountArgs<ExtArgs>
            result: $Utils.Optional<Capacity_effectCountAggregateOutputType> | number
          }
        }
      }
      capacity_category: {
        payload: Prisma.$capacity_categoryPayload<ExtArgs>
        fields: Prisma.capacity_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.capacity_categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.capacity_categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_categoryPayload>
          }
          findFirst: {
            args: Prisma.capacity_categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.capacity_categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_categoryPayload>
          }
          findMany: {
            args: Prisma.capacity_categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_categoryPayload>[]
          }
          create: {
            args: Prisma.capacity_categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_categoryPayload>
          }
          createMany: {
            args: Prisma.capacity_categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.capacity_categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_categoryPayload>
          }
          update: {
            args: Prisma.capacity_categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_categoryPayload>
          }
          deleteMany: {
            args: Prisma.capacity_categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.capacity_categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.capacity_categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_categoryPayload>
          }
          aggregate: {
            args: Prisma.Capacity_categoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapacity_category>
          }
          groupBy: {
            args: Prisma.capacity_categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Capacity_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.capacity_categoryCountArgs<ExtArgs>
            result: $Utils.Optional<Capacity_categoryCountAggregateOutputType> | number
          }
        }
      }
      capsule: {
        payload: Prisma.$capsulePayload<ExtArgs>
        fields: Prisma.capsuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.capsuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.capsuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsulePayload>
          }
          findFirst: {
            args: Prisma.capsuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.capsuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsulePayload>
          }
          findMany: {
            args: Prisma.capsuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsulePayload>[]
          }
          create: {
            args: Prisma.capsuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsulePayload>
          }
          createMany: {
            args: Prisma.capsuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.capsuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsulePayload>
          }
          update: {
            args: Prisma.capsuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsulePayload>
          }
          deleteMany: {
            args: Prisma.capsuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.capsuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.capsuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capsulePayload>
          }
          aggregate: {
            args: Prisma.CapsuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapsule>
          }
          groupBy: {
            args: Prisma.capsuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CapsuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.capsuleCountArgs<ExtArgs>
            result: $Utils.Optional<CapsuleCountAggregateOutputType> | number
          }
        }
      }
      detail: {
        payload: Prisma.$detailPayload<ExtArgs>
        fields: Prisma.detailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detailPayload>
          }
          findFirst: {
            args: Prisma.detailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detailPayload>
          }
          findMany: {
            args: Prisma.detailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detailPayload>[]
          }
          create: {
            args: Prisma.detailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detailPayload>
          }
          createMany: {
            args: Prisma.detailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.detailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detailPayload>
          }
          update: {
            args: Prisma.detailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detailPayload>
          }
          deleteMany: {
            args: Prisma.detailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.detailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.detailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detailPayload>
          }
          aggregate: {
            args: Prisma.DetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetail>
          }
          groupBy: {
            args: Prisma.detailGroupByArgs<ExtArgs>
            result: $Utils.Optional<DetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.detailCountArgs<ExtArgs>
            result: $Utils.Optional<DetailCountAggregateOutputType> | number
          }
        }
      }
      effect_outside_fight: {
        payload: Prisma.$effect_outside_fightPayload<ExtArgs>
        fields: Prisma.effect_outside_fightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.effect_outside_fightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$effect_outside_fightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.effect_outside_fightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$effect_outside_fightPayload>
          }
          findFirst: {
            args: Prisma.effect_outside_fightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$effect_outside_fightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.effect_outside_fightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$effect_outside_fightPayload>
          }
          findMany: {
            args: Prisma.effect_outside_fightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$effect_outside_fightPayload>[]
          }
          create: {
            args: Prisma.effect_outside_fightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$effect_outside_fightPayload>
          }
          createMany: {
            args: Prisma.effect_outside_fightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.effect_outside_fightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$effect_outside_fightPayload>
          }
          update: {
            args: Prisma.effect_outside_fightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$effect_outside_fightPayload>
          }
          deleteMany: {
            args: Prisma.effect_outside_fightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.effect_outside_fightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.effect_outside_fightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$effect_outside_fightPayload>
          }
          aggregate: {
            args: Prisma.Effect_outside_fightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEffect_outside_fight>
          }
          groupBy: {
            args: Prisma.effect_outside_fightGroupByArgs<ExtArgs>
            result: $Utils.Optional<Effect_outside_fightGroupByOutputType>[]
          }
          count: {
            args: Prisma.effect_outside_fightCountArgs<ExtArgs>
            result: $Utils.Optional<Effect_outside_fightCountAggregateOutputType> | number
          }
        }
      }
      influence: {
        payload: Prisma.$influencePayload<ExtArgs>
        fields: Prisma.influenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.influenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$influencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.influenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$influencePayload>
          }
          findFirst: {
            args: Prisma.influenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$influencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.influenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$influencePayload>
          }
          findMany: {
            args: Prisma.influenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$influencePayload>[]
          }
          create: {
            args: Prisma.influenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$influencePayload>
          }
          createMany: {
            args: Prisma.influenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.influenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$influencePayload>
          }
          update: {
            args: Prisma.influenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$influencePayload>
          }
          deleteMany: {
            args: Prisma.influenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.influenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.influenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$influencePayload>
          }
          aggregate: {
            args: Prisma.InfluenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInfluence>
          }
          groupBy: {
            args: Prisma.influenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InfluenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.influenceCountArgs<ExtArgs>
            result: $Utils.Optional<InfluenceCountAggregateOutputType> | number
          }
        }
      }
      location: {
        payload: Prisma.$locationPayload<ExtArgs>
        fields: Prisma.locationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.locationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.locationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          findFirst: {
            args: Prisma.locationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.locationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          findMany: {
            args: Prisma.locationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>[]
          }
          create: {
            args: Prisma.locationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          createMany: {
            args: Prisma.locationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.locationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          update: {
            args: Prisma.locationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          deleteMany: {
            args: Prisma.locationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.locationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.locationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.locationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.locationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      zone: {
        payload: Prisma.$zonePayload<ExtArgs>
        fields: Prisma.zoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.zoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.zoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          findFirst: {
            args: Prisma.zoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.zoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          findMany: {
            args: Prisma.zoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>[]
          }
          create: {
            args: Prisma.zoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          createMany: {
            args: Prisma.zoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.zoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          update: {
            args: Prisma.zoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          deleteMany: {
            args: Prisma.zoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.zoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.zoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.zoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.zoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      location_zone: {
        payload: Prisma.$location_zonePayload<ExtArgs>
        fields: Prisma.location_zoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.location_zoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_zonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.location_zoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_zonePayload>
          }
          findFirst: {
            args: Prisma.location_zoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_zonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.location_zoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_zonePayload>
          }
          findMany: {
            args: Prisma.location_zoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_zonePayload>[]
          }
          create: {
            args: Prisma.location_zoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_zonePayload>
          }
          createMany: {
            args: Prisma.location_zoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.location_zoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_zonePayload>
          }
          update: {
            args: Prisma.location_zoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_zonePayload>
          }
          deleteMany: {
            args: Prisma.location_zoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.location_zoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.location_zoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_zonePayload>
          }
          aggregate: {
            args: Prisma.Location_zoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation_zone>
          }
          groupBy: {
            args: Prisma.location_zoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<Location_zoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.location_zoneCountArgs<ExtArgs>
            result: $Utils.Optional<Location_zoneCountAggregateOutputType> | number
          }
        }
      }
      meteo: {
        payload: Prisma.$meteoPayload<ExtArgs>
        fields: Prisma.meteoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.meteoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meteoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.meteoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meteoPayload>
          }
          findFirst: {
            args: Prisma.meteoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meteoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.meteoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meteoPayload>
          }
          findMany: {
            args: Prisma.meteoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meteoPayload>[]
          }
          create: {
            args: Prisma.meteoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meteoPayload>
          }
          createMany: {
            args: Prisma.meteoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.meteoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meteoPayload>
          }
          update: {
            args: Prisma.meteoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meteoPayload>
          }
          deleteMany: {
            args: Prisma.meteoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.meteoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.meteoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meteoPayload>
          }
          aggregate: {
            args: Prisma.MeteoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeteo>
          }
          groupBy: {
            args: Prisma.meteoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeteoGroupByOutputType>[]
          }
          count: {
            args: Prisma.meteoCountArgs<ExtArgs>
            result: $Utils.Optional<MeteoCountAggregateOutputType> | number
          }
        }
      }
      pokemon_obtation: {
        payload: Prisma.$pokemon_obtationPayload<ExtArgs>
        fields: Prisma.pokemon_obtationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pokemon_obtationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_obtationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pokemon_obtationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_obtationPayload>
          }
          findFirst: {
            args: Prisma.pokemon_obtationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_obtationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pokemon_obtationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_obtationPayload>
          }
          findMany: {
            args: Prisma.pokemon_obtationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_obtationPayload>[]
          }
          create: {
            args: Prisma.pokemon_obtationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_obtationPayload>
          }
          createMany: {
            args: Prisma.pokemon_obtationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pokemon_obtationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_obtationPayload>
          }
          update: {
            args: Prisma.pokemon_obtationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_obtationPayload>
          }
          deleteMany: {
            args: Prisma.pokemon_obtationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pokemon_obtationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pokemon_obtationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_obtationPayload>
          }
          aggregate: {
            args: Prisma.Pokemon_obtationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemon_obtation>
          }
          groupBy: {
            args: Prisma.pokemon_obtationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pokemon_obtationGroupByOutputType>[]
          }
          count: {
            args: Prisma.pokemon_obtationCountArgs<ExtArgs>
            result: $Utils.Optional<Pokemon_obtationCountAggregateOutputType> | number
          }
        }
      }
      rate: {
        payload: Prisma.$ratePayload<ExtArgs>
        fields: Prisma.rateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratePayload>
          }
          findFirst: {
            args: Prisma.rateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratePayload>
          }
          findMany: {
            args: Prisma.rateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratePayload>[]
          }
          create: {
            args: Prisma.rateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratePayload>
          }
          createMany: {
            args: Prisma.rateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratePayload>
          }
          update: {
            args: Prisma.rateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratePayload>
          }
          deleteMany: {
            args: Prisma.rateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratePayload>
          }
          aggregate: {
            args: Prisma.RateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRate>
          }
          groupBy: {
            args: Prisma.rateGroupByArgs<ExtArgs>
            result: $Utils.Optional<RateGroupByOutputType>[]
          }
          count: {
            args: Prisma.rateCountArgs<ExtArgs>
            result: $Utils.Optional<RateCountAggregateOutputType> | number
          }
        }
      }
      shiny_hunting_method_game: {
        payload: Prisma.$shiny_hunting_method_gamePayload<ExtArgs>
        fields: Prisma.shiny_hunting_method_gameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.shiny_hunting_method_gameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_gamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.shiny_hunting_method_gameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_gamePayload>
          }
          findFirst: {
            args: Prisma.shiny_hunting_method_gameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_gamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.shiny_hunting_method_gameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_gamePayload>
          }
          findMany: {
            args: Prisma.shiny_hunting_method_gameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_gamePayload>[]
          }
          create: {
            args: Prisma.shiny_hunting_method_gameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_gamePayload>
          }
          createMany: {
            args: Prisma.shiny_hunting_method_gameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.shiny_hunting_method_gameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_gamePayload>
          }
          update: {
            args: Prisma.shiny_hunting_method_gameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_gamePayload>
          }
          deleteMany: {
            args: Prisma.shiny_hunting_method_gameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.shiny_hunting_method_gameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.shiny_hunting_method_gameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_gamePayload>
          }
          aggregate: {
            args: Prisma.Shiny_hunting_method_gameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiny_hunting_method_game>
          }
          groupBy: {
            args: Prisma.shiny_hunting_method_gameGroupByArgs<ExtArgs>
            result: $Utils.Optional<Shiny_hunting_method_gameGroupByOutputType>[]
          }
          count: {
            args: Prisma.shiny_hunting_method_gameCountArgs<ExtArgs>
            result: $Utils.Optional<Shiny_hunting_method_gameCountAggregateOutputType> | number
          }
        }
      }
      shiny_hunting_method_rate: {
        payload: Prisma.$shiny_hunting_method_ratePayload<ExtArgs>
        fields: Prisma.shiny_hunting_method_rateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.shiny_hunting_method_rateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_ratePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.shiny_hunting_method_rateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_ratePayload>
          }
          findFirst: {
            args: Prisma.shiny_hunting_method_rateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_ratePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.shiny_hunting_method_rateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_ratePayload>
          }
          findMany: {
            args: Prisma.shiny_hunting_method_rateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_ratePayload>[]
          }
          create: {
            args: Prisma.shiny_hunting_method_rateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_ratePayload>
          }
          createMany: {
            args: Prisma.shiny_hunting_method_rateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.shiny_hunting_method_rateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_ratePayload>
          }
          update: {
            args: Prisma.shiny_hunting_method_rateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_ratePayload>
          }
          deleteMany: {
            args: Prisma.shiny_hunting_method_rateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.shiny_hunting_method_rateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.shiny_hunting_method_rateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiny_hunting_method_ratePayload>
          }
          aggregate: {
            args: Prisma.Shiny_hunting_method_rateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiny_hunting_method_rate>
          }
          groupBy: {
            args: Prisma.shiny_hunting_method_rateGroupByArgs<ExtArgs>
            result: $Utils.Optional<Shiny_hunting_method_rateGroupByOutputType>[]
          }
          count: {
            args: Prisma.shiny_hunting_method_rateCountArgs<ExtArgs>
            result: $Utils.Optional<Shiny_hunting_method_rateCountAggregateOutputType> | number
          }
        }
      }
      skill_obtation_type: {
        payload: Prisma.$skill_obtation_typePayload<ExtArgs>
        fields: Prisma.skill_obtation_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.skill_obtation_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtation_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.skill_obtation_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtation_typePayload>
          }
          findFirst: {
            args: Prisma.skill_obtation_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtation_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.skill_obtation_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtation_typePayload>
          }
          findMany: {
            args: Prisma.skill_obtation_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtation_typePayload>[]
          }
          create: {
            args: Prisma.skill_obtation_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtation_typePayload>
          }
          createMany: {
            args: Prisma.skill_obtation_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.skill_obtation_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtation_typePayload>
          }
          update: {
            args: Prisma.skill_obtation_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtation_typePayload>
          }
          deleteMany: {
            args: Prisma.skill_obtation_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.skill_obtation_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.skill_obtation_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtation_typePayload>
          }
          aggregate: {
            args: Prisma.Skill_obtation_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill_obtation_type>
          }
          groupBy: {
            args: Prisma.skill_obtation_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Skill_obtation_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.skill_obtation_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Skill_obtation_typeCountAggregateOutputType> | number
          }
        }
      }
      statistic: {
        payload: Prisma.$statisticPayload<ExtArgs>
        fields: Prisma.statisticFieldRefs
        operations: {
          findUnique: {
            args: Prisma.statisticFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statisticPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.statisticFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statisticPayload>
          }
          findFirst: {
            args: Prisma.statisticFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statisticPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.statisticFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statisticPayload>
          }
          findMany: {
            args: Prisma.statisticFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statisticPayload>[]
          }
          create: {
            args: Prisma.statisticCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statisticPayload>
          }
          createMany: {
            args: Prisma.statisticCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.statisticDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statisticPayload>
          }
          update: {
            args: Prisma.statisticUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statisticPayload>
          }
          deleteMany: {
            args: Prisma.statisticDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.statisticUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.statisticUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statisticPayload>
          }
          aggregate: {
            args: Prisma.StatisticAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatistic>
          }
          groupBy: {
            args: Prisma.statisticGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatisticGroupByOutputType>[]
          }
          count: {
            args: Prisma.statisticCountArgs<ExtArgs>
            result: $Utils.Optional<StatisticCountAggregateOutputType> | number
          }
        }
      }
      statistic_group_game: {
        payload: Prisma.$statistic_group_gamePayload<ExtArgs>
        fields: Prisma.statistic_group_gameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.statistic_group_gameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statistic_group_gamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.statistic_group_gameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statistic_group_gamePayload>
          }
          findFirst: {
            args: Prisma.statistic_group_gameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statistic_group_gamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.statistic_group_gameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statistic_group_gamePayload>
          }
          findMany: {
            args: Prisma.statistic_group_gameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statistic_group_gamePayload>[]
          }
          create: {
            args: Prisma.statistic_group_gameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statistic_group_gamePayload>
          }
          createMany: {
            args: Prisma.statistic_group_gameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.statistic_group_gameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statistic_group_gamePayload>
          }
          update: {
            args: Prisma.statistic_group_gameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statistic_group_gamePayload>
          }
          deleteMany: {
            args: Prisma.statistic_group_gameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.statistic_group_gameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.statistic_group_gameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statistic_group_gamePayload>
          }
          aggregate: {
            args: Prisma.Statistic_group_gameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatistic_group_game>
          }
          groupBy: {
            args: Prisma.statistic_group_gameGroupByArgs<ExtArgs>
            result: $Utils.Optional<Statistic_group_gameGroupByOutputType>[]
          }
          count: {
            args: Prisma.statistic_group_gameCountArgs<ExtArgs>
            result: $Utils.Optional<Statistic_group_gameCountAggregateOutputType> | number
          }
        }
      }
      target: {
        payload: Prisma.$targetPayload<ExtArgs>
        fields: Prisma.targetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.targetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$targetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.targetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$targetPayload>
          }
          findFirst: {
            args: Prisma.targetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$targetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.targetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$targetPayload>
          }
          findMany: {
            args: Prisma.targetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$targetPayload>[]
          }
          create: {
            args: Prisma.targetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$targetPayload>
          }
          createMany: {
            args: Prisma.targetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.targetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$targetPayload>
          }
          update: {
            args: Prisma.targetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$targetPayload>
          }
          deleteMany: {
            args: Prisma.targetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.targetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.targetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$targetPayload>
          }
          aggregate: {
            args: Prisma.TargetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTarget>
          }
          groupBy: {
            args: Prisma.targetGroupByArgs<ExtArgs>
            result: $Utils.Optional<TargetGroupByOutputType>[]
          }
          count: {
            args: Prisma.targetCountArgs<ExtArgs>
            result: $Utils.Optional<TargetCountAggregateOutputType> | number
          }
        }
      }
      capacity_info: {
        payload: Prisma.$capacity_infoPayload<ExtArgs>
        fields: Prisma.capacity_infoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.capacity_infoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_infoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.capacity_infoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_infoPayload>
          }
          findFirst: {
            args: Prisma.capacity_infoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_infoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.capacity_infoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_infoPayload>
          }
          findMany: {
            args: Prisma.capacity_infoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_infoPayload>[]
          }
          create: {
            args: Prisma.capacity_infoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_infoPayload>
          }
          createMany: {
            args: Prisma.capacity_infoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.capacity_infoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_infoPayload>
          }
          update: {
            args: Prisma.capacity_infoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_infoPayload>
          }
          deleteMany: {
            args: Prisma.capacity_infoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.capacity_infoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.capacity_infoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_infoPayload>
          }
          aggregate: {
            args: Prisma.Capacity_infoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapacity_info>
          }
          groupBy: {
            args: Prisma.capacity_infoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Capacity_infoGroupByOutputType>[]
          }
          count: {
            args: Prisma.capacity_infoCountArgs<ExtArgs>
            result: $Utils.Optional<Capacity_infoCountAggregateOutputType> | number
          }
        }
      }
      capacity_info_influence: {
        payload: Prisma.$capacity_info_influencePayload<ExtArgs>
        fields: Prisma.capacity_info_influenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.capacity_info_influenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_info_influencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.capacity_info_influenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_info_influencePayload>
          }
          findFirst: {
            args: Prisma.capacity_info_influenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_info_influencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.capacity_info_influenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_info_influencePayload>
          }
          findMany: {
            args: Prisma.capacity_info_influenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_info_influencePayload>[]
          }
          create: {
            args: Prisma.capacity_info_influenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_info_influencePayload>
          }
          createMany: {
            args: Prisma.capacity_info_influenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.capacity_info_influenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_info_influencePayload>
          }
          update: {
            args: Prisma.capacity_info_influenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_info_influencePayload>
          }
          deleteMany: {
            args: Prisma.capacity_info_influenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.capacity_info_influenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.capacity_info_influenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacity_info_influencePayload>
          }
          aggregate: {
            args: Prisma.Capacity_info_influenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapacity_info_influence>
          }
          groupBy: {
            args: Prisma.capacity_info_influenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Capacity_info_influenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.capacity_info_influenceCountArgs<ExtArgs>
            result: $Utils.Optional<Capacity_info_influenceCountAggregateOutputType> | number
          }
        }
      }
      pokemon_game_location: {
        payload: Prisma.$pokemon_game_locationPayload<ExtArgs>
        fields: Prisma.pokemon_game_locationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pokemon_game_locationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_game_locationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pokemon_game_locationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_game_locationPayload>
          }
          findFirst: {
            args: Prisma.pokemon_game_locationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_game_locationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pokemon_game_locationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_game_locationPayload>
          }
          findMany: {
            args: Prisma.pokemon_game_locationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_game_locationPayload>[]
          }
          create: {
            args: Prisma.pokemon_game_locationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_game_locationPayload>
          }
          createMany: {
            args: Prisma.pokemon_game_locationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pokemon_game_locationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_game_locationPayload>
          }
          update: {
            args: Prisma.pokemon_game_locationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_game_locationPayload>
          }
          deleteMany: {
            args: Prisma.pokemon_game_locationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pokemon_game_locationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pokemon_game_locationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pokemon_game_locationPayload>
          }
          aggregate: {
            args: Prisma.Pokemon_game_locationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemon_game_location>
          }
          groupBy: {
            args: Prisma.pokemon_game_locationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pokemon_game_locationGroupByOutputType>[]
          }
          count: {
            args: Prisma.pokemon_game_locationCountArgs<ExtArgs>
            result: $Utils.Optional<Pokemon_game_locationCountAggregateOutputType> | number
          }
        }
      }
      skill_obtation: {
        payload: Prisma.$skill_obtationPayload<ExtArgs>
        fields: Prisma.skill_obtationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.skill_obtationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.skill_obtationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtationPayload>
          }
          findFirst: {
            args: Prisma.skill_obtationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.skill_obtationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtationPayload>
          }
          findMany: {
            args: Prisma.skill_obtationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtationPayload>[]
          }
          create: {
            args: Prisma.skill_obtationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtationPayload>
          }
          createMany: {
            args: Prisma.skill_obtationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.skill_obtationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtationPayload>
          }
          update: {
            args: Prisma.skill_obtationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtationPayload>
          }
          deleteMany: {
            args: Prisma.skill_obtationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.skill_obtationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.skill_obtationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skill_obtationPayload>
          }
          aggregate: {
            args: Prisma.Skill_obtationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill_obtation>
          }
          groupBy: {
            args: Prisma.skill_obtationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Skill_obtationGroupByOutputType>[]
          }
          count: {
            args: Prisma.skill_obtationCountArgs<ExtArgs>
            result: $Utils.Optional<Skill_obtationCountAggregateOutputType> | number
          }
        }
      }
      refresh_token: {
        payload: Prisma.$refresh_tokenPayload<ExtArgs>
        fields: Prisma.refresh_tokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.refresh_tokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.refresh_tokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokenPayload>
          }
          findFirst: {
            args: Prisma.refresh_tokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.refresh_tokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokenPayload>
          }
          findMany: {
            args: Prisma.refresh_tokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokenPayload>[]
          }
          create: {
            args: Prisma.refresh_tokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokenPayload>
          }
          createMany: {
            args: Prisma.refresh_tokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.refresh_tokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokenPayload>
          }
          update: {
            args: Prisma.refresh_tokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokenPayload>
          }
          deleteMany: {
            args: Prisma.refresh_tokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.refresh_tokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.refresh_tokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokenPayload>
          }
          aggregate: {
            args: Prisma.Refresh_tokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefresh_token>
          }
          groupBy: {
            args: Prisma.refresh_tokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<Refresh_tokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.refresh_tokenCountArgs<ExtArgs>
            result: $Utils.Optional<Refresh_tokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    langue?: langueOmit
    translation?: translationOmit
    user?: userOmit
    shiny_hunting_method?: shiny_hunting_methodOmit
    pokeball?: pokeballOmit
    generation?: generationOmit
    game?: gameOmit
    game_group_game?: game_group_gameOmit
    group_game?: group_gameOmit
    capsule_game_capacity_info?: capsule_game_capacity_infoOmit
    pokemon_category?: pokemon_categoryOmit
    pokemon?: pokemonOmit
    gender?: genderOmit
    form?: formOmit
    pokemon_form_gender?: pokemon_form_genderOmit
    pokemon_form?: pokemon_formOmit
    owned_pokemon?: owned_pokemonOmit
    owned_pokemon_detail?: owned_pokemon_detailOmit
    ability?: abilityOmit
    ability_info?: ability_infoOmit
    pokemon_info?: pokemon_infoOmit
    ability_order?: ability_orderOmit
    evolution_method?: evolution_methodOmit
    evolution?: evolutionOmit
    evolution_info?: evolution_infoOmit
    egg_group?: egg_groupOmit
    egg_group_order?: egg_group_orderOmit
    type?: typeOmit
    type_order?: type_orderOmit
    national_number?: national_numberOmit
    land?: landOmit
    capacity?: capacityOmit
    capacity_effect?: capacity_effectOmit
    capacity_category?: capacity_categoryOmit
    capsule?: capsuleOmit
    detail?: detailOmit
    effect_outside_fight?: effect_outside_fightOmit
    influence?: influenceOmit
    location?: locationOmit
    zone?: zoneOmit
    location_zone?: location_zoneOmit
    meteo?: meteoOmit
    pokemon_obtation?: pokemon_obtationOmit
    rate?: rateOmit
    shiny_hunting_method_game?: shiny_hunting_method_gameOmit
    shiny_hunting_method_rate?: shiny_hunting_method_rateOmit
    skill_obtation_type?: skill_obtation_typeOmit
    statistic?: statisticOmit
    statistic_group_game?: statistic_group_gameOmit
    target?: targetOmit
    capacity_info?: capacity_infoOmit
    capacity_info_influence?: capacity_info_influenceOmit
    pokemon_game_location?: pokemon_game_locationOmit
    skill_obtation?: skill_obtationOmit
    refresh_token?: refresh_tokenOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type LangueCountOutputType
   */

  export type LangueCountOutputType = {
    translations: number
  }

  export type LangueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | LangueCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * LangueCountOutputType without action
   */
  export type LangueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LangueCountOutputType
     */
    select?: LangueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LangueCountOutputType without action
   */
  export type LangueCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: translationWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedPokemons: number
    refreshTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedPokemons?: boolean | UserCountOutputTypeCountOwnedPokemonsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedPokemonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: owned_pokemonWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refresh_tokenWhereInput
  }


  /**
   * Count Type Shiny_hunting_methodCountOutputType
   */

  export type Shiny_hunting_methodCountOutputType = {
    ownedPokemons: number
    shinyHuntingMethodGames: number
    shinyHuntingMethodRates: number
  }

  export type Shiny_hunting_methodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedPokemons?: boolean | Shiny_hunting_methodCountOutputTypeCountOwnedPokemonsArgs
    shinyHuntingMethodGames?: boolean | Shiny_hunting_methodCountOutputTypeCountShinyHuntingMethodGamesArgs
    shinyHuntingMethodRates?: boolean | Shiny_hunting_methodCountOutputTypeCountShinyHuntingMethodRatesArgs
  }

  // Custom InputTypes
  /**
   * Shiny_hunting_methodCountOutputType without action
   */
  export type Shiny_hunting_methodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shiny_hunting_methodCountOutputType
     */
    select?: Shiny_hunting_methodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Shiny_hunting_methodCountOutputType without action
   */
  export type Shiny_hunting_methodCountOutputTypeCountOwnedPokemonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: owned_pokemonWhereInput
  }

  /**
   * Shiny_hunting_methodCountOutputType without action
   */
  export type Shiny_hunting_methodCountOutputTypeCountShinyHuntingMethodGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: shiny_hunting_method_gameWhereInput
  }

  /**
   * Shiny_hunting_methodCountOutputType without action
   */
  export type Shiny_hunting_methodCountOutputTypeCountShinyHuntingMethodRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: shiny_hunting_method_rateWhereInput
  }


  /**
   * Count Type PokeballCountOutputType
   */

  export type PokeballCountOutputType = {
    ownedPokemonDetails: number
  }

  export type PokeballCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedPokemonDetails?: boolean | PokeballCountOutputTypeCountOwnedPokemonDetailsArgs
  }

  // Custom InputTypes
  /**
   * PokeballCountOutputType without action
   */
  export type PokeballCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokeballCountOutputType
     */
    select?: PokeballCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PokeballCountOutputType without action
   */
  export type PokeballCountOutputTypeCountOwnedPokemonDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: owned_pokemon_detailWhereInput
  }


  /**
   * Count Type GenerationCountOutputType
   */

  export type GenerationCountOutputType = {
    abilities: number
    abilityInfos: number
    games: number
    pokemons: number
    pokemonInfos: number
  }

  export type GenerationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abilities?: boolean | GenerationCountOutputTypeCountAbilitiesArgs
    abilityInfos?: boolean | GenerationCountOutputTypeCountAbilityInfosArgs
    games?: boolean | GenerationCountOutputTypeCountGamesArgs
    pokemons?: boolean | GenerationCountOutputTypeCountPokemonsArgs
    pokemonInfos?: boolean | GenerationCountOutputTypeCountPokemonInfosArgs
  }

  // Custom InputTypes
  /**
   * GenerationCountOutputType without action
   */
  export type GenerationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenerationCountOutputType
     */
    select?: GenerationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenerationCountOutputType without action
   */
  export type GenerationCountOutputTypeCountAbilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: abilityWhereInput
  }

  /**
   * GenerationCountOutputType without action
   */
  export type GenerationCountOutputTypeCountAbilityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ability_infoWhereInput
  }

  /**
   * GenerationCountOutputType without action
   */
  export type GenerationCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gameWhereInput
  }

  /**
   * GenerationCountOutputType without action
   */
  export type GenerationCountOutputTypeCountPokemonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemonWhereInput
  }

  /**
   * GenerationCountOutputType without action
   */
  export type GenerationCountOutputTypeCountPokemonInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_infoWhereInput
  }


  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    gameGroupGames: number
    ownedPokemons: number
    pokemonRatingGames: number
  }

  export type GameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameGroupGames?: boolean | GameCountOutputTypeCountGameGroupGamesArgs
    ownedPokemons?: boolean | GameCountOutputTypeCountOwnedPokemonsArgs
    pokemonRatingGames?: boolean | GameCountOutputTypeCountPokemonRatingGamesArgs
  }

  // Custom InputTypes
  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountGameGroupGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_group_gameWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountOwnedPokemonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: owned_pokemonWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountPokemonRatingGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_game_locationWhereInput
  }


  /**
   * Count Type Group_gameCountOutputType
   */

  export type Group_gameCountOutputType = {
    capsuleGameCapacityIinfos: number
    gameGroupGames: number
    nationnalNumbers: number
    shinyHuntingMethodGames: number
    skillObtations: number
    statisticGroupGames: number
  }

  export type Group_gameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capsuleGameCapacityIinfos?: boolean | Group_gameCountOutputTypeCountCapsuleGameCapacityIinfosArgs
    gameGroupGames?: boolean | Group_gameCountOutputTypeCountGameGroupGamesArgs
    nationnalNumbers?: boolean | Group_gameCountOutputTypeCountNationnalNumbersArgs
    shinyHuntingMethodGames?: boolean | Group_gameCountOutputTypeCountShinyHuntingMethodGamesArgs
    skillObtations?: boolean | Group_gameCountOutputTypeCountSkillObtationsArgs
    statisticGroupGames?: boolean | Group_gameCountOutputTypeCountStatisticGroupGamesArgs
  }

  // Custom InputTypes
  /**
   * Group_gameCountOutputType without action
   */
  export type Group_gameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group_gameCountOutputType
     */
    select?: Group_gameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Group_gameCountOutputType without action
   */
  export type Group_gameCountOutputTypeCountCapsuleGameCapacityIinfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capsule_game_capacity_infoWhereInput
  }

  /**
   * Group_gameCountOutputType without action
   */
  export type Group_gameCountOutputTypeCountGameGroupGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_group_gameWhereInput
  }

  /**
   * Group_gameCountOutputType without action
   */
  export type Group_gameCountOutputTypeCountNationnalNumbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: national_numberWhereInput
  }

  /**
   * Group_gameCountOutputType without action
   */
  export type Group_gameCountOutputTypeCountShinyHuntingMethodGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: shiny_hunting_method_gameWhereInput
  }

  /**
   * Group_gameCountOutputType without action
   */
  export type Group_gameCountOutputTypeCountSkillObtationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skill_obtationWhereInput
  }

  /**
   * Group_gameCountOutputType without action
   */
  export type Group_gameCountOutputTypeCountStatisticGroupGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: statistic_group_gameWhereInput
  }


  /**
   * Count Type Pokemon_categoryCountOutputType
   */

  export type Pokemon_categoryCountOutputType = {
    pokemons: number
  }

  export type Pokemon_categoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemons?: boolean | Pokemon_categoryCountOutputTypeCountPokemonsArgs
  }

  // Custom InputTypes
  /**
   * Pokemon_categoryCountOutputType without action
   */
  export type Pokemon_categoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon_categoryCountOutputType
     */
    select?: Pokemon_categoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Pokemon_categoryCountOutputType without action
   */
  export type Pokemon_categoryCountOutputTypeCountPokemonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemonWhereInput
  }


  /**
   * Count Type PokemonCountOutputType
   */

  export type PokemonCountOutputType = {
    nationalNumbers: number
    pokemonForms: number
    pokemonInfos: number
    skillObtations: number
    statisticGroupGames: number
  }

  export type PokemonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nationalNumbers?: boolean | PokemonCountOutputTypeCountNationalNumbersArgs
    pokemonForms?: boolean | PokemonCountOutputTypeCountPokemonFormsArgs
    pokemonInfos?: boolean | PokemonCountOutputTypeCountPokemonInfosArgs
    skillObtations?: boolean | PokemonCountOutputTypeCountSkillObtationsArgs
    statisticGroupGames?: boolean | PokemonCountOutputTypeCountStatisticGroupGamesArgs
  }

  // Custom InputTypes
  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonCountOutputType
     */
    select?: PokemonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeCountNationalNumbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: national_numberWhereInput
  }

  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeCountPokemonFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_formWhereInput
  }

  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeCountPokemonInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_infoWhereInput
  }

  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeCountSkillObtationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skill_obtationWhereInput
  }

  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeCountStatisticGroupGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: statistic_group_gameWhereInput
  }


  /**
   * Count Type GenderCountOutputType
   */

  export type GenderCountOutputType = {
    pokemonFormGenders: number
  }

  export type GenderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemonFormGenders?: boolean | GenderCountOutputTypeCountPokemonFormGendersArgs
  }

  // Custom InputTypes
  /**
   * GenderCountOutputType without action
   */
  export type GenderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenderCountOutputType
     */
    select?: GenderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenderCountOutputType without action
   */
  export type GenderCountOutputTypeCountPokemonFormGendersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_form_genderWhereInput
  }


  /**
   * Count Type FormCountOutputType
   */

  export type FormCountOutputType = {
    pokemonForms: number
  }

  export type FormCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemonForms?: boolean | FormCountOutputTypeCountPokemonFormsArgs
  }

  // Custom InputTypes
  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormCountOutputType
     */
    select?: FormCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeCountPokemonFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_formWhereInput
  }


  /**
   * Count Type Pokemon_formCountOutputType
   */

  export type Pokemon_formCountOutputType = {
    evolutionEnds: number
    evolutionStarts: number
    ownedPokemons: number
    pokemonFormGenders: number
    pokemonRatingGames: number
  }

  export type Pokemon_formCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolutionEnds?: boolean | Pokemon_formCountOutputTypeCountEvolutionEndsArgs
    evolutionStarts?: boolean | Pokemon_formCountOutputTypeCountEvolutionStartsArgs
    ownedPokemons?: boolean | Pokemon_formCountOutputTypeCountOwnedPokemonsArgs
    pokemonFormGenders?: boolean | Pokemon_formCountOutputTypeCountPokemonFormGendersArgs
    pokemonRatingGames?: boolean | Pokemon_formCountOutputTypeCountPokemonRatingGamesArgs
  }

  // Custom InputTypes
  /**
   * Pokemon_formCountOutputType without action
   */
  export type Pokemon_formCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon_formCountOutputType
     */
    select?: Pokemon_formCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Pokemon_formCountOutputType without action
   */
  export type Pokemon_formCountOutputTypeCountEvolutionEndsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: evolutionWhereInput
  }

  /**
   * Pokemon_formCountOutputType without action
   */
  export type Pokemon_formCountOutputTypeCountEvolutionStartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: evolutionWhereInput
  }

  /**
   * Pokemon_formCountOutputType without action
   */
  export type Pokemon_formCountOutputTypeCountOwnedPokemonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: owned_pokemonWhereInput
  }

  /**
   * Pokemon_formCountOutputType without action
   */
  export type Pokemon_formCountOutputTypeCountPokemonFormGendersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_form_genderWhereInput
  }

  /**
   * Pokemon_formCountOutputType without action
   */
  export type Pokemon_formCountOutputTypeCountPokemonRatingGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_game_locationWhereInput
  }


  /**
   * Count Type Owned_pokemonCountOutputType
   */

  export type Owned_pokemonCountOutputType = {
    ownedPokemonDetails: number
  }

  export type Owned_pokemonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedPokemonDetails?: boolean | Owned_pokemonCountOutputTypeCountOwnedPokemonDetailsArgs
  }

  // Custom InputTypes
  /**
   * Owned_pokemonCountOutputType without action
   */
  export type Owned_pokemonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owned_pokemonCountOutputType
     */
    select?: Owned_pokemonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Owned_pokemonCountOutputType without action
   */
  export type Owned_pokemonCountOutputTypeCountOwnedPokemonDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: owned_pokemon_detailWhereInput
  }


  /**
   * Count Type AbilityCountOutputType
   */

  export type AbilityCountOutputType = {
    abilityInfos: number
    abilityOrders: number
  }

  export type AbilityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abilityInfos?: boolean | AbilityCountOutputTypeCountAbilityInfosArgs
    abilityOrders?: boolean | AbilityCountOutputTypeCountAbilityOrdersArgs
  }

  // Custom InputTypes
  /**
   * AbilityCountOutputType without action
   */
  export type AbilityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbilityCountOutputType
     */
    select?: AbilityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AbilityCountOutputType without action
   */
  export type AbilityCountOutputTypeCountAbilityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ability_infoWhereInput
  }

  /**
   * AbilityCountOutputType without action
   */
  export type AbilityCountOutputTypeCountAbilityOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ability_orderWhereInput
  }


  /**
   * Count Type Pokemon_infoCountOutputType
   */

  export type Pokemon_infoCountOutputType = {
    abilityOrders: number
    eggGroupOrders: number
    typeOrders: number
  }

  export type Pokemon_infoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abilityOrders?: boolean | Pokemon_infoCountOutputTypeCountAbilityOrdersArgs
    eggGroupOrders?: boolean | Pokemon_infoCountOutputTypeCountEggGroupOrdersArgs
    typeOrders?: boolean | Pokemon_infoCountOutputTypeCountTypeOrdersArgs
  }

  // Custom InputTypes
  /**
   * Pokemon_infoCountOutputType without action
   */
  export type Pokemon_infoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon_infoCountOutputType
     */
    select?: Pokemon_infoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Pokemon_infoCountOutputType without action
   */
  export type Pokemon_infoCountOutputTypeCountAbilityOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ability_orderWhereInput
  }

  /**
   * Pokemon_infoCountOutputType without action
   */
  export type Pokemon_infoCountOutputTypeCountEggGroupOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: egg_group_orderWhereInput
  }

  /**
   * Pokemon_infoCountOutputType without action
   */
  export type Pokemon_infoCountOutputTypeCountTypeOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: type_orderWhereInput
  }


  /**
   * Count Type Evolution_methodCountOutputType
   */

  export type Evolution_methodCountOutputType = {
    evolutions: number
  }

  export type Evolution_methodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolutions?: boolean | Evolution_methodCountOutputTypeCountEvolutionsArgs
  }

  // Custom InputTypes
  /**
   * Evolution_methodCountOutputType without action
   */
  export type Evolution_methodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution_methodCountOutputType
     */
    select?: Evolution_methodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Evolution_methodCountOutputType without action
   */
  export type Evolution_methodCountOutputTypeCountEvolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: evolutionWhereInput
  }


  /**
   * Count Type Evolution_infoCountOutputType
   */

  export type Evolution_infoCountOutputType = {
    evolutions: number
  }

  export type Evolution_infoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolutions?: boolean | Evolution_infoCountOutputTypeCountEvolutionsArgs
  }

  // Custom InputTypes
  /**
   * Evolution_infoCountOutputType without action
   */
  export type Evolution_infoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution_infoCountOutputType
     */
    select?: Evolution_infoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Evolution_infoCountOutputType without action
   */
  export type Evolution_infoCountOutputTypeCountEvolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: evolutionWhereInput
  }


  /**
   * Count Type Egg_groupCountOutputType
   */

  export type Egg_groupCountOutputType = {
    eggGroupOrders: number
  }

  export type Egg_groupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eggGroupOrders?: boolean | Egg_groupCountOutputTypeCountEggGroupOrdersArgs
  }

  // Custom InputTypes
  /**
   * Egg_groupCountOutputType without action
   */
  export type Egg_groupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Egg_groupCountOutputType
     */
    select?: Egg_groupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Egg_groupCountOutputType without action
   */
  export type Egg_groupCountOutputTypeCountEggGroupOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: egg_group_orderWhereInput
  }


  /**
   * Count Type TypeCountOutputType
   */

  export type TypeCountOutputType = {
    capacityInfos: number
    typeOrders: number
  }

  export type TypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfos?: boolean | TypeCountOutputTypeCountCapacityInfosArgs
    typeOrders?: boolean | TypeCountOutputTypeCountTypeOrdersArgs
  }

  // Custom InputTypes
  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCountOutputType
     */
    select?: TypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeCountCapacityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacity_infoWhereInput
  }

  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeCountTypeOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: type_orderWhereInput
  }


  /**
   * Count Type LandCountOutputType
   */

  export type LandCountOutputType = {
    game_group_game: number
  }

  export type LandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game_group_game?: boolean | LandCountOutputTypeCountGame_group_gameArgs
  }

  // Custom InputTypes
  /**
   * LandCountOutputType without action
   */
  export type LandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandCountOutputType
     */
    select?: LandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LandCountOutputType without action
   */
  export type LandCountOutputTypeCountGame_group_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_group_gameWhereInput
  }


  /**
   * Count Type CapacityCountOutputType
   */

  export type CapacityCountOutputType = {
    capacityInfos: number
    skillObtations: number
  }

  export type CapacityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfos?: boolean | CapacityCountOutputTypeCountCapacityInfosArgs
    skillObtations?: boolean | CapacityCountOutputTypeCountSkillObtationsArgs
  }

  // Custom InputTypes
  /**
   * CapacityCountOutputType without action
   */
  export type CapacityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityCountOutputType
     */
    select?: CapacityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CapacityCountOutputType without action
   */
  export type CapacityCountOutputTypeCountCapacityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacity_infoWhereInput
  }

  /**
   * CapacityCountOutputType without action
   */
  export type CapacityCountOutputTypeCountSkillObtationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skill_obtationWhereInput
  }


  /**
   * Count Type Capacity_effectCountOutputType
   */

  export type Capacity_effectCountOutputType = {
    capacityInfos: number
    capacityZInfos: number
  }

  export type Capacity_effectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfos?: boolean | Capacity_effectCountOutputTypeCountCapacityInfosArgs
    capacityZInfos?: boolean | Capacity_effectCountOutputTypeCountCapacityZInfosArgs
  }

  // Custom InputTypes
  /**
   * Capacity_effectCountOutputType without action
   */
  export type Capacity_effectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capacity_effectCountOutputType
     */
    select?: Capacity_effectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Capacity_effectCountOutputType without action
   */
  export type Capacity_effectCountOutputTypeCountCapacityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacity_infoWhereInput
  }

  /**
   * Capacity_effectCountOutputType without action
   */
  export type Capacity_effectCountOutputTypeCountCapacityZInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacity_infoWhereInput
  }


  /**
   * Count Type Capacity_categoryCountOutputType
   */

  export type Capacity_categoryCountOutputType = {
    capacityInfos: number
  }

  export type Capacity_categoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfos?: boolean | Capacity_categoryCountOutputTypeCountCapacityInfosArgs
  }

  // Custom InputTypes
  /**
   * Capacity_categoryCountOutputType without action
   */
  export type Capacity_categoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capacity_categoryCountOutputType
     */
    select?: Capacity_categoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Capacity_categoryCountOutputType without action
   */
  export type Capacity_categoryCountOutputTypeCountCapacityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacity_infoWhereInput
  }


  /**
   * Count Type CapsuleCountOutputType
   */

  export type CapsuleCountOutputType = {
    capsule_game_capacity_info: number
  }

  export type CapsuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capsule_game_capacity_info?: boolean | CapsuleCountOutputTypeCountCapsule_game_capacity_infoArgs
  }

  // Custom InputTypes
  /**
   * CapsuleCountOutputType without action
   */
  export type CapsuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapsuleCountOutputType
     */
    select?: CapsuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CapsuleCountOutputType without action
   */
  export type CapsuleCountOutputTypeCountCapsule_game_capacity_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capsule_game_capacity_infoWhereInput
  }


  /**
   * Count Type DetailCountOutputType
   */

  export type DetailCountOutputType = {
    conditionRates: number
    detailRates: number
  }

  export type DetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conditionRates?: boolean | DetailCountOutputTypeCountConditionRatesArgs
    detailRates?: boolean | DetailCountOutputTypeCountDetailRatesArgs
  }

  // Custom InputTypes
  /**
   * DetailCountOutputType without action
   */
  export type DetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailCountOutputType
     */
    select?: DetailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DetailCountOutputType without action
   */
  export type DetailCountOutputTypeCountConditionRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rateWhereInput
  }

  /**
   * DetailCountOutputType without action
   */
  export type DetailCountOutputTypeCountDetailRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rateWhereInput
  }


  /**
   * Count Type Effect_outside_fightCountOutputType
   */

  export type Effect_outside_fightCountOutputType = {
    abilityInfos: number
    capacityInfos: number
  }

  export type Effect_outside_fightCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abilityInfos?: boolean | Effect_outside_fightCountOutputTypeCountAbilityInfosArgs
    capacityInfos?: boolean | Effect_outside_fightCountOutputTypeCountCapacityInfosArgs
  }

  // Custom InputTypes
  /**
   * Effect_outside_fightCountOutputType without action
   */
  export type Effect_outside_fightCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Effect_outside_fightCountOutputType
     */
    select?: Effect_outside_fightCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Effect_outside_fightCountOutputType without action
   */
  export type Effect_outside_fightCountOutputTypeCountAbilityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ability_infoWhereInput
  }

  /**
   * Effect_outside_fightCountOutputType without action
   */
  export type Effect_outside_fightCountOutputTypeCountCapacityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacity_infoWhereInput
  }


  /**
   * Count Type InfluenceCountOutputType
   */

  export type InfluenceCountOutputType = {
    capacityInfoInfluences: number
  }

  export type InfluenceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfoInfluences?: boolean | InfluenceCountOutputTypeCountCapacityInfoInfluencesArgs
  }

  // Custom InputTypes
  /**
   * InfluenceCountOutputType without action
   */
  export type InfluenceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluenceCountOutputType
     */
    select?: InfluenceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InfluenceCountOutputType without action
   */
  export type InfluenceCountOutputTypeCountCapacityInfoInfluencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacity_info_influenceWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    locationZones: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationZones?: boolean | LocationCountOutputTypeCountLocationZonesArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountLocationZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: location_zoneWhereInput
  }


  /**
   * Count Type ZoneCountOutputType
   */

  export type ZoneCountOutputType = {
    locationZones: number
  }

  export type ZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationZones?: boolean | ZoneCountOutputTypeCountLocationZonesArgs
  }

  // Custom InputTypes
  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneCountOutputType
     */
    select?: ZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountLocationZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: location_zoneWhereInput
  }


  /**
   * Count Type Location_zoneCountOutputType
   */

  export type Location_zoneCountOutputType = {
    pokemonRatingGames: number
  }

  export type Location_zoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemonRatingGames?: boolean | Location_zoneCountOutputTypeCountPokemonRatingGamesArgs
  }

  // Custom InputTypes
  /**
   * Location_zoneCountOutputType without action
   */
  export type Location_zoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location_zoneCountOutputType
     */
    select?: Location_zoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Location_zoneCountOutputType without action
   */
  export type Location_zoneCountOutputTypeCountPokemonRatingGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_game_locationWhereInput
  }


  /**
   * Count Type MeteoCountOutputType
   */

  export type MeteoCountOutputType = {
    rates: number
  }

  export type MeteoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rates?: boolean | MeteoCountOutputTypeCountRatesArgs
  }

  // Custom InputTypes
  /**
   * MeteoCountOutputType without action
   */
  export type MeteoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeteoCountOutputType
     */
    select?: MeteoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MeteoCountOutputType without action
   */
  export type MeteoCountOutputTypeCountRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rateWhereInput
  }


  /**
   * Count Type Pokemon_obtationCountOutputType
   */

  export type Pokemon_obtationCountOutputType = {
    pokemonRatingGames: number
  }

  export type Pokemon_obtationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemonRatingGames?: boolean | Pokemon_obtationCountOutputTypeCountPokemonRatingGamesArgs
  }

  // Custom InputTypes
  /**
   * Pokemon_obtationCountOutputType without action
   */
  export type Pokemon_obtationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon_obtationCountOutputType
     */
    select?: Pokemon_obtationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Pokemon_obtationCountOutputType without action
   */
  export type Pokemon_obtationCountOutputTypeCountPokemonRatingGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_game_locationWhereInput
  }


  /**
   * Count Type RateCountOutputType
   */

  export type RateCountOutputType = {
    pokemonRatingGames: number
    shinyHuntingMethodRates: number
  }

  export type RateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemonRatingGames?: boolean | RateCountOutputTypeCountPokemonRatingGamesArgs
    shinyHuntingMethodRates?: boolean | RateCountOutputTypeCountShinyHuntingMethodRatesArgs
  }

  // Custom InputTypes
  /**
   * RateCountOutputType without action
   */
  export type RateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCountOutputType
     */
    select?: RateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RateCountOutputType without action
   */
  export type RateCountOutputTypeCountPokemonRatingGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_game_locationWhereInput
  }

  /**
   * RateCountOutputType without action
   */
  export type RateCountOutputTypeCountShinyHuntingMethodRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: shiny_hunting_method_rateWhereInput
  }


  /**
   * Count Type Skill_obtation_typeCountOutputType
   */

  export type Skill_obtation_typeCountOutputType = {
    skillObtations: number
  }

  export type Skill_obtation_typeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skillObtations?: boolean | Skill_obtation_typeCountOutputTypeCountSkillObtationsArgs
  }

  // Custom InputTypes
  /**
   * Skill_obtation_typeCountOutputType without action
   */
  export type Skill_obtation_typeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill_obtation_typeCountOutputType
     */
    select?: Skill_obtation_typeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Skill_obtation_typeCountOutputType without action
   */
  export type Skill_obtation_typeCountOutputTypeCountSkillObtationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skill_obtationWhereInput
  }


  /**
   * Count Type StatisticCountOutputType
   */

  export type StatisticCountOutputType = {
    statisticGroupGames: number
  }

  export type StatisticCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    statisticGroupGames?: boolean | StatisticCountOutputTypeCountStatisticGroupGamesArgs
  }

  // Custom InputTypes
  /**
   * StatisticCountOutputType without action
   */
  export type StatisticCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatisticCountOutputType
     */
    select?: StatisticCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StatisticCountOutputType without action
   */
  export type StatisticCountOutputTypeCountStatisticGroupGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: statistic_group_gameWhereInput
  }


  /**
   * Count Type TargetCountOutputType
   */

  export type TargetCountOutputType = {
    capacityInfos: number
  }

  export type TargetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfos?: boolean | TargetCountOutputTypeCountCapacityInfosArgs
  }

  // Custom InputTypes
  /**
   * TargetCountOutputType without action
   */
  export type TargetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetCountOutputType
     */
    select?: TargetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TargetCountOutputType without action
   */
  export type TargetCountOutputTypeCountCapacityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacity_infoWhereInput
  }


  /**
   * Count Type Capacity_infoCountOutputType
   */

  export type Capacity_infoCountOutputType = {
    capacityInfoInfluences: number
    capsuleGameCapacityInfos: number
  }

  export type Capacity_infoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfoInfluences?: boolean | Capacity_infoCountOutputTypeCountCapacityInfoInfluencesArgs
    capsuleGameCapacityInfos?: boolean | Capacity_infoCountOutputTypeCountCapsuleGameCapacityInfosArgs
  }

  // Custom InputTypes
  /**
   * Capacity_infoCountOutputType without action
   */
  export type Capacity_infoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capacity_infoCountOutputType
     */
    select?: Capacity_infoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Capacity_infoCountOutputType without action
   */
  export type Capacity_infoCountOutputTypeCountCapacityInfoInfluencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacity_info_influenceWhereInput
  }

  /**
   * Capacity_infoCountOutputType without action
   */
  export type Capacity_infoCountOutputTypeCountCapsuleGameCapacityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capsule_game_capacity_infoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model langue
   */

  export type AggregateLangue = {
    _count: LangueCountAggregateOutputType | null
    _avg: LangueAvgAggregateOutputType | null
    _sum: LangueSumAggregateOutputType | null
    _min: LangueMinAggregateOutputType | null
    _max: LangueMaxAggregateOutputType | null
  }

  export type LangueAvgAggregateOutputType = {
    id: number | null
  }

  export type LangueSumAggregateOutputType = {
    id: number | null
  }

  export type LangueMinAggregateOutputType = {
    id: number | null
    name: string | null
    isoCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type LangueMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isoCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type LangueCountAggregateOutputType = {
    id: number
    name: number
    isoCode: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type LangueAvgAggregateInputType = {
    id?: true
  }

  export type LangueSumAggregateInputType = {
    id?: true
  }

  export type LangueMinAggregateInputType = {
    id?: true
    name?: true
    isoCode?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type LangueMaxAggregateInputType = {
    id?: true
    name?: true
    isoCode?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type LangueCountAggregateInputType = {
    id?: true
    name?: true
    isoCode?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type LangueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which langue to aggregate.
     */
    where?: langueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of langues to fetch.
     */
    orderBy?: langueOrderByWithRelationInput | langueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: langueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` langues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` langues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned langues
    **/
    _count?: true | LangueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LangueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LangueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LangueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LangueMaxAggregateInputType
  }

  export type GetLangueAggregateType<T extends LangueAggregateArgs> = {
        [P in keyof T & keyof AggregateLangue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLangue[P]>
      : GetScalarType<T[P], AggregateLangue[P]>
  }




  export type langueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: langueWhereInput
    orderBy?: langueOrderByWithAggregationInput | langueOrderByWithAggregationInput[]
    by: LangueScalarFieldEnum[] | LangueScalarFieldEnum
    having?: langueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LangueCountAggregateInputType | true
    _avg?: LangueAvgAggregateInputType
    _sum?: LangueSumAggregateInputType
    _min?: LangueMinAggregateInputType
    _max?: LangueMaxAggregateInputType
  }

  export type LangueGroupByOutputType = {
    id: number
    name: string
    isoCode: string
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: LangueCountAggregateOutputType | null
    _avg: LangueAvgAggregateOutputType | null
    _sum: LangueSumAggregateOutputType | null
    _min: LangueMinAggregateOutputType | null
    _max: LangueMaxAggregateOutputType | null
  }

  type GetLangueGroupByPayload<T extends langueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LangueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LangueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LangueGroupByOutputType[P]>
            : GetScalarType<T[P], LangueGroupByOutputType[P]>
        }
      >
    >


  export type langueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isoCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    translations?: boolean | langue$translationsArgs<ExtArgs>
    _count?: boolean | LangueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["langue"]>



  export type langueSelectScalar = {
    id?: boolean
    name?: boolean
    isoCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type langueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isoCode" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["langue"]>
  export type langueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | langue$translationsArgs<ExtArgs>
    _count?: boolean | LangueCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $languePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "langue"
    objects: {
      translations: Prisma.$translationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      isoCode: string
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["langue"]>
    composites: {}
  }

  type langueGetPayload<S extends boolean | null | undefined | langueDefaultArgs> = $Result.GetResult<Prisma.$languePayload, S>

  type langueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<langueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LangueCountAggregateInputType | true
    }

  export interface langueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['langue'], meta: { name: 'langue' } }
    /**
     * Find zero or one Langue that matches the filter.
     * @param {langueFindUniqueArgs} args - Arguments to find a Langue
     * @example
     * // Get one Langue
     * const langue = await prisma.langue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends langueFindUniqueArgs>(args: SelectSubset<T, langueFindUniqueArgs<ExtArgs>>): Prisma__langueClient<$Result.GetResult<Prisma.$languePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Langue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {langueFindUniqueOrThrowArgs} args - Arguments to find a Langue
     * @example
     * // Get one Langue
     * const langue = await prisma.langue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends langueFindUniqueOrThrowArgs>(args: SelectSubset<T, langueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__langueClient<$Result.GetResult<Prisma.$languePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Langue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {langueFindFirstArgs} args - Arguments to find a Langue
     * @example
     * // Get one Langue
     * const langue = await prisma.langue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends langueFindFirstArgs>(args?: SelectSubset<T, langueFindFirstArgs<ExtArgs>>): Prisma__langueClient<$Result.GetResult<Prisma.$languePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Langue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {langueFindFirstOrThrowArgs} args - Arguments to find a Langue
     * @example
     * // Get one Langue
     * const langue = await prisma.langue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends langueFindFirstOrThrowArgs>(args?: SelectSubset<T, langueFindFirstOrThrowArgs<ExtArgs>>): Prisma__langueClient<$Result.GetResult<Prisma.$languePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Langues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {langueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Langues
     * const langues = await prisma.langue.findMany()
     * 
     * // Get first 10 Langues
     * const langues = await prisma.langue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const langueWithIdOnly = await prisma.langue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends langueFindManyArgs>(args?: SelectSubset<T, langueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$languePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Langue.
     * @param {langueCreateArgs} args - Arguments to create a Langue.
     * @example
     * // Create one Langue
     * const Langue = await prisma.langue.create({
     *   data: {
     *     // ... data to create a Langue
     *   }
     * })
     * 
     */
    create<T extends langueCreateArgs>(args: SelectSubset<T, langueCreateArgs<ExtArgs>>): Prisma__langueClient<$Result.GetResult<Prisma.$languePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Langues.
     * @param {langueCreateManyArgs} args - Arguments to create many Langues.
     * @example
     * // Create many Langues
     * const langue = await prisma.langue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends langueCreateManyArgs>(args?: SelectSubset<T, langueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Langue.
     * @param {langueDeleteArgs} args - Arguments to delete one Langue.
     * @example
     * // Delete one Langue
     * const Langue = await prisma.langue.delete({
     *   where: {
     *     // ... filter to delete one Langue
     *   }
     * })
     * 
     */
    delete<T extends langueDeleteArgs>(args: SelectSubset<T, langueDeleteArgs<ExtArgs>>): Prisma__langueClient<$Result.GetResult<Prisma.$languePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Langue.
     * @param {langueUpdateArgs} args - Arguments to update one Langue.
     * @example
     * // Update one Langue
     * const langue = await prisma.langue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends langueUpdateArgs>(args: SelectSubset<T, langueUpdateArgs<ExtArgs>>): Prisma__langueClient<$Result.GetResult<Prisma.$languePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Langues.
     * @param {langueDeleteManyArgs} args - Arguments to filter Langues to delete.
     * @example
     * // Delete a few Langues
     * const { count } = await prisma.langue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends langueDeleteManyArgs>(args?: SelectSubset<T, langueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Langues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {langueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Langues
     * const langue = await prisma.langue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends langueUpdateManyArgs>(args: SelectSubset<T, langueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Langue.
     * @param {langueUpsertArgs} args - Arguments to update or create a Langue.
     * @example
     * // Update or create a Langue
     * const langue = await prisma.langue.upsert({
     *   create: {
     *     // ... data to create a Langue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Langue we want to update
     *   }
     * })
     */
    upsert<T extends langueUpsertArgs>(args: SelectSubset<T, langueUpsertArgs<ExtArgs>>): Prisma__langueClient<$Result.GetResult<Prisma.$languePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Langues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {langueCountArgs} args - Arguments to filter Langues to count.
     * @example
     * // Count the number of Langues
     * const count = await prisma.langue.count({
     *   where: {
     *     // ... the filter for the Langues we want to count
     *   }
     * })
    **/
    count<T extends langueCountArgs>(
      args?: Subset<T, langueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LangueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Langue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LangueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LangueAggregateArgs>(args: Subset<T, LangueAggregateArgs>): Prisma.PrismaPromise<GetLangueAggregateType<T>>

    /**
     * Group by Langue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {langueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends langueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: langueGroupByArgs['orderBy'] }
        : { orderBy?: langueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, langueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLangueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the langue model
   */
  readonly fields: langueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for langue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__langueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends langue$translationsArgs<ExtArgs> = {}>(args?: Subset<T, langue$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$translationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the langue model
   */
  interface langueFieldRefs {
    readonly id: FieldRef<"langue", 'Int'>
    readonly name: FieldRef<"langue", 'String'>
    readonly isoCode: FieldRef<"langue", 'String'>
    readonly createdAt: FieldRef<"langue", 'DateTime'>
    readonly updatedAt: FieldRef<"langue", 'DateTime'>
    readonly status: FieldRef<"langue", 'String'>
  }
    

  // Custom InputTypes
  /**
   * langue findUnique
   */
  export type langueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the langue
     */
    select?: langueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the langue
     */
    omit?: langueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: langueInclude<ExtArgs> | null
    /**
     * Filter, which langue to fetch.
     */
    where: langueWhereUniqueInput
  }

  /**
   * langue findUniqueOrThrow
   */
  export type langueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the langue
     */
    select?: langueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the langue
     */
    omit?: langueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: langueInclude<ExtArgs> | null
    /**
     * Filter, which langue to fetch.
     */
    where: langueWhereUniqueInput
  }

  /**
   * langue findFirst
   */
  export type langueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the langue
     */
    select?: langueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the langue
     */
    omit?: langueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: langueInclude<ExtArgs> | null
    /**
     * Filter, which langue to fetch.
     */
    where?: langueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of langues to fetch.
     */
    orderBy?: langueOrderByWithRelationInput | langueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for langues.
     */
    cursor?: langueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` langues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` langues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of langues.
     */
    distinct?: LangueScalarFieldEnum | LangueScalarFieldEnum[]
  }

  /**
   * langue findFirstOrThrow
   */
  export type langueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the langue
     */
    select?: langueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the langue
     */
    omit?: langueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: langueInclude<ExtArgs> | null
    /**
     * Filter, which langue to fetch.
     */
    where?: langueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of langues to fetch.
     */
    orderBy?: langueOrderByWithRelationInput | langueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for langues.
     */
    cursor?: langueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` langues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` langues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of langues.
     */
    distinct?: LangueScalarFieldEnum | LangueScalarFieldEnum[]
  }

  /**
   * langue findMany
   */
  export type langueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the langue
     */
    select?: langueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the langue
     */
    omit?: langueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: langueInclude<ExtArgs> | null
    /**
     * Filter, which langues to fetch.
     */
    where?: langueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of langues to fetch.
     */
    orderBy?: langueOrderByWithRelationInput | langueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing langues.
     */
    cursor?: langueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` langues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` langues.
     */
    skip?: number
    distinct?: LangueScalarFieldEnum | LangueScalarFieldEnum[]
  }

  /**
   * langue create
   */
  export type langueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the langue
     */
    select?: langueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the langue
     */
    omit?: langueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: langueInclude<ExtArgs> | null
    /**
     * The data needed to create a langue.
     */
    data: XOR<langueCreateInput, langueUncheckedCreateInput>
  }

  /**
   * langue createMany
   */
  export type langueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many langues.
     */
    data: langueCreateManyInput | langueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * langue update
   */
  export type langueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the langue
     */
    select?: langueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the langue
     */
    omit?: langueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: langueInclude<ExtArgs> | null
    /**
     * The data needed to update a langue.
     */
    data: XOR<langueUpdateInput, langueUncheckedUpdateInput>
    /**
     * Choose, which langue to update.
     */
    where: langueWhereUniqueInput
  }

  /**
   * langue updateMany
   */
  export type langueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update langues.
     */
    data: XOR<langueUpdateManyMutationInput, langueUncheckedUpdateManyInput>
    /**
     * Filter which langues to update
     */
    where?: langueWhereInput
    /**
     * Limit how many langues to update.
     */
    limit?: number
  }

  /**
   * langue upsert
   */
  export type langueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the langue
     */
    select?: langueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the langue
     */
    omit?: langueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: langueInclude<ExtArgs> | null
    /**
     * The filter to search for the langue to update in case it exists.
     */
    where: langueWhereUniqueInput
    /**
     * In case the langue found by the `where` argument doesn't exist, create a new langue with this data.
     */
    create: XOR<langueCreateInput, langueUncheckedCreateInput>
    /**
     * In case the langue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<langueUpdateInput, langueUncheckedUpdateInput>
  }

  /**
   * langue delete
   */
  export type langueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the langue
     */
    select?: langueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the langue
     */
    omit?: langueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: langueInclude<ExtArgs> | null
    /**
     * Filter which langue to delete.
     */
    where: langueWhereUniqueInput
  }

  /**
   * langue deleteMany
   */
  export type langueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which langues to delete
     */
    where?: langueWhereInput
    /**
     * Limit how many langues to delete.
     */
    limit?: number
  }

  /**
   * langue.translations
   */
  export type langue$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translation
     */
    select?: translationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the translation
     */
    omit?: translationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: translationInclude<ExtArgs> | null
    where?: translationWhereInput
    orderBy?: translationOrderByWithRelationInput | translationOrderByWithRelationInput[]
    cursor?: translationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * langue without action
   */
  export type langueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the langue
     */
    select?: langueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the langue
     */
    omit?: langueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: langueInclude<ExtArgs> | null
  }


  /**
   * Model translation
   */

  export type AggregateTranslation = {
    _count: TranslationCountAggregateOutputType | null
    _avg: TranslationAvgAggregateOutputType | null
    _sum: TranslationSumAggregateOutputType | null
    _min: TranslationMinAggregateOutputType | null
    _max: TranslationMaxAggregateOutputType | null
  }

  export type TranslationAvgAggregateOutputType = {
    langueId: number | null
    referenceId: number | null
  }

  export type TranslationSumAggregateOutputType = {
    langueId: number | null
    referenceId: bigint | null
  }

  export type TranslationMinAggregateOutputType = {
    langueId: number | null
    referenceId: bigint | null
    referenceTable: $Enums.reference_table | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type TranslationMaxAggregateOutputType = {
    langueId: number | null
    referenceId: bigint | null
    referenceTable: $Enums.reference_table | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type TranslationCountAggregateOutputType = {
    langueId: number
    referenceId: number
    referenceTable: number
    name: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type TranslationAvgAggregateInputType = {
    langueId?: true
    referenceId?: true
  }

  export type TranslationSumAggregateInputType = {
    langueId?: true
    referenceId?: true
  }

  export type TranslationMinAggregateInputType = {
    langueId?: true
    referenceId?: true
    referenceTable?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type TranslationMaxAggregateInputType = {
    langueId?: true
    referenceId?: true
    referenceTable?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type TranslationCountAggregateInputType = {
    langueId?: true
    referenceId?: true
    referenceTable?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type TranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which translation to aggregate.
     */
    where?: translationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of translations to fetch.
     */
    orderBy?: translationOrderByWithRelationInput | translationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: translationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned translations
    **/
    _count?: true | TranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranslationMaxAggregateInputType
  }

  export type GetTranslationAggregateType<T extends TranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranslation[P]>
      : GetScalarType<T[P], AggregateTranslation[P]>
  }




  export type translationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: translationWhereInput
    orderBy?: translationOrderByWithAggregationInput | translationOrderByWithAggregationInput[]
    by: TranslationScalarFieldEnum[] | TranslationScalarFieldEnum
    having?: translationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranslationCountAggregateInputType | true
    _avg?: TranslationAvgAggregateInputType
    _sum?: TranslationSumAggregateInputType
    _min?: TranslationMinAggregateInputType
    _max?: TranslationMaxAggregateInputType
  }

  export type TranslationGroupByOutputType = {
    langueId: number
    referenceId: bigint
    referenceTable: $Enums.reference_table
    name: string
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: TranslationCountAggregateOutputType | null
    _avg: TranslationAvgAggregateOutputType | null
    _sum: TranslationSumAggregateOutputType | null
    _min: TranslationMinAggregateOutputType | null
    _max: TranslationMaxAggregateOutputType | null
  }

  type GetTranslationGroupByPayload<T extends translationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranslationGroupByOutputType[P]>
            : GetScalarType<T[P], TranslationGroupByOutputType[P]>
        }
      >
    >


  export type translationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    langueId?: boolean
    referenceId?: boolean
    referenceTable?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    langue?: boolean | langueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["translation"]>



  export type translationSelectScalar = {
    langueId?: boolean
    referenceId?: boolean
    referenceTable?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type translationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"langueId" | "referenceId" | "referenceTable" | "name" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["translation"]>
  export type translationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    langue?: boolean | langueDefaultArgs<ExtArgs>
  }

  export type $translationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "translation"
    objects: {
      langue: Prisma.$languePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      langueId: number
      referenceId: bigint
      referenceTable: $Enums.reference_table
      name: string
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["translation"]>
    composites: {}
  }

  type translationGetPayload<S extends boolean | null | undefined | translationDefaultArgs> = $Result.GetResult<Prisma.$translationPayload, S>

  type translationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<translationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TranslationCountAggregateInputType | true
    }

  export interface translationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['translation'], meta: { name: 'translation' } }
    /**
     * Find zero or one Translation that matches the filter.
     * @param {translationFindUniqueArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends translationFindUniqueArgs>(args: SelectSubset<T, translationFindUniqueArgs<ExtArgs>>): Prisma__translationClient<$Result.GetResult<Prisma.$translationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Translation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {translationFindUniqueOrThrowArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends translationFindUniqueOrThrowArgs>(args: SelectSubset<T, translationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__translationClient<$Result.GetResult<Prisma.$translationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Translation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationFindFirstArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends translationFindFirstArgs>(args?: SelectSubset<T, translationFindFirstArgs<ExtArgs>>): Prisma__translationClient<$Result.GetResult<Prisma.$translationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Translation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationFindFirstOrThrowArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends translationFindFirstOrThrowArgs>(args?: SelectSubset<T, translationFindFirstOrThrowArgs<ExtArgs>>): Prisma__translationClient<$Result.GetResult<Prisma.$translationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Translations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Translations
     * const translations = await prisma.translation.findMany()
     * 
     * // Get first 10 Translations
     * const translations = await prisma.translation.findMany({ take: 10 })
     * 
     * // Only select the `langueId`
     * const translationWithLangueIdOnly = await prisma.translation.findMany({ select: { langueId: true } })
     * 
     */
    findMany<T extends translationFindManyArgs>(args?: SelectSubset<T, translationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$translationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Translation.
     * @param {translationCreateArgs} args - Arguments to create a Translation.
     * @example
     * // Create one Translation
     * const Translation = await prisma.translation.create({
     *   data: {
     *     // ... data to create a Translation
     *   }
     * })
     * 
     */
    create<T extends translationCreateArgs>(args: SelectSubset<T, translationCreateArgs<ExtArgs>>): Prisma__translationClient<$Result.GetResult<Prisma.$translationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Translations.
     * @param {translationCreateManyArgs} args - Arguments to create many Translations.
     * @example
     * // Create many Translations
     * const translation = await prisma.translation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends translationCreateManyArgs>(args?: SelectSubset<T, translationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Translation.
     * @param {translationDeleteArgs} args - Arguments to delete one Translation.
     * @example
     * // Delete one Translation
     * const Translation = await prisma.translation.delete({
     *   where: {
     *     // ... filter to delete one Translation
     *   }
     * })
     * 
     */
    delete<T extends translationDeleteArgs>(args: SelectSubset<T, translationDeleteArgs<ExtArgs>>): Prisma__translationClient<$Result.GetResult<Prisma.$translationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Translation.
     * @param {translationUpdateArgs} args - Arguments to update one Translation.
     * @example
     * // Update one Translation
     * const translation = await prisma.translation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends translationUpdateArgs>(args: SelectSubset<T, translationUpdateArgs<ExtArgs>>): Prisma__translationClient<$Result.GetResult<Prisma.$translationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Translations.
     * @param {translationDeleteManyArgs} args - Arguments to filter Translations to delete.
     * @example
     * // Delete a few Translations
     * const { count } = await prisma.translation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends translationDeleteManyArgs>(args?: SelectSubset<T, translationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Translations
     * const translation = await prisma.translation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends translationUpdateManyArgs>(args: SelectSubset<T, translationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Translation.
     * @param {translationUpsertArgs} args - Arguments to update or create a Translation.
     * @example
     * // Update or create a Translation
     * const translation = await prisma.translation.upsert({
     *   create: {
     *     // ... data to create a Translation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Translation we want to update
     *   }
     * })
     */
    upsert<T extends translationUpsertArgs>(args: SelectSubset<T, translationUpsertArgs<ExtArgs>>): Prisma__translationClient<$Result.GetResult<Prisma.$translationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationCountArgs} args - Arguments to filter Translations to count.
     * @example
     * // Count the number of Translations
     * const count = await prisma.translation.count({
     *   where: {
     *     // ... the filter for the Translations we want to count
     *   }
     * })
    **/
    count<T extends translationCountArgs>(
      args?: Subset<T, translationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranslationAggregateArgs>(args: Subset<T, TranslationAggregateArgs>): Prisma.PrismaPromise<GetTranslationAggregateType<T>>

    /**
     * Group by Translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends translationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: translationGroupByArgs['orderBy'] }
        : { orderBy?: translationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, translationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the translation model
   */
  readonly fields: translationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for translation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__translationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    langue<T extends langueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, langueDefaultArgs<ExtArgs>>): Prisma__langueClient<$Result.GetResult<Prisma.$languePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the translation model
   */
  interface translationFieldRefs {
    readonly langueId: FieldRef<"translation", 'Int'>
    readonly referenceId: FieldRef<"translation", 'BigInt'>
    readonly referenceTable: FieldRef<"translation", 'reference_table'>
    readonly name: FieldRef<"translation", 'String'>
    readonly createdAt: FieldRef<"translation", 'DateTime'>
    readonly updatedAt: FieldRef<"translation", 'DateTime'>
    readonly status: FieldRef<"translation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * translation findUnique
   */
  export type translationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translation
     */
    select?: translationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the translation
     */
    omit?: translationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: translationInclude<ExtArgs> | null
    /**
     * Filter, which translation to fetch.
     */
    where: translationWhereUniqueInput
  }

  /**
   * translation findUniqueOrThrow
   */
  export type translationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translation
     */
    select?: translationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the translation
     */
    omit?: translationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: translationInclude<ExtArgs> | null
    /**
     * Filter, which translation to fetch.
     */
    where: translationWhereUniqueInput
  }

  /**
   * translation findFirst
   */
  export type translationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translation
     */
    select?: translationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the translation
     */
    omit?: translationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: translationInclude<ExtArgs> | null
    /**
     * Filter, which translation to fetch.
     */
    where?: translationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of translations to fetch.
     */
    orderBy?: translationOrderByWithRelationInput | translationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for translations.
     */
    cursor?: translationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of translations.
     */
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * translation findFirstOrThrow
   */
  export type translationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translation
     */
    select?: translationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the translation
     */
    omit?: translationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: translationInclude<ExtArgs> | null
    /**
     * Filter, which translation to fetch.
     */
    where?: translationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of translations to fetch.
     */
    orderBy?: translationOrderByWithRelationInput | translationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for translations.
     */
    cursor?: translationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of translations.
     */
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * translation findMany
   */
  export type translationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translation
     */
    select?: translationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the translation
     */
    omit?: translationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: translationInclude<ExtArgs> | null
    /**
     * Filter, which translations to fetch.
     */
    where?: translationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of translations to fetch.
     */
    orderBy?: translationOrderByWithRelationInput | translationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing translations.
     */
    cursor?: translationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` translations.
     */
    skip?: number
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * translation create
   */
  export type translationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translation
     */
    select?: translationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the translation
     */
    omit?: translationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: translationInclude<ExtArgs> | null
    /**
     * The data needed to create a translation.
     */
    data: XOR<translationCreateInput, translationUncheckedCreateInput>
  }

  /**
   * translation createMany
   */
  export type translationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many translations.
     */
    data: translationCreateManyInput | translationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * translation update
   */
  export type translationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translation
     */
    select?: translationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the translation
     */
    omit?: translationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: translationInclude<ExtArgs> | null
    /**
     * The data needed to update a translation.
     */
    data: XOR<translationUpdateInput, translationUncheckedUpdateInput>
    /**
     * Choose, which translation to update.
     */
    where: translationWhereUniqueInput
  }

  /**
   * translation updateMany
   */
  export type translationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update translations.
     */
    data: XOR<translationUpdateManyMutationInput, translationUncheckedUpdateManyInput>
    /**
     * Filter which translations to update
     */
    where?: translationWhereInput
    /**
     * Limit how many translations to update.
     */
    limit?: number
  }

  /**
   * translation upsert
   */
  export type translationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translation
     */
    select?: translationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the translation
     */
    omit?: translationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: translationInclude<ExtArgs> | null
    /**
     * The filter to search for the translation to update in case it exists.
     */
    where: translationWhereUniqueInput
    /**
     * In case the translation found by the `where` argument doesn't exist, create a new translation with this data.
     */
    create: XOR<translationCreateInput, translationUncheckedCreateInput>
    /**
     * In case the translation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<translationUpdateInput, translationUncheckedUpdateInput>
  }

  /**
   * translation delete
   */
  export type translationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translation
     */
    select?: translationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the translation
     */
    omit?: translationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: translationInclude<ExtArgs> | null
    /**
     * Filter which translation to delete.
     */
    where: translationWhereUniqueInput
  }

  /**
   * translation deleteMany
   */
  export type translationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which translations to delete
     */
    where?: translationWhereInput
    /**
     * Limit how many translations to delete.
     */
    limit?: number
  }

  /**
   * translation without action
   */
  export type translationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translation
     */
    select?: translationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the translation
     */
    omit?: translationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: translationInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    discordId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    discordId: bigint | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    discordId: bigint | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    pseudonym: string | null
    role: $Enums.role | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    discordId: bigint | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    pseudonym: string | null
    role: $Enums.role | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    discordId: number
    email: number
    password: number
    createdAt: number
    updatedAt: number
    status: number
    pseudonym: number
    role: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    discordId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    discordId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    discordId?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    pseudonym?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    discordId?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    pseudonym?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    discordId?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    pseudonym?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    discordId: bigint | null
    email: string
    password: string
    createdAt: Date
    updatedAt: Date | null
    status: string
    pseudonym: string
    role: $Enums.role
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discordId?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    pseudonym?: boolean
    role?: boolean
    ownedPokemons?: boolean | user$ownedPokemonsArgs<ExtArgs>
    refreshTokens?: boolean | user$refreshTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    id?: boolean
    discordId?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    pseudonym?: boolean
    role?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "discordId" | "email" | "password" | "createdAt" | "updatedAt" | "status" | "pseudonym" | "role", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedPokemons?: boolean | user$ownedPokemonsArgs<ExtArgs>
    refreshTokens?: boolean | user$refreshTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      ownedPokemons: Prisma.$owned_pokemonPayload<ExtArgs>[]
      refreshTokens: Prisma.$refresh_tokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      discordId: bigint | null
      email: string
      password: string
      createdAt: Date
      updatedAt: Date | null
      status: string
      pseudonym: string
      role: $Enums.role
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ownedPokemons<T extends user$ownedPokemonsArgs<ExtArgs> = {}>(args?: Subset<T, user$ownedPokemonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$owned_pokemonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends user$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, user$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refresh_tokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly discordId: FieldRef<"user", 'BigInt'>
    readonly email: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly createdAt: FieldRef<"user", 'DateTime'>
    readonly updatedAt: FieldRef<"user", 'DateTime'>
    readonly status: FieldRef<"user", 'String'>
    readonly pseudonym: FieldRef<"user", 'String'>
    readonly role: FieldRef<"user", 'role'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.ownedPokemons
   */
  export type user$ownedPokemonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon
     */
    select?: owned_pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon
     */
    omit?: owned_pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemonInclude<ExtArgs> | null
    where?: owned_pokemonWhereInput
    orderBy?: owned_pokemonOrderByWithRelationInput | owned_pokemonOrderByWithRelationInput[]
    cursor?: owned_pokemonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Owned_pokemonScalarFieldEnum | Owned_pokemonScalarFieldEnum[]
  }

  /**
   * user.refreshTokens
   */
  export type user$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_token
     */
    select?: refresh_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_token
     */
    omit?: refresh_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokenInclude<ExtArgs> | null
    where?: refresh_tokenWhereInput
    orderBy?: refresh_tokenOrderByWithRelationInput | refresh_tokenOrderByWithRelationInput[]
    cursor?: refresh_tokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Refresh_tokenScalarFieldEnum | Refresh_tokenScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model shiny_hunting_method
   */

  export type AggregateShiny_hunting_method = {
    _count: Shiny_hunting_methodCountAggregateOutputType | null
    _avg: Shiny_hunting_methodAvgAggregateOutputType | null
    _sum: Shiny_hunting_methodSumAggregateOutputType | null
    _min: Shiny_hunting_methodMinAggregateOutputType | null
    _max: Shiny_hunting_methodMaxAggregateOutputType | null
  }

  export type Shiny_hunting_methodAvgAggregateOutputType = {
    id: number | null
  }

  export type Shiny_hunting_methodSumAggregateOutputType = {
    id: number | null
  }

  export type Shiny_hunting_methodMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Shiny_hunting_methodMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Shiny_hunting_methodCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Shiny_hunting_methodAvgAggregateInputType = {
    id?: true
  }

  export type Shiny_hunting_methodSumAggregateInputType = {
    id?: true
  }

  export type Shiny_hunting_methodMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Shiny_hunting_methodMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Shiny_hunting_methodCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Shiny_hunting_methodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shiny_hunting_method to aggregate.
     */
    where?: shiny_hunting_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shiny_hunting_methods to fetch.
     */
    orderBy?: shiny_hunting_methodOrderByWithRelationInput | shiny_hunting_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: shiny_hunting_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shiny_hunting_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shiny_hunting_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned shiny_hunting_methods
    **/
    _count?: true | Shiny_hunting_methodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Shiny_hunting_methodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Shiny_hunting_methodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Shiny_hunting_methodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Shiny_hunting_methodMaxAggregateInputType
  }

  export type GetShiny_hunting_methodAggregateType<T extends Shiny_hunting_methodAggregateArgs> = {
        [P in keyof T & keyof AggregateShiny_hunting_method]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiny_hunting_method[P]>
      : GetScalarType<T[P], AggregateShiny_hunting_method[P]>
  }




  export type shiny_hunting_methodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: shiny_hunting_methodWhereInput
    orderBy?: shiny_hunting_methodOrderByWithAggregationInput | shiny_hunting_methodOrderByWithAggregationInput[]
    by: Shiny_hunting_methodScalarFieldEnum[] | Shiny_hunting_methodScalarFieldEnum
    having?: shiny_hunting_methodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Shiny_hunting_methodCountAggregateInputType | true
    _avg?: Shiny_hunting_methodAvgAggregateInputType
    _sum?: Shiny_hunting_methodSumAggregateInputType
    _min?: Shiny_hunting_methodMinAggregateInputType
    _max?: Shiny_hunting_methodMaxAggregateInputType
  }

  export type Shiny_hunting_methodGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Shiny_hunting_methodCountAggregateOutputType | null
    _avg: Shiny_hunting_methodAvgAggregateOutputType | null
    _sum: Shiny_hunting_methodSumAggregateOutputType | null
    _min: Shiny_hunting_methodMinAggregateOutputType | null
    _max: Shiny_hunting_methodMaxAggregateOutputType | null
  }

  type GetShiny_hunting_methodGroupByPayload<T extends shiny_hunting_methodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Shiny_hunting_methodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Shiny_hunting_methodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Shiny_hunting_methodGroupByOutputType[P]>
            : GetScalarType<T[P], Shiny_hunting_methodGroupByOutputType[P]>
        }
      >
    >


  export type shiny_hunting_methodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    ownedPokemons?: boolean | shiny_hunting_method$ownedPokemonsArgs<ExtArgs>
    shinyHuntingMethodGames?: boolean | shiny_hunting_method$shinyHuntingMethodGamesArgs<ExtArgs>
    shinyHuntingMethodRates?: boolean | shiny_hunting_method$shinyHuntingMethodRatesArgs<ExtArgs>
    _count?: boolean | Shiny_hunting_methodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiny_hunting_method"]>



  export type shiny_hunting_methodSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type shiny_hunting_methodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["shiny_hunting_method"]>
  export type shiny_hunting_methodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedPokemons?: boolean | shiny_hunting_method$ownedPokemonsArgs<ExtArgs>
    shinyHuntingMethodGames?: boolean | shiny_hunting_method$shinyHuntingMethodGamesArgs<ExtArgs>
    shinyHuntingMethodRates?: boolean | shiny_hunting_method$shinyHuntingMethodRatesArgs<ExtArgs>
    _count?: boolean | Shiny_hunting_methodCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $shiny_hunting_methodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "shiny_hunting_method"
    objects: {
      ownedPokemons: Prisma.$owned_pokemonPayload<ExtArgs>[]
      shinyHuntingMethodGames: Prisma.$shiny_hunting_method_gamePayload<ExtArgs>[]
      shinyHuntingMethodRates: Prisma.$shiny_hunting_method_ratePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["shiny_hunting_method"]>
    composites: {}
  }

  type shiny_hunting_methodGetPayload<S extends boolean | null | undefined | shiny_hunting_methodDefaultArgs> = $Result.GetResult<Prisma.$shiny_hunting_methodPayload, S>

  type shiny_hunting_methodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<shiny_hunting_methodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Shiny_hunting_methodCountAggregateInputType | true
    }

  export interface shiny_hunting_methodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shiny_hunting_method'], meta: { name: 'shiny_hunting_method' } }
    /**
     * Find zero or one Shiny_hunting_method that matches the filter.
     * @param {shiny_hunting_methodFindUniqueArgs} args - Arguments to find a Shiny_hunting_method
     * @example
     * // Get one Shiny_hunting_method
     * const shiny_hunting_method = await prisma.shiny_hunting_method.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends shiny_hunting_methodFindUniqueArgs>(args: SelectSubset<T, shiny_hunting_methodFindUniqueArgs<ExtArgs>>): Prisma__shiny_hunting_methodClient<$Result.GetResult<Prisma.$shiny_hunting_methodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shiny_hunting_method that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {shiny_hunting_methodFindUniqueOrThrowArgs} args - Arguments to find a Shiny_hunting_method
     * @example
     * // Get one Shiny_hunting_method
     * const shiny_hunting_method = await prisma.shiny_hunting_method.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends shiny_hunting_methodFindUniqueOrThrowArgs>(args: SelectSubset<T, shiny_hunting_methodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shiny_hunting_methodClient<$Result.GetResult<Prisma.$shiny_hunting_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shiny_hunting_method that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_methodFindFirstArgs} args - Arguments to find a Shiny_hunting_method
     * @example
     * // Get one Shiny_hunting_method
     * const shiny_hunting_method = await prisma.shiny_hunting_method.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends shiny_hunting_methodFindFirstArgs>(args?: SelectSubset<T, shiny_hunting_methodFindFirstArgs<ExtArgs>>): Prisma__shiny_hunting_methodClient<$Result.GetResult<Prisma.$shiny_hunting_methodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shiny_hunting_method that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_methodFindFirstOrThrowArgs} args - Arguments to find a Shiny_hunting_method
     * @example
     * // Get one Shiny_hunting_method
     * const shiny_hunting_method = await prisma.shiny_hunting_method.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends shiny_hunting_methodFindFirstOrThrowArgs>(args?: SelectSubset<T, shiny_hunting_methodFindFirstOrThrowArgs<ExtArgs>>): Prisma__shiny_hunting_methodClient<$Result.GetResult<Prisma.$shiny_hunting_methodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shiny_hunting_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_methodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shiny_hunting_methods
     * const shiny_hunting_methods = await prisma.shiny_hunting_method.findMany()
     * 
     * // Get first 10 Shiny_hunting_methods
     * const shiny_hunting_methods = await prisma.shiny_hunting_method.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiny_hunting_methodWithIdOnly = await prisma.shiny_hunting_method.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends shiny_hunting_methodFindManyArgs>(args?: SelectSubset<T, shiny_hunting_methodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shiny_hunting_methodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shiny_hunting_method.
     * @param {shiny_hunting_methodCreateArgs} args - Arguments to create a Shiny_hunting_method.
     * @example
     * // Create one Shiny_hunting_method
     * const Shiny_hunting_method = await prisma.shiny_hunting_method.create({
     *   data: {
     *     // ... data to create a Shiny_hunting_method
     *   }
     * })
     * 
     */
    create<T extends shiny_hunting_methodCreateArgs>(args: SelectSubset<T, shiny_hunting_methodCreateArgs<ExtArgs>>): Prisma__shiny_hunting_methodClient<$Result.GetResult<Prisma.$shiny_hunting_methodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shiny_hunting_methods.
     * @param {shiny_hunting_methodCreateManyArgs} args - Arguments to create many Shiny_hunting_methods.
     * @example
     * // Create many Shiny_hunting_methods
     * const shiny_hunting_method = await prisma.shiny_hunting_method.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends shiny_hunting_methodCreateManyArgs>(args?: SelectSubset<T, shiny_hunting_methodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shiny_hunting_method.
     * @param {shiny_hunting_methodDeleteArgs} args - Arguments to delete one Shiny_hunting_method.
     * @example
     * // Delete one Shiny_hunting_method
     * const Shiny_hunting_method = await prisma.shiny_hunting_method.delete({
     *   where: {
     *     // ... filter to delete one Shiny_hunting_method
     *   }
     * })
     * 
     */
    delete<T extends shiny_hunting_methodDeleteArgs>(args: SelectSubset<T, shiny_hunting_methodDeleteArgs<ExtArgs>>): Prisma__shiny_hunting_methodClient<$Result.GetResult<Prisma.$shiny_hunting_methodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shiny_hunting_method.
     * @param {shiny_hunting_methodUpdateArgs} args - Arguments to update one Shiny_hunting_method.
     * @example
     * // Update one Shiny_hunting_method
     * const shiny_hunting_method = await prisma.shiny_hunting_method.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends shiny_hunting_methodUpdateArgs>(args: SelectSubset<T, shiny_hunting_methodUpdateArgs<ExtArgs>>): Prisma__shiny_hunting_methodClient<$Result.GetResult<Prisma.$shiny_hunting_methodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shiny_hunting_methods.
     * @param {shiny_hunting_methodDeleteManyArgs} args - Arguments to filter Shiny_hunting_methods to delete.
     * @example
     * // Delete a few Shiny_hunting_methods
     * const { count } = await prisma.shiny_hunting_method.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends shiny_hunting_methodDeleteManyArgs>(args?: SelectSubset<T, shiny_hunting_methodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shiny_hunting_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_methodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shiny_hunting_methods
     * const shiny_hunting_method = await prisma.shiny_hunting_method.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends shiny_hunting_methodUpdateManyArgs>(args: SelectSubset<T, shiny_hunting_methodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shiny_hunting_method.
     * @param {shiny_hunting_methodUpsertArgs} args - Arguments to update or create a Shiny_hunting_method.
     * @example
     * // Update or create a Shiny_hunting_method
     * const shiny_hunting_method = await prisma.shiny_hunting_method.upsert({
     *   create: {
     *     // ... data to create a Shiny_hunting_method
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shiny_hunting_method we want to update
     *   }
     * })
     */
    upsert<T extends shiny_hunting_methodUpsertArgs>(args: SelectSubset<T, shiny_hunting_methodUpsertArgs<ExtArgs>>): Prisma__shiny_hunting_methodClient<$Result.GetResult<Prisma.$shiny_hunting_methodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shiny_hunting_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_methodCountArgs} args - Arguments to filter Shiny_hunting_methods to count.
     * @example
     * // Count the number of Shiny_hunting_methods
     * const count = await prisma.shiny_hunting_method.count({
     *   where: {
     *     // ... the filter for the Shiny_hunting_methods we want to count
     *   }
     * })
    **/
    count<T extends shiny_hunting_methodCountArgs>(
      args?: Subset<T, shiny_hunting_methodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Shiny_hunting_methodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shiny_hunting_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shiny_hunting_methodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Shiny_hunting_methodAggregateArgs>(args: Subset<T, Shiny_hunting_methodAggregateArgs>): Prisma.PrismaPromise<GetShiny_hunting_methodAggregateType<T>>

    /**
     * Group by Shiny_hunting_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_methodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends shiny_hunting_methodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: shiny_hunting_methodGroupByArgs['orderBy'] }
        : { orderBy?: shiny_hunting_methodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, shiny_hunting_methodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiny_hunting_methodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the shiny_hunting_method model
   */
  readonly fields: shiny_hunting_methodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for shiny_hunting_method.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__shiny_hunting_methodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ownedPokemons<T extends shiny_hunting_method$ownedPokemonsArgs<ExtArgs> = {}>(args?: Subset<T, shiny_hunting_method$ownedPokemonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$owned_pokemonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shinyHuntingMethodGames<T extends shiny_hunting_method$shinyHuntingMethodGamesArgs<ExtArgs> = {}>(args?: Subset<T, shiny_hunting_method$shinyHuntingMethodGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shiny_hunting_method_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shinyHuntingMethodRates<T extends shiny_hunting_method$shinyHuntingMethodRatesArgs<ExtArgs> = {}>(args?: Subset<T, shiny_hunting_method$shinyHuntingMethodRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shiny_hunting_method_ratePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the shiny_hunting_method model
   */
  interface shiny_hunting_methodFieldRefs {
    readonly id: FieldRef<"shiny_hunting_method", 'Int'>
    readonly createdAt: FieldRef<"shiny_hunting_method", 'DateTime'>
    readonly updatedAt: FieldRef<"shiny_hunting_method", 'DateTime'>
    readonly status: FieldRef<"shiny_hunting_method", 'String'>
  }
    

  // Custom InputTypes
  /**
   * shiny_hunting_method findUnique
   */
  export type shiny_hunting_methodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method
     */
    select?: shiny_hunting_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method
     */
    omit?: shiny_hunting_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_methodInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_method to fetch.
     */
    where: shiny_hunting_methodWhereUniqueInput
  }

  /**
   * shiny_hunting_method findUniqueOrThrow
   */
  export type shiny_hunting_methodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method
     */
    select?: shiny_hunting_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method
     */
    omit?: shiny_hunting_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_methodInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_method to fetch.
     */
    where: shiny_hunting_methodWhereUniqueInput
  }

  /**
   * shiny_hunting_method findFirst
   */
  export type shiny_hunting_methodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method
     */
    select?: shiny_hunting_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method
     */
    omit?: shiny_hunting_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_methodInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_method to fetch.
     */
    where?: shiny_hunting_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shiny_hunting_methods to fetch.
     */
    orderBy?: shiny_hunting_methodOrderByWithRelationInput | shiny_hunting_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shiny_hunting_methods.
     */
    cursor?: shiny_hunting_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shiny_hunting_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shiny_hunting_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shiny_hunting_methods.
     */
    distinct?: Shiny_hunting_methodScalarFieldEnum | Shiny_hunting_methodScalarFieldEnum[]
  }

  /**
   * shiny_hunting_method findFirstOrThrow
   */
  export type shiny_hunting_methodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method
     */
    select?: shiny_hunting_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method
     */
    omit?: shiny_hunting_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_methodInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_method to fetch.
     */
    where?: shiny_hunting_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shiny_hunting_methods to fetch.
     */
    orderBy?: shiny_hunting_methodOrderByWithRelationInput | shiny_hunting_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shiny_hunting_methods.
     */
    cursor?: shiny_hunting_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shiny_hunting_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shiny_hunting_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shiny_hunting_methods.
     */
    distinct?: Shiny_hunting_methodScalarFieldEnum | Shiny_hunting_methodScalarFieldEnum[]
  }

  /**
   * shiny_hunting_method findMany
   */
  export type shiny_hunting_methodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method
     */
    select?: shiny_hunting_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method
     */
    omit?: shiny_hunting_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_methodInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_methods to fetch.
     */
    where?: shiny_hunting_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shiny_hunting_methods to fetch.
     */
    orderBy?: shiny_hunting_methodOrderByWithRelationInput | shiny_hunting_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing shiny_hunting_methods.
     */
    cursor?: shiny_hunting_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shiny_hunting_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shiny_hunting_methods.
     */
    skip?: number
    distinct?: Shiny_hunting_methodScalarFieldEnum | Shiny_hunting_methodScalarFieldEnum[]
  }

  /**
   * shiny_hunting_method create
   */
  export type shiny_hunting_methodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method
     */
    select?: shiny_hunting_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method
     */
    omit?: shiny_hunting_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_methodInclude<ExtArgs> | null
    /**
     * The data needed to create a shiny_hunting_method.
     */
    data?: XOR<shiny_hunting_methodCreateInput, shiny_hunting_methodUncheckedCreateInput>
  }

  /**
   * shiny_hunting_method createMany
   */
  export type shiny_hunting_methodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many shiny_hunting_methods.
     */
    data: shiny_hunting_methodCreateManyInput | shiny_hunting_methodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * shiny_hunting_method update
   */
  export type shiny_hunting_methodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method
     */
    select?: shiny_hunting_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method
     */
    omit?: shiny_hunting_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_methodInclude<ExtArgs> | null
    /**
     * The data needed to update a shiny_hunting_method.
     */
    data: XOR<shiny_hunting_methodUpdateInput, shiny_hunting_methodUncheckedUpdateInput>
    /**
     * Choose, which shiny_hunting_method to update.
     */
    where: shiny_hunting_methodWhereUniqueInput
  }

  /**
   * shiny_hunting_method updateMany
   */
  export type shiny_hunting_methodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update shiny_hunting_methods.
     */
    data: XOR<shiny_hunting_methodUpdateManyMutationInput, shiny_hunting_methodUncheckedUpdateManyInput>
    /**
     * Filter which shiny_hunting_methods to update
     */
    where?: shiny_hunting_methodWhereInput
    /**
     * Limit how many shiny_hunting_methods to update.
     */
    limit?: number
  }

  /**
   * shiny_hunting_method upsert
   */
  export type shiny_hunting_methodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method
     */
    select?: shiny_hunting_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method
     */
    omit?: shiny_hunting_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_methodInclude<ExtArgs> | null
    /**
     * The filter to search for the shiny_hunting_method to update in case it exists.
     */
    where: shiny_hunting_methodWhereUniqueInput
    /**
     * In case the shiny_hunting_method found by the `where` argument doesn't exist, create a new shiny_hunting_method with this data.
     */
    create: XOR<shiny_hunting_methodCreateInput, shiny_hunting_methodUncheckedCreateInput>
    /**
     * In case the shiny_hunting_method was found with the provided `where` argument, update it with this data.
     */
    update: XOR<shiny_hunting_methodUpdateInput, shiny_hunting_methodUncheckedUpdateInput>
  }

  /**
   * shiny_hunting_method delete
   */
  export type shiny_hunting_methodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method
     */
    select?: shiny_hunting_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method
     */
    omit?: shiny_hunting_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_methodInclude<ExtArgs> | null
    /**
     * Filter which shiny_hunting_method to delete.
     */
    where: shiny_hunting_methodWhereUniqueInput
  }

  /**
   * shiny_hunting_method deleteMany
   */
  export type shiny_hunting_methodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shiny_hunting_methods to delete
     */
    where?: shiny_hunting_methodWhereInput
    /**
     * Limit how many shiny_hunting_methods to delete.
     */
    limit?: number
  }

  /**
   * shiny_hunting_method.ownedPokemons
   */
  export type shiny_hunting_method$ownedPokemonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon
     */
    select?: owned_pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon
     */
    omit?: owned_pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemonInclude<ExtArgs> | null
    where?: owned_pokemonWhereInput
    orderBy?: owned_pokemonOrderByWithRelationInput | owned_pokemonOrderByWithRelationInput[]
    cursor?: owned_pokemonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Owned_pokemonScalarFieldEnum | Owned_pokemonScalarFieldEnum[]
  }

  /**
   * shiny_hunting_method.shinyHuntingMethodGames
   */
  export type shiny_hunting_method$shinyHuntingMethodGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_game
     */
    select?: shiny_hunting_method_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_game
     */
    omit?: shiny_hunting_method_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_gameInclude<ExtArgs> | null
    where?: shiny_hunting_method_gameWhereInput
    orderBy?: shiny_hunting_method_gameOrderByWithRelationInput | shiny_hunting_method_gameOrderByWithRelationInput[]
    cursor?: shiny_hunting_method_gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Shiny_hunting_method_gameScalarFieldEnum | Shiny_hunting_method_gameScalarFieldEnum[]
  }

  /**
   * shiny_hunting_method.shinyHuntingMethodRates
   */
  export type shiny_hunting_method$shinyHuntingMethodRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_rate
     */
    select?: shiny_hunting_method_rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_rate
     */
    omit?: shiny_hunting_method_rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_rateInclude<ExtArgs> | null
    where?: shiny_hunting_method_rateWhereInput
    orderBy?: shiny_hunting_method_rateOrderByWithRelationInput | shiny_hunting_method_rateOrderByWithRelationInput[]
    cursor?: shiny_hunting_method_rateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Shiny_hunting_method_rateScalarFieldEnum | Shiny_hunting_method_rateScalarFieldEnum[]
  }

  /**
   * shiny_hunting_method without action
   */
  export type shiny_hunting_methodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method
     */
    select?: shiny_hunting_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method
     */
    omit?: shiny_hunting_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_methodInclude<ExtArgs> | null
  }


  /**
   * Model pokeball
   */

  export type AggregatePokeball = {
    _count: PokeballCountAggregateOutputType | null
    _avg: PokeballAvgAggregateOutputType | null
    _sum: PokeballSumAggregateOutputType | null
    _min: PokeballMinAggregateOutputType | null
    _max: PokeballMaxAggregateOutputType | null
  }

  export type PokeballAvgAggregateOutputType = {
    id: number | null
  }

  export type PokeballSumAggregateOutputType = {
    id: number | null
  }

  export type PokeballMinAggregateOutputType = {
    id: number | null
    picture: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type PokeballMaxAggregateOutputType = {
    id: number | null
    picture: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type PokeballCountAggregateOutputType = {
    id: number
    picture: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type PokeballAvgAggregateInputType = {
    id?: true
  }

  export type PokeballSumAggregateInputType = {
    id?: true
  }

  export type PokeballMinAggregateInputType = {
    id?: true
    picture?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type PokeballMaxAggregateInputType = {
    id?: true
    picture?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type PokeballCountAggregateInputType = {
    id?: true
    picture?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type PokeballAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokeball to aggregate.
     */
    where?: pokeballWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokeballs to fetch.
     */
    orderBy?: pokeballOrderByWithRelationInput | pokeballOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pokeballWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokeballs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokeballs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pokeballs
    **/
    _count?: true | PokeballCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PokeballAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PokeballSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PokeballMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PokeballMaxAggregateInputType
  }

  export type GetPokeballAggregateType<T extends PokeballAggregateArgs> = {
        [P in keyof T & keyof AggregatePokeball]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokeball[P]>
      : GetScalarType<T[P], AggregatePokeball[P]>
  }




  export type pokeballGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokeballWhereInput
    orderBy?: pokeballOrderByWithAggregationInput | pokeballOrderByWithAggregationInput[]
    by: PokeballScalarFieldEnum[] | PokeballScalarFieldEnum
    having?: pokeballScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PokeballCountAggregateInputType | true
    _avg?: PokeballAvgAggregateInputType
    _sum?: PokeballSumAggregateInputType
    _min?: PokeballMinAggregateInputType
    _max?: PokeballMaxAggregateInputType
  }

  export type PokeballGroupByOutputType = {
    id: number
    picture: string
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: PokeballCountAggregateOutputType | null
    _avg: PokeballAvgAggregateOutputType | null
    _sum: PokeballSumAggregateOutputType | null
    _min: PokeballMinAggregateOutputType | null
    _max: PokeballMaxAggregateOutputType | null
  }

  type GetPokeballGroupByPayload<T extends pokeballGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PokeballGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PokeballGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PokeballGroupByOutputType[P]>
            : GetScalarType<T[P], PokeballGroupByOutputType[P]>
        }
      >
    >


  export type pokeballSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    picture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    ownedPokemonDetails?: boolean | pokeball$ownedPokemonDetailsArgs<ExtArgs>
    _count?: boolean | PokeballCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokeball"]>



  export type pokeballSelectScalar = {
    id?: boolean
    picture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type pokeballOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "picture" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["pokeball"]>
  export type pokeballInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedPokemonDetails?: boolean | pokeball$ownedPokemonDetailsArgs<ExtArgs>
    _count?: boolean | PokeballCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $pokeballPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pokeball"
    objects: {
      ownedPokemonDetails: Prisma.$owned_pokemon_detailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      picture: string
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["pokeball"]>
    composites: {}
  }

  type pokeballGetPayload<S extends boolean | null | undefined | pokeballDefaultArgs> = $Result.GetResult<Prisma.$pokeballPayload, S>

  type pokeballCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pokeballFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PokeballCountAggregateInputType | true
    }

  export interface pokeballDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pokeball'], meta: { name: 'pokeball' } }
    /**
     * Find zero or one Pokeball that matches the filter.
     * @param {pokeballFindUniqueArgs} args - Arguments to find a Pokeball
     * @example
     * // Get one Pokeball
     * const pokeball = await prisma.pokeball.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pokeballFindUniqueArgs>(args: SelectSubset<T, pokeballFindUniqueArgs<ExtArgs>>): Prisma__pokeballClient<$Result.GetResult<Prisma.$pokeballPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pokeball that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pokeballFindUniqueOrThrowArgs} args - Arguments to find a Pokeball
     * @example
     * // Get one Pokeball
     * const pokeball = await prisma.pokeball.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pokeballFindUniqueOrThrowArgs>(args: SelectSubset<T, pokeballFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pokeballClient<$Result.GetResult<Prisma.$pokeballPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokeball that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokeballFindFirstArgs} args - Arguments to find a Pokeball
     * @example
     * // Get one Pokeball
     * const pokeball = await prisma.pokeball.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pokeballFindFirstArgs>(args?: SelectSubset<T, pokeballFindFirstArgs<ExtArgs>>): Prisma__pokeballClient<$Result.GetResult<Prisma.$pokeballPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokeball that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokeballFindFirstOrThrowArgs} args - Arguments to find a Pokeball
     * @example
     * // Get one Pokeball
     * const pokeball = await prisma.pokeball.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pokeballFindFirstOrThrowArgs>(args?: SelectSubset<T, pokeballFindFirstOrThrowArgs<ExtArgs>>): Prisma__pokeballClient<$Result.GetResult<Prisma.$pokeballPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pokeballs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokeballFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pokeballs
     * const pokeballs = await prisma.pokeball.findMany()
     * 
     * // Get first 10 Pokeballs
     * const pokeballs = await prisma.pokeball.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokeballWithIdOnly = await prisma.pokeball.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pokeballFindManyArgs>(args?: SelectSubset<T, pokeballFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokeballPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pokeball.
     * @param {pokeballCreateArgs} args - Arguments to create a Pokeball.
     * @example
     * // Create one Pokeball
     * const Pokeball = await prisma.pokeball.create({
     *   data: {
     *     // ... data to create a Pokeball
     *   }
     * })
     * 
     */
    create<T extends pokeballCreateArgs>(args: SelectSubset<T, pokeballCreateArgs<ExtArgs>>): Prisma__pokeballClient<$Result.GetResult<Prisma.$pokeballPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pokeballs.
     * @param {pokeballCreateManyArgs} args - Arguments to create many Pokeballs.
     * @example
     * // Create many Pokeballs
     * const pokeball = await prisma.pokeball.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pokeballCreateManyArgs>(args?: SelectSubset<T, pokeballCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pokeball.
     * @param {pokeballDeleteArgs} args - Arguments to delete one Pokeball.
     * @example
     * // Delete one Pokeball
     * const Pokeball = await prisma.pokeball.delete({
     *   where: {
     *     // ... filter to delete one Pokeball
     *   }
     * })
     * 
     */
    delete<T extends pokeballDeleteArgs>(args: SelectSubset<T, pokeballDeleteArgs<ExtArgs>>): Prisma__pokeballClient<$Result.GetResult<Prisma.$pokeballPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pokeball.
     * @param {pokeballUpdateArgs} args - Arguments to update one Pokeball.
     * @example
     * // Update one Pokeball
     * const pokeball = await prisma.pokeball.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pokeballUpdateArgs>(args: SelectSubset<T, pokeballUpdateArgs<ExtArgs>>): Prisma__pokeballClient<$Result.GetResult<Prisma.$pokeballPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pokeballs.
     * @param {pokeballDeleteManyArgs} args - Arguments to filter Pokeballs to delete.
     * @example
     * // Delete a few Pokeballs
     * const { count } = await prisma.pokeball.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pokeballDeleteManyArgs>(args?: SelectSubset<T, pokeballDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pokeballs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokeballUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pokeballs
     * const pokeball = await prisma.pokeball.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pokeballUpdateManyArgs>(args: SelectSubset<T, pokeballUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pokeball.
     * @param {pokeballUpsertArgs} args - Arguments to update or create a Pokeball.
     * @example
     * // Update or create a Pokeball
     * const pokeball = await prisma.pokeball.upsert({
     *   create: {
     *     // ... data to create a Pokeball
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pokeball we want to update
     *   }
     * })
     */
    upsert<T extends pokeballUpsertArgs>(args: SelectSubset<T, pokeballUpsertArgs<ExtArgs>>): Prisma__pokeballClient<$Result.GetResult<Prisma.$pokeballPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pokeballs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokeballCountArgs} args - Arguments to filter Pokeballs to count.
     * @example
     * // Count the number of Pokeballs
     * const count = await prisma.pokeball.count({
     *   where: {
     *     // ... the filter for the Pokeballs we want to count
     *   }
     * })
    **/
    count<T extends pokeballCountArgs>(
      args?: Subset<T, pokeballCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PokeballCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pokeball.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokeballAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PokeballAggregateArgs>(args: Subset<T, PokeballAggregateArgs>): Prisma.PrismaPromise<GetPokeballAggregateType<T>>

    /**
     * Group by Pokeball.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokeballGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pokeballGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pokeballGroupByArgs['orderBy'] }
        : { orderBy?: pokeballGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pokeballGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokeballGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pokeball model
   */
  readonly fields: pokeballFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pokeball.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pokeballClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ownedPokemonDetails<T extends pokeball$ownedPokemonDetailsArgs<ExtArgs> = {}>(args?: Subset<T, pokeball$ownedPokemonDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$owned_pokemon_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pokeball model
   */
  interface pokeballFieldRefs {
    readonly id: FieldRef<"pokeball", 'Int'>
    readonly picture: FieldRef<"pokeball", 'String'>
    readonly createdAt: FieldRef<"pokeball", 'DateTime'>
    readonly updatedAt: FieldRef<"pokeball", 'DateTime'>
    readonly status: FieldRef<"pokeball", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pokeball findUnique
   */
  export type pokeballFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokeball
     */
    select?: pokeballSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokeball
     */
    omit?: pokeballOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokeballInclude<ExtArgs> | null
    /**
     * Filter, which pokeball to fetch.
     */
    where: pokeballWhereUniqueInput
  }

  /**
   * pokeball findUniqueOrThrow
   */
  export type pokeballFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokeball
     */
    select?: pokeballSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokeball
     */
    omit?: pokeballOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokeballInclude<ExtArgs> | null
    /**
     * Filter, which pokeball to fetch.
     */
    where: pokeballWhereUniqueInput
  }

  /**
   * pokeball findFirst
   */
  export type pokeballFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokeball
     */
    select?: pokeballSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokeball
     */
    omit?: pokeballOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokeballInclude<ExtArgs> | null
    /**
     * Filter, which pokeball to fetch.
     */
    where?: pokeballWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokeballs to fetch.
     */
    orderBy?: pokeballOrderByWithRelationInput | pokeballOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokeballs.
     */
    cursor?: pokeballWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokeballs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokeballs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokeballs.
     */
    distinct?: PokeballScalarFieldEnum | PokeballScalarFieldEnum[]
  }

  /**
   * pokeball findFirstOrThrow
   */
  export type pokeballFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokeball
     */
    select?: pokeballSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokeball
     */
    omit?: pokeballOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokeballInclude<ExtArgs> | null
    /**
     * Filter, which pokeball to fetch.
     */
    where?: pokeballWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokeballs to fetch.
     */
    orderBy?: pokeballOrderByWithRelationInput | pokeballOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokeballs.
     */
    cursor?: pokeballWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokeballs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokeballs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokeballs.
     */
    distinct?: PokeballScalarFieldEnum | PokeballScalarFieldEnum[]
  }

  /**
   * pokeball findMany
   */
  export type pokeballFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokeball
     */
    select?: pokeballSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokeball
     */
    omit?: pokeballOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokeballInclude<ExtArgs> | null
    /**
     * Filter, which pokeballs to fetch.
     */
    where?: pokeballWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokeballs to fetch.
     */
    orderBy?: pokeballOrderByWithRelationInput | pokeballOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pokeballs.
     */
    cursor?: pokeballWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokeballs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokeballs.
     */
    skip?: number
    distinct?: PokeballScalarFieldEnum | PokeballScalarFieldEnum[]
  }

  /**
   * pokeball create
   */
  export type pokeballCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokeball
     */
    select?: pokeballSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokeball
     */
    omit?: pokeballOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokeballInclude<ExtArgs> | null
    /**
     * The data needed to create a pokeball.
     */
    data: XOR<pokeballCreateInput, pokeballUncheckedCreateInput>
  }

  /**
   * pokeball createMany
   */
  export type pokeballCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pokeballs.
     */
    data: pokeballCreateManyInput | pokeballCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pokeball update
   */
  export type pokeballUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokeball
     */
    select?: pokeballSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokeball
     */
    omit?: pokeballOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokeballInclude<ExtArgs> | null
    /**
     * The data needed to update a pokeball.
     */
    data: XOR<pokeballUpdateInput, pokeballUncheckedUpdateInput>
    /**
     * Choose, which pokeball to update.
     */
    where: pokeballWhereUniqueInput
  }

  /**
   * pokeball updateMany
   */
  export type pokeballUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pokeballs.
     */
    data: XOR<pokeballUpdateManyMutationInput, pokeballUncheckedUpdateManyInput>
    /**
     * Filter which pokeballs to update
     */
    where?: pokeballWhereInput
    /**
     * Limit how many pokeballs to update.
     */
    limit?: number
  }

  /**
   * pokeball upsert
   */
  export type pokeballUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokeball
     */
    select?: pokeballSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokeball
     */
    omit?: pokeballOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokeballInclude<ExtArgs> | null
    /**
     * The filter to search for the pokeball to update in case it exists.
     */
    where: pokeballWhereUniqueInput
    /**
     * In case the pokeball found by the `where` argument doesn't exist, create a new pokeball with this data.
     */
    create: XOR<pokeballCreateInput, pokeballUncheckedCreateInput>
    /**
     * In case the pokeball was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pokeballUpdateInput, pokeballUncheckedUpdateInput>
  }

  /**
   * pokeball delete
   */
  export type pokeballDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokeball
     */
    select?: pokeballSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokeball
     */
    omit?: pokeballOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokeballInclude<ExtArgs> | null
    /**
     * Filter which pokeball to delete.
     */
    where: pokeballWhereUniqueInput
  }

  /**
   * pokeball deleteMany
   */
  export type pokeballDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokeballs to delete
     */
    where?: pokeballWhereInput
    /**
     * Limit how many pokeballs to delete.
     */
    limit?: number
  }

  /**
   * pokeball.ownedPokemonDetails
   */
  export type pokeball$ownedPokemonDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon_detail
     */
    select?: owned_pokemon_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon_detail
     */
    omit?: owned_pokemon_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemon_detailInclude<ExtArgs> | null
    where?: owned_pokemon_detailWhereInput
    orderBy?: owned_pokemon_detailOrderByWithRelationInput | owned_pokemon_detailOrderByWithRelationInput[]
    cursor?: owned_pokemon_detailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Owned_pokemon_detailScalarFieldEnum | Owned_pokemon_detailScalarFieldEnum[]
  }

  /**
   * pokeball without action
   */
  export type pokeballDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokeball
     */
    select?: pokeballSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokeball
     */
    omit?: pokeballOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokeballInclude<ExtArgs> | null
  }


  /**
   * Model generation
   */

  export type AggregateGeneration = {
    _count: GenerationCountAggregateOutputType | null
    _avg: GenerationAvgAggregateOutputType | null
    _sum: GenerationSumAggregateOutputType | null
    _min: GenerationMinAggregateOutputType | null
    _max: GenerationMaxAggregateOutputType | null
  }

  export type GenerationAvgAggregateOutputType = {
    id: number | null
  }

  export type GenerationSumAggregateOutputType = {
    id: number | null
  }

  export type GenerationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type GenerationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type GenerationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type GenerationAvgAggregateInputType = {
    id?: true
  }

  export type GenerationSumAggregateInputType = {
    id?: true
  }

  export type GenerationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type GenerationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type GenerationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type GenerationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which generation to aggregate.
     */
    where?: generationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generations to fetch.
     */
    orderBy?: generationOrderByWithRelationInput | generationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: generationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned generations
    **/
    _count?: true | GenerationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenerationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenerationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenerationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenerationMaxAggregateInputType
  }

  export type GetGenerationAggregateType<T extends GenerationAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneration[P]>
      : GetScalarType<T[P], AggregateGeneration[P]>
  }




  export type generationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: generationWhereInput
    orderBy?: generationOrderByWithAggregationInput | generationOrderByWithAggregationInput[]
    by: GenerationScalarFieldEnum[] | GenerationScalarFieldEnum
    having?: generationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenerationCountAggregateInputType | true
    _avg?: GenerationAvgAggregateInputType
    _sum?: GenerationSumAggregateInputType
    _min?: GenerationMinAggregateInputType
    _max?: GenerationMaxAggregateInputType
  }

  export type GenerationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: GenerationCountAggregateOutputType | null
    _avg: GenerationAvgAggregateOutputType | null
    _sum: GenerationSumAggregateOutputType | null
    _min: GenerationMinAggregateOutputType | null
    _max: GenerationMaxAggregateOutputType | null
  }

  type GetGenerationGroupByPayload<T extends generationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenerationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenerationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenerationGroupByOutputType[P]>
            : GetScalarType<T[P], GenerationGroupByOutputType[P]>
        }
      >
    >


  export type generationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    abilities?: boolean | generation$abilitiesArgs<ExtArgs>
    abilityInfos?: boolean | generation$abilityInfosArgs<ExtArgs>
    games?: boolean | generation$gamesArgs<ExtArgs>
    pokemons?: boolean | generation$pokemonsArgs<ExtArgs>
    pokemonInfos?: boolean | generation$pokemonInfosArgs<ExtArgs>
    _count?: boolean | GenerationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generation"]>



  export type generationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type generationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["generation"]>
  export type generationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abilities?: boolean | generation$abilitiesArgs<ExtArgs>
    abilityInfos?: boolean | generation$abilityInfosArgs<ExtArgs>
    games?: boolean | generation$gamesArgs<ExtArgs>
    pokemons?: boolean | generation$pokemonsArgs<ExtArgs>
    pokemonInfos?: boolean | generation$pokemonInfosArgs<ExtArgs>
    _count?: boolean | GenerationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $generationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "generation"
    objects: {
      abilities: Prisma.$abilityPayload<ExtArgs>[]
      abilityInfos: Prisma.$ability_infoPayload<ExtArgs>[]
      games: Prisma.$gamePayload<ExtArgs>[]
      pokemons: Prisma.$pokemonPayload<ExtArgs>[]
      pokemonInfos: Prisma.$pokemon_infoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["generation"]>
    composites: {}
  }

  type generationGetPayload<S extends boolean | null | undefined | generationDefaultArgs> = $Result.GetResult<Prisma.$generationPayload, S>

  type generationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<generationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenerationCountAggregateInputType | true
    }

  export interface generationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['generation'], meta: { name: 'generation' } }
    /**
     * Find zero or one Generation that matches the filter.
     * @param {generationFindUniqueArgs} args - Arguments to find a Generation
     * @example
     * // Get one Generation
     * const generation = await prisma.generation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends generationFindUniqueArgs>(args: SelectSubset<T, generationFindUniqueArgs<ExtArgs>>): Prisma__generationClient<$Result.GetResult<Prisma.$generationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Generation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {generationFindUniqueOrThrowArgs} args - Arguments to find a Generation
     * @example
     * // Get one Generation
     * const generation = await prisma.generation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends generationFindUniqueOrThrowArgs>(args: SelectSubset<T, generationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__generationClient<$Result.GetResult<Prisma.$generationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Generation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generationFindFirstArgs} args - Arguments to find a Generation
     * @example
     * // Get one Generation
     * const generation = await prisma.generation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends generationFindFirstArgs>(args?: SelectSubset<T, generationFindFirstArgs<ExtArgs>>): Prisma__generationClient<$Result.GetResult<Prisma.$generationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Generation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generationFindFirstOrThrowArgs} args - Arguments to find a Generation
     * @example
     * // Get one Generation
     * const generation = await prisma.generation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends generationFindFirstOrThrowArgs>(args?: SelectSubset<T, generationFindFirstOrThrowArgs<ExtArgs>>): Prisma__generationClient<$Result.GetResult<Prisma.$generationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Generations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Generations
     * const generations = await prisma.generation.findMany()
     * 
     * // Get first 10 Generations
     * const generations = await prisma.generation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generationWithIdOnly = await prisma.generation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends generationFindManyArgs>(args?: SelectSubset<T, generationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$generationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Generation.
     * @param {generationCreateArgs} args - Arguments to create a Generation.
     * @example
     * // Create one Generation
     * const Generation = await prisma.generation.create({
     *   data: {
     *     // ... data to create a Generation
     *   }
     * })
     * 
     */
    create<T extends generationCreateArgs>(args: SelectSubset<T, generationCreateArgs<ExtArgs>>): Prisma__generationClient<$Result.GetResult<Prisma.$generationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Generations.
     * @param {generationCreateManyArgs} args - Arguments to create many Generations.
     * @example
     * // Create many Generations
     * const generation = await prisma.generation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends generationCreateManyArgs>(args?: SelectSubset<T, generationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Generation.
     * @param {generationDeleteArgs} args - Arguments to delete one Generation.
     * @example
     * // Delete one Generation
     * const Generation = await prisma.generation.delete({
     *   where: {
     *     // ... filter to delete one Generation
     *   }
     * })
     * 
     */
    delete<T extends generationDeleteArgs>(args: SelectSubset<T, generationDeleteArgs<ExtArgs>>): Prisma__generationClient<$Result.GetResult<Prisma.$generationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Generation.
     * @param {generationUpdateArgs} args - Arguments to update one Generation.
     * @example
     * // Update one Generation
     * const generation = await prisma.generation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends generationUpdateArgs>(args: SelectSubset<T, generationUpdateArgs<ExtArgs>>): Prisma__generationClient<$Result.GetResult<Prisma.$generationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Generations.
     * @param {generationDeleteManyArgs} args - Arguments to filter Generations to delete.
     * @example
     * // Delete a few Generations
     * const { count } = await prisma.generation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends generationDeleteManyArgs>(args?: SelectSubset<T, generationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Generations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Generations
     * const generation = await prisma.generation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends generationUpdateManyArgs>(args: SelectSubset<T, generationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Generation.
     * @param {generationUpsertArgs} args - Arguments to update or create a Generation.
     * @example
     * // Update or create a Generation
     * const generation = await prisma.generation.upsert({
     *   create: {
     *     // ... data to create a Generation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Generation we want to update
     *   }
     * })
     */
    upsert<T extends generationUpsertArgs>(args: SelectSubset<T, generationUpsertArgs<ExtArgs>>): Prisma__generationClient<$Result.GetResult<Prisma.$generationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Generations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generationCountArgs} args - Arguments to filter Generations to count.
     * @example
     * // Count the number of Generations
     * const count = await prisma.generation.count({
     *   where: {
     *     // ... the filter for the Generations we want to count
     *   }
     * })
    **/
    count<T extends generationCountArgs>(
      args?: Subset<T, generationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenerationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Generation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenerationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenerationAggregateArgs>(args: Subset<T, GenerationAggregateArgs>): Prisma.PrismaPromise<GetGenerationAggregateType<T>>

    /**
     * Group by Generation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends generationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: generationGroupByArgs['orderBy'] }
        : { orderBy?: generationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, generationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenerationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the generation model
   */
  readonly fields: generationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for generation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__generationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    abilities<T extends generation$abilitiesArgs<ExtArgs> = {}>(args?: Subset<T, generation$abilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$abilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    abilityInfos<T extends generation$abilityInfosArgs<ExtArgs> = {}>(args?: Subset<T, generation$abilityInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ability_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    games<T extends generation$gamesArgs<ExtArgs> = {}>(args?: Subset<T, generation$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pokemons<T extends generation$pokemonsArgs<ExtArgs> = {}>(args?: Subset<T, generation$pokemonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pokemonInfos<T extends generation$pokemonInfosArgs<ExtArgs> = {}>(args?: Subset<T, generation$pokemonInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the generation model
   */
  interface generationFieldRefs {
    readonly id: FieldRef<"generation", 'Int'>
    readonly createdAt: FieldRef<"generation", 'DateTime'>
    readonly updatedAt: FieldRef<"generation", 'DateTime'>
    readonly status: FieldRef<"generation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * generation findUnique
   */
  export type generationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generation
     */
    select?: generationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generation
     */
    omit?: generationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generationInclude<ExtArgs> | null
    /**
     * Filter, which generation to fetch.
     */
    where: generationWhereUniqueInput
  }

  /**
   * generation findUniqueOrThrow
   */
  export type generationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generation
     */
    select?: generationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generation
     */
    omit?: generationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generationInclude<ExtArgs> | null
    /**
     * Filter, which generation to fetch.
     */
    where: generationWhereUniqueInput
  }

  /**
   * generation findFirst
   */
  export type generationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generation
     */
    select?: generationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generation
     */
    omit?: generationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generationInclude<ExtArgs> | null
    /**
     * Filter, which generation to fetch.
     */
    where?: generationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generations to fetch.
     */
    orderBy?: generationOrderByWithRelationInput | generationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for generations.
     */
    cursor?: generationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of generations.
     */
    distinct?: GenerationScalarFieldEnum | GenerationScalarFieldEnum[]
  }

  /**
   * generation findFirstOrThrow
   */
  export type generationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generation
     */
    select?: generationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generation
     */
    omit?: generationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generationInclude<ExtArgs> | null
    /**
     * Filter, which generation to fetch.
     */
    where?: generationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generations to fetch.
     */
    orderBy?: generationOrderByWithRelationInput | generationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for generations.
     */
    cursor?: generationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of generations.
     */
    distinct?: GenerationScalarFieldEnum | GenerationScalarFieldEnum[]
  }

  /**
   * generation findMany
   */
  export type generationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generation
     */
    select?: generationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generation
     */
    omit?: generationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generationInclude<ExtArgs> | null
    /**
     * Filter, which generations to fetch.
     */
    where?: generationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generations to fetch.
     */
    orderBy?: generationOrderByWithRelationInput | generationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing generations.
     */
    cursor?: generationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generations.
     */
    skip?: number
    distinct?: GenerationScalarFieldEnum | GenerationScalarFieldEnum[]
  }

  /**
   * generation create
   */
  export type generationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generation
     */
    select?: generationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generation
     */
    omit?: generationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generationInclude<ExtArgs> | null
    /**
     * The data needed to create a generation.
     */
    data: XOR<generationCreateInput, generationUncheckedCreateInput>
  }

  /**
   * generation createMany
   */
  export type generationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many generations.
     */
    data: generationCreateManyInput | generationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * generation update
   */
  export type generationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generation
     */
    select?: generationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generation
     */
    omit?: generationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generationInclude<ExtArgs> | null
    /**
     * The data needed to update a generation.
     */
    data: XOR<generationUpdateInput, generationUncheckedUpdateInput>
    /**
     * Choose, which generation to update.
     */
    where: generationWhereUniqueInput
  }

  /**
   * generation updateMany
   */
  export type generationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update generations.
     */
    data: XOR<generationUpdateManyMutationInput, generationUncheckedUpdateManyInput>
    /**
     * Filter which generations to update
     */
    where?: generationWhereInput
    /**
     * Limit how many generations to update.
     */
    limit?: number
  }

  /**
   * generation upsert
   */
  export type generationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generation
     */
    select?: generationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generation
     */
    omit?: generationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generationInclude<ExtArgs> | null
    /**
     * The filter to search for the generation to update in case it exists.
     */
    where: generationWhereUniqueInput
    /**
     * In case the generation found by the `where` argument doesn't exist, create a new generation with this data.
     */
    create: XOR<generationCreateInput, generationUncheckedCreateInput>
    /**
     * In case the generation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<generationUpdateInput, generationUncheckedUpdateInput>
  }

  /**
   * generation delete
   */
  export type generationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generation
     */
    select?: generationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generation
     */
    omit?: generationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generationInclude<ExtArgs> | null
    /**
     * Filter which generation to delete.
     */
    where: generationWhereUniqueInput
  }

  /**
   * generation deleteMany
   */
  export type generationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which generations to delete
     */
    where?: generationWhereInput
    /**
     * Limit how many generations to delete.
     */
    limit?: number
  }

  /**
   * generation.abilities
   */
  export type generation$abilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability
     */
    select?: abilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability
     */
    omit?: abilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: abilityInclude<ExtArgs> | null
    where?: abilityWhereInput
    orderBy?: abilityOrderByWithRelationInput | abilityOrderByWithRelationInput[]
    cursor?: abilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }

  /**
   * generation.abilityInfos
   */
  export type generation$abilityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_info
     */
    select?: ability_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_info
     */
    omit?: ability_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_infoInclude<ExtArgs> | null
    where?: ability_infoWhereInput
    orderBy?: ability_infoOrderByWithRelationInput | ability_infoOrderByWithRelationInput[]
    cursor?: ability_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ability_infoScalarFieldEnum | Ability_infoScalarFieldEnum[]
  }

  /**
   * generation.games
   */
  export type generation$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    where?: gameWhereInput
    orderBy?: gameOrderByWithRelationInput | gameOrderByWithRelationInput[]
    cursor?: gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * generation.pokemons
   */
  export type generation$pokemonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon
     */
    select?: pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon
     */
    omit?: pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemonInclude<ExtArgs> | null
    where?: pokemonWhereInput
    orderBy?: pokemonOrderByWithRelationInput | pokemonOrderByWithRelationInput[]
    cursor?: pokemonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonScalarFieldEnum | PokemonScalarFieldEnum[]
  }

  /**
   * generation.pokemonInfos
   */
  export type generation$pokemonInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_info
     */
    select?: pokemon_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_info
     */
    omit?: pokemon_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_infoInclude<ExtArgs> | null
    where?: pokemon_infoWhereInput
    orderBy?: pokemon_infoOrderByWithRelationInput | pokemon_infoOrderByWithRelationInput[]
    cursor?: pokemon_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pokemon_infoScalarFieldEnum | Pokemon_infoScalarFieldEnum[]
  }

  /**
   * generation without action
   */
  export type generationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generation
     */
    select?: generationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generation
     */
    omit?: generationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generationInclude<ExtArgs> | null
  }


  /**
   * Model game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    id: number | null
    generationId: number | null
  }

  export type GameSumAggregateOutputType = {
    id: number | null
    generationId: number | null
  }

  export type GameMinAggregateOutputType = {
    id: number | null
    generationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type GameMaxAggregateOutputType = {
    id: number | null
    generationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    generationId: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    id?: true
    generationId?: true
  }

  export type GameSumAggregateInputType = {
    id?: true
    generationId?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    generationId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    generationId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    generationId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game to aggregate.
     */
    where?: gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gameOrderByWithRelationInput | gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type gameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gameWhereInput
    orderBy?: gameOrderByWithAggregationInput | gameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: gameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: number
    generationId: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends gameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type gameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    generationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    generation?: boolean | generationDefaultArgs<ExtArgs>
    gameGroupGames?: boolean | game$gameGroupGamesArgs<ExtArgs>
    ownedPokemons?: boolean | game$ownedPokemonsArgs<ExtArgs>
    pokemonRatingGames?: boolean | game$pokemonRatingGamesArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>



  export type gameSelectScalar = {
    id?: boolean
    generationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type gameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "generationId" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["game"]>
  export type gameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generation?: boolean | generationDefaultArgs<ExtArgs>
    gameGroupGames?: boolean | game$gameGroupGamesArgs<ExtArgs>
    ownedPokemons?: boolean | game$ownedPokemonsArgs<ExtArgs>
    pokemonRatingGames?: boolean | game$pokemonRatingGamesArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $gamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "game"
    objects: {
      generation: Prisma.$generationPayload<ExtArgs>
      gameGroupGames: Prisma.$game_group_gamePayload<ExtArgs>[]
      ownedPokemons: Prisma.$owned_pokemonPayload<ExtArgs>[]
      pokemonRatingGames: Prisma.$pokemon_game_locationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      generationId: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type gameGetPayload<S extends boolean | null | undefined | gameDefaultArgs> = $Result.GetResult<Prisma.$gamePayload, S>

  type gameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<gameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface gameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['game'], meta: { name: 'game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {gameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gameFindUniqueArgs>(args: SelectSubset<T, gameFindUniqueArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {gameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gameFindUniqueOrThrowArgs>(args: SelectSubset<T, gameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gameFindFirstArgs>(args?: SelectSubset<T, gameFindFirstArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gameFindFirstOrThrowArgs>(args?: SelectSubset<T, gameFindFirstOrThrowArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends gameFindManyArgs>(args?: SelectSubset<T, gameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game.
     * @param {gameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends gameCreateArgs>(args: SelectSubset<T, gameCreateArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Games.
     * @param {gameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gameCreateManyArgs>(args?: SelectSubset<T, gameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Game.
     * @param {gameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends gameDeleteArgs>(args: SelectSubset<T, gameDeleteArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game.
     * @param {gameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gameUpdateArgs>(args: SelectSubset<T, gameUpdateArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Games.
     * @param {gameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gameDeleteManyArgs>(args?: SelectSubset<T, gameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gameUpdateManyArgs>(args: SelectSubset<T, gameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game.
     * @param {gameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends gameUpsertArgs>(args: SelectSubset<T, gameUpsertArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends gameCountArgs>(
      args?: Subset<T, gameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gameGroupByArgs['orderBy'] }
        : { orderBy?: gameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the game model
   */
  readonly fields: gameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    generation<T extends generationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, generationDefaultArgs<ExtArgs>>): Prisma__generationClient<$Result.GetResult<Prisma.$generationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    gameGroupGames<T extends game$gameGroupGamesArgs<ExtArgs> = {}>(args?: Subset<T, game$gameGroupGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_group_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedPokemons<T extends game$ownedPokemonsArgs<ExtArgs> = {}>(args?: Subset<T, game$ownedPokemonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$owned_pokemonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pokemonRatingGames<T extends game$pokemonRatingGamesArgs<ExtArgs> = {}>(args?: Subset<T, game$pokemonRatingGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_game_locationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the game model
   */
  interface gameFieldRefs {
    readonly id: FieldRef<"game", 'Int'>
    readonly generationId: FieldRef<"game", 'Int'>
    readonly createdAt: FieldRef<"game", 'DateTime'>
    readonly updatedAt: FieldRef<"game", 'DateTime'>
    readonly status: FieldRef<"game", 'String'>
  }
    

  // Custom InputTypes
  /**
   * game findUnique
   */
  export type gameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * Filter, which game to fetch.
     */
    where: gameWhereUniqueInput
  }

  /**
   * game findUniqueOrThrow
   */
  export type gameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * Filter, which game to fetch.
     */
    where: gameWhereUniqueInput
  }

  /**
   * game findFirst
   */
  export type gameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * Filter, which game to fetch.
     */
    where?: gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gameOrderByWithRelationInput | gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for games.
     */
    cursor?: gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * game findFirstOrThrow
   */
  export type gameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * Filter, which game to fetch.
     */
    where?: gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gameOrderByWithRelationInput | gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for games.
     */
    cursor?: gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * game findMany
   */
  export type gameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * Filter, which games to fetch.
     */
    where?: gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gameOrderByWithRelationInput | gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing games.
     */
    cursor?: gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * game create
   */
  export type gameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * The data needed to create a game.
     */
    data: XOR<gameCreateInput, gameUncheckedCreateInput>
  }

  /**
   * game createMany
   */
  export type gameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many games.
     */
    data: gameCreateManyInput | gameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * game update
   */
  export type gameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * The data needed to update a game.
     */
    data: XOR<gameUpdateInput, gameUncheckedUpdateInput>
    /**
     * Choose, which game to update.
     */
    where: gameWhereUniqueInput
  }

  /**
   * game updateMany
   */
  export type gameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update games.
     */
    data: XOR<gameUpdateManyMutationInput, gameUncheckedUpdateManyInput>
    /**
     * Filter which games to update
     */
    where?: gameWhereInput
    /**
     * Limit how many games to update.
     */
    limit?: number
  }

  /**
   * game upsert
   */
  export type gameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * The filter to search for the game to update in case it exists.
     */
    where: gameWhereUniqueInput
    /**
     * In case the game found by the `where` argument doesn't exist, create a new game with this data.
     */
    create: XOR<gameCreateInput, gameUncheckedCreateInput>
    /**
     * In case the game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gameUpdateInput, gameUncheckedUpdateInput>
  }

  /**
   * game delete
   */
  export type gameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * Filter which game to delete.
     */
    where: gameWhereUniqueInput
  }

  /**
   * game deleteMany
   */
  export type gameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which games to delete
     */
    where?: gameWhereInput
    /**
     * Limit how many games to delete.
     */
    limit?: number
  }

  /**
   * game.gameGroupGames
   */
  export type game$gameGroupGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_group_game
     */
    select?: game_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_group_game
     */
    omit?: game_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_group_gameInclude<ExtArgs> | null
    where?: game_group_gameWhereInput
    orderBy?: game_group_gameOrderByWithRelationInput | game_group_gameOrderByWithRelationInput[]
    cursor?: game_group_gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Game_group_gameScalarFieldEnum | Game_group_gameScalarFieldEnum[]
  }

  /**
   * game.ownedPokemons
   */
  export type game$ownedPokemonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon
     */
    select?: owned_pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon
     */
    omit?: owned_pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemonInclude<ExtArgs> | null
    where?: owned_pokemonWhereInput
    orderBy?: owned_pokemonOrderByWithRelationInput | owned_pokemonOrderByWithRelationInput[]
    cursor?: owned_pokemonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Owned_pokemonScalarFieldEnum | Owned_pokemonScalarFieldEnum[]
  }

  /**
   * game.pokemonRatingGames
   */
  export type game$pokemonRatingGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
    where?: pokemon_game_locationWhereInput
    orderBy?: pokemon_game_locationOrderByWithRelationInput | pokemon_game_locationOrderByWithRelationInput[]
    cursor?: pokemon_game_locationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pokemon_game_locationScalarFieldEnum | Pokemon_game_locationScalarFieldEnum[]
  }

  /**
   * game without action
   */
  export type gameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
  }


  /**
   * Model game_group_game
   */

  export type AggregateGame_group_game = {
    _count: Game_group_gameCountAggregateOutputType | null
    _avg: Game_group_gameAvgAggregateOutputType | null
    _sum: Game_group_gameSumAggregateOutputType | null
    _min: Game_group_gameMinAggregateOutputType | null
    _max: Game_group_gameMaxAggregateOutputType | null
  }

  export type Game_group_gameAvgAggregateOutputType = {
    gameId: number | null
    groupGameId: number | null
    landId: number | null
  }

  export type Game_group_gameSumAggregateOutputType = {
    gameId: number | null
    groupGameId: number | null
    landId: number | null
  }

  export type Game_group_gameMinAggregateOutputType = {
    gameId: number | null
    groupGameId: number | null
    landId: number | null
  }

  export type Game_group_gameMaxAggregateOutputType = {
    gameId: number | null
    groupGameId: number | null
    landId: number | null
  }

  export type Game_group_gameCountAggregateOutputType = {
    gameId: number
    groupGameId: number
    landId: number
    _all: number
  }


  export type Game_group_gameAvgAggregateInputType = {
    gameId?: true
    groupGameId?: true
    landId?: true
  }

  export type Game_group_gameSumAggregateInputType = {
    gameId?: true
    groupGameId?: true
    landId?: true
  }

  export type Game_group_gameMinAggregateInputType = {
    gameId?: true
    groupGameId?: true
    landId?: true
  }

  export type Game_group_gameMaxAggregateInputType = {
    gameId?: true
    groupGameId?: true
    landId?: true
  }

  export type Game_group_gameCountAggregateInputType = {
    gameId?: true
    groupGameId?: true
    landId?: true
    _all?: true
  }

  export type Game_group_gameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game_group_game to aggregate.
     */
    where?: game_group_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_group_games to fetch.
     */
    orderBy?: game_group_gameOrderByWithRelationInput | game_group_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: game_group_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_group_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_group_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned game_group_games
    **/
    _count?: true | Game_group_gameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Game_group_gameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Game_group_gameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Game_group_gameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Game_group_gameMaxAggregateInputType
  }

  export type GetGame_group_gameAggregateType<T extends Game_group_gameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame_group_game]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame_group_game[P]>
      : GetScalarType<T[P], AggregateGame_group_game[P]>
  }




  export type game_group_gameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_group_gameWhereInput
    orderBy?: game_group_gameOrderByWithAggregationInput | game_group_gameOrderByWithAggregationInput[]
    by: Game_group_gameScalarFieldEnum[] | Game_group_gameScalarFieldEnum
    having?: game_group_gameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Game_group_gameCountAggregateInputType | true
    _avg?: Game_group_gameAvgAggregateInputType
    _sum?: Game_group_gameSumAggregateInputType
    _min?: Game_group_gameMinAggregateInputType
    _max?: Game_group_gameMaxAggregateInputType
  }

  export type Game_group_gameGroupByOutputType = {
    gameId: number
    groupGameId: number
    landId: number
    _count: Game_group_gameCountAggregateOutputType | null
    _avg: Game_group_gameAvgAggregateOutputType | null
    _sum: Game_group_gameSumAggregateOutputType | null
    _min: Game_group_gameMinAggregateOutputType | null
    _max: Game_group_gameMaxAggregateOutputType | null
  }

  type GetGame_group_gameGroupByPayload<T extends game_group_gameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Game_group_gameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Game_group_gameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Game_group_gameGroupByOutputType[P]>
            : GetScalarType<T[P], Game_group_gameGroupByOutputType[P]>
        }
      >
    >


  export type game_group_gameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    gameId?: boolean
    groupGameId?: boolean
    landId?: boolean
    game?: boolean | gameDefaultArgs<ExtArgs>
    groupGame?: boolean | group_gameDefaultArgs<ExtArgs>
    land?: boolean | landDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game_group_game"]>



  export type game_group_gameSelectScalar = {
    gameId?: boolean
    groupGameId?: boolean
    landId?: boolean
  }

  export type game_group_gameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"gameId" | "groupGameId" | "landId", ExtArgs["result"]["game_group_game"]>
  export type game_group_gameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | gameDefaultArgs<ExtArgs>
    groupGame?: boolean | group_gameDefaultArgs<ExtArgs>
    land?: boolean | landDefaultArgs<ExtArgs>
  }

  export type $game_group_gamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "game_group_game"
    objects: {
      game: Prisma.$gamePayload<ExtArgs>
      groupGame: Prisma.$group_gamePayload<ExtArgs>
      land: Prisma.$landPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      gameId: number
      groupGameId: number
      landId: number
    }, ExtArgs["result"]["game_group_game"]>
    composites: {}
  }

  type game_group_gameGetPayload<S extends boolean | null | undefined | game_group_gameDefaultArgs> = $Result.GetResult<Prisma.$game_group_gamePayload, S>

  type game_group_gameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<game_group_gameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Game_group_gameCountAggregateInputType | true
    }

  export interface game_group_gameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['game_group_game'], meta: { name: 'game_group_game' } }
    /**
     * Find zero or one Game_group_game that matches the filter.
     * @param {game_group_gameFindUniqueArgs} args - Arguments to find a Game_group_game
     * @example
     * // Get one Game_group_game
     * const game_group_game = await prisma.game_group_game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends game_group_gameFindUniqueArgs>(args: SelectSubset<T, game_group_gameFindUniqueArgs<ExtArgs>>): Prisma__game_group_gameClient<$Result.GetResult<Prisma.$game_group_gamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game_group_game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {game_group_gameFindUniqueOrThrowArgs} args - Arguments to find a Game_group_game
     * @example
     * // Get one Game_group_game
     * const game_group_game = await prisma.game_group_game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends game_group_gameFindUniqueOrThrowArgs>(args: SelectSubset<T, game_group_gameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__game_group_gameClient<$Result.GetResult<Prisma.$game_group_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game_group_game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_group_gameFindFirstArgs} args - Arguments to find a Game_group_game
     * @example
     * // Get one Game_group_game
     * const game_group_game = await prisma.game_group_game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends game_group_gameFindFirstArgs>(args?: SelectSubset<T, game_group_gameFindFirstArgs<ExtArgs>>): Prisma__game_group_gameClient<$Result.GetResult<Prisma.$game_group_gamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game_group_game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_group_gameFindFirstOrThrowArgs} args - Arguments to find a Game_group_game
     * @example
     * // Get one Game_group_game
     * const game_group_game = await prisma.game_group_game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends game_group_gameFindFirstOrThrowArgs>(args?: SelectSubset<T, game_group_gameFindFirstOrThrowArgs<ExtArgs>>): Prisma__game_group_gameClient<$Result.GetResult<Prisma.$game_group_gamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Game_group_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_group_gameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Game_group_games
     * const game_group_games = await prisma.game_group_game.findMany()
     * 
     * // Get first 10 Game_group_games
     * const game_group_games = await prisma.game_group_game.findMany({ take: 10 })
     * 
     * // Only select the `gameId`
     * const game_group_gameWithGameIdOnly = await prisma.game_group_game.findMany({ select: { gameId: true } })
     * 
     */
    findMany<T extends game_group_gameFindManyArgs>(args?: SelectSubset<T, game_group_gameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_group_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game_group_game.
     * @param {game_group_gameCreateArgs} args - Arguments to create a Game_group_game.
     * @example
     * // Create one Game_group_game
     * const Game_group_game = await prisma.game_group_game.create({
     *   data: {
     *     // ... data to create a Game_group_game
     *   }
     * })
     * 
     */
    create<T extends game_group_gameCreateArgs>(args: SelectSubset<T, game_group_gameCreateArgs<ExtArgs>>): Prisma__game_group_gameClient<$Result.GetResult<Prisma.$game_group_gamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Game_group_games.
     * @param {game_group_gameCreateManyArgs} args - Arguments to create many Game_group_games.
     * @example
     * // Create many Game_group_games
     * const game_group_game = await prisma.game_group_game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends game_group_gameCreateManyArgs>(args?: SelectSubset<T, game_group_gameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Game_group_game.
     * @param {game_group_gameDeleteArgs} args - Arguments to delete one Game_group_game.
     * @example
     * // Delete one Game_group_game
     * const Game_group_game = await prisma.game_group_game.delete({
     *   where: {
     *     // ... filter to delete one Game_group_game
     *   }
     * })
     * 
     */
    delete<T extends game_group_gameDeleteArgs>(args: SelectSubset<T, game_group_gameDeleteArgs<ExtArgs>>): Prisma__game_group_gameClient<$Result.GetResult<Prisma.$game_group_gamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game_group_game.
     * @param {game_group_gameUpdateArgs} args - Arguments to update one Game_group_game.
     * @example
     * // Update one Game_group_game
     * const game_group_game = await prisma.game_group_game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends game_group_gameUpdateArgs>(args: SelectSubset<T, game_group_gameUpdateArgs<ExtArgs>>): Prisma__game_group_gameClient<$Result.GetResult<Prisma.$game_group_gamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Game_group_games.
     * @param {game_group_gameDeleteManyArgs} args - Arguments to filter Game_group_games to delete.
     * @example
     * // Delete a few Game_group_games
     * const { count } = await prisma.game_group_game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends game_group_gameDeleteManyArgs>(args?: SelectSubset<T, game_group_gameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Game_group_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_group_gameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Game_group_games
     * const game_group_game = await prisma.game_group_game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends game_group_gameUpdateManyArgs>(args: SelectSubset<T, game_group_gameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game_group_game.
     * @param {game_group_gameUpsertArgs} args - Arguments to update or create a Game_group_game.
     * @example
     * // Update or create a Game_group_game
     * const game_group_game = await prisma.game_group_game.upsert({
     *   create: {
     *     // ... data to create a Game_group_game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game_group_game we want to update
     *   }
     * })
     */
    upsert<T extends game_group_gameUpsertArgs>(args: SelectSubset<T, game_group_gameUpsertArgs<ExtArgs>>): Prisma__game_group_gameClient<$Result.GetResult<Prisma.$game_group_gamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Game_group_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_group_gameCountArgs} args - Arguments to filter Game_group_games to count.
     * @example
     * // Count the number of Game_group_games
     * const count = await prisma.game_group_game.count({
     *   where: {
     *     // ... the filter for the Game_group_games we want to count
     *   }
     * })
    **/
    count<T extends game_group_gameCountArgs>(
      args?: Subset<T, game_group_gameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Game_group_gameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game_group_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_group_gameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Game_group_gameAggregateArgs>(args: Subset<T, Game_group_gameAggregateArgs>): Prisma.PrismaPromise<GetGame_group_gameAggregateType<T>>

    /**
     * Group by Game_group_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_group_gameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends game_group_gameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: game_group_gameGroupByArgs['orderBy'] }
        : { orderBy?: game_group_gameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, game_group_gameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGame_group_gameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the game_group_game model
   */
  readonly fields: game_group_gameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for game_group_game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__game_group_gameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends gameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, gameDefaultArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    groupGame<T extends group_gameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, group_gameDefaultArgs<ExtArgs>>): Prisma__group_gameClient<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    land<T extends landDefaultArgs<ExtArgs> = {}>(args?: Subset<T, landDefaultArgs<ExtArgs>>): Prisma__landClient<$Result.GetResult<Prisma.$landPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the game_group_game model
   */
  interface game_group_gameFieldRefs {
    readonly gameId: FieldRef<"game_group_game", 'Int'>
    readonly groupGameId: FieldRef<"game_group_game", 'Int'>
    readonly landId: FieldRef<"game_group_game", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * game_group_game findUnique
   */
  export type game_group_gameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_group_game
     */
    select?: game_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_group_game
     */
    omit?: game_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_group_gameInclude<ExtArgs> | null
    /**
     * Filter, which game_group_game to fetch.
     */
    where: game_group_gameWhereUniqueInput
  }

  /**
   * game_group_game findUniqueOrThrow
   */
  export type game_group_gameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_group_game
     */
    select?: game_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_group_game
     */
    omit?: game_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_group_gameInclude<ExtArgs> | null
    /**
     * Filter, which game_group_game to fetch.
     */
    where: game_group_gameWhereUniqueInput
  }

  /**
   * game_group_game findFirst
   */
  export type game_group_gameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_group_game
     */
    select?: game_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_group_game
     */
    omit?: game_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_group_gameInclude<ExtArgs> | null
    /**
     * Filter, which game_group_game to fetch.
     */
    where?: game_group_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_group_games to fetch.
     */
    orderBy?: game_group_gameOrderByWithRelationInput | game_group_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for game_group_games.
     */
    cursor?: game_group_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_group_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_group_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of game_group_games.
     */
    distinct?: Game_group_gameScalarFieldEnum | Game_group_gameScalarFieldEnum[]
  }

  /**
   * game_group_game findFirstOrThrow
   */
  export type game_group_gameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_group_game
     */
    select?: game_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_group_game
     */
    omit?: game_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_group_gameInclude<ExtArgs> | null
    /**
     * Filter, which game_group_game to fetch.
     */
    where?: game_group_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_group_games to fetch.
     */
    orderBy?: game_group_gameOrderByWithRelationInput | game_group_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for game_group_games.
     */
    cursor?: game_group_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_group_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_group_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of game_group_games.
     */
    distinct?: Game_group_gameScalarFieldEnum | Game_group_gameScalarFieldEnum[]
  }

  /**
   * game_group_game findMany
   */
  export type game_group_gameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_group_game
     */
    select?: game_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_group_game
     */
    omit?: game_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_group_gameInclude<ExtArgs> | null
    /**
     * Filter, which game_group_games to fetch.
     */
    where?: game_group_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_group_games to fetch.
     */
    orderBy?: game_group_gameOrderByWithRelationInput | game_group_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing game_group_games.
     */
    cursor?: game_group_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_group_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_group_games.
     */
    skip?: number
    distinct?: Game_group_gameScalarFieldEnum | Game_group_gameScalarFieldEnum[]
  }

  /**
   * game_group_game create
   */
  export type game_group_gameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_group_game
     */
    select?: game_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_group_game
     */
    omit?: game_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_group_gameInclude<ExtArgs> | null
    /**
     * The data needed to create a game_group_game.
     */
    data: XOR<game_group_gameCreateInput, game_group_gameUncheckedCreateInput>
  }

  /**
   * game_group_game createMany
   */
  export type game_group_gameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many game_group_games.
     */
    data: game_group_gameCreateManyInput | game_group_gameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * game_group_game update
   */
  export type game_group_gameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_group_game
     */
    select?: game_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_group_game
     */
    omit?: game_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_group_gameInclude<ExtArgs> | null
    /**
     * The data needed to update a game_group_game.
     */
    data: XOR<game_group_gameUpdateInput, game_group_gameUncheckedUpdateInput>
    /**
     * Choose, which game_group_game to update.
     */
    where: game_group_gameWhereUniqueInput
  }

  /**
   * game_group_game updateMany
   */
  export type game_group_gameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update game_group_games.
     */
    data: XOR<game_group_gameUpdateManyMutationInput, game_group_gameUncheckedUpdateManyInput>
    /**
     * Filter which game_group_games to update
     */
    where?: game_group_gameWhereInput
    /**
     * Limit how many game_group_games to update.
     */
    limit?: number
  }

  /**
   * game_group_game upsert
   */
  export type game_group_gameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_group_game
     */
    select?: game_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_group_game
     */
    omit?: game_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_group_gameInclude<ExtArgs> | null
    /**
     * The filter to search for the game_group_game to update in case it exists.
     */
    where: game_group_gameWhereUniqueInput
    /**
     * In case the game_group_game found by the `where` argument doesn't exist, create a new game_group_game with this data.
     */
    create: XOR<game_group_gameCreateInput, game_group_gameUncheckedCreateInput>
    /**
     * In case the game_group_game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<game_group_gameUpdateInput, game_group_gameUncheckedUpdateInput>
  }

  /**
   * game_group_game delete
   */
  export type game_group_gameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_group_game
     */
    select?: game_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_group_game
     */
    omit?: game_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_group_gameInclude<ExtArgs> | null
    /**
     * Filter which game_group_game to delete.
     */
    where: game_group_gameWhereUniqueInput
  }

  /**
   * game_group_game deleteMany
   */
  export type game_group_gameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game_group_games to delete
     */
    where?: game_group_gameWhereInput
    /**
     * Limit how many game_group_games to delete.
     */
    limit?: number
  }

  /**
   * game_group_game without action
   */
  export type game_group_gameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_group_game
     */
    select?: game_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_group_game
     */
    omit?: game_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_group_gameInclude<ExtArgs> | null
  }


  /**
   * Model group_game
   */

  export type AggregateGroup_game = {
    _count: Group_gameCountAggregateOutputType | null
    _avg: Group_gameAvgAggregateOutputType | null
    _sum: Group_gameSumAggregateOutputType | null
    _min: Group_gameMinAggregateOutputType | null
    _max: Group_gameMaxAggregateOutputType | null
  }

  export type Group_gameAvgAggregateOutputType = {
    id: number | null
  }

  export type Group_gameSumAggregateOutputType = {
    id: number | null
  }

  export type Group_gameMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Group_gameMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Group_gameCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Group_gameAvgAggregateInputType = {
    id?: true
  }

  export type Group_gameSumAggregateInputType = {
    id?: true
  }

  export type Group_gameMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Group_gameMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Group_gameCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Group_gameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group_game to aggregate.
     */
    where?: group_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_games to fetch.
     */
    orderBy?: group_gameOrderByWithRelationInput | group_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: group_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned group_games
    **/
    _count?: true | Group_gameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Group_gameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Group_gameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Group_gameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Group_gameMaxAggregateInputType
  }

  export type GetGroup_gameAggregateType<T extends Group_gameAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup_game]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup_game[P]>
      : GetScalarType<T[P], AggregateGroup_game[P]>
  }




  export type group_gameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: group_gameWhereInput
    orderBy?: group_gameOrderByWithAggregationInput | group_gameOrderByWithAggregationInput[]
    by: Group_gameScalarFieldEnum[] | Group_gameScalarFieldEnum
    having?: group_gameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Group_gameCountAggregateInputType | true
    _avg?: Group_gameAvgAggregateInputType
    _sum?: Group_gameSumAggregateInputType
    _min?: Group_gameMinAggregateInputType
    _max?: Group_gameMaxAggregateInputType
  }

  export type Group_gameGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Group_gameCountAggregateOutputType | null
    _avg: Group_gameAvgAggregateOutputType | null
    _sum: Group_gameSumAggregateOutputType | null
    _min: Group_gameMinAggregateOutputType | null
    _max: Group_gameMaxAggregateOutputType | null
  }

  type GetGroup_gameGroupByPayload<T extends group_gameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Group_gameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Group_gameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Group_gameGroupByOutputType[P]>
            : GetScalarType<T[P], Group_gameGroupByOutputType[P]>
        }
      >
    >


  export type group_gameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    capsuleGameCapacityIinfos?: boolean | group_game$capsuleGameCapacityIinfosArgs<ExtArgs>
    gameGroupGames?: boolean | group_game$gameGroupGamesArgs<ExtArgs>
    nationnalNumbers?: boolean | group_game$nationnalNumbersArgs<ExtArgs>
    shinyHuntingMethodGames?: boolean | group_game$shinyHuntingMethodGamesArgs<ExtArgs>
    skillObtations?: boolean | group_game$skillObtationsArgs<ExtArgs>
    statisticGroupGames?: boolean | group_game$statisticGroupGamesArgs<ExtArgs>
    _count?: boolean | Group_gameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group_game"]>



  export type group_gameSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type group_gameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["group_game"]>
  export type group_gameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capsuleGameCapacityIinfos?: boolean | group_game$capsuleGameCapacityIinfosArgs<ExtArgs>
    gameGroupGames?: boolean | group_game$gameGroupGamesArgs<ExtArgs>
    nationnalNumbers?: boolean | group_game$nationnalNumbersArgs<ExtArgs>
    shinyHuntingMethodGames?: boolean | group_game$shinyHuntingMethodGamesArgs<ExtArgs>
    skillObtations?: boolean | group_game$skillObtationsArgs<ExtArgs>
    statisticGroupGames?: boolean | group_game$statisticGroupGamesArgs<ExtArgs>
    _count?: boolean | Group_gameCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $group_gamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "group_game"
    objects: {
      capsuleGameCapacityIinfos: Prisma.$capsule_game_capacity_infoPayload<ExtArgs>[]
      gameGroupGames: Prisma.$game_group_gamePayload<ExtArgs>[]
      nationnalNumbers: Prisma.$national_numberPayload<ExtArgs>[]
      shinyHuntingMethodGames: Prisma.$shiny_hunting_method_gamePayload<ExtArgs>[]
      skillObtations: Prisma.$skill_obtationPayload<ExtArgs>[]
      statisticGroupGames: Prisma.$statistic_group_gamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["group_game"]>
    composites: {}
  }

  type group_gameGetPayload<S extends boolean | null | undefined | group_gameDefaultArgs> = $Result.GetResult<Prisma.$group_gamePayload, S>

  type group_gameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<group_gameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Group_gameCountAggregateInputType | true
    }

  export interface group_gameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['group_game'], meta: { name: 'group_game' } }
    /**
     * Find zero or one Group_game that matches the filter.
     * @param {group_gameFindUniqueArgs} args - Arguments to find a Group_game
     * @example
     * // Get one Group_game
     * const group_game = await prisma.group_game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends group_gameFindUniqueArgs>(args: SelectSubset<T, group_gameFindUniqueArgs<ExtArgs>>): Prisma__group_gameClient<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group_game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {group_gameFindUniqueOrThrowArgs} args - Arguments to find a Group_game
     * @example
     * // Get one Group_game
     * const group_game = await prisma.group_game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends group_gameFindUniqueOrThrowArgs>(args: SelectSubset<T, group_gameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__group_gameClient<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group_game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_gameFindFirstArgs} args - Arguments to find a Group_game
     * @example
     * // Get one Group_game
     * const group_game = await prisma.group_game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends group_gameFindFirstArgs>(args?: SelectSubset<T, group_gameFindFirstArgs<ExtArgs>>): Prisma__group_gameClient<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group_game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_gameFindFirstOrThrowArgs} args - Arguments to find a Group_game
     * @example
     * // Get one Group_game
     * const group_game = await prisma.group_game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends group_gameFindFirstOrThrowArgs>(args?: SelectSubset<T, group_gameFindFirstOrThrowArgs<ExtArgs>>): Prisma__group_gameClient<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Group_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_gameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Group_games
     * const group_games = await prisma.group_game.findMany()
     * 
     * // Get first 10 Group_games
     * const group_games = await prisma.group_game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const group_gameWithIdOnly = await prisma.group_game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends group_gameFindManyArgs>(args?: SelectSubset<T, group_gameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group_game.
     * @param {group_gameCreateArgs} args - Arguments to create a Group_game.
     * @example
     * // Create one Group_game
     * const Group_game = await prisma.group_game.create({
     *   data: {
     *     // ... data to create a Group_game
     *   }
     * })
     * 
     */
    create<T extends group_gameCreateArgs>(args: SelectSubset<T, group_gameCreateArgs<ExtArgs>>): Prisma__group_gameClient<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Group_games.
     * @param {group_gameCreateManyArgs} args - Arguments to create many Group_games.
     * @example
     * // Create many Group_games
     * const group_game = await prisma.group_game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends group_gameCreateManyArgs>(args?: SelectSubset<T, group_gameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Group_game.
     * @param {group_gameDeleteArgs} args - Arguments to delete one Group_game.
     * @example
     * // Delete one Group_game
     * const Group_game = await prisma.group_game.delete({
     *   where: {
     *     // ... filter to delete one Group_game
     *   }
     * })
     * 
     */
    delete<T extends group_gameDeleteArgs>(args: SelectSubset<T, group_gameDeleteArgs<ExtArgs>>): Prisma__group_gameClient<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group_game.
     * @param {group_gameUpdateArgs} args - Arguments to update one Group_game.
     * @example
     * // Update one Group_game
     * const group_game = await prisma.group_game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends group_gameUpdateArgs>(args: SelectSubset<T, group_gameUpdateArgs<ExtArgs>>): Prisma__group_gameClient<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Group_games.
     * @param {group_gameDeleteManyArgs} args - Arguments to filter Group_games to delete.
     * @example
     * // Delete a few Group_games
     * const { count } = await prisma.group_game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends group_gameDeleteManyArgs>(args?: SelectSubset<T, group_gameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Group_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_gameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Group_games
     * const group_game = await prisma.group_game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends group_gameUpdateManyArgs>(args: SelectSubset<T, group_gameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group_game.
     * @param {group_gameUpsertArgs} args - Arguments to update or create a Group_game.
     * @example
     * // Update or create a Group_game
     * const group_game = await prisma.group_game.upsert({
     *   create: {
     *     // ... data to create a Group_game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group_game we want to update
     *   }
     * })
     */
    upsert<T extends group_gameUpsertArgs>(args: SelectSubset<T, group_gameUpsertArgs<ExtArgs>>): Prisma__group_gameClient<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Group_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_gameCountArgs} args - Arguments to filter Group_games to count.
     * @example
     * // Count the number of Group_games
     * const count = await prisma.group_game.count({
     *   where: {
     *     // ... the filter for the Group_games we want to count
     *   }
     * })
    **/
    count<T extends group_gameCountArgs>(
      args?: Subset<T, group_gameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Group_gameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Group_gameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Group_gameAggregateArgs>(args: Subset<T, Group_gameAggregateArgs>): Prisma.PrismaPromise<GetGroup_gameAggregateType<T>>

    /**
     * Group by Group_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_gameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends group_gameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: group_gameGroupByArgs['orderBy'] }
        : { orderBy?: group_gameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, group_gameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroup_gameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the group_game model
   */
  readonly fields: group_gameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for group_game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__group_gameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capsuleGameCapacityIinfos<T extends group_game$capsuleGameCapacityIinfosArgs<ExtArgs> = {}>(args?: Subset<T, group_game$capsuleGameCapacityIinfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capsule_game_capacity_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gameGroupGames<T extends group_game$gameGroupGamesArgs<ExtArgs> = {}>(args?: Subset<T, group_game$gameGroupGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_group_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nationnalNumbers<T extends group_game$nationnalNumbersArgs<ExtArgs> = {}>(args?: Subset<T, group_game$nationnalNumbersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$national_numberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shinyHuntingMethodGames<T extends group_game$shinyHuntingMethodGamesArgs<ExtArgs> = {}>(args?: Subset<T, group_game$shinyHuntingMethodGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shiny_hunting_method_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skillObtations<T extends group_game$skillObtationsArgs<ExtArgs> = {}>(args?: Subset<T, group_game$skillObtationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skill_obtationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statisticGroupGames<T extends group_game$statisticGroupGamesArgs<ExtArgs> = {}>(args?: Subset<T, group_game$statisticGroupGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statistic_group_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the group_game model
   */
  interface group_gameFieldRefs {
    readonly id: FieldRef<"group_game", 'Int'>
    readonly createdAt: FieldRef<"group_game", 'DateTime'>
    readonly updatedAt: FieldRef<"group_game", 'DateTime'>
    readonly status: FieldRef<"group_game", 'String'>
  }
    

  // Custom InputTypes
  /**
   * group_game findUnique
   */
  export type group_gameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_game
     */
    select?: group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_game
     */
    omit?: group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_gameInclude<ExtArgs> | null
    /**
     * Filter, which group_game to fetch.
     */
    where: group_gameWhereUniqueInput
  }

  /**
   * group_game findUniqueOrThrow
   */
  export type group_gameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_game
     */
    select?: group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_game
     */
    omit?: group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_gameInclude<ExtArgs> | null
    /**
     * Filter, which group_game to fetch.
     */
    where: group_gameWhereUniqueInput
  }

  /**
   * group_game findFirst
   */
  export type group_gameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_game
     */
    select?: group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_game
     */
    omit?: group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_gameInclude<ExtArgs> | null
    /**
     * Filter, which group_game to fetch.
     */
    where?: group_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_games to fetch.
     */
    orderBy?: group_gameOrderByWithRelationInput | group_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for group_games.
     */
    cursor?: group_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of group_games.
     */
    distinct?: Group_gameScalarFieldEnum | Group_gameScalarFieldEnum[]
  }

  /**
   * group_game findFirstOrThrow
   */
  export type group_gameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_game
     */
    select?: group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_game
     */
    omit?: group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_gameInclude<ExtArgs> | null
    /**
     * Filter, which group_game to fetch.
     */
    where?: group_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_games to fetch.
     */
    orderBy?: group_gameOrderByWithRelationInput | group_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for group_games.
     */
    cursor?: group_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of group_games.
     */
    distinct?: Group_gameScalarFieldEnum | Group_gameScalarFieldEnum[]
  }

  /**
   * group_game findMany
   */
  export type group_gameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_game
     */
    select?: group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_game
     */
    omit?: group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_gameInclude<ExtArgs> | null
    /**
     * Filter, which group_games to fetch.
     */
    where?: group_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_games to fetch.
     */
    orderBy?: group_gameOrderByWithRelationInput | group_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing group_games.
     */
    cursor?: group_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_games.
     */
    skip?: number
    distinct?: Group_gameScalarFieldEnum | Group_gameScalarFieldEnum[]
  }

  /**
   * group_game create
   */
  export type group_gameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_game
     */
    select?: group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_game
     */
    omit?: group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_gameInclude<ExtArgs> | null
    /**
     * The data needed to create a group_game.
     */
    data?: XOR<group_gameCreateInput, group_gameUncheckedCreateInput>
  }

  /**
   * group_game createMany
   */
  export type group_gameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many group_games.
     */
    data: group_gameCreateManyInput | group_gameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * group_game update
   */
  export type group_gameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_game
     */
    select?: group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_game
     */
    omit?: group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_gameInclude<ExtArgs> | null
    /**
     * The data needed to update a group_game.
     */
    data: XOR<group_gameUpdateInput, group_gameUncheckedUpdateInput>
    /**
     * Choose, which group_game to update.
     */
    where: group_gameWhereUniqueInput
  }

  /**
   * group_game updateMany
   */
  export type group_gameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update group_games.
     */
    data: XOR<group_gameUpdateManyMutationInput, group_gameUncheckedUpdateManyInput>
    /**
     * Filter which group_games to update
     */
    where?: group_gameWhereInput
    /**
     * Limit how many group_games to update.
     */
    limit?: number
  }

  /**
   * group_game upsert
   */
  export type group_gameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_game
     */
    select?: group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_game
     */
    omit?: group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_gameInclude<ExtArgs> | null
    /**
     * The filter to search for the group_game to update in case it exists.
     */
    where: group_gameWhereUniqueInput
    /**
     * In case the group_game found by the `where` argument doesn't exist, create a new group_game with this data.
     */
    create: XOR<group_gameCreateInput, group_gameUncheckedCreateInput>
    /**
     * In case the group_game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<group_gameUpdateInput, group_gameUncheckedUpdateInput>
  }

  /**
   * group_game delete
   */
  export type group_gameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_game
     */
    select?: group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_game
     */
    omit?: group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_gameInclude<ExtArgs> | null
    /**
     * Filter which group_game to delete.
     */
    where: group_gameWhereUniqueInput
  }

  /**
   * group_game deleteMany
   */
  export type group_gameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group_games to delete
     */
    where?: group_gameWhereInput
    /**
     * Limit how many group_games to delete.
     */
    limit?: number
  }

  /**
   * group_game.capsuleGameCapacityIinfos
   */
  export type group_game$capsuleGameCapacityIinfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule_game_capacity_info
     */
    select?: capsule_game_capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule_game_capacity_info
     */
    omit?: capsule_game_capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsule_game_capacity_infoInclude<ExtArgs> | null
    where?: capsule_game_capacity_infoWhereInput
    orderBy?: capsule_game_capacity_infoOrderByWithRelationInput | capsule_game_capacity_infoOrderByWithRelationInput[]
    cursor?: capsule_game_capacity_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Capsule_game_capacity_infoScalarFieldEnum | Capsule_game_capacity_infoScalarFieldEnum[]
  }

  /**
   * group_game.gameGroupGames
   */
  export type group_game$gameGroupGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_group_game
     */
    select?: game_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_group_game
     */
    omit?: game_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_group_gameInclude<ExtArgs> | null
    where?: game_group_gameWhereInput
    orderBy?: game_group_gameOrderByWithRelationInput | game_group_gameOrderByWithRelationInput[]
    cursor?: game_group_gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Game_group_gameScalarFieldEnum | Game_group_gameScalarFieldEnum[]
  }

  /**
   * group_game.nationnalNumbers
   */
  export type group_game$nationnalNumbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the national_number
     */
    select?: national_numberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the national_number
     */
    omit?: national_numberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: national_numberInclude<ExtArgs> | null
    where?: national_numberWhereInput
    orderBy?: national_numberOrderByWithRelationInput | national_numberOrderByWithRelationInput[]
    cursor?: national_numberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: National_numberScalarFieldEnum | National_numberScalarFieldEnum[]
  }

  /**
   * group_game.shinyHuntingMethodGames
   */
  export type group_game$shinyHuntingMethodGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_game
     */
    select?: shiny_hunting_method_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_game
     */
    omit?: shiny_hunting_method_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_gameInclude<ExtArgs> | null
    where?: shiny_hunting_method_gameWhereInput
    orderBy?: shiny_hunting_method_gameOrderByWithRelationInput | shiny_hunting_method_gameOrderByWithRelationInput[]
    cursor?: shiny_hunting_method_gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Shiny_hunting_method_gameScalarFieldEnum | Shiny_hunting_method_gameScalarFieldEnum[]
  }

  /**
   * group_game.skillObtations
   */
  export type group_game$skillObtationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation
     */
    select?: skill_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation
     */
    omit?: skill_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtationInclude<ExtArgs> | null
    where?: skill_obtationWhereInput
    orderBy?: skill_obtationOrderByWithRelationInput | skill_obtationOrderByWithRelationInput[]
    cursor?: skill_obtationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Skill_obtationScalarFieldEnum | Skill_obtationScalarFieldEnum[]
  }

  /**
   * group_game.statisticGroupGames
   */
  export type group_game$statisticGroupGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic_group_game
     */
    select?: statistic_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic_group_game
     */
    omit?: statistic_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statistic_group_gameInclude<ExtArgs> | null
    where?: statistic_group_gameWhereInput
    orderBy?: statistic_group_gameOrderByWithRelationInput | statistic_group_gameOrderByWithRelationInput[]
    cursor?: statistic_group_gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Statistic_group_gameScalarFieldEnum | Statistic_group_gameScalarFieldEnum[]
  }

  /**
   * group_game without action
   */
  export type group_gameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_game
     */
    select?: group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_game
     */
    omit?: group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_gameInclude<ExtArgs> | null
  }


  /**
   * Model capsule_game_capacity_info
   */

  export type AggregateCapsule_game_capacity_info = {
    _count: Capsule_game_capacity_infoCountAggregateOutputType | null
    _avg: Capsule_game_capacity_infoAvgAggregateOutputType | null
    _sum: Capsule_game_capacity_infoSumAggregateOutputType | null
    _min: Capsule_game_capacity_infoMinAggregateOutputType | null
    _max: Capsule_game_capacity_infoMaxAggregateOutputType | null
  }

  export type Capsule_game_capacity_infoAvgAggregateOutputType = {
    capacityInfoId: number | null
    capsuleId: number | null
    groupeGameId: number | null
  }

  export type Capsule_game_capacity_infoSumAggregateOutputType = {
    capacityInfoId: number | null
    capsuleId: number | null
    groupeGameId: number | null
  }

  export type Capsule_game_capacity_infoMinAggregateOutputType = {
    capacityInfoId: number | null
    capsuleId: number | null
    groupeGameId: number | null
  }

  export type Capsule_game_capacity_infoMaxAggregateOutputType = {
    capacityInfoId: number | null
    capsuleId: number | null
    groupeGameId: number | null
  }

  export type Capsule_game_capacity_infoCountAggregateOutputType = {
    capacityInfoId: number
    capsuleId: number
    groupeGameId: number
    _all: number
  }


  export type Capsule_game_capacity_infoAvgAggregateInputType = {
    capacityInfoId?: true
    capsuleId?: true
    groupeGameId?: true
  }

  export type Capsule_game_capacity_infoSumAggregateInputType = {
    capacityInfoId?: true
    capsuleId?: true
    groupeGameId?: true
  }

  export type Capsule_game_capacity_infoMinAggregateInputType = {
    capacityInfoId?: true
    capsuleId?: true
    groupeGameId?: true
  }

  export type Capsule_game_capacity_infoMaxAggregateInputType = {
    capacityInfoId?: true
    capsuleId?: true
    groupeGameId?: true
  }

  export type Capsule_game_capacity_infoCountAggregateInputType = {
    capacityInfoId?: true
    capsuleId?: true
    groupeGameId?: true
    _all?: true
  }

  export type Capsule_game_capacity_infoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capsule_game_capacity_info to aggregate.
     */
    where?: capsule_game_capacity_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capsule_game_capacity_infos to fetch.
     */
    orderBy?: capsule_game_capacity_infoOrderByWithRelationInput | capsule_game_capacity_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: capsule_game_capacity_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capsule_game_capacity_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capsule_game_capacity_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned capsule_game_capacity_infos
    **/
    _count?: true | Capsule_game_capacity_infoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Capsule_game_capacity_infoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Capsule_game_capacity_infoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Capsule_game_capacity_infoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Capsule_game_capacity_infoMaxAggregateInputType
  }

  export type GetCapsule_game_capacity_infoAggregateType<T extends Capsule_game_capacity_infoAggregateArgs> = {
        [P in keyof T & keyof AggregateCapsule_game_capacity_info]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapsule_game_capacity_info[P]>
      : GetScalarType<T[P], AggregateCapsule_game_capacity_info[P]>
  }




  export type capsule_game_capacity_infoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capsule_game_capacity_infoWhereInput
    orderBy?: capsule_game_capacity_infoOrderByWithAggregationInput | capsule_game_capacity_infoOrderByWithAggregationInput[]
    by: Capsule_game_capacity_infoScalarFieldEnum[] | Capsule_game_capacity_infoScalarFieldEnum
    having?: capsule_game_capacity_infoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Capsule_game_capacity_infoCountAggregateInputType | true
    _avg?: Capsule_game_capacity_infoAvgAggregateInputType
    _sum?: Capsule_game_capacity_infoSumAggregateInputType
    _min?: Capsule_game_capacity_infoMinAggregateInputType
    _max?: Capsule_game_capacity_infoMaxAggregateInputType
  }

  export type Capsule_game_capacity_infoGroupByOutputType = {
    capacityInfoId: number
    capsuleId: number
    groupeGameId: number
    _count: Capsule_game_capacity_infoCountAggregateOutputType | null
    _avg: Capsule_game_capacity_infoAvgAggregateOutputType | null
    _sum: Capsule_game_capacity_infoSumAggregateOutputType | null
    _min: Capsule_game_capacity_infoMinAggregateOutputType | null
    _max: Capsule_game_capacity_infoMaxAggregateOutputType | null
  }

  type GetCapsule_game_capacity_infoGroupByPayload<T extends capsule_game_capacity_infoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Capsule_game_capacity_infoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Capsule_game_capacity_infoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Capsule_game_capacity_infoGroupByOutputType[P]>
            : GetScalarType<T[P], Capsule_game_capacity_infoGroupByOutputType[P]>
        }
      >
    >


  export type capsule_game_capacity_infoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    capacityInfoId?: boolean
    capsuleId?: boolean
    groupeGameId?: boolean
    capacityInfo?: boolean | capacity_infoDefaultArgs<ExtArgs>
    capsule?: boolean | capsuleDefaultArgs<ExtArgs>
    groupGame?: boolean | group_gameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capsule_game_capacity_info"]>



  export type capsule_game_capacity_infoSelectScalar = {
    capacityInfoId?: boolean
    capsuleId?: boolean
    groupeGameId?: boolean
  }

  export type capsule_game_capacity_infoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"capacityInfoId" | "capsuleId" | "groupeGameId", ExtArgs["result"]["capsule_game_capacity_info"]>
  export type capsule_game_capacity_infoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfo?: boolean | capacity_infoDefaultArgs<ExtArgs>
    capsule?: boolean | capsuleDefaultArgs<ExtArgs>
    groupGame?: boolean | group_gameDefaultArgs<ExtArgs>
  }

  export type $capsule_game_capacity_infoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "capsule_game_capacity_info"
    objects: {
      capacityInfo: Prisma.$capacity_infoPayload<ExtArgs>
      capsule: Prisma.$capsulePayload<ExtArgs>
      groupGame: Prisma.$group_gamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      capacityInfoId: number
      capsuleId: number
      groupeGameId: number
    }, ExtArgs["result"]["capsule_game_capacity_info"]>
    composites: {}
  }

  type capsule_game_capacity_infoGetPayload<S extends boolean | null | undefined | capsule_game_capacity_infoDefaultArgs> = $Result.GetResult<Prisma.$capsule_game_capacity_infoPayload, S>

  type capsule_game_capacity_infoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<capsule_game_capacity_infoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Capsule_game_capacity_infoCountAggregateInputType | true
    }

  export interface capsule_game_capacity_infoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['capsule_game_capacity_info'], meta: { name: 'capsule_game_capacity_info' } }
    /**
     * Find zero or one Capsule_game_capacity_info that matches the filter.
     * @param {capsule_game_capacity_infoFindUniqueArgs} args - Arguments to find a Capsule_game_capacity_info
     * @example
     * // Get one Capsule_game_capacity_info
     * const capsule_game_capacity_info = await prisma.capsule_game_capacity_info.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends capsule_game_capacity_infoFindUniqueArgs>(args: SelectSubset<T, capsule_game_capacity_infoFindUniqueArgs<ExtArgs>>): Prisma__capsule_game_capacity_infoClient<$Result.GetResult<Prisma.$capsule_game_capacity_infoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Capsule_game_capacity_info that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {capsule_game_capacity_infoFindUniqueOrThrowArgs} args - Arguments to find a Capsule_game_capacity_info
     * @example
     * // Get one Capsule_game_capacity_info
     * const capsule_game_capacity_info = await prisma.capsule_game_capacity_info.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends capsule_game_capacity_infoFindUniqueOrThrowArgs>(args: SelectSubset<T, capsule_game_capacity_infoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__capsule_game_capacity_infoClient<$Result.GetResult<Prisma.$capsule_game_capacity_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capsule_game_capacity_info that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capsule_game_capacity_infoFindFirstArgs} args - Arguments to find a Capsule_game_capacity_info
     * @example
     * // Get one Capsule_game_capacity_info
     * const capsule_game_capacity_info = await prisma.capsule_game_capacity_info.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends capsule_game_capacity_infoFindFirstArgs>(args?: SelectSubset<T, capsule_game_capacity_infoFindFirstArgs<ExtArgs>>): Prisma__capsule_game_capacity_infoClient<$Result.GetResult<Prisma.$capsule_game_capacity_infoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capsule_game_capacity_info that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capsule_game_capacity_infoFindFirstOrThrowArgs} args - Arguments to find a Capsule_game_capacity_info
     * @example
     * // Get one Capsule_game_capacity_info
     * const capsule_game_capacity_info = await prisma.capsule_game_capacity_info.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends capsule_game_capacity_infoFindFirstOrThrowArgs>(args?: SelectSubset<T, capsule_game_capacity_infoFindFirstOrThrowArgs<ExtArgs>>): Prisma__capsule_game_capacity_infoClient<$Result.GetResult<Prisma.$capsule_game_capacity_infoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Capsule_game_capacity_infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capsule_game_capacity_infoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Capsule_game_capacity_infos
     * const capsule_game_capacity_infos = await prisma.capsule_game_capacity_info.findMany()
     * 
     * // Get first 10 Capsule_game_capacity_infos
     * const capsule_game_capacity_infos = await prisma.capsule_game_capacity_info.findMany({ take: 10 })
     * 
     * // Only select the `capacityInfoId`
     * const capsule_game_capacity_infoWithCapacityInfoIdOnly = await prisma.capsule_game_capacity_info.findMany({ select: { capacityInfoId: true } })
     * 
     */
    findMany<T extends capsule_game_capacity_infoFindManyArgs>(args?: SelectSubset<T, capsule_game_capacity_infoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capsule_game_capacity_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Capsule_game_capacity_info.
     * @param {capsule_game_capacity_infoCreateArgs} args - Arguments to create a Capsule_game_capacity_info.
     * @example
     * // Create one Capsule_game_capacity_info
     * const Capsule_game_capacity_info = await prisma.capsule_game_capacity_info.create({
     *   data: {
     *     // ... data to create a Capsule_game_capacity_info
     *   }
     * })
     * 
     */
    create<T extends capsule_game_capacity_infoCreateArgs>(args: SelectSubset<T, capsule_game_capacity_infoCreateArgs<ExtArgs>>): Prisma__capsule_game_capacity_infoClient<$Result.GetResult<Prisma.$capsule_game_capacity_infoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Capsule_game_capacity_infos.
     * @param {capsule_game_capacity_infoCreateManyArgs} args - Arguments to create many Capsule_game_capacity_infos.
     * @example
     * // Create many Capsule_game_capacity_infos
     * const capsule_game_capacity_info = await prisma.capsule_game_capacity_info.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends capsule_game_capacity_infoCreateManyArgs>(args?: SelectSubset<T, capsule_game_capacity_infoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Capsule_game_capacity_info.
     * @param {capsule_game_capacity_infoDeleteArgs} args - Arguments to delete one Capsule_game_capacity_info.
     * @example
     * // Delete one Capsule_game_capacity_info
     * const Capsule_game_capacity_info = await prisma.capsule_game_capacity_info.delete({
     *   where: {
     *     // ... filter to delete one Capsule_game_capacity_info
     *   }
     * })
     * 
     */
    delete<T extends capsule_game_capacity_infoDeleteArgs>(args: SelectSubset<T, capsule_game_capacity_infoDeleteArgs<ExtArgs>>): Prisma__capsule_game_capacity_infoClient<$Result.GetResult<Prisma.$capsule_game_capacity_infoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Capsule_game_capacity_info.
     * @param {capsule_game_capacity_infoUpdateArgs} args - Arguments to update one Capsule_game_capacity_info.
     * @example
     * // Update one Capsule_game_capacity_info
     * const capsule_game_capacity_info = await prisma.capsule_game_capacity_info.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends capsule_game_capacity_infoUpdateArgs>(args: SelectSubset<T, capsule_game_capacity_infoUpdateArgs<ExtArgs>>): Prisma__capsule_game_capacity_infoClient<$Result.GetResult<Prisma.$capsule_game_capacity_infoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Capsule_game_capacity_infos.
     * @param {capsule_game_capacity_infoDeleteManyArgs} args - Arguments to filter Capsule_game_capacity_infos to delete.
     * @example
     * // Delete a few Capsule_game_capacity_infos
     * const { count } = await prisma.capsule_game_capacity_info.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends capsule_game_capacity_infoDeleteManyArgs>(args?: SelectSubset<T, capsule_game_capacity_infoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capsule_game_capacity_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capsule_game_capacity_infoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Capsule_game_capacity_infos
     * const capsule_game_capacity_info = await prisma.capsule_game_capacity_info.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends capsule_game_capacity_infoUpdateManyArgs>(args: SelectSubset<T, capsule_game_capacity_infoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Capsule_game_capacity_info.
     * @param {capsule_game_capacity_infoUpsertArgs} args - Arguments to update or create a Capsule_game_capacity_info.
     * @example
     * // Update or create a Capsule_game_capacity_info
     * const capsule_game_capacity_info = await prisma.capsule_game_capacity_info.upsert({
     *   create: {
     *     // ... data to create a Capsule_game_capacity_info
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Capsule_game_capacity_info we want to update
     *   }
     * })
     */
    upsert<T extends capsule_game_capacity_infoUpsertArgs>(args: SelectSubset<T, capsule_game_capacity_infoUpsertArgs<ExtArgs>>): Prisma__capsule_game_capacity_infoClient<$Result.GetResult<Prisma.$capsule_game_capacity_infoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Capsule_game_capacity_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capsule_game_capacity_infoCountArgs} args - Arguments to filter Capsule_game_capacity_infos to count.
     * @example
     * // Count the number of Capsule_game_capacity_infos
     * const count = await prisma.capsule_game_capacity_info.count({
     *   where: {
     *     // ... the filter for the Capsule_game_capacity_infos we want to count
     *   }
     * })
    **/
    count<T extends capsule_game_capacity_infoCountArgs>(
      args?: Subset<T, capsule_game_capacity_infoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Capsule_game_capacity_infoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Capsule_game_capacity_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Capsule_game_capacity_infoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Capsule_game_capacity_infoAggregateArgs>(args: Subset<T, Capsule_game_capacity_infoAggregateArgs>): Prisma.PrismaPromise<GetCapsule_game_capacity_infoAggregateType<T>>

    /**
     * Group by Capsule_game_capacity_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capsule_game_capacity_infoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends capsule_game_capacity_infoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: capsule_game_capacity_infoGroupByArgs['orderBy'] }
        : { orderBy?: capsule_game_capacity_infoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, capsule_game_capacity_infoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapsule_game_capacity_infoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the capsule_game_capacity_info model
   */
  readonly fields: capsule_game_capacity_infoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for capsule_game_capacity_info.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__capsule_game_capacity_infoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capacityInfo<T extends capacity_infoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, capacity_infoDefaultArgs<ExtArgs>>): Prisma__capacity_infoClient<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    capsule<T extends capsuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, capsuleDefaultArgs<ExtArgs>>): Prisma__capsuleClient<$Result.GetResult<Prisma.$capsulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    groupGame<T extends group_gameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, group_gameDefaultArgs<ExtArgs>>): Prisma__group_gameClient<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the capsule_game_capacity_info model
   */
  interface capsule_game_capacity_infoFieldRefs {
    readonly capacityInfoId: FieldRef<"capsule_game_capacity_info", 'Int'>
    readonly capsuleId: FieldRef<"capsule_game_capacity_info", 'Int'>
    readonly groupeGameId: FieldRef<"capsule_game_capacity_info", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * capsule_game_capacity_info findUnique
   */
  export type capsule_game_capacity_infoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule_game_capacity_info
     */
    select?: capsule_game_capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule_game_capacity_info
     */
    omit?: capsule_game_capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsule_game_capacity_infoInclude<ExtArgs> | null
    /**
     * Filter, which capsule_game_capacity_info to fetch.
     */
    where: capsule_game_capacity_infoWhereUniqueInput
  }

  /**
   * capsule_game_capacity_info findUniqueOrThrow
   */
  export type capsule_game_capacity_infoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule_game_capacity_info
     */
    select?: capsule_game_capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule_game_capacity_info
     */
    omit?: capsule_game_capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsule_game_capacity_infoInclude<ExtArgs> | null
    /**
     * Filter, which capsule_game_capacity_info to fetch.
     */
    where: capsule_game_capacity_infoWhereUniqueInput
  }

  /**
   * capsule_game_capacity_info findFirst
   */
  export type capsule_game_capacity_infoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule_game_capacity_info
     */
    select?: capsule_game_capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule_game_capacity_info
     */
    omit?: capsule_game_capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsule_game_capacity_infoInclude<ExtArgs> | null
    /**
     * Filter, which capsule_game_capacity_info to fetch.
     */
    where?: capsule_game_capacity_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capsule_game_capacity_infos to fetch.
     */
    orderBy?: capsule_game_capacity_infoOrderByWithRelationInput | capsule_game_capacity_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capsule_game_capacity_infos.
     */
    cursor?: capsule_game_capacity_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capsule_game_capacity_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capsule_game_capacity_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capsule_game_capacity_infos.
     */
    distinct?: Capsule_game_capacity_infoScalarFieldEnum | Capsule_game_capacity_infoScalarFieldEnum[]
  }

  /**
   * capsule_game_capacity_info findFirstOrThrow
   */
  export type capsule_game_capacity_infoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule_game_capacity_info
     */
    select?: capsule_game_capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule_game_capacity_info
     */
    omit?: capsule_game_capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsule_game_capacity_infoInclude<ExtArgs> | null
    /**
     * Filter, which capsule_game_capacity_info to fetch.
     */
    where?: capsule_game_capacity_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capsule_game_capacity_infos to fetch.
     */
    orderBy?: capsule_game_capacity_infoOrderByWithRelationInput | capsule_game_capacity_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capsule_game_capacity_infos.
     */
    cursor?: capsule_game_capacity_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capsule_game_capacity_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capsule_game_capacity_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capsule_game_capacity_infos.
     */
    distinct?: Capsule_game_capacity_infoScalarFieldEnum | Capsule_game_capacity_infoScalarFieldEnum[]
  }

  /**
   * capsule_game_capacity_info findMany
   */
  export type capsule_game_capacity_infoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule_game_capacity_info
     */
    select?: capsule_game_capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule_game_capacity_info
     */
    omit?: capsule_game_capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsule_game_capacity_infoInclude<ExtArgs> | null
    /**
     * Filter, which capsule_game_capacity_infos to fetch.
     */
    where?: capsule_game_capacity_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capsule_game_capacity_infos to fetch.
     */
    orderBy?: capsule_game_capacity_infoOrderByWithRelationInput | capsule_game_capacity_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing capsule_game_capacity_infos.
     */
    cursor?: capsule_game_capacity_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capsule_game_capacity_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capsule_game_capacity_infos.
     */
    skip?: number
    distinct?: Capsule_game_capacity_infoScalarFieldEnum | Capsule_game_capacity_infoScalarFieldEnum[]
  }

  /**
   * capsule_game_capacity_info create
   */
  export type capsule_game_capacity_infoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule_game_capacity_info
     */
    select?: capsule_game_capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule_game_capacity_info
     */
    omit?: capsule_game_capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsule_game_capacity_infoInclude<ExtArgs> | null
    /**
     * The data needed to create a capsule_game_capacity_info.
     */
    data: XOR<capsule_game_capacity_infoCreateInput, capsule_game_capacity_infoUncheckedCreateInput>
  }

  /**
   * capsule_game_capacity_info createMany
   */
  export type capsule_game_capacity_infoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many capsule_game_capacity_infos.
     */
    data: capsule_game_capacity_infoCreateManyInput | capsule_game_capacity_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * capsule_game_capacity_info update
   */
  export type capsule_game_capacity_infoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule_game_capacity_info
     */
    select?: capsule_game_capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule_game_capacity_info
     */
    omit?: capsule_game_capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsule_game_capacity_infoInclude<ExtArgs> | null
    /**
     * The data needed to update a capsule_game_capacity_info.
     */
    data: XOR<capsule_game_capacity_infoUpdateInput, capsule_game_capacity_infoUncheckedUpdateInput>
    /**
     * Choose, which capsule_game_capacity_info to update.
     */
    where: capsule_game_capacity_infoWhereUniqueInput
  }

  /**
   * capsule_game_capacity_info updateMany
   */
  export type capsule_game_capacity_infoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update capsule_game_capacity_infos.
     */
    data: XOR<capsule_game_capacity_infoUpdateManyMutationInput, capsule_game_capacity_infoUncheckedUpdateManyInput>
    /**
     * Filter which capsule_game_capacity_infos to update
     */
    where?: capsule_game_capacity_infoWhereInput
    /**
     * Limit how many capsule_game_capacity_infos to update.
     */
    limit?: number
  }

  /**
   * capsule_game_capacity_info upsert
   */
  export type capsule_game_capacity_infoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule_game_capacity_info
     */
    select?: capsule_game_capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule_game_capacity_info
     */
    omit?: capsule_game_capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsule_game_capacity_infoInclude<ExtArgs> | null
    /**
     * The filter to search for the capsule_game_capacity_info to update in case it exists.
     */
    where: capsule_game_capacity_infoWhereUniqueInput
    /**
     * In case the capsule_game_capacity_info found by the `where` argument doesn't exist, create a new capsule_game_capacity_info with this data.
     */
    create: XOR<capsule_game_capacity_infoCreateInput, capsule_game_capacity_infoUncheckedCreateInput>
    /**
     * In case the capsule_game_capacity_info was found with the provided `where` argument, update it with this data.
     */
    update: XOR<capsule_game_capacity_infoUpdateInput, capsule_game_capacity_infoUncheckedUpdateInput>
  }

  /**
   * capsule_game_capacity_info delete
   */
  export type capsule_game_capacity_infoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule_game_capacity_info
     */
    select?: capsule_game_capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule_game_capacity_info
     */
    omit?: capsule_game_capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsule_game_capacity_infoInclude<ExtArgs> | null
    /**
     * Filter which capsule_game_capacity_info to delete.
     */
    where: capsule_game_capacity_infoWhereUniqueInput
  }

  /**
   * capsule_game_capacity_info deleteMany
   */
  export type capsule_game_capacity_infoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capsule_game_capacity_infos to delete
     */
    where?: capsule_game_capacity_infoWhereInput
    /**
     * Limit how many capsule_game_capacity_infos to delete.
     */
    limit?: number
  }

  /**
   * capsule_game_capacity_info without action
   */
  export type capsule_game_capacity_infoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule_game_capacity_info
     */
    select?: capsule_game_capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule_game_capacity_info
     */
    omit?: capsule_game_capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsule_game_capacity_infoInclude<ExtArgs> | null
  }


  /**
   * Model pokemon_category
   */

  export type AggregatePokemon_category = {
    _count: Pokemon_categoryCountAggregateOutputType | null
    _avg: Pokemon_categoryAvgAggregateOutputType | null
    _sum: Pokemon_categorySumAggregateOutputType | null
    _min: Pokemon_categoryMinAggregateOutputType | null
    _max: Pokemon_categoryMaxAggregateOutputType | null
  }

  export type Pokemon_categoryAvgAggregateOutputType = {
    id: number | null
  }

  export type Pokemon_categorySumAggregateOutputType = {
    id: number | null
  }

  export type Pokemon_categoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Pokemon_categoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Pokemon_categoryCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Pokemon_categoryAvgAggregateInputType = {
    id?: true
  }

  export type Pokemon_categorySumAggregateInputType = {
    id?: true
  }

  export type Pokemon_categoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Pokemon_categoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Pokemon_categoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Pokemon_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokemon_category to aggregate.
     */
    where?: pokemon_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_categories to fetch.
     */
    orderBy?: pokemon_categoryOrderByWithRelationInput | pokemon_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pokemon_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pokemon_categories
    **/
    _count?: true | Pokemon_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pokemon_categoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pokemon_categorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pokemon_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pokemon_categoryMaxAggregateInputType
  }

  export type GetPokemon_categoryAggregateType<T extends Pokemon_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemon_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemon_category[P]>
      : GetScalarType<T[P], AggregatePokemon_category[P]>
  }




  export type pokemon_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_categoryWhereInput
    orderBy?: pokemon_categoryOrderByWithAggregationInput | pokemon_categoryOrderByWithAggregationInput[]
    by: Pokemon_categoryScalarFieldEnum[] | Pokemon_categoryScalarFieldEnum
    having?: pokemon_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pokemon_categoryCountAggregateInputType | true
    _avg?: Pokemon_categoryAvgAggregateInputType
    _sum?: Pokemon_categorySumAggregateInputType
    _min?: Pokemon_categoryMinAggregateInputType
    _max?: Pokemon_categoryMaxAggregateInputType
  }

  export type Pokemon_categoryGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Pokemon_categoryCountAggregateOutputType | null
    _avg: Pokemon_categoryAvgAggregateOutputType | null
    _sum: Pokemon_categorySumAggregateOutputType | null
    _min: Pokemon_categoryMinAggregateOutputType | null
    _max: Pokemon_categoryMaxAggregateOutputType | null
  }

  type GetPokemon_categoryGroupByPayload<T extends pokemon_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pokemon_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pokemon_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pokemon_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Pokemon_categoryGroupByOutputType[P]>
        }
      >
    >


  export type pokemon_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    pokemons?: boolean | pokemon_category$pokemonsArgs<ExtArgs>
    _count?: boolean | Pokemon_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemon_category"]>



  export type pokemon_categorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type pokemon_categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["pokemon_category"]>
  export type pokemon_categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemons?: boolean | pokemon_category$pokemonsArgs<ExtArgs>
    _count?: boolean | Pokemon_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $pokemon_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pokemon_category"
    objects: {
      pokemons: Prisma.$pokemonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["pokemon_category"]>
    composites: {}
  }

  type pokemon_categoryGetPayload<S extends boolean | null | undefined | pokemon_categoryDefaultArgs> = $Result.GetResult<Prisma.$pokemon_categoryPayload, S>

  type pokemon_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pokemon_categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pokemon_categoryCountAggregateInputType | true
    }

  export interface pokemon_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pokemon_category'], meta: { name: 'pokemon_category' } }
    /**
     * Find zero or one Pokemon_category that matches the filter.
     * @param {pokemon_categoryFindUniqueArgs} args - Arguments to find a Pokemon_category
     * @example
     * // Get one Pokemon_category
     * const pokemon_category = await prisma.pokemon_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pokemon_categoryFindUniqueArgs>(args: SelectSubset<T, pokemon_categoryFindUniqueArgs<ExtArgs>>): Prisma__pokemon_categoryClient<$Result.GetResult<Prisma.$pokemon_categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pokemon_category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pokemon_categoryFindUniqueOrThrowArgs} args - Arguments to find a Pokemon_category
     * @example
     * // Get one Pokemon_category
     * const pokemon_category = await prisma.pokemon_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pokemon_categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, pokemon_categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pokemon_categoryClient<$Result.GetResult<Prisma.$pokemon_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_categoryFindFirstArgs} args - Arguments to find a Pokemon_category
     * @example
     * // Get one Pokemon_category
     * const pokemon_category = await prisma.pokemon_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pokemon_categoryFindFirstArgs>(args?: SelectSubset<T, pokemon_categoryFindFirstArgs<ExtArgs>>): Prisma__pokemon_categoryClient<$Result.GetResult<Prisma.$pokemon_categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_categoryFindFirstOrThrowArgs} args - Arguments to find a Pokemon_category
     * @example
     * // Get one Pokemon_category
     * const pokemon_category = await prisma.pokemon_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pokemon_categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, pokemon_categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__pokemon_categoryClient<$Result.GetResult<Prisma.$pokemon_categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pokemon_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pokemon_categories
     * const pokemon_categories = await prisma.pokemon_category.findMany()
     * 
     * // Get first 10 Pokemon_categories
     * const pokemon_categories = await prisma.pokemon_category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokemon_categoryWithIdOnly = await prisma.pokemon_category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pokemon_categoryFindManyArgs>(args?: SelectSubset<T, pokemon_categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pokemon_category.
     * @param {pokemon_categoryCreateArgs} args - Arguments to create a Pokemon_category.
     * @example
     * // Create one Pokemon_category
     * const Pokemon_category = await prisma.pokemon_category.create({
     *   data: {
     *     // ... data to create a Pokemon_category
     *   }
     * })
     * 
     */
    create<T extends pokemon_categoryCreateArgs>(args: SelectSubset<T, pokemon_categoryCreateArgs<ExtArgs>>): Prisma__pokemon_categoryClient<$Result.GetResult<Prisma.$pokemon_categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pokemon_categories.
     * @param {pokemon_categoryCreateManyArgs} args - Arguments to create many Pokemon_categories.
     * @example
     * // Create many Pokemon_categories
     * const pokemon_category = await prisma.pokemon_category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pokemon_categoryCreateManyArgs>(args?: SelectSubset<T, pokemon_categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pokemon_category.
     * @param {pokemon_categoryDeleteArgs} args - Arguments to delete one Pokemon_category.
     * @example
     * // Delete one Pokemon_category
     * const Pokemon_category = await prisma.pokemon_category.delete({
     *   where: {
     *     // ... filter to delete one Pokemon_category
     *   }
     * })
     * 
     */
    delete<T extends pokemon_categoryDeleteArgs>(args: SelectSubset<T, pokemon_categoryDeleteArgs<ExtArgs>>): Prisma__pokemon_categoryClient<$Result.GetResult<Prisma.$pokemon_categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pokemon_category.
     * @param {pokemon_categoryUpdateArgs} args - Arguments to update one Pokemon_category.
     * @example
     * // Update one Pokemon_category
     * const pokemon_category = await prisma.pokemon_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pokemon_categoryUpdateArgs>(args: SelectSubset<T, pokemon_categoryUpdateArgs<ExtArgs>>): Prisma__pokemon_categoryClient<$Result.GetResult<Prisma.$pokemon_categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pokemon_categories.
     * @param {pokemon_categoryDeleteManyArgs} args - Arguments to filter Pokemon_categories to delete.
     * @example
     * // Delete a few Pokemon_categories
     * const { count } = await prisma.pokemon_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pokemon_categoryDeleteManyArgs>(args?: SelectSubset<T, pokemon_categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pokemon_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pokemon_categories
     * const pokemon_category = await prisma.pokemon_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pokemon_categoryUpdateManyArgs>(args: SelectSubset<T, pokemon_categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pokemon_category.
     * @param {pokemon_categoryUpsertArgs} args - Arguments to update or create a Pokemon_category.
     * @example
     * // Update or create a Pokemon_category
     * const pokemon_category = await prisma.pokemon_category.upsert({
     *   create: {
     *     // ... data to create a Pokemon_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pokemon_category we want to update
     *   }
     * })
     */
    upsert<T extends pokemon_categoryUpsertArgs>(args: SelectSubset<T, pokemon_categoryUpsertArgs<ExtArgs>>): Prisma__pokemon_categoryClient<$Result.GetResult<Prisma.$pokemon_categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pokemon_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_categoryCountArgs} args - Arguments to filter Pokemon_categories to count.
     * @example
     * // Count the number of Pokemon_categories
     * const count = await prisma.pokemon_category.count({
     *   where: {
     *     // ... the filter for the Pokemon_categories we want to count
     *   }
     * })
    **/
    count<T extends pokemon_categoryCountArgs>(
      args?: Subset<T, pokemon_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pokemon_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pokemon_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pokemon_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pokemon_categoryAggregateArgs>(args: Subset<T, Pokemon_categoryAggregateArgs>): Prisma.PrismaPromise<GetPokemon_categoryAggregateType<T>>

    /**
     * Group by Pokemon_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pokemon_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pokemon_categoryGroupByArgs['orderBy'] }
        : { orderBy?: pokemon_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pokemon_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemon_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pokemon_category model
   */
  readonly fields: pokemon_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pokemon_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pokemon_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pokemons<T extends pokemon_category$pokemonsArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_category$pokemonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pokemon_category model
   */
  interface pokemon_categoryFieldRefs {
    readonly id: FieldRef<"pokemon_category", 'Int'>
    readonly createdAt: FieldRef<"pokemon_category", 'DateTime'>
    readonly updatedAt: FieldRef<"pokemon_category", 'DateTime'>
    readonly status: FieldRef<"pokemon_category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pokemon_category findUnique
   */
  export type pokemon_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_category
     */
    select?: pokemon_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_category
     */
    omit?: pokemon_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_categoryInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_category to fetch.
     */
    where: pokemon_categoryWhereUniqueInput
  }

  /**
   * pokemon_category findUniqueOrThrow
   */
  export type pokemon_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_category
     */
    select?: pokemon_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_category
     */
    omit?: pokemon_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_categoryInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_category to fetch.
     */
    where: pokemon_categoryWhereUniqueInput
  }

  /**
   * pokemon_category findFirst
   */
  export type pokemon_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_category
     */
    select?: pokemon_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_category
     */
    omit?: pokemon_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_categoryInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_category to fetch.
     */
    where?: pokemon_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_categories to fetch.
     */
    orderBy?: pokemon_categoryOrderByWithRelationInput | pokemon_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokemon_categories.
     */
    cursor?: pokemon_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokemon_categories.
     */
    distinct?: Pokemon_categoryScalarFieldEnum | Pokemon_categoryScalarFieldEnum[]
  }

  /**
   * pokemon_category findFirstOrThrow
   */
  export type pokemon_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_category
     */
    select?: pokemon_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_category
     */
    omit?: pokemon_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_categoryInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_category to fetch.
     */
    where?: pokemon_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_categories to fetch.
     */
    orderBy?: pokemon_categoryOrderByWithRelationInput | pokemon_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokemon_categories.
     */
    cursor?: pokemon_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokemon_categories.
     */
    distinct?: Pokemon_categoryScalarFieldEnum | Pokemon_categoryScalarFieldEnum[]
  }

  /**
   * pokemon_category findMany
   */
  export type pokemon_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_category
     */
    select?: pokemon_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_category
     */
    omit?: pokemon_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_categoryInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_categories to fetch.
     */
    where?: pokemon_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_categories to fetch.
     */
    orderBy?: pokemon_categoryOrderByWithRelationInput | pokemon_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pokemon_categories.
     */
    cursor?: pokemon_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_categories.
     */
    skip?: number
    distinct?: Pokemon_categoryScalarFieldEnum | Pokemon_categoryScalarFieldEnum[]
  }

  /**
   * pokemon_category create
   */
  export type pokemon_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_category
     */
    select?: pokemon_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_category
     */
    omit?: pokemon_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a pokemon_category.
     */
    data?: XOR<pokemon_categoryCreateInput, pokemon_categoryUncheckedCreateInput>
  }

  /**
   * pokemon_category createMany
   */
  export type pokemon_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pokemon_categories.
     */
    data: pokemon_categoryCreateManyInput | pokemon_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pokemon_category update
   */
  export type pokemon_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_category
     */
    select?: pokemon_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_category
     */
    omit?: pokemon_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a pokemon_category.
     */
    data: XOR<pokemon_categoryUpdateInput, pokemon_categoryUncheckedUpdateInput>
    /**
     * Choose, which pokemon_category to update.
     */
    where: pokemon_categoryWhereUniqueInput
  }

  /**
   * pokemon_category updateMany
   */
  export type pokemon_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pokemon_categories.
     */
    data: XOR<pokemon_categoryUpdateManyMutationInput, pokemon_categoryUncheckedUpdateManyInput>
    /**
     * Filter which pokemon_categories to update
     */
    where?: pokemon_categoryWhereInput
    /**
     * Limit how many pokemon_categories to update.
     */
    limit?: number
  }

  /**
   * pokemon_category upsert
   */
  export type pokemon_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_category
     */
    select?: pokemon_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_category
     */
    omit?: pokemon_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the pokemon_category to update in case it exists.
     */
    where: pokemon_categoryWhereUniqueInput
    /**
     * In case the pokemon_category found by the `where` argument doesn't exist, create a new pokemon_category with this data.
     */
    create: XOR<pokemon_categoryCreateInput, pokemon_categoryUncheckedCreateInput>
    /**
     * In case the pokemon_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pokemon_categoryUpdateInput, pokemon_categoryUncheckedUpdateInput>
  }

  /**
   * pokemon_category delete
   */
  export type pokemon_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_category
     */
    select?: pokemon_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_category
     */
    omit?: pokemon_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_categoryInclude<ExtArgs> | null
    /**
     * Filter which pokemon_category to delete.
     */
    where: pokemon_categoryWhereUniqueInput
  }

  /**
   * pokemon_category deleteMany
   */
  export type pokemon_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokemon_categories to delete
     */
    where?: pokemon_categoryWhereInput
    /**
     * Limit how many pokemon_categories to delete.
     */
    limit?: number
  }

  /**
   * pokemon_category.pokemons
   */
  export type pokemon_category$pokemonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon
     */
    select?: pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon
     */
    omit?: pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemonInclude<ExtArgs> | null
    where?: pokemonWhereInput
    orderBy?: pokemonOrderByWithRelationInput | pokemonOrderByWithRelationInput[]
    cursor?: pokemonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonScalarFieldEnum | PokemonScalarFieldEnum[]
  }

  /**
   * pokemon_category without action
   */
  export type pokemon_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_category
     */
    select?: pokemon_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_category
     */
    omit?: pokemon_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_categoryInclude<ExtArgs> | null
  }


  /**
   * Model pokemon
   */

  export type AggregatePokemon = {
    _count: PokemonCountAggregateOutputType | null
    _avg: PokemonAvgAggregateOutputType | null
    _sum: PokemonSumAggregateOutputType | null
    _min: PokemonMinAggregateOutputType | null
    _max: PokemonMaxAggregateOutputType | null
  }

  export type PokemonAvgAggregateOutputType = {
    id: number | null
    internationalNumber: number | null
    hatchingCycle: number | null
    globalXp: number | null
    captureRate: number | null
    callHelpRate: number | null
    size: Decimal | null
    weight: Decimal | null
    maleRate: Decimal | null
    femelleRate: Decimal | null
    pokemonCategoryId: number | null
    generationId: number | null
  }

  export type PokemonSumAggregateOutputType = {
    id: number | null
    internationalNumber: number | null
    hatchingCycle: number | null
    globalXp: number | null
    captureRate: number | null
    callHelpRate: number | null
    size: Decimal | null
    weight: Decimal | null
    maleRate: Decimal | null
    femelleRate: Decimal | null
    pokemonCategoryId: number | null
    generationId: number | null
  }

  export type PokemonMinAggregateOutputType = {
    id: number | null
    internationalNumber: number | null
    hatchingCycle: number | null
    globalXp: number | null
    captureRate: number | null
    callHelpRate: number | null
    size: Decimal | null
    weight: Decimal | null
    maleRate: Decimal | null
    femelleRate: Decimal | null
    pokemonCategoryId: number | null
    generationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type PokemonMaxAggregateOutputType = {
    id: number | null
    internationalNumber: number | null
    hatchingCycle: number | null
    globalXp: number | null
    captureRate: number | null
    callHelpRate: number | null
    size: Decimal | null
    weight: Decimal | null
    maleRate: Decimal | null
    femelleRate: Decimal | null
    pokemonCategoryId: number | null
    generationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type PokemonCountAggregateOutputType = {
    id: number
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: number
    weight: number
    maleRate: number
    femelleRate: number
    pokemonCategoryId: number
    generationId: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type PokemonAvgAggregateInputType = {
    id?: true
    internationalNumber?: true
    hatchingCycle?: true
    globalXp?: true
    captureRate?: true
    callHelpRate?: true
    size?: true
    weight?: true
    maleRate?: true
    femelleRate?: true
    pokemonCategoryId?: true
    generationId?: true
  }

  export type PokemonSumAggregateInputType = {
    id?: true
    internationalNumber?: true
    hatchingCycle?: true
    globalXp?: true
    captureRate?: true
    callHelpRate?: true
    size?: true
    weight?: true
    maleRate?: true
    femelleRate?: true
    pokemonCategoryId?: true
    generationId?: true
  }

  export type PokemonMinAggregateInputType = {
    id?: true
    internationalNumber?: true
    hatchingCycle?: true
    globalXp?: true
    captureRate?: true
    callHelpRate?: true
    size?: true
    weight?: true
    maleRate?: true
    femelleRate?: true
    pokemonCategoryId?: true
    generationId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type PokemonMaxAggregateInputType = {
    id?: true
    internationalNumber?: true
    hatchingCycle?: true
    globalXp?: true
    captureRate?: true
    callHelpRate?: true
    size?: true
    weight?: true
    maleRate?: true
    femelleRate?: true
    pokemonCategoryId?: true
    generationId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type PokemonCountAggregateInputType = {
    id?: true
    internationalNumber?: true
    hatchingCycle?: true
    globalXp?: true
    captureRate?: true
    callHelpRate?: true
    size?: true
    weight?: true
    maleRate?: true
    femelleRate?: true
    pokemonCategoryId?: true
    generationId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type PokemonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokemon to aggregate.
     */
    where?: pokemonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon to fetch.
     */
    orderBy?: pokemonOrderByWithRelationInput | pokemonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pokemonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pokemon
    **/
    _count?: true | PokemonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PokemonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PokemonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PokemonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PokemonMaxAggregateInputType
  }

  export type GetPokemonAggregateType<T extends PokemonAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemon[P]>
      : GetScalarType<T[P], AggregatePokemon[P]>
  }




  export type pokemonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemonWhereInput
    orderBy?: pokemonOrderByWithAggregationInput | pokemonOrderByWithAggregationInput[]
    by: PokemonScalarFieldEnum[] | PokemonScalarFieldEnum
    having?: pokemonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PokemonCountAggregateInputType | true
    _avg?: PokemonAvgAggregateInputType
    _sum?: PokemonSumAggregateInputType
    _min?: PokemonMinAggregateInputType
    _max?: PokemonMaxAggregateInputType
  }

  export type PokemonGroupByOutputType = {
    id: number
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal
    weight: Decimal
    maleRate: Decimal
    femelleRate: Decimal
    pokemonCategoryId: number
    generationId: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: PokemonCountAggregateOutputType | null
    _avg: PokemonAvgAggregateOutputType | null
    _sum: PokemonSumAggregateOutputType | null
    _min: PokemonMinAggregateOutputType | null
    _max: PokemonMaxAggregateOutputType | null
  }

  type GetPokemonGroupByPayload<T extends pokemonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PokemonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PokemonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PokemonGroupByOutputType[P]>
            : GetScalarType<T[P], PokemonGroupByOutputType[P]>
        }
      >
    >


  export type pokemonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    internationalNumber?: boolean
    hatchingCycle?: boolean
    globalXp?: boolean
    captureRate?: boolean
    callHelpRate?: boolean
    size?: boolean
    weight?: boolean
    maleRate?: boolean
    femelleRate?: boolean
    pokemonCategoryId?: boolean
    generationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    nationalNumbers?: boolean | pokemon$nationalNumbersArgs<ExtArgs>
    pokemon_category?: boolean | pokemon_categoryDefaultArgs<ExtArgs>
    generation?: boolean | generationDefaultArgs<ExtArgs>
    pokemonForms?: boolean | pokemon$pokemonFormsArgs<ExtArgs>
    pokemonInfos?: boolean | pokemon$pokemonInfosArgs<ExtArgs>
    skillObtations?: boolean | pokemon$skillObtationsArgs<ExtArgs>
    statisticGroupGames?: boolean | pokemon$statisticGroupGamesArgs<ExtArgs>
    _count?: boolean | PokemonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemon"]>



  export type pokemonSelectScalar = {
    id?: boolean
    internationalNumber?: boolean
    hatchingCycle?: boolean
    globalXp?: boolean
    captureRate?: boolean
    callHelpRate?: boolean
    size?: boolean
    weight?: boolean
    maleRate?: boolean
    femelleRate?: boolean
    pokemonCategoryId?: boolean
    generationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type pokemonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "internationalNumber" | "hatchingCycle" | "globalXp" | "captureRate" | "callHelpRate" | "size" | "weight" | "maleRate" | "femelleRate" | "pokemonCategoryId" | "generationId" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["pokemon"]>
  export type pokemonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nationalNumbers?: boolean | pokemon$nationalNumbersArgs<ExtArgs>
    pokemon_category?: boolean | pokemon_categoryDefaultArgs<ExtArgs>
    generation?: boolean | generationDefaultArgs<ExtArgs>
    pokemonForms?: boolean | pokemon$pokemonFormsArgs<ExtArgs>
    pokemonInfos?: boolean | pokemon$pokemonInfosArgs<ExtArgs>
    skillObtations?: boolean | pokemon$skillObtationsArgs<ExtArgs>
    statisticGroupGames?: boolean | pokemon$statisticGroupGamesArgs<ExtArgs>
    _count?: boolean | PokemonCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $pokemonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pokemon"
    objects: {
      nationalNumbers: Prisma.$national_numberPayload<ExtArgs>[]
      pokemon_category: Prisma.$pokemon_categoryPayload<ExtArgs>
      generation: Prisma.$generationPayload<ExtArgs>
      pokemonForms: Prisma.$pokemon_formPayload<ExtArgs>[]
      pokemonInfos: Prisma.$pokemon_infoPayload<ExtArgs>[]
      skillObtations: Prisma.$skill_obtationPayload<ExtArgs>[]
      statisticGroupGames: Prisma.$statistic_group_gamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      internationalNumber: number
      hatchingCycle: number
      globalXp: number
      captureRate: number
      callHelpRate: number
      size: Prisma.Decimal
      weight: Prisma.Decimal
      maleRate: Prisma.Decimal
      femelleRate: Prisma.Decimal
      pokemonCategoryId: number
      generationId: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["pokemon"]>
    composites: {}
  }

  type pokemonGetPayload<S extends boolean | null | undefined | pokemonDefaultArgs> = $Result.GetResult<Prisma.$pokemonPayload, S>

  type pokemonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pokemonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PokemonCountAggregateInputType | true
    }

  export interface pokemonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pokemon'], meta: { name: 'pokemon' } }
    /**
     * Find zero or one Pokemon that matches the filter.
     * @param {pokemonFindUniqueArgs} args - Arguments to find a Pokemon
     * @example
     * // Get one Pokemon
     * const pokemon = await prisma.pokemon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pokemonFindUniqueArgs>(args: SelectSubset<T, pokemonFindUniqueArgs<ExtArgs>>): Prisma__pokemonClient<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pokemon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pokemonFindUniqueOrThrowArgs} args - Arguments to find a Pokemon
     * @example
     * // Get one Pokemon
     * const pokemon = await prisma.pokemon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pokemonFindUniqueOrThrowArgs>(args: SelectSubset<T, pokemonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pokemonClient<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemonFindFirstArgs} args - Arguments to find a Pokemon
     * @example
     * // Get one Pokemon
     * const pokemon = await prisma.pokemon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pokemonFindFirstArgs>(args?: SelectSubset<T, pokemonFindFirstArgs<ExtArgs>>): Prisma__pokemonClient<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemonFindFirstOrThrowArgs} args - Arguments to find a Pokemon
     * @example
     * // Get one Pokemon
     * const pokemon = await prisma.pokemon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pokemonFindFirstOrThrowArgs>(args?: SelectSubset<T, pokemonFindFirstOrThrowArgs<ExtArgs>>): Prisma__pokemonClient<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pokemon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pokemon
     * const pokemon = await prisma.pokemon.findMany()
     * 
     * // Get first 10 Pokemon
     * const pokemon = await prisma.pokemon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokemonWithIdOnly = await prisma.pokemon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pokemonFindManyArgs>(args?: SelectSubset<T, pokemonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pokemon.
     * @param {pokemonCreateArgs} args - Arguments to create a Pokemon.
     * @example
     * // Create one Pokemon
     * const Pokemon = await prisma.pokemon.create({
     *   data: {
     *     // ... data to create a Pokemon
     *   }
     * })
     * 
     */
    create<T extends pokemonCreateArgs>(args: SelectSubset<T, pokemonCreateArgs<ExtArgs>>): Prisma__pokemonClient<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pokemon.
     * @param {pokemonCreateManyArgs} args - Arguments to create many Pokemon.
     * @example
     * // Create many Pokemon
     * const pokemon = await prisma.pokemon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pokemonCreateManyArgs>(args?: SelectSubset<T, pokemonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pokemon.
     * @param {pokemonDeleteArgs} args - Arguments to delete one Pokemon.
     * @example
     * // Delete one Pokemon
     * const Pokemon = await prisma.pokemon.delete({
     *   where: {
     *     // ... filter to delete one Pokemon
     *   }
     * })
     * 
     */
    delete<T extends pokemonDeleteArgs>(args: SelectSubset<T, pokemonDeleteArgs<ExtArgs>>): Prisma__pokemonClient<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pokemon.
     * @param {pokemonUpdateArgs} args - Arguments to update one Pokemon.
     * @example
     * // Update one Pokemon
     * const pokemon = await prisma.pokemon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pokemonUpdateArgs>(args: SelectSubset<T, pokemonUpdateArgs<ExtArgs>>): Prisma__pokemonClient<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pokemon.
     * @param {pokemonDeleteManyArgs} args - Arguments to filter Pokemon to delete.
     * @example
     * // Delete a few Pokemon
     * const { count } = await prisma.pokemon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pokemonDeleteManyArgs>(args?: SelectSubset<T, pokemonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pokemon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pokemon
     * const pokemon = await prisma.pokemon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pokemonUpdateManyArgs>(args: SelectSubset<T, pokemonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pokemon.
     * @param {pokemonUpsertArgs} args - Arguments to update or create a Pokemon.
     * @example
     * // Update or create a Pokemon
     * const pokemon = await prisma.pokemon.upsert({
     *   create: {
     *     // ... data to create a Pokemon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pokemon we want to update
     *   }
     * })
     */
    upsert<T extends pokemonUpsertArgs>(args: SelectSubset<T, pokemonUpsertArgs<ExtArgs>>): Prisma__pokemonClient<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pokemon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemonCountArgs} args - Arguments to filter Pokemon to count.
     * @example
     * // Count the number of Pokemon
     * const count = await prisma.pokemon.count({
     *   where: {
     *     // ... the filter for the Pokemon we want to count
     *   }
     * })
    **/
    count<T extends pokemonCountArgs>(
      args?: Subset<T, pokemonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PokemonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pokemon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PokemonAggregateArgs>(args: Subset<T, PokemonAggregateArgs>): Prisma.PrismaPromise<GetPokemonAggregateType<T>>

    /**
     * Group by Pokemon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pokemonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pokemonGroupByArgs['orderBy'] }
        : { orderBy?: pokemonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pokemonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pokemon model
   */
  readonly fields: pokemonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pokemon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pokemonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nationalNumbers<T extends pokemon$nationalNumbersArgs<ExtArgs> = {}>(args?: Subset<T, pokemon$nationalNumbersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$national_numberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pokemon_category<T extends pokemon_categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_categoryDefaultArgs<ExtArgs>>): Prisma__pokemon_categoryClient<$Result.GetResult<Prisma.$pokemon_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    generation<T extends generationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, generationDefaultArgs<ExtArgs>>): Prisma__generationClient<$Result.GetResult<Prisma.$generationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemonForms<T extends pokemon$pokemonFormsArgs<ExtArgs> = {}>(args?: Subset<T, pokemon$pokemonFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pokemonInfos<T extends pokemon$pokemonInfosArgs<ExtArgs> = {}>(args?: Subset<T, pokemon$pokemonInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skillObtations<T extends pokemon$skillObtationsArgs<ExtArgs> = {}>(args?: Subset<T, pokemon$skillObtationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skill_obtationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statisticGroupGames<T extends pokemon$statisticGroupGamesArgs<ExtArgs> = {}>(args?: Subset<T, pokemon$statisticGroupGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statistic_group_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pokemon model
   */
  interface pokemonFieldRefs {
    readonly id: FieldRef<"pokemon", 'Int'>
    readonly internationalNumber: FieldRef<"pokemon", 'Int'>
    readonly hatchingCycle: FieldRef<"pokemon", 'Int'>
    readonly globalXp: FieldRef<"pokemon", 'Int'>
    readonly captureRate: FieldRef<"pokemon", 'Int'>
    readonly callHelpRate: FieldRef<"pokemon", 'Int'>
    readonly size: FieldRef<"pokemon", 'Decimal'>
    readonly weight: FieldRef<"pokemon", 'Decimal'>
    readonly maleRate: FieldRef<"pokemon", 'Decimal'>
    readonly femelleRate: FieldRef<"pokemon", 'Decimal'>
    readonly pokemonCategoryId: FieldRef<"pokemon", 'Int'>
    readonly generationId: FieldRef<"pokemon", 'Int'>
    readonly createdAt: FieldRef<"pokemon", 'DateTime'>
    readonly updatedAt: FieldRef<"pokemon", 'DateTime'>
    readonly status: FieldRef<"pokemon", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pokemon findUnique
   */
  export type pokemonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon
     */
    select?: pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon
     */
    omit?: pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemonInclude<ExtArgs> | null
    /**
     * Filter, which pokemon to fetch.
     */
    where: pokemonWhereUniqueInput
  }

  /**
   * pokemon findUniqueOrThrow
   */
  export type pokemonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon
     */
    select?: pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon
     */
    omit?: pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemonInclude<ExtArgs> | null
    /**
     * Filter, which pokemon to fetch.
     */
    where: pokemonWhereUniqueInput
  }

  /**
   * pokemon findFirst
   */
  export type pokemonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon
     */
    select?: pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon
     */
    omit?: pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemonInclude<ExtArgs> | null
    /**
     * Filter, which pokemon to fetch.
     */
    where?: pokemonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon to fetch.
     */
    orderBy?: pokemonOrderByWithRelationInput | pokemonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokemon.
     */
    cursor?: pokemonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokemon.
     */
    distinct?: PokemonScalarFieldEnum | PokemonScalarFieldEnum[]
  }

  /**
   * pokemon findFirstOrThrow
   */
  export type pokemonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon
     */
    select?: pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon
     */
    omit?: pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemonInclude<ExtArgs> | null
    /**
     * Filter, which pokemon to fetch.
     */
    where?: pokemonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon to fetch.
     */
    orderBy?: pokemonOrderByWithRelationInput | pokemonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokemon.
     */
    cursor?: pokemonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokemon.
     */
    distinct?: PokemonScalarFieldEnum | PokemonScalarFieldEnum[]
  }

  /**
   * pokemon findMany
   */
  export type pokemonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon
     */
    select?: pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon
     */
    omit?: pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemonInclude<ExtArgs> | null
    /**
     * Filter, which pokemon to fetch.
     */
    where?: pokemonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon to fetch.
     */
    orderBy?: pokemonOrderByWithRelationInput | pokemonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pokemon.
     */
    cursor?: pokemonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon.
     */
    skip?: number
    distinct?: PokemonScalarFieldEnum | PokemonScalarFieldEnum[]
  }

  /**
   * pokemon create
   */
  export type pokemonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon
     */
    select?: pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon
     */
    omit?: pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemonInclude<ExtArgs> | null
    /**
     * The data needed to create a pokemon.
     */
    data: XOR<pokemonCreateInput, pokemonUncheckedCreateInput>
  }

  /**
   * pokemon createMany
   */
  export type pokemonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pokemon.
     */
    data: pokemonCreateManyInput | pokemonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pokemon update
   */
  export type pokemonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon
     */
    select?: pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon
     */
    omit?: pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemonInclude<ExtArgs> | null
    /**
     * The data needed to update a pokemon.
     */
    data: XOR<pokemonUpdateInput, pokemonUncheckedUpdateInput>
    /**
     * Choose, which pokemon to update.
     */
    where: pokemonWhereUniqueInput
  }

  /**
   * pokemon updateMany
   */
  export type pokemonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pokemon.
     */
    data: XOR<pokemonUpdateManyMutationInput, pokemonUncheckedUpdateManyInput>
    /**
     * Filter which pokemon to update
     */
    where?: pokemonWhereInput
    /**
     * Limit how many pokemon to update.
     */
    limit?: number
  }

  /**
   * pokemon upsert
   */
  export type pokemonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon
     */
    select?: pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon
     */
    omit?: pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemonInclude<ExtArgs> | null
    /**
     * The filter to search for the pokemon to update in case it exists.
     */
    where: pokemonWhereUniqueInput
    /**
     * In case the pokemon found by the `where` argument doesn't exist, create a new pokemon with this data.
     */
    create: XOR<pokemonCreateInput, pokemonUncheckedCreateInput>
    /**
     * In case the pokemon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pokemonUpdateInput, pokemonUncheckedUpdateInput>
  }

  /**
   * pokemon delete
   */
  export type pokemonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon
     */
    select?: pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon
     */
    omit?: pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemonInclude<ExtArgs> | null
    /**
     * Filter which pokemon to delete.
     */
    where: pokemonWhereUniqueInput
  }

  /**
   * pokemon deleteMany
   */
  export type pokemonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokemon to delete
     */
    where?: pokemonWhereInput
    /**
     * Limit how many pokemon to delete.
     */
    limit?: number
  }

  /**
   * pokemon.nationalNumbers
   */
  export type pokemon$nationalNumbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the national_number
     */
    select?: national_numberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the national_number
     */
    omit?: national_numberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: national_numberInclude<ExtArgs> | null
    where?: national_numberWhereInput
    orderBy?: national_numberOrderByWithRelationInput | national_numberOrderByWithRelationInput[]
    cursor?: national_numberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: National_numberScalarFieldEnum | National_numberScalarFieldEnum[]
  }

  /**
   * pokemon.pokemonForms
   */
  export type pokemon$pokemonFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form
     */
    select?: pokemon_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form
     */
    omit?: pokemon_formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_formInclude<ExtArgs> | null
    where?: pokemon_formWhereInput
    orderBy?: pokemon_formOrderByWithRelationInput | pokemon_formOrderByWithRelationInput[]
    cursor?: pokemon_formWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pokemon_formScalarFieldEnum | Pokemon_formScalarFieldEnum[]
  }

  /**
   * pokemon.pokemonInfos
   */
  export type pokemon$pokemonInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_info
     */
    select?: pokemon_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_info
     */
    omit?: pokemon_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_infoInclude<ExtArgs> | null
    where?: pokemon_infoWhereInput
    orderBy?: pokemon_infoOrderByWithRelationInput | pokemon_infoOrderByWithRelationInput[]
    cursor?: pokemon_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pokemon_infoScalarFieldEnum | Pokemon_infoScalarFieldEnum[]
  }

  /**
   * pokemon.skillObtations
   */
  export type pokemon$skillObtationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation
     */
    select?: skill_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation
     */
    omit?: skill_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtationInclude<ExtArgs> | null
    where?: skill_obtationWhereInput
    orderBy?: skill_obtationOrderByWithRelationInput | skill_obtationOrderByWithRelationInput[]
    cursor?: skill_obtationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Skill_obtationScalarFieldEnum | Skill_obtationScalarFieldEnum[]
  }

  /**
   * pokemon.statisticGroupGames
   */
  export type pokemon$statisticGroupGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic_group_game
     */
    select?: statistic_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic_group_game
     */
    omit?: statistic_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statistic_group_gameInclude<ExtArgs> | null
    where?: statistic_group_gameWhereInput
    orderBy?: statistic_group_gameOrderByWithRelationInput | statistic_group_gameOrderByWithRelationInput[]
    cursor?: statistic_group_gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Statistic_group_gameScalarFieldEnum | Statistic_group_gameScalarFieldEnum[]
  }

  /**
   * pokemon without action
   */
  export type pokemonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon
     */
    select?: pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon
     */
    omit?: pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemonInclude<ExtArgs> | null
  }


  /**
   * Model gender
   */

  export type AggregateGender = {
    _count: GenderCountAggregateOutputType | null
    _avg: GenderAvgAggregateOutputType | null
    _sum: GenderSumAggregateOutputType | null
    _min: GenderMinAggregateOutputType | null
    _max: GenderMaxAggregateOutputType | null
  }

  export type GenderAvgAggregateOutputType = {
    id: number | null
  }

  export type GenderSumAggregateOutputType = {
    id: number | null
  }

  export type GenderMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type GenderMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type GenderCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type GenderAvgAggregateInputType = {
    id?: true
  }

  export type GenderSumAggregateInputType = {
    id?: true
  }

  export type GenderMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type GenderMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type GenderCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type GenderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gender to aggregate.
     */
    where?: genderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genders to fetch.
     */
    orderBy?: genderOrderByWithRelationInput | genderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: genderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned genders
    **/
    _count?: true | GenderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenderMaxAggregateInputType
  }

  export type GetGenderAggregateType<T extends GenderAggregateArgs> = {
        [P in keyof T & keyof AggregateGender]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGender[P]>
      : GetScalarType<T[P], AggregateGender[P]>
  }




  export type genderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: genderWhereInput
    orderBy?: genderOrderByWithAggregationInput | genderOrderByWithAggregationInput[]
    by: GenderScalarFieldEnum[] | GenderScalarFieldEnum
    having?: genderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenderCountAggregateInputType | true
    _avg?: GenderAvgAggregateInputType
    _sum?: GenderSumAggregateInputType
    _min?: GenderMinAggregateInputType
    _max?: GenderMaxAggregateInputType
  }

  export type GenderGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: GenderCountAggregateOutputType | null
    _avg: GenderAvgAggregateOutputType | null
    _sum: GenderSumAggregateOutputType | null
    _min: GenderMinAggregateOutputType | null
    _max: GenderMaxAggregateOutputType | null
  }

  type GetGenderGroupByPayload<T extends genderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenderGroupByOutputType[P]>
            : GetScalarType<T[P], GenderGroupByOutputType[P]>
        }
      >
    >


  export type genderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    pokemonFormGenders?: boolean | gender$pokemonFormGendersArgs<ExtArgs>
    _count?: boolean | GenderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gender"]>



  export type genderSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type genderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["gender"]>
  export type genderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemonFormGenders?: boolean | gender$pokemonFormGendersArgs<ExtArgs>
    _count?: boolean | GenderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $genderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "gender"
    objects: {
      pokemonFormGenders: Prisma.$pokemon_form_genderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["gender"]>
    composites: {}
  }

  type genderGetPayload<S extends boolean | null | undefined | genderDefaultArgs> = $Result.GetResult<Prisma.$genderPayload, S>

  type genderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<genderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenderCountAggregateInputType | true
    }

  export interface genderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gender'], meta: { name: 'gender' } }
    /**
     * Find zero or one Gender that matches the filter.
     * @param {genderFindUniqueArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends genderFindUniqueArgs>(args: SelectSubset<T, genderFindUniqueArgs<ExtArgs>>): Prisma__genderClient<$Result.GetResult<Prisma.$genderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gender that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {genderFindUniqueOrThrowArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends genderFindUniqueOrThrowArgs>(args: SelectSubset<T, genderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__genderClient<$Result.GetResult<Prisma.$genderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gender that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genderFindFirstArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends genderFindFirstArgs>(args?: SelectSubset<T, genderFindFirstArgs<ExtArgs>>): Prisma__genderClient<$Result.GetResult<Prisma.$genderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gender that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genderFindFirstOrThrowArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends genderFindFirstOrThrowArgs>(args?: SelectSubset<T, genderFindFirstOrThrowArgs<ExtArgs>>): Prisma__genderClient<$Result.GetResult<Prisma.$genderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Genders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genders
     * const genders = await prisma.gender.findMany()
     * 
     * // Get first 10 Genders
     * const genders = await prisma.gender.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genderWithIdOnly = await prisma.gender.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends genderFindManyArgs>(args?: SelectSubset<T, genderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$genderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gender.
     * @param {genderCreateArgs} args - Arguments to create a Gender.
     * @example
     * // Create one Gender
     * const Gender = await prisma.gender.create({
     *   data: {
     *     // ... data to create a Gender
     *   }
     * })
     * 
     */
    create<T extends genderCreateArgs>(args: SelectSubset<T, genderCreateArgs<ExtArgs>>): Prisma__genderClient<$Result.GetResult<Prisma.$genderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Genders.
     * @param {genderCreateManyArgs} args - Arguments to create many Genders.
     * @example
     * // Create many Genders
     * const gender = await prisma.gender.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends genderCreateManyArgs>(args?: SelectSubset<T, genderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gender.
     * @param {genderDeleteArgs} args - Arguments to delete one Gender.
     * @example
     * // Delete one Gender
     * const Gender = await prisma.gender.delete({
     *   where: {
     *     // ... filter to delete one Gender
     *   }
     * })
     * 
     */
    delete<T extends genderDeleteArgs>(args: SelectSubset<T, genderDeleteArgs<ExtArgs>>): Prisma__genderClient<$Result.GetResult<Prisma.$genderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gender.
     * @param {genderUpdateArgs} args - Arguments to update one Gender.
     * @example
     * // Update one Gender
     * const gender = await prisma.gender.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends genderUpdateArgs>(args: SelectSubset<T, genderUpdateArgs<ExtArgs>>): Prisma__genderClient<$Result.GetResult<Prisma.$genderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Genders.
     * @param {genderDeleteManyArgs} args - Arguments to filter Genders to delete.
     * @example
     * // Delete a few Genders
     * const { count } = await prisma.gender.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends genderDeleteManyArgs>(args?: SelectSubset<T, genderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genders
     * const gender = await prisma.gender.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends genderUpdateManyArgs>(args: SelectSubset<T, genderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gender.
     * @param {genderUpsertArgs} args - Arguments to update or create a Gender.
     * @example
     * // Update or create a Gender
     * const gender = await prisma.gender.upsert({
     *   create: {
     *     // ... data to create a Gender
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gender we want to update
     *   }
     * })
     */
    upsert<T extends genderUpsertArgs>(args: SelectSubset<T, genderUpsertArgs<ExtArgs>>): Prisma__genderClient<$Result.GetResult<Prisma.$genderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Genders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genderCountArgs} args - Arguments to filter Genders to count.
     * @example
     * // Count the number of Genders
     * const count = await prisma.gender.count({
     *   where: {
     *     // ... the filter for the Genders we want to count
     *   }
     * })
    **/
    count<T extends genderCountArgs>(
      args?: Subset<T, genderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenderAggregateArgs>(args: Subset<T, GenderAggregateArgs>): Prisma.PrismaPromise<GetGenderAggregateType<T>>

    /**
     * Group by Gender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends genderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: genderGroupByArgs['orderBy'] }
        : { orderBy?: genderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, genderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the gender model
   */
  readonly fields: genderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for gender.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__genderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pokemonFormGenders<T extends gender$pokemonFormGendersArgs<ExtArgs> = {}>(args?: Subset<T, gender$pokemonFormGendersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_form_genderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the gender model
   */
  interface genderFieldRefs {
    readonly id: FieldRef<"gender", 'Int'>
    readonly createdAt: FieldRef<"gender", 'DateTime'>
    readonly updatedAt: FieldRef<"gender", 'DateTime'>
    readonly status: FieldRef<"gender", 'String'>
  }
    

  // Custom InputTypes
  /**
   * gender findUnique
   */
  export type genderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gender
     */
    omit?: genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genderInclude<ExtArgs> | null
    /**
     * Filter, which gender to fetch.
     */
    where: genderWhereUniqueInput
  }

  /**
   * gender findUniqueOrThrow
   */
  export type genderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gender
     */
    omit?: genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genderInclude<ExtArgs> | null
    /**
     * Filter, which gender to fetch.
     */
    where: genderWhereUniqueInput
  }

  /**
   * gender findFirst
   */
  export type genderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gender
     */
    omit?: genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genderInclude<ExtArgs> | null
    /**
     * Filter, which gender to fetch.
     */
    where?: genderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genders to fetch.
     */
    orderBy?: genderOrderByWithRelationInput | genderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for genders.
     */
    cursor?: genderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of genders.
     */
    distinct?: GenderScalarFieldEnum | GenderScalarFieldEnum[]
  }

  /**
   * gender findFirstOrThrow
   */
  export type genderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gender
     */
    omit?: genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genderInclude<ExtArgs> | null
    /**
     * Filter, which gender to fetch.
     */
    where?: genderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genders to fetch.
     */
    orderBy?: genderOrderByWithRelationInput | genderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for genders.
     */
    cursor?: genderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of genders.
     */
    distinct?: GenderScalarFieldEnum | GenderScalarFieldEnum[]
  }

  /**
   * gender findMany
   */
  export type genderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gender
     */
    omit?: genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genderInclude<ExtArgs> | null
    /**
     * Filter, which genders to fetch.
     */
    where?: genderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genders to fetch.
     */
    orderBy?: genderOrderByWithRelationInput | genderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing genders.
     */
    cursor?: genderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genders.
     */
    skip?: number
    distinct?: GenderScalarFieldEnum | GenderScalarFieldEnum[]
  }

  /**
   * gender create
   */
  export type genderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gender
     */
    omit?: genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genderInclude<ExtArgs> | null
    /**
     * The data needed to create a gender.
     */
    data?: XOR<genderCreateInput, genderUncheckedCreateInput>
  }

  /**
   * gender createMany
   */
  export type genderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many genders.
     */
    data: genderCreateManyInput | genderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gender update
   */
  export type genderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gender
     */
    omit?: genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genderInclude<ExtArgs> | null
    /**
     * The data needed to update a gender.
     */
    data: XOR<genderUpdateInput, genderUncheckedUpdateInput>
    /**
     * Choose, which gender to update.
     */
    where: genderWhereUniqueInput
  }

  /**
   * gender updateMany
   */
  export type genderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update genders.
     */
    data: XOR<genderUpdateManyMutationInput, genderUncheckedUpdateManyInput>
    /**
     * Filter which genders to update
     */
    where?: genderWhereInput
    /**
     * Limit how many genders to update.
     */
    limit?: number
  }

  /**
   * gender upsert
   */
  export type genderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gender
     */
    omit?: genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genderInclude<ExtArgs> | null
    /**
     * The filter to search for the gender to update in case it exists.
     */
    where: genderWhereUniqueInput
    /**
     * In case the gender found by the `where` argument doesn't exist, create a new gender with this data.
     */
    create: XOR<genderCreateInput, genderUncheckedCreateInput>
    /**
     * In case the gender was found with the provided `where` argument, update it with this data.
     */
    update: XOR<genderUpdateInput, genderUncheckedUpdateInput>
  }

  /**
   * gender delete
   */
  export type genderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gender
     */
    omit?: genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genderInclude<ExtArgs> | null
    /**
     * Filter which gender to delete.
     */
    where: genderWhereUniqueInput
  }

  /**
   * gender deleteMany
   */
  export type genderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which genders to delete
     */
    where?: genderWhereInput
    /**
     * Limit how many genders to delete.
     */
    limit?: number
  }

  /**
   * gender.pokemonFormGenders
   */
  export type gender$pokemonFormGendersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form_gender
     */
    select?: pokemon_form_genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form_gender
     */
    omit?: pokemon_form_genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_form_genderInclude<ExtArgs> | null
    where?: pokemon_form_genderWhereInput
    orderBy?: pokemon_form_genderOrderByWithRelationInput | pokemon_form_genderOrderByWithRelationInput[]
    cursor?: pokemon_form_genderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pokemon_form_genderScalarFieldEnum | Pokemon_form_genderScalarFieldEnum[]
  }

  /**
   * gender without action
   */
  export type genderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gender
     */
    omit?: genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genderInclude<ExtArgs> | null
  }


  /**
   * Model form
   */

  export type AggregateForm = {
    _count: FormCountAggregateOutputType | null
    _avg: FormAvgAggregateOutputType | null
    _sum: FormSumAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  export type FormAvgAggregateOutputType = {
    id: number | null
  }

  export type FormSumAggregateOutputType = {
    id: number | null
  }

  export type FormMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type FormMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type FormCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type FormAvgAggregateInputType = {
    id?: true
  }

  export type FormSumAggregateInputType = {
    id?: true
  }

  export type FormMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type FormMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type FormCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type FormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which form to aggregate.
     */
    where?: formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forms to fetch.
     */
    orderBy?: formOrderByWithRelationInput | formOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned forms
    **/
    _count?: true | FormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormMaxAggregateInputType
  }

  export type GetFormAggregateType<T extends FormAggregateArgs> = {
        [P in keyof T & keyof AggregateForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForm[P]>
      : GetScalarType<T[P], AggregateForm[P]>
  }




  export type formGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formWhereInput
    orderBy?: formOrderByWithAggregationInput | formOrderByWithAggregationInput[]
    by: FormScalarFieldEnum[] | FormScalarFieldEnum
    having?: formScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormCountAggregateInputType | true
    _avg?: FormAvgAggregateInputType
    _sum?: FormSumAggregateInputType
    _min?: FormMinAggregateInputType
    _max?: FormMaxAggregateInputType
  }

  export type FormGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: FormCountAggregateOutputType | null
    _avg: FormAvgAggregateOutputType | null
    _sum: FormSumAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  type GetFormGroupByPayload<T extends formGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormGroupByOutputType[P]>
            : GetScalarType<T[P], FormGroupByOutputType[P]>
        }
      >
    >


  export type formSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    pokemonForms?: boolean | form$pokemonFormsArgs<ExtArgs>
    _count?: boolean | FormCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["form"]>



  export type formSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type formOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["form"]>
  export type formInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemonForms?: boolean | form$pokemonFormsArgs<ExtArgs>
    _count?: boolean | FormCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $formPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "form"
    objects: {
      pokemonForms: Prisma.$pokemon_formPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["form"]>
    composites: {}
  }

  type formGetPayload<S extends boolean | null | undefined | formDefaultArgs> = $Result.GetResult<Prisma.$formPayload, S>

  type formCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<formFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormCountAggregateInputType | true
    }

  export interface formDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['form'], meta: { name: 'form' } }
    /**
     * Find zero or one Form that matches the filter.
     * @param {formFindUniqueArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends formFindUniqueArgs>(args: SelectSubset<T, formFindUniqueArgs<ExtArgs>>): Prisma__formClient<$Result.GetResult<Prisma.$formPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Form that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {formFindUniqueOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends formFindUniqueOrThrowArgs>(args: SelectSubset<T, formFindUniqueOrThrowArgs<ExtArgs>>): Prisma__formClient<$Result.GetResult<Prisma.$formPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Form that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formFindFirstArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends formFindFirstArgs>(args?: SelectSubset<T, formFindFirstArgs<ExtArgs>>): Prisma__formClient<$Result.GetResult<Prisma.$formPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Form that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formFindFirstOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends formFindFirstOrThrowArgs>(args?: SelectSubset<T, formFindFirstOrThrowArgs<ExtArgs>>): Prisma__formClient<$Result.GetResult<Prisma.$formPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Forms
     * const forms = await prisma.form.findMany()
     * 
     * // Get first 10 Forms
     * const forms = await prisma.form.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formWithIdOnly = await prisma.form.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends formFindManyArgs>(args?: SelectSubset<T, formFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Form.
     * @param {formCreateArgs} args - Arguments to create a Form.
     * @example
     * // Create one Form
     * const Form = await prisma.form.create({
     *   data: {
     *     // ... data to create a Form
     *   }
     * })
     * 
     */
    create<T extends formCreateArgs>(args: SelectSubset<T, formCreateArgs<ExtArgs>>): Prisma__formClient<$Result.GetResult<Prisma.$formPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Forms.
     * @param {formCreateManyArgs} args - Arguments to create many Forms.
     * @example
     * // Create many Forms
     * const form = await prisma.form.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends formCreateManyArgs>(args?: SelectSubset<T, formCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Form.
     * @param {formDeleteArgs} args - Arguments to delete one Form.
     * @example
     * // Delete one Form
     * const Form = await prisma.form.delete({
     *   where: {
     *     // ... filter to delete one Form
     *   }
     * })
     * 
     */
    delete<T extends formDeleteArgs>(args: SelectSubset<T, formDeleteArgs<ExtArgs>>): Prisma__formClient<$Result.GetResult<Prisma.$formPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Form.
     * @param {formUpdateArgs} args - Arguments to update one Form.
     * @example
     * // Update one Form
     * const form = await prisma.form.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends formUpdateArgs>(args: SelectSubset<T, formUpdateArgs<ExtArgs>>): Prisma__formClient<$Result.GetResult<Prisma.$formPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Forms.
     * @param {formDeleteManyArgs} args - Arguments to filter Forms to delete.
     * @example
     * // Delete a few Forms
     * const { count } = await prisma.form.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends formDeleteManyArgs>(args?: SelectSubset<T, formDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Forms
     * const form = await prisma.form.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends formUpdateManyArgs>(args: SelectSubset<T, formUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Form.
     * @param {formUpsertArgs} args - Arguments to update or create a Form.
     * @example
     * // Update or create a Form
     * const form = await prisma.form.upsert({
     *   create: {
     *     // ... data to create a Form
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Form we want to update
     *   }
     * })
     */
    upsert<T extends formUpsertArgs>(args: SelectSubset<T, formUpsertArgs<ExtArgs>>): Prisma__formClient<$Result.GetResult<Prisma.$formPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formCountArgs} args - Arguments to filter Forms to count.
     * @example
     * // Count the number of Forms
     * const count = await prisma.form.count({
     *   where: {
     *     // ... the filter for the Forms we want to count
     *   }
     * })
    **/
    count<T extends formCountArgs>(
      args?: Subset<T, formCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormAggregateArgs>(args: Subset<T, FormAggregateArgs>): Prisma.PrismaPromise<GetFormAggregateType<T>>

    /**
     * Group by Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends formGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: formGroupByArgs['orderBy'] }
        : { orderBy?: formGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, formGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the form model
   */
  readonly fields: formFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for form.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__formClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pokemonForms<T extends form$pokemonFormsArgs<ExtArgs> = {}>(args?: Subset<T, form$pokemonFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the form model
   */
  interface formFieldRefs {
    readonly id: FieldRef<"form", 'Int'>
    readonly createdAt: FieldRef<"form", 'DateTime'>
    readonly updatedAt: FieldRef<"form", 'DateTime'>
    readonly status: FieldRef<"form", 'String'>
  }
    

  // Custom InputTypes
  /**
   * form findUnique
   */
  export type formFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form
     */
    select?: formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form
     */
    omit?: formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formInclude<ExtArgs> | null
    /**
     * Filter, which form to fetch.
     */
    where: formWhereUniqueInput
  }

  /**
   * form findUniqueOrThrow
   */
  export type formFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form
     */
    select?: formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form
     */
    omit?: formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formInclude<ExtArgs> | null
    /**
     * Filter, which form to fetch.
     */
    where: formWhereUniqueInput
  }

  /**
   * form findFirst
   */
  export type formFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form
     */
    select?: formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form
     */
    omit?: formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formInclude<ExtArgs> | null
    /**
     * Filter, which form to fetch.
     */
    where?: formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forms to fetch.
     */
    orderBy?: formOrderByWithRelationInput | formOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for forms.
     */
    cursor?: formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * form findFirstOrThrow
   */
  export type formFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form
     */
    select?: formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form
     */
    omit?: formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formInclude<ExtArgs> | null
    /**
     * Filter, which form to fetch.
     */
    where?: formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forms to fetch.
     */
    orderBy?: formOrderByWithRelationInput | formOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for forms.
     */
    cursor?: formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * form findMany
   */
  export type formFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form
     */
    select?: formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form
     */
    omit?: formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formInclude<ExtArgs> | null
    /**
     * Filter, which forms to fetch.
     */
    where?: formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forms to fetch.
     */
    orderBy?: formOrderByWithRelationInput | formOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing forms.
     */
    cursor?: formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forms.
     */
    skip?: number
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * form create
   */
  export type formCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form
     */
    select?: formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form
     */
    omit?: formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formInclude<ExtArgs> | null
    /**
     * The data needed to create a form.
     */
    data?: XOR<formCreateInput, formUncheckedCreateInput>
  }

  /**
   * form createMany
   */
  export type formCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many forms.
     */
    data: formCreateManyInput | formCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * form update
   */
  export type formUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form
     */
    select?: formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form
     */
    omit?: formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formInclude<ExtArgs> | null
    /**
     * The data needed to update a form.
     */
    data: XOR<formUpdateInput, formUncheckedUpdateInput>
    /**
     * Choose, which form to update.
     */
    where: formWhereUniqueInput
  }

  /**
   * form updateMany
   */
  export type formUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update forms.
     */
    data: XOR<formUpdateManyMutationInput, formUncheckedUpdateManyInput>
    /**
     * Filter which forms to update
     */
    where?: formWhereInput
    /**
     * Limit how many forms to update.
     */
    limit?: number
  }

  /**
   * form upsert
   */
  export type formUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form
     */
    select?: formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form
     */
    omit?: formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formInclude<ExtArgs> | null
    /**
     * The filter to search for the form to update in case it exists.
     */
    where: formWhereUniqueInput
    /**
     * In case the form found by the `where` argument doesn't exist, create a new form with this data.
     */
    create: XOR<formCreateInput, formUncheckedCreateInput>
    /**
     * In case the form was found with the provided `where` argument, update it with this data.
     */
    update: XOR<formUpdateInput, formUncheckedUpdateInput>
  }

  /**
   * form delete
   */
  export type formDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form
     */
    select?: formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form
     */
    omit?: formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formInclude<ExtArgs> | null
    /**
     * Filter which form to delete.
     */
    where: formWhereUniqueInput
  }

  /**
   * form deleteMany
   */
  export type formDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which forms to delete
     */
    where?: formWhereInput
    /**
     * Limit how many forms to delete.
     */
    limit?: number
  }

  /**
   * form.pokemonForms
   */
  export type form$pokemonFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form
     */
    select?: pokemon_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form
     */
    omit?: pokemon_formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_formInclude<ExtArgs> | null
    where?: pokemon_formWhereInput
    orderBy?: pokemon_formOrderByWithRelationInput | pokemon_formOrderByWithRelationInput[]
    cursor?: pokemon_formWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pokemon_formScalarFieldEnum | Pokemon_formScalarFieldEnum[]
  }

  /**
   * form without action
   */
  export type formDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form
     */
    select?: formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form
     */
    omit?: formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formInclude<ExtArgs> | null
  }


  /**
   * Model pokemon_form_gender
   */

  export type AggregatePokemon_form_gender = {
    _count: Pokemon_form_genderCountAggregateOutputType | null
    _avg: Pokemon_form_genderAvgAggregateOutputType | null
    _sum: Pokemon_form_genderSumAggregateOutputType | null
    _min: Pokemon_form_genderMinAggregateOutputType | null
    _max: Pokemon_form_genderMaxAggregateOutputType | null
  }

  export type Pokemon_form_genderAvgAggregateOutputType = {
    pokemonFormId: number | null
    genderId: number | null
  }

  export type Pokemon_form_genderSumAggregateOutputType = {
    pokemonFormId: number | null
    genderId: number | null
  }

  export type Pokemon_form_genderMinAggregateOutputType = {
    pokemonFormId: number | null
    genderId: number | null
  }

  export type Pokemon_form_genderMaxAggregateOutputType = {
    pokemonFormId: number | null
    genderId: number | null
  }

  export type Pokemon_form_genderCountAggregateOutputType = {
    pokemonFormId: number
    genderId: number
    _all: number
  }


  export type Pokemon_form_genderAvgAggregateInputType = {
    pokemonFormId?: true
    genderId?: true
  }

  export type Pokemon_form_genderSumAggregateInputType = {
    pokemonFormId?: true
    genderId?: true
  }

  export type Pokemon_form_genderMinAggregateInputType = {
    pokemonFormId?: true
    genderId?: true
  }

  export type Pokemon_form_genderMaxAggregateInputType = {
    pokemonFormId?: true
    genderId?: true
  }

  export type Pokemon_form_genderCountAggregateInputType = {
    pokemonFormId?: true
    genderId?: true
    _all?: true
  }

  export type Pokemon_form_genderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokemon_form_gender to aggregate.
     */
    where?: pokemon_form_genderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_form_genders to fetch.
     */
    orderBy?: pokemon_form_genderOrderByWithRelationInput | pokemon_form_genderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pokemon_form_genderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_form_genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_form_genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pokemon_form_genders
    **/
    _count?: true | Pokemon_form_genderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pokemon_form_genderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pokemon_form_genderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pokemon_form_genderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pokemon_form_genderMaxAggregateInputType
  }

  export type GetPokemon_form_genderAggregateType<T extends Pokemon_form_genderAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemon_form_gender]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemon_form_gender[P]>
      : GetScalarType<T[P], AggregatePokemon_form_gender[P]>
  }




  export type pokemon_form_genderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_form_genderWhereInput
    orderBy?: pokemon_form_genderOrderByWithAggregationInput | pokemon_form_genderOrderByWithAggregationInput[]
    by: Pokemon_form_genderScalarFieldEnum[] | Pokemon_form_genderScalarFieldEnum
    having?: pokemon_form_genderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pokemon_form_genderCountAggregateInputType | true
    _avg?: Pokemon_form_genderAvgAggregateInputType
    _sum?: Pokemon_form_genderSumAggregateInputType
    _min?: Pokemon_form_genderMinAggregateInputType
    _max?: Pokemon_form_genderMaxAggregateInputType
  }

  export type Pokemon_form_genderGroupByOutputType = {
    pokemonFormId: number
    genderId: number
    _count: Pokemon_form_genderCountAggregateOutputType | null
    _avg: Pokemon_form_genderAvgAggregateOutputType | null
    _sum: Pokemon_form_genderSumAggregateOutputType | null
    _min: Pokemon_form_genderMinAggregateOutputType | null
    _max: Pokemon_form_genderMaxAggregateOutputType | null
  }

  type GetPokemon_form_genderGroupByPayload<T extends pokemon_form_genderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pokemon_form_genderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pokemon_form_genderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pokemon_form_genderGroupByOutputType[P]>
            : GetScalarType<T[P], Pokemon_form_genderGroupByOutputType[P]>
        }
      >
    >


  export type pokemon_form_genderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pokemonFormId?: boolean
    genderId?: boolean
    gender?: boolean | genderDefaultArgs<ExtArgs>
    pokemon_form?: boolean | pokemon_formDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemon_form_gender"]>



  export type pokemon_form_genderSelectScalar = {
    pokemonFormId?: boolean
    genderId?: boolean
  }

  export type pokemon_form_genderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pokemonFormId" | "genderId", ExtArgs["result"]["pokemon_form_gender"]>
  export type pokemon_form_genderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gender?: boolean | genderDefaultArgs<ExtArgs>
    pokemon_form?: boolean | pokemon_formDefaultArgs<ExtArgs>
  }

  export type $pokemon_form_genderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pokemon_form_gender"
    objects: {
      gender: Prisma.$genderPayload<ExtArgs>
      pokemon_form: Prisma.$pokemon_formPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      pokemonFormId: number
      genderId: number
    }, ExtArgs["result"]["pokemon_form_gender"]>
    composites: {}
  }

  type pokemon_form_genderGetPayload<S extends boolean | null | undefined | pokemon_form_genderDefaultArgs> = $Result.GetResult<Prisma.$pokemon_form_genderPayload, S>

  type pokemon_form_genderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pokemon_form_genderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pokemon_form_genderCountAggregateInputType | true
    }

  export interface pokemon_form_genderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pokemon_form_gender'], meta: { name: 'pokemon_form_gender' } }
    /**
     * Find zero or one Pokemon_form_gender that matches the filter.
     * @param {pokemon_form_genderFindUniqueArgs} args - Arguments to find a Pokemon_form_gender
     * @example
     * // Get one Pokemon_form_gender
     * const pokemon_form_gender = await prisma.pokemon_form_gender.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pokemon_form_genderFindUniqueArgs>(args: SelectSubset<T, pokemon_form_genderFindUniqueArgs<ExtArgs>>): Prisma__pokemon_form_genderClient<$Result.GetResult<Prisma.$pokemon_form_genderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pokemon_form_gender that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pokemon_form_genderFindUniqueOrThrowArgs} args - Arguments to find a Pokemon_form_gender
     * @example
     * // Get one Pokemon_form_gender
     * const pokemon_form_gender = await prisma.pokemon_form_gender.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pokemon_form_genderFindUniqueOrThrowArgs>(args: SelectSubset<T, pokemon_form_genderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pokemon_form_genderClient<$Result.GetResult<Prisma.$pokemon_form_genderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon_form_gender that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_form_genderFindFirstArgs} args - Arguments to find a Pokemon_form_gender
     * @example
     * // Get one Pokemon_form_gender
     * const pokemon_form_gender = await prisma.pokemon_form_gender.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pokemon_form_genderFindFirstArgs>(args?: SelectSubset<T, pokemon_form_genderFindFirstArgs<ExtArgs>>): Prisma__pokemon_form_genderClient<$Result.GetResult<Prisma.$pokemon_form_genderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon_form_gender that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_form_genderFindFirstOrThrowArgs} args - Arguments to find a Pokemon_form_gender
     * @example
     * // Get one Pokemon_form_gender
     * const pokemon_form_gender = await prisma.pokemon_form_gender.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pokemon_form_genderFindFirstOrThrowArgs>(args?: SelectSubset<T, pokemon_form_genderFindFirstOrThrowArgs<ExtArgs>>): Prisma__pokemon_form_genderClient<$Result.GetResult<Prisma.$pokemon_form_genderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pokemon_form_genders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_form_genderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pokemon_form_genders
     * const pokemon_form_genders = await prisma.pokemon_form_gender.findMany()
     * 
     * // Get first 10 Pokemon_form_genders
     * const pokemon_form_genders = await prisma.pokemon_form_gender.findMany({ take: 10 })
     * 
     * // Only select the `pokemonFormId`
     * const pokemon_form_genderWithPokemonFormIdOnly = await prisma.pokemon_form_gender.findMany({ select: { pokemonFormId: true } })
     * 
     */
    findMany<T extends pokemon_form_genderFindManyArgs>(args?: SelectSubset<T, pokemon_form_genderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_form_genderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pokemon_form_gender.
     * @param {pokemon_form_genderCreateArgs} args - Arguments to create a Pokemon_form_gender.
     * @example
     * // Create one Pokemon_form_gender
     * const Pokemon_form_gender = await prisma.pokemon_form_gender.create({
     *   data: {
     *     // ... data to create a Pokemon_form_gender
     *   }
     * })
     * 
     */
    create<T extends pokemon_form_genderCreateArgs>(args: SelectSubset<T, pokemon_form_genderCreateArgs<ExtArgs>>): Prisma__pokemon_form_genderClient<$Result.GetResult<Prisma.$pokemon_form_genderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pokemon_form_genders.
     * @param {pokemon_form_genderCreateManyArgs} args - Arguments to create many Pokemon_form_genders.
     * @example
     * // Create many Pokemon_form_genders
     * const pokemon_form_gender = await prisma.pokemon_form_gender.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pokemon_form_genderCreateManyArgs>(args?: SelectSubset<T, pokemon_form_genderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pokemon_form_gender.
     * @param {pokemon_form_genderDeleteArgs} args - Arguments to delete one Pokemon_form_gender.
     * @example
     * // Delete one Pokemon_form_gender
     * const Pokemon_form_gender = await prisma.pokemon_form_gender.delete({
     *   where: {
     *     // ... filter to delete one Pokemon_form_gender
     *   }
     * })
     * 
     */
    delete<T extends pokemon_form_genderDeleteArgs>(args: SelectSubset<T, pokemon_form_genderDeleteArgs<ExtArgs>>): Prisma__pokemon_form_genderClient<$Result.GetResult<Prisma.$pokemon_form_genderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pokemon_form_gender.
     * @param {pokemon_form_genderUpdateArgs} args - Arguments to update one Pokemon_form_gender.
     * @example
     * // Update one Pokemon_form_gender
     * const pokemon_form_gender = await prisma.pokemon_form_gender.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pokemon_form_genderUpdateArgs>(args: SelectSubset<T, pokemon_form_genderUpdateArgs<ExtArgs>>): Prisma__pokemon_form_genderClient<$Result.GetResult<Prisma.$pokemon_form_genderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pokemon_form_genders.
     * @param {pokemon_form_genderDeleteManyArgs} args - Arguments to filter Pokemon_form_genders to delete.
     * @example
     * // Delete a few Pokemon_form_genders
     * const { count } = await prisma.pokemon_form_gender.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pokemon_form_genderDeleteManyArgs>(args?: SelectSubset<T, pokemon_form_genderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pokemon_form_genders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_form_genderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pokemon_form_genders
     * const pokemon_form_gender = await prisma.pokemon_form_gender.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pokemon_form_genderUpdateManyArgs>(args: SelectSubset<T, pokemon_form_genderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pokemon_form_gender.
     * @param {pokemon_form_genderUpsertArgs} args - Arguments to update or create a Pokemon_form_gender.
     * @example
     * // Update or create a Pokemon_form_gender
     * const pokemon_form_gender = await prisma.pokemon_form_gender.upsert({
     *   create: {
     *     // ... data to create a Pokemon_form_gender
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pokemon_form_gender we want to update
     *   }
     * })
     */
    upsert<T extends pokemon_form_genderUpsertArgs>(args: SelectSubset<T, pokemon_form_genderUpsertArgs<ExtArgs>>): Prisma__pokemon_form_genderClient<$Result.GetResult<Prisma.$pokemon_form_genderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pokemon_form_genders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_form_genderCountArgs} args - Arguments to filter Pokemon_form_genders to count.
     * @example
     * // Count the number of Pokemon_form_genders
     * const count = await prisma.pokemon_form_gender.count({
     *   where: {
     *     // ... the filter for the Pokemon_form_genders we want to count
     *   }
     * })
    **/
    count<T extends pokemon_form_genderCountArgs>(
      args?: Subset<T, pokemon_form_genderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pokemon_form_genderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pokemon_form_gender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pokemon_form_genderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pokemon_form_genderAggregateArgs>(args: Subset<T, Pokemon_form_genderAggregateArgs>): Prisma.PrismaPromise<GetPokemon_form_genderAggregateType<T>>

    /**
     * Group by Pokemon_form_gender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_form_genderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pokemon_form_genderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pokemon_form_genderGroupByArgs['orderBy'] }
        : { orderBy?: pokemon_form_genderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pokemon_form_genderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemon_form_genderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pokemon_form_gender model
   */
  readonly fields: pokemon_form_genderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pokemon_form_gender.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pokemon_form_genderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gender<T extends genderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, genderDefaultArgs<ExtArgs>>): Prisma__genderClient<$Result.GetResult<Prisma.$genderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemon_form<T extends pokemon_formDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_formDefaultArgs<ExtArgs>>): Prisma__pokemon_formClient<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pokemon_form_gender model
   */
  interface pokemon_form_genderFieldRefs {
    readonly pokemonFormId: FieldRef<"pokemon_form_gender", 'Int'>
    readonly genderId: FieldRef<"pokemon_form_gender", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * pokemon_form_gender findUnique
   */
  export type pokemon_form_genderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form_gender
     */
    select?: pokemon_form_genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form_gender
     */
    omit?: pokemon_form_genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_form_genderInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_form_gender to fetch.
     */
    where: pokemon_form_genderWhereUniqueInput
  }

  /**
   * pokemon_form_gender findUniqueOrThrow
   */
  export type pokemon_form_genderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form_gender
     */
    select?: pokemon_form_genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form_gender
     */
    omit?: pokemon_form_genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_form_genderInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_form_gender to fetch.
     */
    where: pokemon_form_genderWhereUniqueInput
  }

  /**
   * pokemon_form_gender findFirst
   */
  export type pokemon_form_genderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form_gender
     */
    select?: pokemon_form_genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form_gender
     */
    omit?: pokemon_form_genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_form_genderInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_form_gender to fetch.
     */
    where?: pokemon_form_genderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_form_genders to fetch.
     */
    orderBy?: pokemon_form_genderOrderByWithRelationInput | pokemon_form_genderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokemon_form_genders.
     */
    cursor?: pokemon_form_genderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_form_genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_form_genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokemon_form_genders.
     */
    distinct?: Pokemon_form_genderScalarFieldEnum | Pokemon_form_genderScalarFieldEnum[]
  }

  /**
   * pokemon_form_gender findFirstOrThrow
   */
  export type pokemon_form_genderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form_gender
     */
    select?: pokemon_form_genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form_gender
     */
    omit?: pokemon_form_genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_form_genderInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_form_gender to fetch.
     */
    where?: pokemon_form_genderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_form_genders to fetch.
     */
    orderBy?: pokemon_form_genderOrderByWithRelationInput | pokemon_form_genderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokemon_form_genders.
     */
    cursor?: pokemon_form_genderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_form_genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_form_genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokemon_form_genders.
     */
    distinct?: Pokemon_form_genderScalarFieldEnum | Pokemon_form_genderScalarFieldEnum[]
  }

  /**
   * pokemon_form_gender findMany
   */
  export type pokemon_form_genderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form_gender
     */
    select?: pokemon_form_genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form_gender
     */
    omit?: pokemon_form_genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_form_genderInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_form_genders to fetch.
     */
    where?: pokemon_form_genderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_form_genders to fetch.
     */
    orderBy?: pokemon_form_genderOrderByWithRelationInput | pokemon_form_genderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pokemon_form_genders.
     */
    cursor?: pokemon_form_genderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_form_genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_form_genders.
     */
    skip?: number
    distinct?: Pokemon_form_genderScalarFieldEnum | Pokemon_form_genderScalarFieldEnum[]
  }

  /**
   * pokemon_form_gender create
   */
  export type pokemon_form_genderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form_gender
     */
    select?: pokemon_form_genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form_gender
     */
    omit?: pokemon_form_genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_form_genderInclude<ExtArgs> | null
    /**
     * The data needed to create a pokemon_form_gender.
     */
    data: XOR<pokemon_form_genderCreateInput, pokemon_form_genderUncheckedCreateInput>
  }

  /**
   * pokemon_form_gender createMany
   */
  export type pokemon_form_genderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pokemon_form_genders.
     */
    data: pokemon_form_genderCreateManyInput | pokemon_form_genderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pokemon_form_gender update
   */
  export type pokemon_form_genderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form_gender
     */
    select?: pokemon_form_genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form_gender
     */
    omit?: pokemon_form_genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_form_genderInclude<ExtArgs> | null
    /**
     * The data needed to update a pokemon_form_gender.
     */
    data: XOR<pokemon_form_genderUpdateInput, pokemon_form_genderUncheckedUpdateInput>
    /**
     * Choose, which pokemon_form_gender to update.
     */
    where: pokemon_form_genderWhereUniqueInput
  }

  /**
   * pokemon_form_gender updateMany
   */
  export type pokemon_form_genderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pokemon_form_genders.
     */
    data: XOR<pokemon_form_genderUpdateManyMutationInput, pokemon_form_genderUncheckedUpdateManyInput>
    /**
     * Filter which pokemon_form_genders to update
     */
    where?: pokemon_form_genderWhereInput
    /**
     * Limit how many pokemon_form_genders to update.
     */
    limit?: number
  }

  /**
   * pokemon_form_gender upsert
   */
  export type pokemon_form_genderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form_gender
     */
    select?: pokemon_form_genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form_gender
     */
    omit?: pokemon_form_genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_form_genderInclude<ExtArgs> | null
    /**
     * The filter to search for the pokemon_form_gender to update in case it exists.
     */
    where: pokemon_form_genderWhereUniqueInput
    /**
     * In case the pokemon_form_gender found by the `where` argument doesn't exist, create a new pokemon_form_gender with this data.
     */
    create: XOR<pokemon_form_genderCreateInput, pokemon_form_genderUncheckedCreateInput>
    /**
     * In case the pokemon_form_gender was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pokemon_form_genderUpdateInput, pokemon_form_genderUncheckedUpdateInput>
  }

  /**
   * pokemon_form_gender delete
   */
  export type pokemon_form_genderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form_gender
     */
    select?: pokemon_form_genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form_gender
     */
    omit?: pokemon_form_genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_form_genderInclude<ExtArgs> | null
    /**
     * Filter which pokemon_form_gender to delete.
     */
    where: pokemon_form_genderWhereUniqueInput
  }

  /**
   * pokemon_form_gender deleteMany
   */
  export type pokemon_form_genderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokemon_form_genders to delete
     */
    where?: pokemon_form_genderWhereInput
    /**
     * Limit how many pokemon_form_genders to delete.
     */
    limit?: number
  }

  /**
   * pokemon_form_gender without action
   */
  export type pokemon_form_genderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form_gender
     */
    select?: pokemon_form_genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form_gender
     */
    omit?: pokemon_form_genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_form_genderInclude<ExtArgs> | null
  }


  /**
   * Model pokemon_form
   */

  export type AggregatePokemon_form = {
    _count: Pokemon_formCountAggregateOutputType | null
    _avg: Pokemon_formAvgAggregateOutputType | null
    _sum: Pokemon_formSumAggregateOutputType | null
    _min: Pokemon_formMinAggregateOutputType | null
    _max: Pokemon_formMaxAggregateOutputType | null
  }

  export type Pokemon_formAvgAggregateOutputType = {
    pokemonId: number | null
    formId: number | null
    id: number | null
  }

  export type Pokemon_formSumAggregateOutputType = {
    pokemonId: number | null
    formId: number | null
    id: number | null
  }

  export type Pokemon_formMinAggregateOutputType = {
    pokemonId: number | null
    formId: number | null
    createdAt: Date | null
    id: number | null
    status: string | null
    updatedAt: Date | null
  }

  export type Pokemon_formMaxAggregateOutputType = {
    pokemonId: number | null
    formId: number | null
    createdAt: Date | null
    id: number | null
    status: string | null
    updatedAt: Date | null
  }

  export type Pokemon_formCountAggregateOutputType = {
    pokemonId: number
    formId: number
    createdAt: number
    id: number
    status: number
    updatedAt: number
    _all: number
  }


  export type Pokemon_formAvgAggregateInputType = {
    pokemonId?: true
    formId?: true
    id?: true
  }

  export type Pokemon_formSumAggregateInputType = {
    pokemonId?: true
    formId?: true
    id?: true
  }

  export type Pokemon_formMinAggregateInputType = {
    pokemonId?: true
    formId?: true
    createdAt?: true
    id?: true
    status?: true
    updatedAt?: true
  }

  export type Pokemon_formMaxAggregateInputType = {
    pokemonId?: true
    formId?: true
    createdAt?: true
    id?: true
    status?: true
    updatedAt?: true
  }

  export type Pokemon_formCountAggregateInputType = {
    pokemonId?: true
    formId?: true
    createdAt?: true
    id?: true
    status?: true
    updatedAt?: true
    _all?: true
  }

  export type Pokemon_formAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokemon_form to aggregate.
     */
    where?: pokemon_formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_forms to fetch.
     */
    orderBy?: pokemon_formOrderByWithRelationInput | pokemon_formOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pokemon_formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pokemon_forms
    **/
    _count?: true | Pokemon_formCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pokemon_formAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pokemon_formSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pokemon_formMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pokemon_formMaxAggregateInputType
  }

  export type GetPokemon_formAggregateType<T extends Pokemon_formAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemon_form]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemon_form[P]>
      : GetScalarType<T[P], AggregatePokemon_form[P]>
  }




  export type pokemon_formGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_formWhereInput
    orderBy?: pokemon_formOrderByWithAggregationInput | pokemon_formOrderByWithAggregationInput[]
    by: Pokemon_formScalarFieldEnum[] | Pokemon_formScalarFieldEnum
    having?: pokemon_formScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pokemon_formCountAggregateInputType | true
    _avg?: Pokemon_formAvgAggregateInputType
    _sum?: Pokemon_formSumAggregateInputType
    _min?: Pokemon_formMinAggregateInputType
    _max?: Pokemon_formMaxAggregateInputType
  }

  export type Pokemon_formGroupByOutputType = {
    pokemonId: number
    formId: number
    createdAt: Date
    id: number
    status: string
    updatedAt: Date | null
    _count: Pokemon_formCountAggregateOutputType | null
    _avg: Pokemon_formAvgAggregateOutputType | null
    _sum: Pokemon_formSumAggregateOutputType | null
    _min: Pokemon_formMinAggregateOutputType | null
    _max: Pokemon_formMaxAggregateOutputType | null
  }

  type GetPokemon_formGroupByPayload<T extends pokemon_formGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pokemon_formGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pokemon_formGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pokemon_formGroupByOutputType[P]>
            : GetScalarType<T[P], Pokemon_formGroupByOutputType[P]>
        }
      >
    >


  export type pokemon_formSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pokemonId?: boolean
    formId?: boolean
    createdAt?: boolean
    id?: boolean
    status?: boolean
    updatedAt?: boolean
    evolutionEnds?: boolean | pokemon_form$evolutionEndsArgs<ExtArgs>
    evolutionStarts?: boolean | pokemon_form$evolutionStartsArgs<ExtArgs>
    ownedPokemons?: boolean | pokemon_form$ownedPokemonsArgs<ExtArgs>
    form?: boolean | formDefaultArgs<ExtArgs>
    pokemon?: boolean | pokemonDefaultArgs<ExtArgs>
    pokemonFormGenders?: boolean | pokemon_form$pokemonFormGendersArgs<ExtArgs>
    pokemonRatingGames?: boolean | pokemon_form$pokemonRatingGamesArgs<ExtArgs>
    _count?: boolean | Pokemon_formCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemon_form"]>



  export type pokemon_formSelectScalar = {
    pokemonId?: boolean
    formId?: boolean
    createdAt?: boolean
    id?: boolean
    status?: boolean
    updatedAt?: boolean
  }

  export type pokemon_formOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pokemonId" | "formId" | "createdAt" | "id" | "status" | "updatedAt", ExtArgs["result"]["pokemon_form"]>
  export type pokemon_formInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolutionEnds?: boolean | pokemon_form$evolutionEndsArgs<ExtArgs>
    evolutionStarts?: boolean | pokemon_form$evolutionStartsArgs<ExtArgs>
    ownedPokemons?: boolean | pokemon_form$ownedPokemonsArgs<ExtArgs>
    form?: boolean | formDefaultArgs<ExtArgs>
    pokemon?: boolean | pokemonDefaultArgs<ExtArgs>
    pokemonFormGenders?: boolean | pokemon_form$pokemonFormGendersArgs<ExtArgs>
    pokemonRatingGames?: boolean | pokemon_form$pokemonRatingGamesArgs<ExtArgs>
    _count?: boolean | Pokemon_formCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $pokemon_formPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pokemon_form"
    objects: {
      evolutionEnds: Prisma.$evolutionPayload<ExtArgs>[]
      evolutionStarts: Prisma.$evolutionPayload<ExtArgs>[]
      ownedPokemons: Prisma.$owned_pokemonPayload<ExtArgs>[]
      form: Prisma.$formPayload<ExtArgs>
      pokemon: Prisma.$pokemonPayload<ExtArgs>
      pokemonFormGenders: Prisma.$pokemon_form_genderPayload<ExtArgs>[]
      pokemonRatingGames: Prisma.$pokemon_game_locationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      pokemonId: number
      formId: number
      createdAt: Date
      id: number
      status: string
      updatedAt: Date | null
    }, ExtArgs["result"]["pokemon_form"]>
    composites: {}
  }

  type pokemon_formGetPayload<S extends boolean | null | undefined | pokemon_formDefaultArgs> = $Result.GetResult<Prisma.$pokemon_formPayload, S>

  type pokemon_formCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pokemon_formFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pokemon_formCountAggregateInputType | true
    }

  export interface pokemon_formDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pokemon_form'], meta: { name: 'pokemon_form' } }
    /**
     * Find zero or one Pokemon_form that matches the filter.
     * @param {pokemon_formFindUniqueArgs} args - Arguments to find a Pokemon_form
     * @example
     * // Get one Pokemon_form
     * const pokemon_form = await prisma.pokemon_form.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pokemon_formFindUniqueArgs>(args: SelectSubset<T, pokemon_formFindUniqueArgs<ExtArgs>>): Prisma__pokemon_formClient<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pokemon_form that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pokemon_formFindUniqueOrThrowArgs} args - Arguments to find a Pokemon_form
     * @example
     * // Get one Pokemon_form
     * const pokemon_form = await prisma.pokemon_form.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pokemon_formFindUniqueOrThrowArgs>(args: SelectSubset<T, pokemon_formFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pokemon_formClient<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon_form that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_formFindFirstArgs} args - Arguments to find a Pokemon_form
     * @example
     * // Get one Pokemon_form
     * const pokemon_form = await prisma.pokemon_form.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pokemon_formFindFirstArgs>(args?: SelectSubset<T, pokemon_formFindFirstArgs<ExtArgs>>): Prisma__pokemon_formClient<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon_form that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_formFindFirstOrThrowArgs} args - Arguments to find a Pokemon_form
     * @example
     * // Get one Pokemon_form
     * const pokemon_form = await prisma.pokemon_form.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pokemon_formFindFirstOrThrowArgs>(args?: SelectSubset<T, pokemon_formFindFirstOrThrowArgs<ExtArgs>>): Prisma__pokemon_formClient<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pokemon_forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_formFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pokemon_forms
     * const pokemon_forms = await prisma.pokemon_form.findMany()
     * 
     * // Get first 10 Pokemon_forms
     * const pokemon_forms = await prisma.pokemon_form.findMany({ take: 10 })
     * 
     * // Only select the `pokemonId`
     * const pokemon_formWithPokemonIdOnly = await prisma.pokemon_form.findMany({ select: { pokemonId: true } })
     * 
     */
    findMany<T extends pokemon_formFindManyArgs>(args?: SelectSubset<T, pokemon_formFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pokemon_form.
     * @param {pokemon_formCreateArgs} args - Arguments to create a Pokemon_form.
     * @example
     * // Create one Pokemon_form
     * const Pokemon_form = await prisma.pokemon_form.create({
     *   data: {
     *     // ... data to create a Pokemon_form
     *   }
     * })
     * 
     */
    create<T extends pokemon_formCreateArgs>(args: SelectSubset<T, pokemon_formCreateArgs<ExtArgs>>): Prisma__pokemon_formClient<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pokemon_forms.
     * @param {pokemon_formCreateManyArgs} args - Arguments to create many Pokemon_forms.
     * @example
     * // Create many Pokemon_forms
     * const pokemon_form = await prisma.pokemon_form.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pokemon_formCreateManyArgs>(args?: SelectSubset<T, pokemon_formCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pokemon_form.
     * @param {pokemon_formDeleteArgs} args - Arguments to delete one Pokemon_form.
     * @example
     * // Delete one Pokemon_form
     * const Pokemon_form = await prisma.pokemon_form.delete({
     *   where: {
     *     // ... filter to delete one Pokemon_form
     *   }
     * })
     * 
     */
    delete<T extends pokemon_formDeleteArgs>(args: SelectSubset<T, pokemon_formDeleteArgs<ExtArgs>>): Prisma__pokemon_formClient<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pokemon_form.
     * @param {pokemon_formUpdateArgs} args - Arguments to update one Pokemon_form.
     * @example
     * // Update one Pokemon_form
     * const pokemon_form = await prisma.pokemon_form.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pokemon_formUpdateArgs>(args: SelectSubset<T, pokemon_formUpdateArgs<ExtArgs>>): Prisma__pokemon_formClient<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pokemon_forms.
     * @param {pokemon_formDeleteManyArgs} args - Arguments to filter Pokemon_forms to delete.
     * @example
     * // Delete a few Pokemon_forms
     * const { count } = await prisma.pokemon_form.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pokemon_formDeleteManyArgs>(args?: SelectSubset<T, pokemon_formDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pokemon_forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_formUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pokemon_forms
     * const pokemon_form = await prisma.pokemon_form.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pokemon_formUpdateManyArgs>(args: SelectSubset<T, pokemon_formUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pokemon_form.
     * @param {pokemon_formUpsertArgs} args - Arguments to update or create a Pokemon_form.
     * @example
     * // Update or create a Pokemon_form
     * const pokemon_form = await prisma.pokemon_form.upsert({
     *   create: {
     *     // ... data to create a Pokemon_form
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pokemon_form we want to update
     *   }
     * })
     */
    upsert<T extends pokemon_formUpsertArgs>(args: SelectSubset<T, pokemon_formUpsertArgs<ExtArgs>>): Prisma__pokemon_formClient<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pokemon_forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_formCountArgs} args - Arguments to filter Pokemon_forms to count.
     * @example
     * // Count the number of Pokemon_forms
     * const count = await prisma.pokemon_form.count({
     *   where: {
     *     // ... the filter for the Pokemon_forms we want to count
     *   }
     * })
    **/
    count<T extends pokemon_formCountArgs>(
      args?: Subset<T, pokemon_formCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pokemon_formCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pokemon_form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pokemon_formAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pokemon_formAggregateArgs>(args: Subset<T, Pokemon_formAggregateArgs>): Prisma.PrismaPromise<GetPokemon_formAggregateType<T>>

    /**
     * Group by Pokemon_form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_formGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pokemon_formGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pokemon_formGroupByArgs['orderBy'] }
        : { orderBy?: pokemon_formGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pokemon_formGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemon_formGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pokemon_form model
   */
  readonly fields: pokemon_formFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pokemon_form.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pokemon_formClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evolutionEnds<T extends pokemon_form$evolutionEndsArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_form$evolutionEndsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$evolutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evolutionStarts<T extends pokemon_form$evolutionStartsArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_form$evolutionStartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$evolutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedPokemons<T extends pokemon_form$ownedPokemonsArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_form$ownedPokemonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$owned_pokemonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    form<T extends formDefaultArgs<ExtArgs> = {}>(args?: Subset<T, formDefaultArgs<ExtArgs>>): Prisma__formClient<$Result.GetResult<Prisma.$formPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemon<T extends pokemonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemonDefaultArgs<ExtArgs>>): Prisma__pokemonClient<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemonFormGenders<T extends pokemon_form$pokemonFormGendersArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_form$pokemonFormGendersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_form_genderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pokemonRatingGames<T extends pokemon_form$pokemonRatingGamesArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_form$pokemonRatingGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_game_locationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pokemon_form model
   */
  interface pokemon_formFieldRefs {
    readonly pokemonId: FieldRef<"pokemon_form", 'Int'>
    readonly formId: FieldRef<"pokemon_form", 'Int'>
    readonly createdAt: FieldRef<"pokemon_form", 'DateTime'>
    readonly id: FieldRef<"pokemon_form", 'Int'>
    readonly status: FieldRef<"pokemon_form", 'String'>
    readonly updatedAt: FieldRef<"pokemon_form", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pokemon_form findUnique
   */
  export type pokemon_formFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form
     */
    select?: pokemon_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form
     */
    omit?: pokemon_formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_formInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_form to fetch.
     */
    where: pokemon_formWhereUniqueInput
  }

  /**
   * pokemon_form findUniqueOrThrow
   */
  export type pokemon_formFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form
     */
    select?: pokemon_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form
     */
    omit?: pokemon_formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_formInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_form to fetch.
     */
    where: pokemon_formWhereUniqueInput
  }

  /**
   * pokemon_form findFirst
   */
  export type pokemon_formFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form
     */
    select?: pokemon_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form
     */
    omit?: pokemon_formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_formInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_form to fetch.
     */
    where?: pokemon_formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_forms to fetch.
     */
    orderBy?: pokemon_formOrderByWithRelationInput | pokemon_formOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokemon_forms.
     */
    cursor?: pokemon_formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokemon_forms.
     */
    distinct?: Pokemon_formScalarFieldEnum | Pokemon_formScalarFieldEnum[]
  }

  /**
   * pokemon_form findFirstOrThrow
   */
  export type pokemon_formFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form
     */
    select?: pokemon_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form
     */
    omit?: pokemon_formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_formInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_form to fetch.
     */
    where?: pokemon_formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_forms to fetch.
     */
    orderBy?: pokemon_formOrderByWithRelationInput | pokemon_formOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokemon_forms.
     */
    cursor?: pokemon_formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokemon_forms.
     */
    distinct?: Pokemon_formScalarFieldEnum | Pokemon_formScalarFieldEnum[]
  }

  /**
   * pokemon_form findMany
   */
  export type pokemon_formFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form
     */
    select?: pokemon_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form
     */
    omit?: pokemon_formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_formInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_forms to fetch.
     */
    where?: pokemon_formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_forms to fetch.
     */
    orderBy?: pokemon_formOrderByWithRelationInput | pokemon_formOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pokemon_forms.
     */
    cursor?: pokemon_formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_forms.
     */
    skip?: number
    distinct?: Pokemon_formScalarFieldEnum | Pokemon_formScalarFieldEnum[]
  }

  /**
   * pokemon_form create
   */
  export type pokemon_formCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form
     */
    select?: pokemon_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form
     */
    omit?: pokemon_formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_formInclude<ExtArgs> | null
    /**
     * The data needed to create a pokemon_form.
     */
    data: XOR<pokemon_formCreateInput, pokemon_formUncheckedCreateInput>
  }

  /**
   * pokemon_form createMany
   */
  export type pokemon_formCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pokemon_forms.
     */
    data: pokemon_formCreateManyInput | pokemon_formCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pokemon_form update
   */
  export type pokemon_formUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form
     */
    select?: pokemon_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form
     */
    omit?: pokemon_formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_formInclude<ExtArgs> | null
    /**
     * The data needed to update a pokemon_form.
     */
    data: XOR<pokemon_formUpdateInput, pokemon_formUncheckedUpdateInput>
    /**
     * Choose, which pokemon_form to update.
     */
    where: pokemon_formWhereUniqueInput
  }

  /**
   * pokemon_form updateMany
   */
  export type pokemon_formUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pokemon_forms.
     */
    data: XOR<pokemon_formUpdateManyMutationInput, pokemon_formUncheckedUpdateManyInput>
    /**
     * Filter which pokemon_forms to update
     */
    where?: pokemon_formWhereInput
    /**
     * Limit how many pokemon_forms to update.
     */
    limit?: number
  }

  /**
   * pokemon_form upsert
   */
  export type pokemon_formUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form
     */
    select?: pokemon_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form
     */
    omit?: pokemon_formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_formInclude<ExtArgs> | null
    /**
     * The filter to search for the pokemon_form to update in case it exists.
     */
    where: pokemon_formWhereUniqueInput
    /**
     * In case the pokemon_form found by the `where` argument doesn't exist, create a new pokemon_form with this data.
     */
    create: XOR<pokemon_formCreateInput, pokemon_formUncheckedCreateInput>
    /**
     * In case the pokemon_form was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pokemon_formUpdateInput, pokemon_formUncheckedUpdateInput>
  }

  /**
   * pokemon_form delete
   */
  export type pokemon_formDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form
     */
    select?: pokemon_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form
     */
    omit?: pokemon_formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_formInclude<ExtArgs> | null
    /**
     * Filter which pokemon_form to delete.
     */
    where: pokemon_formWhereUniqueInput
  }

  /**
   * pokemon_form deleteMany
   */
  export type pokemon_formDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokemon_forms to delete
     */
    where?: pokemon_formWhereInput
    /**
     * Limit how many pokemon_forms to delete.
     */
    limit?: number
  }

  /**
   * pokemon_form.evolutionEnds
   */
  export type pokemon_form$evolutionEndsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution
     */
    select?: evolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution
     */
    omit?: evolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolutionInclude<ExtArgs> | null
    where?: evolutionWhereInput
    orderBy?: evolutionOrderByWithRelationInput | evolutionOrderByWithRelationInput[]
    cursor?: evolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvolutionScalarFieldEnum | EvolutionScalarFieldEnum[]
  }

  /**
   * pokemon_form.evolutionStarts
   */
  export type pokemon_form$evolutionStartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution
     */
    select?: evolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution
     */
    omit?: evolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolutionInclude<ExtArgs> | null
    where?: evolutionWhereInput
    orderBy?: evolutionOrderByWithRelationInput | evolutionOrderByWithRelationInput[]
    cursor?: evolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvolutionScalarFieldEnum | EvolutionScalarFieldEnum[]
  }

  /**
   * pokemon_form.ownedPokemons
   */
  export type pokemon_form$ownedPokemonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon
     */
    select?: owned_pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon
     */
    omit?: owned_pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemonInclude<ExtArgs> | null
    where?: owned_pokemonWhereInput
    orderBy?: owned_pokemonOrderByWithRelationInput | owned_pokemonOrderByWithRelationInput[]
    cursor?: owned_pokemonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Owned_pokemonScalarFieldEnum | Owned_pokemonScalarFieldEnum[]
  }

  /**
   * pokemon_form.pokemonFormGenders
   */
  export type pokemon_form$pokemonFormGendersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form_gender
     */
    select?: pokemon_form_genderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form_gender
     */
    omit?: pokemon_form_genderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_form_genderInclude<ExtArgs> | null
    where?: pokemon_form_genderWhereInput
    orderBy?: pokemon_form_genderOrderByWithRelationInput | pokemon_form_genderOrderByWithRelationInput[]
    cursor?: pokemon_form_genderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pokemon_form_genderScalarFieldEnum | Pokemon_form_genderScalarFieldEnum[]
  }

  /**
   * pokemon_form.pokemonRatingGames
   */
  export type pokemon_form$pokemonRatingGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
    where?: pokemon_game_locationWhereInput
    orderBy?: pokemon_game_locationOrderByWithRelationInput | pokemon_game_locationOrderByWithRelationInput[]
    cursor?: pokemon_game_locationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pokemon_game_locationScalarFieldEnum | Pokemon_game_locationScalarFieldEnum[]
  }

  /**
   * pokemon_form without action
   */
  export type pokemon_formDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_form
     */
    select?: pokemon_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_form
     */
    omit?: pokemon_formOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_formInclude<ExtArgs> | null
  }


  /**
   * Model owned_pokemon
   */

  export type AggregateOwned_pokemon = {
    _count: Owned_pokemonCountAggregateOutputType | null
    _avg: Owned_pokemonAvgAggregateOutputType | null
    _sum: Owned_pokemonSumAggregateOutputType | null
    _min: Owned_pokemonMinAggregateOutputType | null
    _max: Owned_pokemonMaxAggregateOutputType | null
  }

  export type Owned_pokemonAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    pokemonFormId: number | null
    gameId: number | null
    methodId: number | null
    meetingNumber: number | null
  }

  export type Owned_pokemonSumAggregateOutputType = {
    id: bigint | null
    userId: number | null
    pokemonFormId: number | null
    gameId: number | null
    methodId: number | null
    meetingNumber: number | null
  }

  export type Owned_pokemonMinAggregateOutputType = {
    id: bigint | null
    userId: number | null
    pokemonFormId: number | null
    gameId: number | null
    isShiny: boolean | null
    methodId: number | null
    meetingNumber: number | null
    time: Date | null
    isFinish: boolean | null
    useCharmChroma: boolean | null
    creationDate: Date | null
    finishDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Owned_pokemonMaxAggregateOutputType = {
    id: bigint | null
    userId: number | null
    pokemonFormId: number | null
    gameId: number | null
    isShiny: boolean | null
    methodId: number | null
    meetingNumber: number | null
    time: Date | null
    isFinish: boolean | null
    useCharmChroma: boolean | null
    creationDate: Date | null
    finishDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Owned_pokemonCountAggregateOutputType = {
    id: number
    userId: number
    pokemonFormId: number
    gameId: number
    isShiny: number
    methodId: number
    meetingNumber: number
    time: number
    isFinish: number
    useCharmChroma: number
    creationDate: number
    finishDate: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Owned_pokemonAvgAggregateInputType = {
    id?: true
    userId?: true
    pokemonFormId?: true
    gameId?: true
    methodId?: true
    meetingNumber?: true
  }

  export type Owned_pokemonSumAggregateInputType = {
    id?: true
    userId?: true
    pokemonFormId?: true
    gameId?: true
    methodId?: true
    meetingNumber?: true
  }

  export type Owned_pokemonMinAggregateInputType = {
    id?: true
    userId?: true
    pokemonFormId?: true
    gameId?: true
    isShiny?: true
    methodId?: true
    meetingNumber?: true
    time?: true
    isFinish?: true
    useCharmChroma?: true
    creationDate?: true
    finishDate?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Owned_pokemonMaxAggregateInputType = {
    id?: true
    userId?: true
    pokemonFormId?: true
    gameId?: true
    isShiny?: true
    methodId?: true
    meetingNumber?: true
    time?: true
    isFinish?: true
    useCharmChroma?: true
    creationDate?: true
    finishDate?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Owned_pokemonCountAggregateInputType = {
    id?: true
    userId?: true
    pokemonFormId?: true
    gameId?: true
    isShiny?: true
    methodId?: true
    meetingNumber?: true
    time?: true
    isFinish?: true
    useCharmChroma?: true
    creationDate?: true
    finishDate?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Owned_pokemonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which owned_pokemon to aggregate.
     */
    where?: owned_pokemonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of owned_pokemon to fetch.
     */
    orderBy?: owned_pokemonOrderByWithRelationInput | owned_pokemonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: owned_pokemonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` owned_pokemon from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` owned_pokemon.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned owned_pokemon
    **/
    _count?: true | Owned_pokemonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Owned_pokemonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Owned_pokemonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Owned_pokemonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Owned_pokemonMaxAggregateInputType
  }

  export type GetOwned_pokemonAggregateType<T extends Owned_pokemonAggregateArgs> = {
        [P in keyof T & keyof AggregateOwned_pokemon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwned_pokemon[P]>
      : GetScalarType<T[P], AggregateOwned_pokemon[P]>
  }




  export type owned_pokemonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: owned_pokemonWhereInput
    orderBy?: owned_pokemonOrderByWithAggregationInput | owned_pokemonOrderByWithAggregationInput[]
    by: Owned_pokemonScalarFieldEnum[] | Owned_pokemonScalarFieldEnum
    having?: owned_pokemonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Owned_pokemonCountAggregateInputType | true
    _avg?: Owned_pokemonAvgAggregateInputType
    _sum?: Owned_pokemonSumAggregateInputType
    _min?: Owned_pokemonMinAggregateInputType
    _max?: Owned_pokemonMaxAggregateInputType
  }

  export type Owned_pokemonGroupByOutputType = {
    id: bigint
    userId: number
    pokemonFormId: number
    gameId: number
    isShiny: boolean
    methodId: number
    meetingNumber: number | null
    time: Date | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date
    finishDate: Date | null
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Owned_pokemonCountAggregateOutputType | null
    _avg: Owned_pokemonAvgAggregateOutputType | null
    _sum: Owned_pokemonSumAggregateOutputType | null
    _min: Owned_pokemonMinAggregateOutputType | null
    _max: Owned_pokemonMaxAggregateOutputType | null
  }

  type GetOwned_pokemonGroupByPayload<T extends owned_pokemonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Owned_pokemonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Owned_pokemonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Owned_pokemonGroupByOutputType[P]>
            : GetScalarType<T[P], Owned_pokemonGroupByOutputType[P]>
        }
      >
    >


  export type owned_pokemonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    pokemonFormId?: boolean
    gameId?: boolean
    isShiny?: boolean
    methodId?: boolean
    meetingNumber?: boolean
    time?: boolean
    isFinish?: boolean
    useCharmChroma?: boolean
    creationDate?: boolean
    finishDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    game?: boolean | gameDefaultArgs<ExtArgs>
    shinyHuntingMethod?: boolean | shiny_hunting_methodDefaultArgs<ExtArgs>
    pokemonForms?: boolean | pokemon_formDefaultArgs<ExtArgs>
    users?: boolean | userDefaultArgs<ExtArgs>
    ownedPokemonDetails?: boolean | owned_pokemon$ownedPokemonDetailsArgs<ExtArgs>
    _count?: boolean | Owned_pokemonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["owned_pokemon"]>



  export type owned_pokemonSelectScalar = {
    id?: boolean
    userId?: boolean
    pokemonFormId?: boolean
    gameId?: boolean
    isShiny?: boolean
    methodId?: boolean
    meetingNumber?: boolean
    time?: boolean
    isFinish?: boolean
    useCharmChroma?: boolean
    creationDate?: boolean
    finishDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type owned_pokemonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "pokemonFormId" | "gameId" | "isShiny" | "methodId" | "meetingNumber" | "time" | "isFinish" | "useCharmChroma" | "creationDate" | "finishDate" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["owned_pokemon"]>
  export type owned_pokemonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | gameDefaultArgs<ExtArgs>
    shinyHuntingMethod?: boolean | shiny_hunting_methodDefaultArgs<ExtArgs>
    pokemonForms?: boolean | pokemon_formDefaultArgs<ExtArgs>
    users?: boolean | userDefaultArgs<ExtArgs>
    ownedPokemonDetails?: boolean | owned_pokemon$ownedPokemonDetailsArgs<ExtArgs>
    _count?: boolean | Owned_pokemonCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $owned_pokemonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "owned_pokemon"
    objects: {
      game: Prisma.$gamePayload<ExtArgs>
      shinyHuntingMethod: Prisma.$shiny_hunting_methodPayload<ExtArgs>
      pokemonForms: Prisma.$pokemon_formPayload<ExtArgs>
      users: Prisma.$userPayload<ExtArgs>
      ownedPokemonDetails: Prisma.$owned_pokemon_detailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      userId: number
      pokemonFormId: number
      gameId: number
      isShiny: boolean
      methodId: number
      meetingNumber: number | null
      time: Date | null
      isFinish: boolean
      useCharmChroma: boolean
      creationDate: Date
      finishDate: Date | null
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["owned_pokemon"]>
    composites: {}
  }

  type owned_pokemonGetPayload<S extends boolean | null | undefined | owned_pokemonDefaultArgs> = $Result.GetResult<Prisma.$owned_pokemonPayload, S>

  type owned_pokemonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<owned_pokemonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Owned_pokemonCountAggregateInputType | true
    }

  export interface owned_pokemonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['owned_pokemon'], meta: { name: 'owned_pokemon' } }
    /**
     * Find zero or one Owned_pokemon that matches the filter.
     * @param {owned_pokemonFindUniqueArgs} args - Arguments to find a Owned_pokemon
     * @example
     * // Get one Owned_pokemon
     * const owned_pokemon = await prisma.owned_pokemon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends owned_pokemonFindUniqueArgs>(args: SelectSubset<T, owned_pokemonFindUniqueArgs<ExtArgs>>): Prisma__owned_pokemonClient<$Result.GetResult<Prisma.$owned_pokemonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Owned_pokemon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {owned_pokemonFindUniqueOrThrowArgs} args - Arguments to find a Owned_pokemon
     * @example
     * // Get one Owned_pokemon
     * const owned_pokemon = await prisma.owned_pokemon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends owned_pokemonFindUniqueOrThrowArgs>(args: SelectSubset<T, owned_pokemonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__owned_pokemonClient<$Result.GetResult<Prisma.$owned_pokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Owned_pokemon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {owned_pokemonFindFirstArgs} args - Arguments to find a Owned_pokemon
     * @example
     * // Get one Owned_pokemon
     * const owned_pokemon = await prisma.owned_pokemon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends owned_pokemonFindFirstArgs>(args?: SelectSubset<T, owned_pokemonFindFirstArgs<ExtArgs>>): Prisma__owned_pokemonClient<$Result.GetResult<Prisma.$owned_pokemonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Owned_pokemon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {owned_pokemonFindFirstOrThrowArgs} args - Arguments to find a Owned_pokemon
     * @example
     * // Get one Owned_pokemon
     * const owned_pokemon = await prisma.owned_pokemon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends owned_pokemonFindFirstOrThrowArgs>(args?: SelectSubset<T, owned_pokemonFindFirstOrThrowArgs<ExtArgs>>): Prisma__owned_pokemonClient<$Result.GetResult<Prisma.$owned_pokemonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Owned_pokemon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {owned_pokemonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Owned_pokemon
     * const owned_pokemon = await prisma.owned_pokemon.findMany()
     * 
     * // Get first 10 Owned_pokemon
     * const owned_pokemon = await prisma.owned_pokemon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const owned_pokemonWithIdOnly = await prisma.owned_pokemon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends owned_pokemonFindManyArgs>(args?: SelectSubset<T, owned_pokemonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$owned_pokemonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Owned_pokemon.
     * @param {owned_pokemonCreateArgs} args - Arguments to create a Owned_pokemon.
     * @example
     * // Create one Owned_pokemon
     * const Owned_pokemon = await prisma.owned_pokemon.create({
     *   data: {
     *     // ... data to create a Owned_pokemon
     *   }
     * })
     * 
     */
    create<T extends owned_pokemonCreateArgs>(args: SelectSubset<T, owned_pokemonCreateArgs<ExtArgs>>): Prisma__owned_pokemonClient<$Result.GetResult<Prisma.$owned_pokemonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Owned_pokemon.
     * @param {owned_pokemonCreateManyArgs} args - Arguments to create many Owned_pokemon.
     * @example
     * // Create many Owned_pokemon
     * const owned_pokemon = await prisma.owned_pokemon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends owned_pokemonCreateManyArgs>(args?: SelectSubset<T, owned_pokemonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Owned_pokemon.
     * @param {owned_pokemonDeleteArgs} args - Arguments to delete one Owned_pokemon.
     * @example
     * // Delete one Owned_pokemon
     * const Owned_pokemon = await prisma.owned_pokemon.delete({
     *   where: {
     *     // ... filter to delete one Owned_pokemon
     *   }
     * })
     * 
     */
    delete<T extends owned_pokemonDeleteArgs>(args: SelectSubset<T, owned_pokemonDeleteArgs<ExtArgs>>): Prisma__owned_pokemonClient<$Result.GetResult<Prisma.$owned_pokemonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Owned_pokemon.
     * @param {owned_pokemonUpdateArgs} args - Arguments to update one Owned_pokemon.
     * @example
     * // Update one Owned_pokemon
     * const owned_pokemon = await prisma.owned_pokemon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends owned_pokemonUpdateArgs>(args: SelectSubset<T, owned_pokemonUpdateArgs<ExtArgs>>): Prisma__owned_pokemonClient<$Result.GetResult<Prisma.$owned_pokemonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Owned_pokemon.
     * @param {owned_pokemonDeleteManyArgs} args - Arguments to filter Owned_pokemon to delete.
     * @example
     * // Delete a few Owned_pokemon
     * const { count } = await prisma.owned_pokemon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends owned_pokemonDeleteManyArgs>(args?: SelectSubset<T, owned_pokemonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Owned_pokemon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {owned_pokemonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Owned_pokemon
     * const owned_pokemon = await prisma.owned_pokemon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends owned_pokemonUpdateManyArgs>(args: SelectSubset<T, owned_pokemonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Owned_pokemon.
     * @param {owned_pokemonUpsertArgs} args - Arguments to update or create a Owned_pokemon.
     * @example
     * // Update or create a Owned_pokemon
     * const owned_pokemon = await prisma.owned_pokemon.upsert({
     *   create: {
     *     // ... data to create a Owned_pokemon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Owned_pokemon we want to update
     *   }
     * })
     */
    upsert<T extends owned_pokemonUpsertArgs>(args: SelectSubset<T, owned_pokemonUpsertArgs<ExtArgs>>): Prisma__owned_pokemonClient<$Result.GetResult<Prisma.$owned_pokemonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Owned_pokemon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {owned_pokemonCountArgs} args - Arguments to filter Owned_pokemon to count.
     * @example
     * // Count the number of Owned_pokemon
     * const count = await prisma.owned_pokemon.count({
     *   where: {
     *     // ... the filter for the Owned_pokemon we want to count
     *   }
     * })
    **/
    count<T extends owned_pokemonCountArgs>(
      args?: Subset<T, owned_pokemonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Owned_pokemonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Owned_pokemon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Owned_pokemonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Owned_pokemonAggregateArgs>(args: Subset<T, Owned_pokemonAggregateArgs>): Prisma.PrismaPromise<GetOwned_pokemonAggregateType<T>>

    /**
     * Group by Owned_pokemon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {owned_pokemonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends owned_pokemonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: owned_pokemonGroupByArgs['orderBy'] }
        : { orderBy?: owned_pokemonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, owned_pokemonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwned_pokemonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the owned_pokemon model
   */
  readonly fields: owned_pokemonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for owned_pokemon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__owned_pokemonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends gameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, gameDefaultArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shinyHuntingMethod<T extends shiny_hunting_methodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shiny_hunting_methodDefaultArgs<ExtArgs>>): Prisma__shiny_hunting_methodClient<$Result.GetResult<Prisma.$shiny_hunting_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemonForms<T extends pokemon_formDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_formDefaultArgs<ExtArgs>>): Prisma__pokemon_formClient<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ownedPokemonDetails<T extends owned_pokemon$ownedPokemonDetailsArgs<ExtArgs> = {}>(args?: Subset<T, owned_pokemon$ownedPokemonDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$owned_pokemon_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the owned_pokemon model
   */
  interface owned_pokemonFieldRefs {
    readonly id: FieldRef<"owned_pokemon", 'BigInt'>
    readonly userId: FieldRef<"owned_pokemon", 'Int'>
    readonly pokemonFormId: FieldRef<"owned_pokemon", 'Int'>
    readonly gameId: FieldRef<"owned_pokemon", 'Int'>
    readonly isShiny: FieldRef<"owned_pokemon", 'Boolean'>
    readonly methodId: FieldRef<"owned_pokemon", 'Int'>
    readonly meetingNumber: FieldRef<"owned_pokemon", 'Int'>
    readonly time: FieldRef<"owned_pokemon", 'DateTime'>
    readonly isFinish: FieldRef<"owned_pokemon", 'Boolean'>
    readonly useCharmChroma: FieldRef<"owned_pokemon", 'Boolean'>
    readonly creationDate: FieldRef<"owned_pokemon", 'DateTime'>
    readonly finishDate: FieldRef<"owned_pokemon", 'DateTime'>
    readonly createdAt: FieldRef<"owned_pokemon", 'DateTime'>
    readonly updatedAt: FieldRef<"owned_pokemon", 'DateTime'>
    readonly status: FieldRef<"owned_pokemon", 'String'>
  }
    

  // Custom InputTypes
  /**
   * owned_pokemon findUnique
   */
  export type owned_pokemonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon
     */
    select?: owned_pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon
     */
    omit?: owned_pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemonInclude<ExtArgs> | null
    /**
     * Filter, which owned_pokemon to fetch.
     */
    where: owned_pokemonWhereUniqueInput
  }

  /**
   * owned_pokemon findUniqueOrThrow
   */
  export type owned_pokemonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon
     */
    select?: owned_pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon
     */
    omit?: owned_pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemonInclude<ExtArgs> | null
    /**
     * Filter, which owned_pokemon to fetch.
     */
    where: owned_pokemonWhereUniqueInput
  }

  /**
   * owned_pokemon findFirst
   */
  export type owned_pokemonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon
     */
    select?: owned_pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon
     */
    omit?: owned_pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemonInclude<ExtArgs> | null
    /**
     * Filter, which owned_pokemon to fetch.
     */
    where?: owned_pokemonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of owned_pokemon to fetch.
     */
    orderBy?: owned_pokemonOrderByWithRelationInput | owned_pokemonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for owned_pokemon.
     */
    cursor?: owned_pokemonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` owned_pokemon from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` owned_pokemon.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of owned_pokemon.
     */
    distinct?: Owned_pokemonScalarFieldEnum | Owned_pokemonScalarFieldEnum[]
  }

  /**
   * owned_pokemon findFirstOrThrow
   */
  export type owned_pokemonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon
     */
    select?: owned_pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon
     */
    omit?: owned_pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemonInclude<ExtArgs> | null
    /**
     * Filter, which owned_pokemon to fetch.
     */
    where?: owned_pokemonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of owned_pokemon to fetch.
     */
    orderBy?: owned_pokemonOrderByWithRelationInput | owned_pokemonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for owned_pokemon.
     */
    cursor?: owned_pokemonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` owned_pokemon from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` owned_pokemon.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of owned_pokemon.
     */
    distinct?: Owned_pokemonScalarFieldEnum | Owned_pokemonScalarFieldEnum[]
  }

  /**
   * owned_pokemon findMany
   */
  export type owned_pokemonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon
     */
    select?: owned_pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon
     */
    omit?: owned_pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemonInclude<ExtArgs> | null
    /**
     * Filter, which owned_pokemon to fetch.
     */
    where?: owned_pokemonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of owned_pokemon to fetch.
     */
    orderBy?: owned_pokemonOrderByWithRelationInput | owned_pokemonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing owned_pokemon.
     */
    cursor?: owned_pokemonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` owned_pokemon from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` owned_pokemon.
     */
    skip?: number
    distinct?: Owned_pokemonScalarFieldEnum | Owned_pokemonScalarFieldEnum[]
  }

  /**
   * owned_pokemon create
   */
  export type owned_pokemonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon
     */
    select?: owned_pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon
     */
    omit?: owned_pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemonInclude<ExtArgs> | null
    /**
     * The data needed to create a owned_pokemon.
     */
    data: XOR<owned_pokemonCreateInput, owned_pokemonUncheckedCreateInput>
  }

  /**
   * owned_pokemon createMany
   */
  export type owned_pokemonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many owned_pokemon.
     */
    data: owned_pokemonCreateManyInput | owned_pokemonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * owned_pokemon update
   */
  export type owned_pokemonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon
     */
    select?: owned_pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon
     */
    omit?: owned_pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemonInclude<ExtArgs> | null
    /**
     * The data needed to update a owned_pokemon.
     */
    data: XOR<owned_pokemonUpdateInput, owned_pokemonUncheckedUpdateInput>
    /**
     * Choose, which owned_pokemon to update.
     */
    where: owned_pokemonWhereUniqueInput
  }

  /**
   * owned_pokemon updateMany
   */
  export type owned_pokemonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update owned_pokemon.
     */
    data: XOR<owned_pokemonUpdateManyMutationInput, owned_pokemonUncheckedUpdateManyInput>
    /**
     * Filter which owned_pokemon to update
     */
    where?: owned_pokemonWhereInput
    /**
     * Limit how many owned_pokemon to update.
     */
    limit?: number
  }

  /**
   * owned_pokemon upsert
   */
  export type owned_pokemonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon
     */
    select?: owned_pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon
     */
    omit?: owned_pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemonInclude<ExtArgs> | null
    /**
     * The filter to search for the owned_pokemon to update in case it exists.
     */
    where: owned_pokemonWhereUniqueInput
    /**
     * In case the owned_pokemon found by the `where` argument doesn't exist, create a new owned_pokemon with this data.
     */
    create: XOR<owned_pokemonCreateInput, owned_pokemonUncheckedCreateInput>
    /**
     * In case the owned_pokemon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<owned_pokemonUpdateInput, owned_pokemonUncheckedUpdateInput>
  }

  /**
   * owned_pokemon delete
   */
  export type owned_pokemonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon
     */
    select?: owned_pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon
     */
    omit?: owned_pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemonInclude<ExtArgs> | null
    /**
     * Filter which owned_pokemon to delete.
     */
    where: owned_pokemonWhereUniqueInput
  }

  /**
   * owned_pokemon deleteMany
   */
  export type owned_pokemonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which owned_pokemon to delete
     */
    where?: owned_pokemonWhereInput
    /**
     * Limit how many owned_pokemon to delete.
     */
    limit?: number
  }

  /**
   * owned_pokemon.ownedPokemonDetails
   */
  export type owned_pokemon$ownedPokemonDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon_detail
     */
    select?: owned_pokemon_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon_detail
     */
    omit?: owned_pokemon_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemon_detailInclude<ExtArgs> | null
    where?: owned_pokemon_detailWhereInput
    orderBy?: owned_pokemon_detailOrderByWithRelationInput | owned_pokemon_detailOrderByWithRelationInput[]
    cursor?: owned_pokemon_detailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Owned_pokemon_detailScalarFieldEnum | Owned_pokemon_detailScalarFieldEnum[]
  }

  /**
   * owned_pokemon without action
   */
  export type owned_pokemonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon
     */
    select?: owned_pokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon
     */
    omit?: owned_pokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemonInclude<ExtArgs> | null
  }


  /**
   * Model owned_pokemon_detail
   */

  export type AggregateOwned_pokemon_detail = {
    _count: Owned_pokemon_detailCountAggregateOutputType | null
    _avg: Owned_pokemon_detailAvgAggregateOutputType | null
    _sum: Owned_pokemon_detailSumAggregateOutputType | null
    _min: Owned_pokemon_detailMinAggregateOutputType | null
    _max: Owned_pokemon_detailMaxAggregateOutputType | null
  }

  export type Owned_pokemon_detailAvgAggregateOutputType = {
    id: number | null
    pokeballId: number | null
    ownedPokemonId: number | null
  }

  export type Owned_pokemon_detailSumAggregateOutputType = {
    id: bigint | null
    pokeballId: number | null
    ownedPokemonId: bigint | null
  }

  export type Owned_pokemon_detailMinAggregateOutputType = {
    id: bigint | null
    nickname: string | null
    pokeballId: number | null
    ownedPokemonId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Owned_pokemon_detailMaxAggregateOutputType = {
    id: bigint | null
    nickname: string | null
    pokeballId: number | null
    ownedPokemonId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Owned_pokemon_detailCountAggregateOutputType = {
    id: number
    nickname: number
    pokeballId: number
    ownedPokemonId: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Owned_pokemon_detailAvgAggregateInputType = {
    id?: true
    pokeballId?: true
    ownedPokemonId?: true
  }

  export type Owned_pokemon_detailSumAggregateInputType = {
    id?: true
    pokeballId?: true
    ownedPokemonId?: true
  }

  export type Owned_pokemon_detailMinAggregateInputType = {
    id?: true
    nickname?: true
    pokeballId?: true
    ownedPokemonId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Owned_pokemon_detailMaxAggregateInputType = {
    id?: true
    nickname?: true
    pokeballId?: true
    ownedPokemonId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Owned_pokemon_detailCountAggregateInputType = {
    id?: true
    nickname?: true
    pokeballId?: true
    ownedPokemonId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Owned_pokemon_detailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which owned_pokemon_detail to aggregate.
     */
    where?: owned_pokemon_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of owned_pokemon_details to fetch.
     */
    orderBy?: owned_pokemon_detailOrderByWithRelationInput | owned_pokemon_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: owned_pokemon_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` owned_pokemon_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` owned_pokemon_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned owned_pokemon_details
    **/
    _count?: true | Owned_pokemon_detailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Owned_pokemon_detailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Owned_pokemon_detailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Owned_pokemon_detailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Owned_pokemon_detailMaxAggregateInputType
  }

  export type GetOwned_pokemon_detailAggregateType<T extends Owned_pokemon_detailAggregateArgs> = {
        [P in keyof T & keyof AggregateOwned_pokemon_detail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwned_pokemon_detail[P]>
      : GetScalarType<T[P], AggregateOwned_pokemon_detail[P]>
  }




  export type owned_pokemon_detailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: owned_pokemon_detailWhereInput
    orderBy?: owned_pokemon_detailOrderByWithAggregationInput | owned_pokemon_detailOrderByWithAggregationInput[]
    by: Owned_pokemon_detailScalarFieldEnum[] | Owned_pokemon_detailScalarFieldEnum
    having?: owned_pokemon_detailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Owned_pokemon_detailCountAggregateInputType | true
    _avg?: Owned_pokemon_detailAvgAggregateInputType
    _sum?: Owned_pokemon_detailSumAggregateInputType
    _min?: Owned_pokemon_detailMinAggregateInputType
    _max?: Owned_pokemon_detailMaxAggregateInputType
  }

  export type Owned_pokemon_detailGroupByOutputType = {
    id: bigint
    nickname: string
    pokeballId: number
    ownedPokemonId: bigint
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Owned_pokemon_detailCountAggregateOutputType | null
    _avg: Owned_pokemon_detailAvgAggregateOutputType | null
    _sum: Owned_pokemon_detailSumAggregateOutputType | null
    _min: Owned_pokemon_detailMinAggregateOutputType | null
    _max: Owned_pokemon_detailMaxAggregateOutputType | null
  }

  type GetOwned_pokemon_detailGroupByPayload<T extends owned_pokemon_detailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Owned_pokemon_detailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Owned_pokemon_detailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Owned_pokemon_detailGroupByOutputType[P]>
            : GetScalarType<T[P], Owned_pokemon_detailGroupByOutputType[P]>
        }
      >
    >


  export type owned_pokemon_detailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nickname?: boolean
    pokeballId?: boolean
    ownedPokemonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    ownedPokemon?: boolean | owned_pokemonDefaultArgs<ExtArgs>
    pokeball?: boolean | pokeballDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["owned_pokemon_detail"]>



  export type owned_pokemon_detailSelectScalar = {
    id?: boolean
    nickname?: boolean
    pokeballId?: boolean
    ownedPokemonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type owned_pokemon_detailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nickname" | "pokeballId" | "ownedPokemonId" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["owned_pokemon_detail"]>
  export type owned_pokemon_detailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedPokemon?: boolean | owned_pokemonDefaultArgs<ExtArgs>
    pokeball?: boolean | pokeballDefaultArgs<ExtArgs>
  }

  export type $owned_pokemon_detailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "owned_pokemon_detail"
    objects: {
      ownedPokemon: Prisma.$owned_pokemonPayload<ExtArgs>
      pokeball: Prisma.$pokeballPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      nickname: string
      pokeballId: number
      ownedPokemonId: bigint
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["owned_pokemon_detail"]>
    composites: {}
  }

  type owned_pokemon_detailGetPayload<S extends boolean | null | undefined | owned_pokemon_detailDefaultArgs> = $Result.GetResult<Prisma.$owned_pokemon_detailPayload, S>

  type owned_pokemon_detailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<owned_pokemon_detailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Owned_pokemon_detailCountAggregateInputType | true
    }

  export interface owned_pokemon_detailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['owned_pokemon_detail'], meta: { name: 'owned_pokemon_detail' } }
    /**
     * Find zero or one Owned_pokemon_detail that matches the filter.
     * @param {owned_pokemon_detailFindUniqueArgs} args - Arguments to find a Owned_pokemon_detail
     * @example
     * // Get one Owned_pokemon_detail
     * const owned_pokemon_detail = await prisma.owned_pokemon_detail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends owned_pokemon_detailFindUniqueArgs>(args: SelectSubset<T, owned_pokemon_detailFindUniqueArgs<ExtArgs>>): Prisma__owned_pokemon_detailClient<$Result.GetResult<Prisma.$owned_pokemon_detailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Owned_pokemon_detail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {owned_pokemon_detailFindUniqueOrThrowArgs} args - Arguments to find a Owned_pokemon_detail
     * @example
     * // Get one Owned_pokemon_detail
     * const owned_pokemon_detail = await prisma.owned_pokemon_detail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends owned_pokemon_detailFindUniqueOrThrowArgs>(args: SelectSubset<T, owned_pokemon_detailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__owned_pokemon_detailClient<$Result.GetResult<Prisma.$owned_pokemon_detailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Owned_pokemon_detail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {owned_pokemon_detailFindFirstArgs} args - Arguments to find a Owned_pokemon_detail
     * @example
     * // Get one Owned_pokemon_detail
     * const owned_pokemon_detail = await prisma.owned_pokemon_detail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends owned_pokemon_detailFindFirstArgs>(args?: SelectSubset<T, owned_pokemon_detailFindFirstArgs<ExtArgs>>): Prisma__owned_pokemon_detailClient<$Result.GetResult<Prisma.$owned_pokemon_detailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Owned_pokemon_detail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {owned_pokemon_detailFindFirstOrThrowArgs} args - Arguments to find a Owned_pokemon_detail
     * @example
     * // Get one Owned_pokemon_detail
     * const owned_pokemon_detail = await prisma.owned_pokemon_detail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends owned_pokemon_detailFindFirstOrThrowArgs>(args?: SelectSubset<T, owned_pokemon_detailFindFirstOrThrowArgs<ExtArgs>>): Prisma__owned_pokemon_detailClient<$Result.GetResult<Prisma.$owned_pokemon_detailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Owned_pokemon_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {owned_pokemon_detailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Owned_pokemon_details
     * const owned_pokemon_details = await prisma.owned_pokemon_detail.findMany()
     * 
     * // Get first 10 Owned_pokemon_details
     * const owned_pokemon_details = await prisma.owned_pokemon_detail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const owned_pokemon_detailWithIdOnly = await prisma.owned_pokemon_detail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends owned_pokemon_detailFindManyArgs>(args?: SelectSubset<T, owned_pokemon_detailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$owned_pokemon_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Owned_pokemon_detail.
     * @param {owned_pokemon_detailCreateArgs} args - Arguments to create a Owned_pokemon_detail.
     * @example
     * // Create one Owned_pokemon_detail
     * const Owned_pokemon_detail = await prisma.owned_pokemon_detail.create({
     *   data: {
     *     // ... data to create a Owned_pokemon_detail
     *   }
     * })
     * 
     */
    create<T extends owned_pokemon_detailCreateArgs>(args: SelectSubset<T, owned_pokemon_detailCreateArgs<ExtArgs>>): Prisma__owned_pokemon_detailClient<$Result.GetResult<Prisma.$owned_pokemon_detailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Owned_pokemon_details.
     * @param {owned_pokemon_detailCreateManyArgs} args - Arguments to create many Owned_pokemon_details.
     * @example
     * // Create many Owned_pokemon_details
     * const owned_pokemon_detail = await prisma.owned_pokemon_detail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends owned_pokemon_detailCreateManyArgs>(args?: SelectSubset<T, owned_pokemon_detailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Owned_pokemon_detail.
     * @param {owned_pokemon_detailDeleteArgs} args - Arguments to delete one Owned_pokemon_detail.
     * @example
     * // Delete one Owned_pokemon_detail
     * const Owned_pokemon_detail = await prisma.owned_pokemon_detail.delete({
     *   where: {
     *     // ... filter to delete one Owned_pokemon_detail
     *   }
     * })
     * 
     */
    delete<T extends owned_pokemon_detailDeleteArgs>(args: SelectSubset<T, owned_pokemon_detailDeleteArgs<ExtArgs>>): Prisma__owned_pokemon_detailClient<$Result.GetResult<Prisma.$owned_pokemon_detailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Owned_pokemon_detail.
     * @param {owned_pokemon_detailUpdateArgs} args - Arguments to update one Owned_pokemon_detail.
     * @example
     * // Update one Owned_pokemon_detail
     * const owned_pokemon_detail = await prisma.owned_pokemon_detail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends owned_pokemon_detailUpdateArgs>(args: SelectSubset<T, owned_pokemon_detailUpdateArgs<ExtArgs>>): Prisma__owned_pokemon_detailClient<$Result.GetResult<Prisma.$owned_pokemon_detailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Owned_pokemon_details.
     * @param {owned_pokemon_detailDeleteManyArgs} args - Arguments to filter Owned_pokemon_details to delete.
     * @example
     * // Delete a few Owned_pokemon_details
     * const { count } = await prisma.owned_pokemon_detail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends owned_pokemon_detailDeleteManyArgs>(args?: SelectSubset<T, owned_pokemon_detailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Owned_pokemon_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {owned_pokemon_detailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Owned_pokemon_details
     * const owned_pokemon_detail = await prisma.owned_pokemon_detail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends owned_pokemon_detailUpdateManyArgs>(args: SelectSubset<T, owned_pokemon_detailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Owned_pokemon_detail.
     * @param {owned_pokemon_detailUpsertArgs} args - Arguments to update or create a Owned_pokemon_detail.
     * @example
     * // Update or create a Owned_pokemon_detail
     * const owned_pokemon_detail = await prisma.owned_pokemon_detail.upsert({
     *   create: {
     *     // ... data to create a Owned_pokemon_detail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Owned_pokemon_detail we want to update
     *   }
     * })
     */
    upsert<T extends owned_pokemon_detailUpsertArgs>(args: SelectSubset<T, owned_pokemon_detailUpsertArgs<ExtArgs>>): Prisma__owned_pokemon_detailClient<$Result.GetResult<Prisma.$owned_pokemon_detailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Owned_pokemon_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {owned_pokemon_detailCountArgs} args - Arguments to filter Owned_pokemon_details to count.
     * @example
     * // Count the number of Owned_pokemon_details
     * const count = await prisma.owned_pokemon_detail.count({
     *   where: {
     *     // ... the filter for the Owned_pokemon_details we want to count
     *   }
     * })
    **/
    count<T extends owned_pokemon_detailCountArgs>(
      args?: Subset<T, owned_pokemon_detailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Owned_pokemon_detailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Owned_pokemon_detail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Owned_pokemon_detailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Owned_pokemon_detailAggregateArgs>(args: Subset<T, Owned_pokemon_detailAggregateArgs>): Prisma.PrismaPromise<GetOwned_pokemon_detailAggregateType<T>>

    /**
     * Group by Owned_pokemon_detail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {owned_pokemon_detailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends owned_pokemon_detailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: owned_pokemon_detailGroupByArgs['orderBy'] }
        : { orderBy?: owned_pokemon_detailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, owned_pokemon_detailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwned_pokemon_detailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the owned_pokemon_detail model
   */
  readonly fields: owned_pokemon_detailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for owned_pokemon_detail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__owned_pokemon_detailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ownedPokemon<T extends owned_pokemonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, owned_pokemonDefaultArgs<ExtArgs>>): Prisma__owned_pokemonClient<$Result.GetResult<Prisma.$owned_pokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokeball<T extends pokeballDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokeballDefaultArgs<ExtArgs>>): Prisma__pokeballClient<$Result.GetResult<Prisma.$pokeballPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the owned_pokemon_detail model
   */
  interface owned_pokemon_detailFieldRefs {
    readonly id: FieldRef<"owned_pokemon_detail", 'BigInt'>
    readonly nickname: FieldRef<"owned_pokemon_detail", 'String'>
    readonly pokeballId: FieldRef<"owned_pokemon_detail", 'Int'>
    readonly ownedPokemonId: FieldRef<"owned_pokemon_detail", 'BigInt'>
    readonly createdAt: FieldRef<"owned_pokemon_detail", 'DateTime'>
    readonly updatedAt: FieldRef<"owned_pokemon_detail", 'DateTime'>
    readonly status: FieldRef<"owned_pokemon_detail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * owned_pokemon_detail findUnique
   */
  export type owned_pokemon_detailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon_detail
     */
    select?: owned_pokemon_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon_detail
     */
    omit?: owned_pokemon_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemon_detailInclude<ExtArgs> | null
    /**
     * Filter, which owned_pokemon_detail to fetch.
     */
    where: owned_pokemon_detailWhereUniqueInput
  }

  /**
   * owned_pokemon_detail findUniqueOrThrow
   */
  export type owned_pokemon_detailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon_detail
     */
    select?: owned_pokemon_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon_detail
     */
    omit?: owned_pokemon_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemon_detailInclude<ExtArgs> | null
    /**
     * Filter, which owned_pokemon_detail to fetch.
     */
    where: owned_pokemon_detailWhereUniqueInput
  }

  /**
   * owned_pokemon_detail findFirst
   */
  export type owned_pokemon_detailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon_detail
     */
    select?: owned_pokemon_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon_detail
     */
    omit?: owned_pokemon_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemon_detailInclude<ExtArgs> | null
    /**
     * Filter, which owned_pokemon_detail to fetch.
     */
    where?: owned_pokemon_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of owned_pokemon_details to fetch.
     */
    orderBy?: owned_pokemon_detailOrderByWithRelationInput | owned_pokemon_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for owned_pokemon_details.
     */
    cursor?: owned_pokemon_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` owned_pokemon_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` owned_pokemon_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of owned_pokemon_details.
     */
    distinct?: Owned_pokemon_detailScalarFieldEnum | Owned_pokemon_detailScalarFieldEnum[]
  }

  /**
   * owned_pokemon_detail findFirstOrThrow
   */
  export type owned_pokemon_detailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon_detail
     */
    select?: owned_pokemon_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon_detail
     */
    omit?: owned_pokemon_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemon_detailInclude<ExtArgs> | null
    /**
     * Filter, which owned_pokemon_detail to fetch.
     */
    where?: owned_pokemon_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of owned_pokemon_details to fetch.
     */
    orderBy?: owned_pokemon_detailOrderByWithRelationInput | owned_pokemon_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for owned_pokemon_details.
     */
    cursor?: owned_pokemon_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` owned_pokemon_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` owned_pokemon_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of owned_pokemon_details.
     */
    distinct?: Owned_pokemon_detailScalarFieldEnum | Owned_pokemon_detailScalarFieldEnum[]
  }

  /**
   * owned_pokemon_detail findMany
   */
  export type owned_pokemon_detailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon_detail
     */
    select?: owned_pokemon_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon_detail
     */
    omit?: owned_pokemon_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemon_detailInclude<ExtArgs> | null
    /**
     * Filter, which owned_pokemon_details to fetch.
     */
    where?: owned_pokemon_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of owned_pokemon_details to fetch.
     */
    orderBy?: owned_pokemon_detailOrderByWithRelationInput | owned_pokemon_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing owned_pokemon_details.
     */
    cursor?: owned_pokemon_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` owned_pokemon_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` owned_pokemon_details.
     */
    skip?: number
    distinct?: Owned_pokemon_detailScalarFieldEnum | Owned_pokemon_detailScalarFieldEnum[]
  }

  /**
   * owned_pokemon_detail create
   */
  export type owned_pokemon_detailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon_detail
     */
    select?: owned_pokemon_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon_detail
     */
    omit?: owned_pokemon_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemon_detailInclude<ExtArgs> | null
    /**
     * The data needed to create a owned_pokemon_detail.
     */
    data: XOR<owned_pokemon_detailCreateInput, owned_pokemon_detailUncheckedCreateInput>
  }

  /**
   * owned_pokemon_detail createMany
   */
  export type owned_pokemon_detailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many owned_pokemon_details.
     */
    data: owned_pokemon_detailCreateManyInput | owned_pokemon_detailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * owned_pokemon_detail update
   */
  export type owned_pokemon_detailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon_detail
     */
    select?: owned_pokemon_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon_detail
     */
    omit?: owned_pokemon_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemon_detailInclude<ExtArgs> | null
    /**
     * The data needed to update a owned_pokemon_detail.
     */
    data: XOR<owned_pokemon_detailUpdateInput, owned_pokemon_detailUncheckedUpdateInput>
    /**
     * Choose, which owned_pokemon_detail to update.
     */
    where: owned_pokemon_detailWhereUniqueInput
  }

  /**
   * owned_pokemon_detail updateMany
   */
  export type owned_pokemon_detailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update owned_pokemon_details.
     */
    data: XOR<owned_pokemon_detailUpdateManyMutationInput, owned_pokemon_detailUncheckedUpdateManyInput>
    /**
     * Filter which owned_pokemon_details to update
     */
    where?: owned_pokemon_detailWhereInput
    /**
     * Limit how many owned_pokemon_details to update.
     */
    limit?: number
  }

  /**
   * owned_pokemon_detail upsert
   */
  export type owned_pokemon_detailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon_detail
     */
    select?: owned_pokemon_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon_detail
     */
    omit?: owned_pokemon_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemon_detailInclude<ExtArgs> | null
    /**
     * The filter to search for the owned_pokemon_detail to update in case it exists.
     */
    where: owned_pokemon_detailWhereUniqueInput
    /**
     * In case the owned_pokemon_detail found by the `where` argument doesn't exist, create a new owned_pokemon_detail with this data.
     */
    create: XOR<owned_pokemon_detailCreateInput, owned_pokemon_detailUncheckedCreateInput>
    /**
     * In case the owned_pokemon_detail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<owned_pokemon_detailUpdateInput, owned_pokemon_detailUncheckedUpdateInput>
  }

  /**
   * owned_pokemon_detail delete
   */
  export type owned_pokemon_detailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon_detail
     */
    select?: owned_pokemon_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon_detail
     */
    omit?: owned_pokemon_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemon_detailInclude<ExtArgs> | null
    /**
     * Filter which owned_pokemon_detail to delete.
     */
    where: owned_pokemon_detailWhereUniqueInput
  }

  /**
   * owned_pokemon_detail deleteMany
   */
  export type owned_pokemon_detailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which owned_pokemon_details to delete
     */
    where?: owned_pokemon_detailWhereInput
    /**
     * Limit how many owned_pokemon_details to delete.
     */
    limit?: number
  }

  /**
   * owned_pokemon_detail without action
   */
  export type owned_pokemon_detailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owned_pokemon_detail
     */
    select?: owned_pokemon_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the owned_pokemon_detail
     */
    omit?: owned_pokemon_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: owned_pokemon_detailInclude<ExtArgs> | null
  }


  /**
   * Model ability
   */

  export type AggregateAbility = {
    _count: AbilityCountAggregateOutputType | null
    _avg: AbilityAvgAggregateOutputType | null
    _sum: AbilitySumAggregateOutputType | null
    _min: AbilityMinAggregateOutputType | null
    _max: AbilityMaxAggregateOutputType | null
  }

  export type AbilityAvgAggregateOutputType = {
    id: number | null
    appearanceGenerationId: number | null
  }

  export type AbilitySumAggregateOutputType = {
    id: number | null
    appearanceGenerationId: number | null
  }

  export type AbilityMinAggregateOutputType = {
    id: number | null
    appearanceGenerationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type AbilityMaxAggregateOutputType = {
    id: number | null
    appearanceGenerationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type AbilityCountAggregateOutputType = {
    id: number
    appearanceGenerationId: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type AbilityAvgAggregateInputType = {
    id?: true
    appearanceGenerationId?: true
  }

  export type AbilitySumAggregateInputType = {
    id?: true
    appearanceGenerationId?: true
  }

  export type AbilityMinAggregateInputType = {
    id?: true
    appearanceGenerationId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type AbilityMaxAggregateInputType = {
    id?: true
    appearanceGenerationId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type AbilityCountAggregateInputType = {
    id?: true
    appearanceGenerationId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type AbilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ability to aggregate.
     */
    where?: abilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abilities to fetch.
     */
    orderBy?: abilityOrderByWithRelationInput | abilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: abilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned abilities
    **/
    _count?: true | AbilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbilityMaxAggregateInputType
  }

  export type GetAbilityAggregateType<T extends AbilityAggregateArgs> = {
        [P in keyof T & keyof AggregateAbility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbility[P]>
      : GetScalarType<T[P], AggregateAbility[P]>
  }




  export type abilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: abilityWhereInput
    orderBy?: abilityOrderByWithAggregationInput | abilityOrderByWithAggregationInput[]
    by: AbilityScalarFieldEnum[] | AbilityScalarFieldEnum
    having?: abilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbilityCountAggregateInputType | true
    _avg?: AbilityAvgAggregateInputType
    _sum?: AbilitySumAggregateInputType
    _min?: AbilityMinAggregateInputType
    _max?: AbilityMaxAggregateInputType
  }

  export type AbilityGroupByOutputType = {
    id: number
    appearanceGenerationId: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: AbilityCountAggregateOutputType | null
    _avg: AbilityAvgAggregateOutputType | null
    _sum: AbilitySumAggregateOutputType | null
    _min: AbilityMinAggregateOutputType | null
    _max: AbilityMaxAggregateOutputType | null
  }

  type GetAbilityGroupByPayload<T extends abilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbilityGroupByOutputType[P]>
            : GetScalarType<T[P], AbilityGroupByOutputType[P]>
        }
      >
    >


  export type abilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appearanceGenerationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    generation?: boolean | generationDefaultArgs<ExtArgs>
    abilityInfos?: boolean | ability$abilityInfosArgs<ExtArgs>
    abilityOrders?: boolean | ability$abilityOrdersArgs<ExtArgs>
    _count?: boolean | AbilityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ability"]>



  export type abilitySelectScalar = {
    id?: boolean
    appearanceGenerationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type abilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appearanceGenerationId" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["ability"]>
  export type abilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generation?: boolean | generationDefaultArgs<ExtArgs>
    abilityInfos?: boolean | ability$abilityInfosArgs<ExtArgs>
    abilityOrders?: boolean | ability$abilityOrdersArgs<ExtArgs>
    _count?: boolean | AbilityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $abilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ability"
    objects: {
      generation: Prisma.$generationPayload<ExtArgs>
      abilityInfos: Prisma.$ability_infoPayload<ExtArgs>[]
      abilityOrders: Prisma.$ability_orderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      appearanceGenerationId: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["ability"]>
    composites: {}
  }

  type abilityGetPayload<S extends boolean | null | undefined | abilityDefaultArgs> = $Result.GetResult<Prisma.$abilityPayload, S>

  type abilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<abilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AbilityCountAggregateInputType | true
    }

  export interface abilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ability'], meta: { name: 'ability' } }
    /**
     * Find zero or one Ability that matches the filter.
     * @param {abilityFindUniqueArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends abilityFindUniqueArgs>(args: SelectSubset<T, abilityFindUniqueArgs<ExtArgs>>): Prisma__abilityClient<$Result.GetResult<Prisma.$abilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {abilityFindUniqueOrThrowArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends abilityFindUniqueOrThrowArgs>(args: SelectSubset<T, abilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__abilityClient<$Result.GetResult<Prisma.$abilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abilityFindFirstArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends abilityFindFirstArgs>(args?: SelectSubset<T, abilityFindFirstArgs<ExtArgs>>): Prisma__abilityClient<$Result.GetResult<Prisma.$abilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abilityFindFirstOrThrowArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends abilityFindFirstOrThrowArgs>(args?: SelectSubset<T, abilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__abilityClient<$Result.GetResult<Prisma.$abilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Abilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Abilities
     * const abilities = await prisma.ability.findMany()
     * 
     * // Get first 10 Abilities
     * const abilities = await prisma.ability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const abilityWithIdOnly = await prisma.ability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends abilityFindManyArgs>(args?: SelectSubset<T, abilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$abilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ability.
     * @param {abilityCreateArgs} args - Arguments to create a Ability.
     * @example
     * // Create one Ability
     * const Ability = await prisma.ability.create({
     *   data: {
     *     // ... data to create a Ability
     *   }
     * })
     * 
     */
    create<T extends abilityCreateArgs>(args: SelectSubset<T, abilityCreateArgs<ExtArgs>>): Prisma__abilityClient<$Result.GetResult<Prisma.$abilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Abilities.
     * @param {abilityCreateManyArgs} args - Arguments to create many Abilities.
     * @example
     * // Create many Abilities
     * const ability = await prisma.ability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends abilityCreateManyArgs>(args?: SelectSubset<T, abilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ability.
     * @param {abilityDeleteArgs} args - Arguments to delete one Ability.
     * @example
     * // Delete one Ability
     * const Ability = await prisma.ability.delete({
     *   where: {
     *     // ... filter to delete one Ability
     *   }
     * })
     * 
     */
    delete<T extends abilityDeleteArgs>(args: SelectSubset<T, abilityDeleteArgs<ExtArgs>>): Prisma__abilityClient<$Result.GetResult<Prisma.$abilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ability.
     * @param {abilityUpdateArgs} args - Arguments to update one Ability.
     * @example
     * // Update one Ability
     * const ability = await prisma.ability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends abilityUpdateArgs>(args: SelectSubset<T, abilityUpdateArgs<ExtArgs>>): Prisma__abilityClient<$Result.GetResult<Prisma.$abilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Abilities.
     * @param {abilityDeleteManyArgs} args - Arguments to filter Abilities to delete.
     * @example
     * // Delete a few Abilities
     * const { count } = await prisma.ability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends abilityDeleteManyArgs>(args?: SelectSubset<T, abilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Abilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Abilities
     * const ability = await prisma.ability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends abilityUpdateManyArgs>(args: SelectSubset<T, abilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ability.
     * @param {abilityUpsertArgs} args - Arguments to update or create a Ability.
     * @example
     * // Update or create a Ability
     * const ability = await prisma.ability.upsert({
     *   create: {
     *     // ... data to create a Ability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ability we want to update
     *   }
     * })
     */
    upsert<T extends abilityUpsertArgs>(args: SelectSubset<T, abilityUpsertArgs<ExtArgs>>): Prisma__abilityClient<$Result.GetResult<Prisma.$abilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Abilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abilityCountArgs} args - Arguments to filter Abilities to count.
     * @example
     * // Count the number of Abilities
     * const count = await prisma.ability.count({
     *   where: {
     *     // ... the filter for the Abilities we want to count
     *   }
     * })
    **/
    count<T extends abilityCountArgs>(
      args?: Subset<T, abilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbilityAggregateArgs>(args: Subset<T, AbilityAggregateArgs>): Prisma.PrismaPromise<GetAbilityAggregateType<T>>

    /**
     * Group by Ability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends abilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: abilityGroupByArgs['orderBy'] }
        : { orderBy?: abilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, abilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ability model
   */
  readonly fields: abilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__abilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    generation<T extends generationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, generationDefaultArgs<ExtArgs>>): Prisma__generationClient<$Result.GetResult<Prisma.$generationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    abilityInfos<T extends ability$abilityInfosArgs<ExtArgs> = {}>(args?: Subset<T, ability$abilityInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ability_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    abilityOrders<T extends ability$abilityOrdersArgs<ExtArgs> = {}>(args?: Subset<T, ability$abilityOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ability_orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ability model
   */
  interface abilityFieldRefs {
    readonly id: FieldRef<"ability", 'Int'>
    readonly appearanceGenerationId: FieldRef<"ability", 'Int'>
    readonly createdAt: FieldRef<"ability", 'DateTime'>
    readonly updatedAt: FieldRef<"ability", 'DateTime'>
    readonly status: FieldRef<"ability", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ability findUnique
   */
  export type abilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability
     */
    select?: abilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability
     */
    omit?: abilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: abilityInclude<ExtArgs> | null
    /**
     * Filter, which ability to fetch.
     */
    where: abilityWhereUniqueInput
  }

  /**
   * ability findUniqueOrThrow
   */
  export type abilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability
     */
    select?: abilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability
     */
    omit?: abilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: abilityInclude<ExtArgs> | null
    /**
     * Filter, which ability to fetch.
     */
    where: abilityWhereUniqueInput
  }

  /**
   * ability findFirst
   */
  export type abilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability
     */
    select?: abilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability
     */
    omit?: abilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: abilityInclude<ExtArgs> | null
    /**
     * Filter, which ability to fetch.
     */
    where?: abilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abilities to fetch.
     */
    orderBy?: abilityOrderByWithRelationInput | abilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for abilities.
     */
    cursor?: abilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of abilities.
     */
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }

  /**
   * ability findFirstOrThrow
   */
  export type abilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability
     */
    select?: abilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability
     */
    omit?: abilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: abilityInclude<ExtArgs> | null
    /**
     * Filter, which ability to fetch.
     */
    where?: abilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abilities to fetch.
     */
    orderBy?: abilityOrderByWithRelationInput | abilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for abilities.
     */
    cursor?: abilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of abilities.
     */
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }

  /**
   * ability findMany
   */
  export type abilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability
     */
    select?: abilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability
     */
    omit?: abilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: abilityInclude<ExtArgs> | null
    /**
     * Filter, which abilities to fetch.
     */
    where?: abilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abilities to fetch.
     */
    orderBy?: abilityOrderByWithRelationInput | abilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing abilities.
     */
    cursor?: abilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abilities.
     */
    skip?: number
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }

  /**
   * ability create
   */
  export type abilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability
     */
    select?: abilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability
     */
    omit?: abilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: abilityInclude<ExtArgs> | null
    /**
     * The data needed to create a ability.
     */
    data: XOR<abilityCreateInput, abilityUncheckedCreateInput>
  }

  /**
   * ability createMany
   */
  export type abilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many abilities.
     */
    data: abilityCreateManyInput | abilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ability update
   */
  export type abilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability
     */
    select?: abilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability
     */
    omit?: abilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: abilityInclude<ExtArgs> | null
    /**
     * The data needed to update a ability.
     */
    data: XOR<abilityUpdateInput, abilityUncheckedUpdateInput>
    /**
     * Choose, which ability to update.
     */
    where: abilityWhereUniqueInput
  }

  /**
   * ability updateMany
   */
  export type abilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update abilities.
     */
    data: XOR<abilityUpdateManyMutationInput, abilityUncheckedUpdateManyInput>
    /**
     * Filter which abilities to update
     */
    where?: abilityWhereInput
    /**
     * Limit how many abilities to update.
     */
    limit?: number
  }

  /**
   * ability upsert
   */
  export type abilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability
     */
    select?: abilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability
     */
    omit?: abilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: abilityInclude<ExtArgs> | null
    /**
     * The filter to search for the ability to update in case it exists.
     */
    where: abilityWhereUniqueInput
    /**
     * In case the ability found by the `where` argument doesn't exist, create a new ability with this data.
     */
    create: XOR<abilityCreateInput, abilityUncheckedCreateInput>
    /**
     * In case the ability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<abilityUpdateInput, abilityUncheckedUpdateInput>
  }

  /**
   * ability delete
   */
  export type abilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability
     */
    select?: abilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability
     */
    omit?: abilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: abilityInclude<ExtArgs> | null
    /**
     * Filter which ability to delete.
     */
    where: abilityWhereUniqueInput
  }

  /**
   * ability deleteMany
   */
  export type abilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which abilities to delete
     */
    where?: abilityWhereInput
    /**
     * Limit how many abilities to delete.
     */
    limit?: number
  }

  /**
   * ability.abilityInfos
   */
  export type ability$abilityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_info
     */
    select?: ability_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_info
     */
    omit?: ability_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_infoInclude<ExtArgs> | null
    where?: ability_infoWhereInput
    orderBy?: ability_infoOrderByWithRelationInput | ability_infoOrderByWithRelationInput[]
    cursor?: ability_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ability_infoScalarFieldEnum | Ability_infoScalarFieldEnum[]
  }

  /**
   * ability.abilityOrders
   */
  export type ability$abilityOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_order
     */
    select?: ability_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_order
     */
    omit?: ability_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_orderInclude<ExtArgs> | null
    where?: ability_orderWhereInput
    orderBy?: ability_orderOrderByWithRelationInput | ability_orderOrderByWithRelationInput[]
    cursor?: ability_orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ability_orderScalarFieldEnum | Ability_orderScalarFieldEnum[]
  }

  /**
   * ability without action
   */
  export type abilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability
     */
    select?: abilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability
     */
    omit?: abilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: abilityInclude<ExtArgs> | null
  }


  /**
   * Model ability_info
   */

  export type AggregateAbility_info = {
    _count: Ability_infoCountAggregateOutputType | null
    _avg: Ability_infoAvgAggregateOutputType | null
    _sum: Ability_infoSumAggregateOutputType | null
    _min: Ability_infoMinAggregateOutputType | null
    _max: Ability_infoMaxAggregateOutputType | null
  }

  export type Ability_infoAvgAggregateOutputType = {
    id: number | null
    generationId: number | null
    abilityId: number | null
    effectOutsideFightId: number | null
  }

  export type Ability_infoSumAggregateOutputType = {
    id: number | null
    generationId: number | null
    abilityId: number | null
    effectOutsideFightId: number | null
  }

  export type Ability_infoMinAggregateOutputType = {
    id: number | null
    generationId: number | null
    abilityId: number | null
    effectOutsideFightId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Ability_infoMaxAggregateOutputType = {
    id: number | null
    generationId: number | null
    abilityId: number | null
    effectOutsideFightId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Ability_infoCountAggregateOutputType = {
    id: number
    generationId: number
    abilityId: number
    effectOutsideFightId: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Ability_infoAvgAggregateInputType = {
    id?: true
    generationId?: true
    abilityId?: true
    effectOutsideFightId?: true
  }

  export type Ability_infoSumAggregateInputType = {
    id?: true
    generationId?: true
    abilityId?: true
    effectOutsideFightId?: true
  }

  export type Ability_infoMinAggregateInputType = {
    id?: true
    generationId?: true
    abilityId?: true
    effectOutsideFightId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Ability_infoMaxAggregateInputType = {
    id?: true
    generationId?: true
    abilityId?: true
    effectOutsideFightId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Ability_infoCountAggregateInputType = {
    id?: true
    generationId?: true
    abilityId?: true
    effectOutsideFightId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Ability_infoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ability_info to aggregate.
     */
    where?: ability_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ability_infos to fetch.
     */
    orderBy?: ability_infoOrderByWithRelationInput | ability_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ability_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ability_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ability_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ability_infos
    **/
    _count?: true | Ability_infoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ability_infoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ability_infoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ability_infoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ability_infoMaxAggregateInputType
  }

  export type GetAbility_infoAggregateType<T extends Ability_infoAggregateArgs> = {
        [P in keyof T & keyof AggregateAbility_info]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbility_info[P]>
      : GetScalarType<T[P], AggregateAbility_info[P]>
  }




  export type ability_infoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ability_infoWhereInput
    orderBy?: ability_infoOrderByWithAggregationInput | ability_infoOrderByWithAggregationInput[]
    by: Ability_infoScalarFieldEnum[] | Ability_infoScalarFieldEnum
    having?: ability_infoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ability_infoCountAggregateInputType | true
    _avg?: Ability_infoAvgAggregateInputType
    _sum?: Ability_infoSumAggregateInputType
    _min?: Ability_infoMinAggregateInputType
    _max?: Ability_infoMaxAggregateInputType
  }

  export type Ability_infoGroupByOutputType = {
    id: number
    generationId: number
    abilityId: number
    effectOutsideFightId: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Ability_infoCountAggregateOutputType | null
    _avg: Ability_infoAvgAggregateOutputType | null
    _sum: Ability_infoSumAggregateOutputType | null
    _min: Ability_infoMinAggregateOutputType | null
    _max: Ability_infoMaxAggregateOutputType | null
  }

  type GetAbility_infoGroupByPayload<T extends ability_infoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ability_infoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ability_infoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ability_infoGroupByOutputType[P]>
            : GetScalarType<T[P], Ability_infoGroupByOutputType[P]>
        }
      >
    >


  export type ability_infoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    generationId?: boolean
    abilityId?: boolean
    effectOutsideFightId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    abilities?: boolean | abilityDefaultArgs<ExtArgs>
    effectWithoutFight?: boolean | effect_outside_fightDefaultArgs<ExtArgs>
    generation?: boolean | generationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ability_info"]>



  export type ability_infoSelectScalar = {
    id?: boolean
    generationId?: boolean
    abilityId?: boolean
    effectOutsideFightId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type ability_infoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "generationId" | "abilityId" | "effectOutsideFightId" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["ability_info"]>
  export type ability_infoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abilities?: boolean | abilityDefaultArgs<ExtArgs>
    effectWithoutFight?: boolean | effect_outside_fightDefaultArgs<ExtArgs>
    generation?: boolean | generationDefaultArgs<ExtArgs>
  }

  export type $ability_infoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ability_info"
    objects: {
      abilities: Prisma.$abilityPayload<ExtArgs>
      effectWithoutFight: Prisma.$effect_outside_fightPayload<ExtArgs>
      generation: Prisma.$generationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      generationId: number
      abilityId: number
      effectOutsideFightId: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["ability_info"]>
    composites: {}
  }

  type ability_infoGetPayload<S extends boolean | null | undefined | ability_infoDefaultArgs> = $Result.GetResult<Prisma.$ability_infoPayload, S>

  type ability_infoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ability_infoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ability_infoCountAggregateInputType | true
    }

  export interface ability_infoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ability_info'], meta: { name: 'ability_info' } }
    /**
     * Find zero or one Ability_info that matches the filter.
     * @param {ability_infoFindUniqueArgs} args - Arguments to find a Ability_info
     * @example
     * // Get one Ability_info
     * const ability_info = await prisma.ability_info.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ability_infoFindUniqueArgs>(args: SelectSubset<T, ability_infoFindUniqueArgs<ExtArgs>>): Prisma__ability_infoClient<$Result.GetResult<Prisma.$ability_infoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ability_info that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ability_infoFindUniqueOrThrowArgs} args - Arguments to find a Ability_info
     * @example
     * // Get one Ability_info
     * const ability_info = await prisma.ability_info.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ability_infoFindUniqueOrThrowArgs>(args: SelectSubset<T, ability_infoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ability_infoClient<$Result.GetResult<Prisma.$ability_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ability_info that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ability_infoFindFirstArgs} args - Arguments to find a Ability_info
     * @example
     * // Get one Ability_info
     * const ability_info = await prisma.ability_info.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ability_infoFindFirstArgs>(args?: SelectSubset<T, ability_infoFindFirstArgs<ExtArgs>>): Prisma__ability_infoClient<$Result.GetResult<Prisma.$ability_infoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ability_info that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ability_infoFindFirstOrThrowArgs} args - Arguments to find a Ability_info
     * @example
     * // Get one Ability_info
     * const ability_info = await prisma.ability_info.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ability_infoFindFirstOrThrowArgs>(args?: SelectSubset<T, ability_infoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ability_infoClient<$Result.GetResult<Prisma.$ability_infoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ability_infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ability_infoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ability_infos
     * const ability_infos = await prisma.ability_info.findMany()
     * 
     * // Get first 10 Ability_infos
     * const ability_infos = await prisma.ability_info.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ability_infoWithIdOnly = await prisma.ability_info.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ability_infoFindManyArgs>(args?: SelectSubset<T, ability_infoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ability_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ability_info.
     * @param {ability_infoCreateArgs} args - Arguments to create a Ability_info.
     * @example
     * // Create one Ability_info
     * const Ability_info = await prisma.ability_info.create({
     *   data: {
     *     // ... data to create a Ability_info
     *   }
     * })
     * 
     */
    create<T extends ability_infoCreateArgs>(args: SelectSubset<T, ability_infoCreateArgs<ExtArgs>>): Prisma__ability_infoClient<$Result.GetResult<Prisma.$ability_infoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ability_infos.
     * @param {ability_infoCreateManyArgs} args - Arguments to create many Ability_infos.
     * @example
     * // Create many Ability_infos
     * const ability_info = await prisma.ability_info.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ability_infoCreateManyArgs>(args?: SelectSubset<T, ability_infoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ability_info.
     * @param {ability_infoDeleteArgs} args - Arguments to delete one Ability_info.
     * @example
     * // Delete one Ability_info
     * const Ability_info = await prisma.ability_info.delete({
     *   where: {
     *     // ... filter to delete one Ability_info
     *   }
     * })
     * 
     */
    delete<T extends ability_infoDeleteArgs>(args: SelectSubset<T, ability_infoDeleteArgs<ExtArgs>>): Prisma__ability_infoClient<$Result.GetResult<Prisma.$ability_infoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ability_info.
     * @param {ability_infoUpdateArgs} args - Arguments to update one Ability_info.
     * @example
     * // Update one Ability_info
     * const ability_info = await prisma.ability_info.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ability_infoUpdateArgs>(args: SelectSubset<T, ability_infoUpdateArgs<ExtArgs>>): Prisma__ability_infoClient<$Result.GetResult<Prisma.$ability_infoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ability_infos.
     * @param {ability_infoDeleteManyArgs} args - Arguments to filter Ability_infos to delete.
     * @example
     * // Delete a few Ability_infos
     * const { count } = await prisma.ability_info.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ability_infoDeleteManyArgs>(args?: SelectSubset<T, ability_infoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ability_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ability_infoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ability_infos
     * const ability_info = await prisma.ability_info.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ability_infoUpdateManyArgs>(args: SelectSubset<T, ability_infoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ability_info.
     * @param {ability_infoUpsertArgs} args - Arguments to update or create a Ability_info.
     * @example
     * // Update or create a Ability_info
     * const ability_info = await prisma.ability_info.upsert({
     *   create: {
     *     // ... data to create a Ability_info
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ability_info we want to update
     *   }
     * })
     */
    upsert<T extends ability_infoUpsertArgs>(args: SelectSubset<T, ability_infoUpsertArgs<ExtArgs>>): Prisma__ability_infoClient<$Result.GetResult<Prisma.$ability_infoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ability_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ability_infoCountArgs} args - Arguments to filter Ability_infos to count.
     * @example
     * // Count the number of Ability_infos
     * const count = await prisma.ability_info.count({
     *   where: {
     *     // ... the filter for the Ability_infos we want to count
     *   }
     * })
    **/
    count<T extends ability_infoCountArgs>(
      args?: Subset<T, ability_infoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ability_infoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ability_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ability_infoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ability_infoAggregateArgs>(args: Subset<T, Ability_infoAggregateArgs>): Prisma.PrismaPromise<GetAbility_infoAggregateType<T>>

    /**
     * Group by Ability_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ability_infoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ability_infoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ability_infoGroupByArgs['orderBy'] }
        : { orderBy?: ability_infoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ability_infoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbility_infoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ability_info model
   */
  readonly fields: ability_infoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ability_info.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ability_infoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    abilities<T extends abilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, abilityDefaultArgs<ExtArgs>>): Prisma__abilityClient<$Result.GetResult<Prisma.$abilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    effectWithoutFight<T extends effect_outside_fightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, effect_outside_fightDefaultArgs<ExtArgs>>): Prisma__effect_outside_fightClient<$Result.GetResult<Prisma.$effect_outside_fightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    generation<T extends generationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, generationDefaultArgs<ExtArgs>>): Prisma__generationClient<$Result.GetResult<Prisma.$generationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ability_info model
   */
  interface ability_infoFieldRefs {
    readonly id: FieldRef<"ability_info", 'Int'>
    readonly generationId: FieldRef<"ability_info", 'Int'>
    readonly abilityId: FieldRef<"ability_info", 'Int'>
    readonly effectOutsideFightId: FieldRef<"ability_info", 'Int'>
    readonly createdAt: FieldRef<"ability_info", 'DateTime'>
    readonly updatedAt: FieldRef<"ability_info", 'DateTime'>
    readonly status: FieldRef<"ability_info", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ability_info findUnique
   */
  export type ability_infoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_info
     */
    select?: ability_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_info
     */
    omit?: ability_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_infoInclude<ExtArgs> | null
    /**
     * Filter, which ability_info to fetch.
     */
    where: ability_infoWhereUniqueInput
  }

  /**
   * ability_info findUniqueOrThrow
   */
  export type ability_infoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_info
     */
    select?: ability_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_info
     */
    omit?: ability_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_infoInclude<ExtArgs> | null
    /**
     * Filter, which ability_info to fetch.
     */
    where: ability_infoWhereUniqueInput
  }

  /**
   * ability_info findFirst
   */
  export type ability_infoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_info
     */
    select?: ability_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_info
     */
    omit?: ability_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_infoInclude<ExtArgs> | null
    /**
     * Filter, which ability_info to fetch.
     */
    where?: ability_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ability_infos to fetch.
     */
    orderBy?: ability_infoOrderByWithRelationInput | ability_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ability_infos.
     */
    cursor?: ability_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ability_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ability_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ability_infos.
     */
    distinct?: Ability_infoScalarFieldEnum | Ability_infoScalarFieldEnum[]
  }

  /**
   * ability_info findFirstOrThrow
   */
  export type ability_infoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_info
     */
    select?: ability_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_info
     */
    omit?: ability_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_infoInclude<ExtArgs> | null
    /**
     * Filter, which ability_info to fetch.
     */
    where?: ability_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ability_infos to fetch.
     */
    orderBy?: ability_infoOrderByWithRelationInput | ability_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ability_infos.
     */
    cursor?: ability_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ability_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ability_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ability_infos.
     */
    distinct?: Ability_infoScalarFieldEnum | Ability_infoScalarFieldEnum[]
  }

  /**
   * ability_info findMany
   */
  export type ability_infoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_info
     */
    select?: ability_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_info
     */
    omit?: ability_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_infoInclude<ExtArgs> | null
    /**
     * Filter, which ability_infos to fetch.
     */
    where?: ability_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ability_infos to fetch.
     */
    orderBy?: ability_infoOrderByWithRelationInput | ability_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ability_infos.
     */
    cursor?: ability_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ability_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ability_infos.
     */
    skip?: number
    distinct?: Ability_infoScalarFieldEnum | Ability_infoScalarFieldEnum[]
  }

  /**
   * ability_info create
   */
  export type ability_infoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_info
     */
    select?: ability_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_info
     */
    omit?: ability_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_infoInclude<ExtArgs> | null
    /**
     * The data needed to create a ability_info.
     */
    data: XOR<ability_infoCreateInput, ability_infoUncheckedCreateInput>
  }

  /**
   * ability_info createMany
   */
  export type ability_infoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ability_infos.
     */
    data: ability_infoCreateManyInput | ability_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ability_info update
   */
  export type ability_infoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_info
     */
    select?: ability_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_info
     */
    omit?: ability_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_infoInclude<ExtArgs> | null
    /**
     * The data needed to update a ability_info.
     */
    data: XOR<ability_infoUpdateInput, ability_infoUncheckedUpdateInput>
    /**
     * Choose, which ability_info to update.
     */
    where: ability_infoWhereUniqueInput
  }

  /**
   * ability_info updateMany
   */
  export type ability_infoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ability_infos.
     */
    data: XOR<ability_infoUpdateManyMutationInput, ability_infoUncheckedUpdateManyInput>
    /**
     * Filter which ability_infos to update
     */
    where?: ability_infoWhereInput
    /**
     * Limit how many ability_infos to update.
     */
    limit?: number
  }

  /**
   * ability_info upsert
   */
  export type ability_infoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_info
     */
    select?: ability_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_info
     */
    omit?: ability_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_infoInclude<ExtArgs> | null
    /**
     * The filter to search for the ability_info to update in case it exists.
     */
    where: ability_infoWhereUniqueInput
    /**
     * In case the ability_info found by the `where` argument doesn't exist, create a new ability_info with this data.
     */
    create: XOR<ability_infoCreateInput, ability_infoUncheckedCreateInput>
    /**
     * In case the ability_info was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ability_infoUpdateInput, ability_infoUncheckedUpdateInput>
  }

  /**
   * ability_info delete
   */
  export type ability_infoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_info
     */
    select?: ability_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_info
     */
    omit?: ability_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_infoInclude<ExtArgs> | null
    /**
     * Filter which ability_info to delete.
     */
    where: ability_infoWhereUniqueInput
  }

  /**
   * ability_info deleteMany
   */
  export type ability_infoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ability_infos to delete
     */
    where?: ability_infoWhereInput
    /**
     * Limit how many ability_infos to delete.
     */
    limit?: number
  }

  /**
   * ability_info without action
   */
  export type ability_infoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_info
     */
    select?: ability_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_info
     */
    omit?: ability_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_infoInclude<ExtArgs> | null
  }


  /**
   * Model pokemon_info
   */

  export type AggregatePokemon_info = {
    _count: Pokemon_infoCountAggregateOutputType | null
    _avg: Pokemon_infoAvgAggregateOutputType | null
    _sum: Pokemon_infoSumAggregateOutputType | null
    _min: Pokemon_infoMinAggregateOutputType | null
    _max: Pokemon_infoMaxAggregateOutputType | null
  }

  export type Pokemon_infoAvgAggregateOutputType = {
    id: number | null
    xpGift: number | null
    generationId: number | null
    pokemonId: number | null
  }

  export type Pokemon_infoSumAggregateOutputType = {
    id: number | null
    xpGift: number | null
    generationId: number | null
    pokemonId: number | null
  }

  export type Pokemon_infoMinAggregateOutputType = {
    id: number | null
    xpGift: number | null
    generationId: number | null
    pokemonId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Pokemon_infoMaxAggregateOutputType = {
    id: number | null
    xpGift: number | null
    generationId: number | null
    pokemonId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Pokemon_infoCountAggregateOutputType = {
    id: number
    xpGift: number
    generationId: number
    pokemonId: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Pokemon_infoAvgAggregateInputType = {
    id?: true
    xpGift?: true
    generationId?: true
    pokemonId?: true
  }

  export type Pokemon_infoSumAggregateInputType = {
    id?: true
    xpGift?: true
    generationId?: true
    pokemonId?: true
  }

  export type Pokemon_infoMinAggregateInputType = {
    id?: true
    xpGift?: true
    generationId?: true
    pokemonId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Pokemon_infoMaxAggregateInputType = {
    id?: true
    xpGift?: true
    generationId?: true
    pokemonId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Pokemon_infoCountAggregateInputType = {
    id?: true
    xpGift?: true
    generationId?: true
    pokemonId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Pokemon_infoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokemon_info to aggregate.
     */
    where?: pokemon_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_infos to fetch.
     */
    orderBy?: pokemon_infoOrderByWithRelationInput | pokemon_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pokemon_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pokemon_infos
    **/
    _count?: true | Pokemon_infoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pokemon_infoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pokemon_infoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pokemon_infoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pokemon_infoMaxAggregateInputType
  }

  export type GetPokemon_infoAggregateType<T extends Pokemon_infoAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemon_info]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemon_info[P]>
      : GetScalarType<T[P], AggregatePokemon_info[P]>
  }




  export type pokemon_infoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_infoWhereInput
    orderBy?: pokemon_infoOrderByWithAggregationInput | pokemon_infoOrderByWithAggregationInput[]
    by: Pokemon_infoScalarFieldEnum[] | Pokemon_infoScalarFieldEnum
    having?: pokemon_infoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pokemon_infoCountAggregateInputType | true
    _avg?: Pokemon_infoAvgAggregateInputType
    _sum?: Pokemon_infoSumAggregateInputType
    _min?: Pokemon_infoMinAggregateInputType
    _max?: Pokemon_infoMaxAggregateInputType
  }

  export type Pokemon_infoGroupByOutputType = {
    id: number
    xpGift: number
    generationId: number
    pokemonId: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Pokemon_infoCountAggregateOutputType | null
    _avg: Pokemon_infoAvgAggregateOutputType | null
    _sum: Pokemon_infoSumAggregateOutputType | null
    _min: Pokemon_infoMinAggregateOutputType | null
    _max: Pokemon_infoMaxAggregateOutputType | null
  }

  type GetPokemon_infoGroupByPayload<T extends pokemon_infoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pokemon_infoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pokemon_infoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pokemon_infoGroupByOutputType[P]>
            : GetScalarType<T[P], Pokemon_infoGroupByOutputType[P]>
        }
      >
    >


  export type pokemon_infoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xpGift?: boolean
    generationId?: boolean
    pokemonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    abilityOrders?: boolean | pokemon_info$abilityOrdersArgs<ExtArgs>
    eggGroupOrders?: boolean | pokemon_info$eggGroupOrdersArgs<ExtArgs>
    generation?: boolean | generationDefaultArgs<ExtArgs>
    pokemon?: boolean | pokemonDefaultArgs<ExtArgs>
    typeOrders?: boolean | pokemon_info$typeOrdersArgs<ExtArgs>
    _count?: boolean | Pokemon_infoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemon_info"]>



  export type pokemon_infoSelectScalar = {
    id?: boolean
    xpGift?: boolean
    generationId?: boolean
    pokemonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type pokemon_infoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "xpGift" | "generationId" | "pokemonId" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["pokemon_info"]>
  export type pokemon_infoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abilityOrders?: boolean | pokemon_info$abilityOrdersArgs<ExtArgs>
    eggGroupOrders?: boolean | pokemon_info$eggGroupOrdersArgs<ExtArgs>
    generation?: boolean | generationDefaultArgs<ExtArgs>
    pokemon?: boolean | pokemonDefaultArgs<ExtArgs>
    typeOrders?: boolean | pokemon_info$typeOrdersArgs<ExtArgs>
    _count?: boolean | Pokemon_infoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $pokemon_infoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pokemon_info"
    objects: {
      abilityOrders: Prisma.$ability_orderPayload<ExtArgs>[]
      eggGroupOrders: Prisma.$egg_group_orderPayload<ExtArgs>[]
      generation: Prisma.$generationPayload<ExtArgs>
      pokemon: Prisma.$pokemonPayload<ExtArgs>
      typeOrders: Prisma.$type_orderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      xpGift: number
      generationId: number
      pokemonId: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["pokemon_info"]>
    composites: {}
  }

  type pokemon_infoGetPayload<S extends boolean | null | undefined | pokemon_infoDefaultArgs> = $Result.GetResult<Prisma.$pokemon_infoPayload, S>

  type pokemon_infoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pokemon_infoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pokemon_infoCountAggregateInputType | true
    }

  export interface pokemon_infoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pokemon_info'], meta: { name: 'pokemon_info' } }
    /**
     * Find zero or one Pokemon_info that matches the filter.
     * @param {pokemon_infoFindUniqueArgs} args - Arguments to find a Pokemon_info
     * @example
     * // Get one Pokemon_info
     * const pokemon_info = await prisma.pokemon_info.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pokemon_infoFindUniqueArgs>(args: SelectSubset<T, pokemon_infoFindUniqueArgs<ExtArgs>>): Prisma__pokemon_infoClient<$Result.GetResult<Prisma.$pokemon_infoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pokemon_info that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pokemon_infoFindUniqueOrThrowArgs} args - Arguments to find a Pokemon_info
     * @example
     * // Get one Pokemon_info
     * const pokemon_info = await prisma.pokemon_info.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pokemon_infoFindUniqueOrThrowArgs>(args: SelectSubset<T, pokemon_infoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pokemon_infoClient<$Result.GetResult<Prisma.$pokemon_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon_info that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_infoFindFirstArgs} args - Arguments to find a Pokemon_info
     * @example
     * // Get one Pokemon_info
     * const pokemon_info = await prisma.pokemon_info.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pokemon_infoFindFirstArgs>(args?: SelectSubset<T, pokemon_infoFindFirstArgs<ExtArgs>>): Prisma__pokemon_infoClient<$Result.GetResult<Prisma.$pokemon_infoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon_info that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_infoFindFirstOrThrowArgs} args - Arguments to find a Pokemon_info
     * @example
     * // Get one Pokemon_info
     * const pokemon_info = await prisma.pokemon_info.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pokemon_infoFindFirstOrThrowArgs>(args?: SelectSubset<T, pokemon_infoFindFirstOrThrowArgs<ExtArgs>>): Prisma__pokemon_infoClient<$Result.GetResult<Prisma.$pokemon_infoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pokemon_infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_infoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pokemon_infos
     * const pokemon_infos = await prisma.pokemon_info.findMany()
     * 
     * // Get first 10 Pokemon_infos
     * const pokemon_infos = await prisma.pokemon_info.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokemon_infoWithIdOnly = await prisma.pokemon_info.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pokemon_infoFindManyArgs>(args?: SelectSubset<T, pokemon_infoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pokemon_info.
     * @param {pokemon_infoCreateArgs} args - Arguments to create a Pokemon_info.
     * @example
     * // Create one Pokemon_info
     * const Pokemon_info = await prisma.pokemon_info.create({
     *   data: {
     *     // ... data to create a Pokemon_info
     *   }
     * })
     * 
     */
    create<T extends pokemon_infoCreateArgs>(args: SelectSubset<T, pokemon_infoCreateArgs<ExtArgs>>): Prisma__pokemon_infoClient<$Result.GetResult<Prisma.$pokemon_infoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pokemon_infos.
     * @param {pokemon_infoCreateManyArgs} args - Arguments to create many Pokemon_infos.
     * @example
     * // Create many Pokemon_infos
     * const pokemon_info = await prisma.pokemon_info.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pokemon_infoCreateManyArgs>(args?: SelectSubset<T, pokemon_infoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pokemon_info.
     * @param {pokemon_infoDeleteArgs} args - Arguments to delete one Pokemon_info.
     * @example
     * // Delete one Pokemon_info
     * const Pokemon_info = await prisma.pokemon_info.delete({
     *   where: {
     *     // ... filter to delete one Pokemon_info
     *   }
     * })
     * 
     */
    delete<T extends pokemon_infoDeleteArgs>(args: SelectSubset<T, pokemon_infoDeleteArgs<ExtArgs>>): Prisma__pokemon_infoClient<$Result.GetResult<Prisma.$pokemon_infoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pokemon_info.
     * @param {pokemon_infoUpdateArgs} args - Arguments to update one Pokemon_info.
     * @example
     * // Update one Pokemon_info
     * const pokemon_info = await prisma.pokemon_info.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pokemon_infoUpdateArgs>(args: SelectSubset<T, pokemon_infoUpdateArgs<ExtArgs>>): Prisma__pokemon_infoClient<$Result.GetResult<Prisma.$pokemon_infoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pokemon_infos.
     * @param {pokemon_infoDeleteManyArgs} args - Arguments to filter Pokemon_infos to delete.
     * @example
     * // Delete a few Pokemon_infos
     * const { count } = await prisma.pokemon_info.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pokemon_infoDeleteManyArgs>(args?: SelectSubset<T, pokemon_infoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pokemon_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_infoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pokemon_infos
     * const pokemon_info = await prisma.pokemon_info.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pokemon_infoUpdateManyArgs>(args: SelectSubset<T, pokemon_infoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pokemon_info.
     * @param {pokemon_infoUpsertArgs} args - Arguments to update or create a Pokemon_info.
     * @example
     * // Update or create a Pokemon_info
     * const pokemon_info = await prisma.pokemon_info.upsert({
     *   create: {
     *     // ... data to create a Pokemon_info
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pokemon_info we want to update
     *   }
     * })
     */
    upsert<T extends pokemon_infoUpsertArgs>(args: SelectSubset<T, pokemon_infoUpsertArgs<ExtArgs>>): Prisma__pokemon_infoClient<$Result.GetResult<Prisma.$pokemon_infoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pokemon_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_infoCountArgs} args - Arguments to filter Pokemon_infos to count.
     * @example
     * // Count the number of Pokemon_infos
     * const count = await prisma.pokemon_info.count({
     *   where: {
     *     // ... the filter for the Pokemon_infos we want to count
     *   }
     * })
    **/
    count<T extends pokemon_infoCountArgs>(
      args?: Subset<T, pokemon_infoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pokemon_infoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pokemon_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pokemon_infoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pokemon_infoAggregateArgs>(args: Subset<T, Pokemon_infoAggregateArgs>): Prisma.PrismaPromise<GetPokemon_infoAggregateType<T>>

    /**
     * Group by Pokemon_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_infoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pokemon_infoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pokemon_infoGroupByArgs['orderBy'] }
        : { orderBy?: pokemon_infoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pokemon_infoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemon_infoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pokemon_info model
   */
  readonly fields: pokemon_infoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pokemon_info.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pokemon_infoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    abilityOrders<T extends pokemon_info$abilityOrdersArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_info$abilityOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ability_orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eggGroupOrders<T extends pokemon_info$eggGroupOrdersArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_info$eggGroupOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$egg_group_orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generation<T extends generationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, generationDefaultArgs<ExtArgs>>): Prisma__generationClient<$Result.GetResult<Prisma.$generationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemon<T extends pokemonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemonDefaultArgs<ExtArgs>>): Prisma__pokemonClient<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    typeOrders<T extends pokemon_info$typeOrdersArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_info$typeOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$type_orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pokemon_info model
   */
  interface pokemon_infoFieldRefs {
    readonly id: FieldRef<"pokemon_info", 'Int'>
    readonly xpGift: FieldRef<"pokemon_info", 'Int'>
    readonly generationId: FieldRef<"pokemon_info", 'Int'>
    readonly pokemonId: FieldRef<"pokemon_info", 'Int'>
    readonly createdAt: FieldRef<"pokemon_info", 'DateTime'>
    readonly updatedAt: FieldRef<"pokemon_info", 'DateTime'>
    readonly status: FieldRef<"pokemon_info", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pokemon_info findUnique
   */
  export type pokemon_infoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_info
     */
    select?: pokemon_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_info
     */
    omit?: pokemon_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_infoInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_info to fetch.
     */
    where: pokemon_infoWhereUniqueInput
  }

  /**
   * pokemon_info findUniqueOrThrow
   */
  export type pokemon_infoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_info
     */
    select?: pokemon_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_info
     */
    omit?: pokemon_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_infoInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_info to fetch.
     */
    where: pokemon_infoWhereUniqueInput
  }

  /**
   * pokemon_info findFirst
   */
  export type pokemon_infoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_info
     */
    select?: pokemon_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_info
     */
    omit?: pokemon_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_infoInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_info to fetch.
     */
    where?: pokemon_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_infos to fetch.
     */
    orderBy?: pokemon_infoOrderByWithRelationInput | pokemon_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokemon_infos.
     */
    cursor?: pokemon_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokemon_infos.
     */
    distinct?: Pokemon_infoScalarFieldEnum | Pokemon_infoScalarFieldEnum[]
  }

  /**
   * pokemon_info findFirstOrThrow
   */
  export type pokemon_infoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_info
     */
    select?: pokemon_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_info
     */
    omit?: pokemon_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_infoInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_info to fetch.
     */
    where?: pokemon_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_infos to fetch.
     */
    orderBy?: pokemon_infoOrderByWithRelationInput | pokemon_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokemon_infos.
     */
    cursor?: pokemon_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokemon_infos.
     */
    distinct?: Pokemon_infoScalarFieldEnum | Pokemon_infoScalarFieldEnum[]
  }

  /**
   * pokemon_info findMany
   */
  export type pokemon_infoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_info
     */
    select?: pokemon_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_info
     */
    omit?: pokemon_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_infoInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_infos to fetch.
     */
    where?: pokemon_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_infos to fetch.
     */
    orderBy?: pokemon_infoOrderByWithRelationInput | pokemon_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pokemon_infos.
     */
    cursor?: pokemon_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_infos.
     */
    skip?: number
    distinct?: Pokemon_infoScalarFieldEnum | Pokemon_infoScalarFieldEnum[]
  }

  /**
   * pokemon_info create
   */
  export type pokemon_infoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_info
     */
    select?: pokemon_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_info
     */
    omit?: pokemon_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_infoInclude<ExtArgs> | null
    /**
     * The data needed to create a pokemon_info.
     */
    data: XOR<pokemon_infoCreateInput, pokemon_infoUncheckedCreateInput>
  }

  /**
   * pokemon_info createMany
   */
  export type pokemon_infoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pokemon_infos.
     */
    data: pokemon_infoCreateManyInput | pokemon_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pokemon_info update
   */
  export type pokemon_infoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_info
     */
    select?: pokemon_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_info
     */
    omit?: pokemon_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_infoInclude<ExtArgs> | null
    /**
     * The data needed to update a pokemon_info.
     */
    data: XOR<pokemon_infoUpdateInput, pokemon_infoUncheckedUpdateInput>
    /**
     * Choose, which pokemon_info to update.
     */
    where: pokemon_infoWhereUniqueInput
  }

  /**
   * pokemon_info updateMany
   */
  export type pokemon_infoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pokemon_infos.
     */
    data: XOR<pokemon_infoUpdateManyMutationInput, pokemon_infoUncheckedUpdateManyInput>
    /**
     * Filter which pokemon_infos to update
     */
    where?: pokemon_infoWhereInput
    /**
     * Limit how many pokemon_infos to update.
     */
    limit?: number
  }

  /**
   * pokemon_info upsert
   */
  export type pokemon_infoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_info
     */
    select?: pokemon_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_info
     */
    omit?: pokemon_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_infoInclude<ExtArgs> | null
    /**
     * The filter to search for the pokemon_info to update in case it exists.
     */
    where: pokemon_infoWhereUniqueInput
    /**
     * In case the pokemon_info found by the `where` argument doesn't exist, create a new pokemon_info with this data.
     */
    create: XOR<pokemon_infoCreateInput, pokemon_infoUncheckedCreateInput>
    /**
     * In case the pokemon_info was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pokemon_infoUpdateInput, pokemon_infoUncheckedUpdateInput>
  }

  /**
   * pokemon_info delete
   */
  export type pokemon_infoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_info
     */
    select?: pokemon_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_info
     */
    omit?: pokemon_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_infoInclude<ExtArgs> | null
    /**
     * Filter which pokemon_info to delete.
     */
    where: pokemon_infoWhereUniqueInput
  }

  /**
   * pokemon_info deleteMany
   */
  export type pokemon_infoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokemon_infos to delete
     */
    where?: pokemon_infoWhereInput
    /**
     * Limit how many pokemon_infos to delete.
     */
    limit?: number
  }

  /**
   * pokemon_info.abilityOrders
   */
  export type pokemon_info$abilityOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_order
     */
    select?: ability_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_order
     */
    omit?: ability_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_orderInclude<ExtArgs> | null
    where?: ability_orderWhereInput
    orderBy?: ability_orderOrderByWithRelationInput | ability_orderOrderByWithRelationInput[]
    cursor?: ability_orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ability_orderScalarFieldEnum | Ability_orderScalarFieldEnum[]
  }

  /**
   * pokemon_info.eggGroupOrders
   */
  export type pokemon_info$eggGroupOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group_order
     */
    select?: egg_group_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group_order
     */
    omit?: egg_group_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_group_orderInclude<ExtArgs> | null
    where?: egg_group_orderWhereInput
    orderBy?: egg_group_orderOrderByWithRelationInput | egg_group_orderOrderByWithRelationInput[]
    cursor?: egg_group_orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Egg_group_orderScalarFieldEnum | Egg_group_orderScalarFieldEnum[]
  }

  /**
   * pokemon_info.typeOrders
   */
  export type pokemon_info$typeOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_order
     */
    select?: type_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_order
     */
    omit?: type_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_orderInclude<ExtArgs> | null
    where?: type_orderWhereInput
    orderBy?: type_orderOrderByWithRelationInput | type_orderOrderByWithRelationInput[]
    cursor?: type_orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Type_orderScalarFieldEnum | Type_orderScalarFieldEnum[]
  }

  /**
   * pokemon_info without action
   */
  export type pokemon_infoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_info
     */
    select?: pokemon_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_info
     */
    omit?: pokemon_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_infoInclude<ExtArgs> | null
  }


  /**
   * Model ability_order
   */

  export type AggregateAbility_order = {
    _count: Ability_orderCountAggregateOutputType | null
    _avg: Ability_orderAvgAggregateOutputType | null
    _sum: Ability_orderSumAggregateOutputType | null
    _min: Ability_orderMinAggregateOutputType | null
    _max: Ability_orderMaxAggregateOutputType | null
  }

  export type Ability_orderAvgAggregateOutputType = {
    pokemonInfoId: number | null
    abilityId: number | null
    order: number | null
  }

  export type Ability_orderSumAggregateOutputType = {
    pokemonInfoId: number | null
    abilityId: number | null
    order: number | null
  }

  export type Ability_orderMinAggregateOutputType = {
    pokemonInfoId: number | null
    abilityId: number | null
    order: number | null
    isHidden: boolean | null
  }

  export type Ability_orderMaxAggregateOutputType = {
    pokemonInfoId: number | null
    abilityId: number | null
    order: number | null
    isHidden: boolean | null
  }

  export type Ability_orderCountAggregateOutputType = {
    pokemonInfoId: number
    abilityId: number
    order: number
    isHidden: number
    _all: number
  }


  export type Ability_orderAvgAggregateInputType = {
    pokemonInfoId?: true
    abilityId?: true
    order?: true
  }

  export type Ability_orderSumAggregateInputType = {
    pokemonInfoId?: true
    abilityId?: true
    order?: true
  }

  export type Ability_orderMinAggregateInputType = {
    pokemonInfoId?: true
    abilityId?: true
    order?: true
    isHidden?: true
  }

  export type Ability_orderMaxAggregateInputType = {
    pokemonInfoId?: true
    abilityId?: true
    order?: true
    isHidden?: true
  }

  export type Ability_orderCountAggregateInputType = {
    pokemonInfoId?: true
    abilityId?: true
    order?: true
    isHidden?: true
    _all?: true
  }

  export type Ability_orderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ability_order to aggregate.
     */
    where?: ability_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ability_orders to fetch.
     */
    orderBy?: ability_orderOrderByWithRelationInput | ability_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ability_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ability_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ability_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ability_orders
    **/
    _count?: true | Ability_orderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ability_orderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ability_orderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ability_orderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ability_orderMaxAggregateInputType
  }

  export type GetAbility_orderAggregateType<T extends Ability_orderAggregateArgs> = {
        [P in keyof T & keyof AggregateAbility_order]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbility_order[P]>
      : GetScalarType<T[P], AggregateAbility_order[P]>
  }




  export type ability_orderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ability_orderWhereInput
    orderBy?: ability_orderOrderByWithAggregationInput | ability_orderOrderByWithAggregationInput[]
    by: Ability_orderScalarFieldEnum[] | Ability_orderScalarFieldEnum
    having?: ability_orderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ability_orderCountAggregateInputType | true
    _avg?: Ability_orderAvgAggregateInputType
    _sum?: Ability_orderSumAggregateInputType
    _min?: Ability_orderMinAggregateInputType
    _max?: Ability_orderMaxAggregateInputType
  }

  export type Ability_orderGroupByOutputType = {
    pokemonInfoId: number
    abilityId: number
    order: number
    isHidden: boolean
    _count: Ability_orderCountAggregateOutputType | null
    _avg: Ability_orderAvgAggregateOutputType | null
    _sum: Ability_orderSumAggregateOutputType | null
    _min: Ability_orderMinAggregateOutputType | null
    _max: Ability_orderMaxAggregateOutputType | null
  }

  type GetAbility_orderGroupByPayload<T extends ability_orderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ability_orderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ability_orderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ability_orderGroupByOutputType[P]>
            : GetScalarType<T[P], Ability_orderGroupByOutputType[P]>
        }
      >
    >


  export type ability_orderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pokemonInfoId?: boolean
    abilityId?: boolean
    order?: boolean
    isHidden?: boolean
    ability?: boolean | abilityDefaultArgs<ExtArgs>
    pokemonInfo?: boolean | pokemon_infoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ability_order"]>



  export type ability_orderSelectScalar = {
    pokemonInfoId?: boolean
    abilityId?: boolean
    order?: boolean
    isHidden?: boolean
  }

  export type ability_orderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pokemonInfoId" | "abilityId" | "order" | "isHidden", ExtArgs["result"]["ability_order"]>
  export type ability_orderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ability?: boolean | abilityDefaultArgs<ExtArgs>
    pokemonInfo?: boolean | pokemon_infoDefaultArgs<ExtArgs>
  }

  export type $ability_orderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ability_order"
    objects: {
      ability: Prisma.$abilityPayload<ExtArgs>
      pokemonInfo: Prisma.$pokemon_infoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      pokemonInfoId: number
      abilityId: number
      order: number
      isHidden: boolean
    }, ExtArgs["result"]["ability_order"]>
    composites: {}
  }

  type ability_orderGetPayload<S extends boolean | null | undefined | ability_orderDefaultArgs> = $Result.GetResult<Prisma.$ability_orderPayload, S>

  type ability_orderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ability_orderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ability_orderCountAggregateInputType | true
    }

  export interface ability_orderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ability_order'], meta: { name: 'ability_order' } }
    /**
     * Find zero or one Ability_order that matches the filter.
     * @param {ability_orderFindUniqueArgs} args - Arguments to find a Ability_order
     * @example
     * // Get one Ability_order
     * const ability_order = await prisma.ability_order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ability_orderFindUniqueArgs>(args: SelectSubset<T, ability_orderFindUniqueArgs<ExtArgs>>): Prisma__ability_orderClient<$Result.GetResult<Prisma.$ability_orderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ability_order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ability_orderFindUniqueOrThrowArgs} args - Arguments to find a Ability_order
     * @example
     * // Get one Ability_order
     * const ability_order = await prisma.ability_order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ability_orderFindUniqueOrThrowArgs>(args: SelectSubset<T, ability_orderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ability_orderClient<$Result.GetResult<Prisma.$ability_orderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ability_order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ability_orderFindFirstArgs} args - Arguments to find a Ability_order
     * @example
     * // Get one Ability_order
     * const ability_order = await prisma.ability_order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ability_orderFindFirstArgs>(args?: SelectSubset<T, ability_orderFindFirstArgs<ExtArgs>>): Prisma__ability_orderClient<$Result.GetResult<Prisma.$ability_orderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ability_order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ability_orderFindFirstOrThrowArgs} args - Arguments to find a Ability_order
     * @example
     * // Get one Ability_order
     * const ability_order = await prisma.ability_order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ability_orderFindFirstOrThrowArgs>(args?: SelectSubset<T, ability_orderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ability_orderClient<$Result.GetResult<Prisma.$ability_orderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ability_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ability_orderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ability_orders
     * const ability_orders = await prisma.ability_order.findMany()
     * 
     * // Get first 10 Ability_orders
     * const ability_orders = await prisma.ability_order.findMany({ take: 10 })
     * 
     * // Only select the `pokemonInfoId`
     * const ability_orderWithPokemonInfoIdOnly = await prisma.ability_order.findMany({ select: { pokemonInfoId: true } })
     * 
     */
    findMany<T extends ability_orderFindManyArgs>(args?: SelectSubset<T, ability_orderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ability_orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ability_order.
     * @param {ability_orderCreateArgs} args - Arguments to create a Ability_order.
     * @example
     * // Create one Ability_order
     * const Ability_order = await prisma.ability_order.create({
     *   data: {
     *     // ... data to create a Ability_order
     *   }
     * })
     * 
     */
    create<T extends ability_orderCreateArgs>(args: SelectSubset<T, ability_orderCreateArgs<ExtArgs>>): Prisma__ability_orderClient<$Result.GetResult<Prisma.$ability_orderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ability_orders.
     * @param {ability_orderCreateManyArgs} args - Arguments to create many Ability_orders.
     * @example
     * // Create many Ability_orders
     * const ability_order = await prisma.ability_order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ability_orderCreateManyArgs>(args?: SelectSubset<T, ability_orderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ability_order.
     * @param {ability_orderDeleteArgs} args - Arguments to delete one Ability_order.
     * @example
     * // Delete one Ability_order
     * const Ability_order = await prisma.ability_order.delete({
     *   where: {
     *     // ... filter to delete one Ability_order
     *   }
     * })
     * 
     */
    delete<T extends ability_orderDeleteArgs>(args: SelectSubset<T, ability_orderDeleteArgs<ExtArgs>>): Prisma__ability_orderClient<$Result.GetResult<Prisma.$ability_orderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ability_order.
     * @param {ability_orderUpdateArgs} args - Arguments to update one Ability_order.
     * @example
     * // Update one Ability_order
     * const ability_order = await prisma.ability_order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ability_orderUpdateArgs>(args: SelectSubset<T, ability_orderUpdateArgs<ExtArgs>>): Prisma__ability_orderClient<$Result.GetResult<Prisma.$ability_orderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ability_orders.
     * @param {ability_orderDeleteManyArgs} args - Arguments to filter Ability_orders to delete.
     * @example
     * // Delete a few Ability_orders
     * const { count } = await prisma.ability_order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ability_orderDeleteManyArgs>(args?: SelectSubset<T, ability_orderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ability_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ability_orderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ability_orders
     * const ability_order = await prisma.ability_order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ability_orderUpdateManyArgs>(args: SelectSubset<T, ability_orderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ability_order.
     * @param {ability_orderUpsertArgs} args - Arguments to update or create a Ability_order.
     * @example
     * // Update or create a Ability_order
     * const ability_order = await prisma.ability_order.upsert({
     *   create: {
     *     // ... data to create a Ability_order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ability_order we want to update
     *   }
     * })
     */
    upsert<T extends ability_orderUpsertArgs>(args: SelectSubset<T, ability_orderUpsertArgs<ExtArgs>>): Prisma__ability_orderClient<$Result.GetResult<Prisma.$ability_orderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ability_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ability_orderCountArgs} args - Arguments to filter Ability_orders to count.
     * @example
     * // Count the number of Ability_orders
     * const count = await prisma.ability_order.count({
     *   where: {
     *     // ... the filter for the Ability_orders we want to count
     *   }
     * })
    **/
    count<T extends ability_orderCountArgs>(
      args?: Subset<T, ability_orderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ability_orderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ability_order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ability_orderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ability_orderAggregateArgs>(args: Subset<T, Ability_orderAggregateArgs>): Prisma.PrismaPromise<GetAbility_orderAggregateType<T>>

    /**
     * Group by Ability_order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ability_orderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ability_orderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ability_orderGroupByArgs['orderBy'] }
        : { orderBy?: ability_orderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ability_orderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbility_orderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ability_order model
   */
  readonly fields: ability_orderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ability_order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ability_orderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ability<T extends abilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, abilityDefaultArgs<ExtArgs>>): Prisma__abilityClient<$Result.GetResult<Prisma.$abilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemonInfo<T extends pokemon_infoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_infoDefaultArgs<ExtArgs>>): Prisma__pokemon_infoClient<$Result.GetResult<Prisma.$pokemon_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ability_order model
   */
  interface ability_orderFieldRefs {
    readonly pokemonInfoId: FieldRef<"ability_order", 'Int'>
    readonly abilityId: FieldRef<"ability_order", 'Int'>
    readonly order: FieldRef<"ability_order", 'Int'>
    readonly isHidden: FieldRef<"ability_order", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ability_order findUnique
   */
  export type ability_orderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_order
     */
    select?: ability_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_order
     */
    omit?: ability_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_orderInclude<ExtArgs> | null
    /**
     * Filter, which ability_order to fetch.
     */
    where: ability_orderWhereUniqueInput
  }

  /**
   * ability_order findUniqueOrThrow
   */
  export type ability_orderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_order
     */
    select?: ability_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_order
     */
    omit?: ability_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_orderInclude<ExtArgs> | null
    /**
     * Filter, which ability_order to fetch.
     */
    where: ability_orderWhereUniqueInput
  }

  /**
   * ability_order findFirst
   */
  export type ability_orderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_order
     */
    select?: ability_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_order
     */
    omit?: ability_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_orderInclude<ExtArgs> | null
    /**
     * Filter, which ability_order to fetch.
     */
    where?: ability_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ability_orders to fetch.
     */
    orderBy?: ability_orderOrderByWithRelationInput | ability_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ability_orders.
     */
    cursor?: ability_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ability_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ability_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ability_orders.
     */
    distinct?: Ability_orderScalarFieldEnum | Ability_orderScalarFieldEnum[]
  }

  /**
   * ability_order findFirstOrThrow
   */
  export type ability_orderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_order
     */
    select?: ability_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_order
     */
    omit?: ability_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_orderInclude<ExtArgs> | null
    /**
     * Filter, which ability_order to fetch.
     */
    where?: ability_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ability_orders to fetch.
     */
    orderBy?: ability_orderOrderByWithRelationInput | ability_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ability_orders.
     */
    cursor?: ability_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ability_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ability_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ability_orders.
     */
    distinct?: Ability_orderScalarFieldEnum | Ability_orderScalarFieldEnum[]
  }

  /**
   * ability_order findMany
   */
  export type ability_orderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_order
     */
    select?: ability_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_order
     */
    omit?: ability_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_orderInclude<ExtArgs> | null
    /**
     * Filter, which ability_orders to fetch.
     */
    where?: ability_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ability_orders to fetch.
     */
    orderBy?: ability_orderOrderByWithRelationInput | ability_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ability_orders.
     */
    cursor?: ability_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ability_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ability_orders.
     */
    skip?: number
    distinct?: Ability_orderScalarFieldEnum | Ability_orderScalarFieldEnum[]
  }

  /**
   * ability_order create
   */
  export type ability_orderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_order
     */
    select?: ability_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_order
     */
    omit?: ability_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_orderInclude<ExtArgs> | null
    /**
     * The data needed to create a ability_order.
     */
    data: XOR<ability_orderCreateInput, ability_orderUncheckedCreateInput>
  }

  /**
   * ability_order createMany
   */
  export type ability_orderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ability_orders.
     */
    data: ability_orderCreateManyInput | ability_orderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ability_order update
   */
  export type ability_orderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_order
     */
    select?: ability_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_order
     */
    omit?: ability_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_orderInclude<ExtArgs> | null
    /**
     * The data needed to update a ability_order.
     */
    data: XOR<ability_orderUpdateInput, ability_orderUncheckedUpdateInput>
    /**
     * Choose, which ability_order to update.
     */
    where: ability_orderWhereUniqueInput
  }

  /**
   * ability_order updateMany
   */
  export type ability_orderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ability_orders.
     */
    data: XOR<ability_orderUpdateManyMutationInput, ability_orderUncheckedUpdateManyInput>
    /**
     * Filter which ability_orders to update
     */
    where?: ability_orderWhereInput
    /**
     * Limit how many ability_orders to update.
     */
    limit?: number
  }

  /**
   * ability_order upsert
   */
  export type ability_orderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_order
     */
    select?: ability_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_order
     */
    omit?: ability_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_orderInclude<ExtArgs> | null
    /**
     * The filter to search for the ability_order to update in case it exists.
     */
    where: ability_orderWhereUniqueInput
    /**
     * In case the ability_order found by the `where` argument doesn't exist, create a new ability_order with this data.
     */
    create: XOR<ability_orderCreateInput, ability_orderUncheckedCreateInput>
    /**
     * In case the ability_order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ability_orderUpdateInput, ability_orderUncheckedUpdateInput>
  }

  /**
   * ability_order delete
   */
  export type ability_orderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_order
     */
    select?: ability_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_order
     */
    omit?: ability_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_orderInclude<ExtArgs> | null
    /**
     * Filter which ability_order to delete.
     */
    where: ability_orderWhereUniqueInput
  }

  /**
   * ability_order deleteMany
   */
  export type ability_orderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ability_orders to delete
     */
    where?: ability_orderWhereInput
    /**
     * Limit how many ability_orders to delete.
     */
    limit?: number
  }

  /**
   * ability_order without action
   */
  export type ability_orderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_order
     */
    select?: ability_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_order
     */
    omit?: ability_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_orderInclude<ExtArgs> | null
  }


  /**
   * Model evolution_method
   */

  export type AggregateEvolution_method = {
    _count: Evolution_methodCountAggregateOutputType | null
    _avg: Evolution_methodAvgAggregateOutputType | null
    _sum: Evolution_methodSumAggregateOutputType | null
    _min: Evolution_methodMinAggregateOutputType | null
    _max: Evolution_methodMaxAggregateOutputType | null
  }

  export type Evolution_methodAvgAggregateOutputType = {
    id: number | null
  }

  export type Evolution_methodSumAggregateOutputType = {
    id: number | null
  }

  export type Evolution_methodMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Evolution_methodMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Evolution_methodCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Evolution_methodAvgAggregateInputType = {
    id?: true
  }

  export type Evolution_methodSumAggregateInputType = {
    id?: true
  }

  export type Evolution_methodMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Evolution_methodMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Evolution_methodCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Evolution_methodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which evolution_method to aggregate.
     */
    where?: evolution_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evolution_methods to fetch.
     */
    orderBy?: evolution_methodOrderByWithRelationInput | evolution_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: evolution_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evolution_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evolution_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned evolution_methods
    **/
    _count?: true | Evolution_methodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Evolution_methodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Evolution_methodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Evolution_methodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Evolution_methodMaxAggregateInputType
  }

  export type GetEvolution_methodAggregateType<T extends Evolution_methodAggregateArgs> = {
        [P in keyof T & keyof AggregateEvolution_method]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvolution_method[P]>
      : GetScalarType<T[P], AggregateEvolution_method[P]>
  }




  export type evolution_methodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: evolution_methodWhereInput
    orderBy?: evolution_methodOrderByWithAggregationInput | evolution_methodOrderByWithAggregationInput[]
    by: Evolution_methodScalarFieldEnum[] | Evolution_methodScalarFieldEnum
    having?: evolution_methodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Evolution_methodCountAggregateInputType | true
    _avg?: Evolution_methodAvgAggregateInputType
    _sum?: Evolution_methodSumAggregateInputType
    _min?: Evolution_methodMinAggregateInputType
    _max?: Evolution_methodMaxAggregateInputType
  }

  export type Evolution_methodGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Evolution_methodCountAggregateOutputType | null
    _avg: Evolution_methodAvgAggregateOutputType | null
    _sum: Evolution_methodSumAggregateOutputType | null
    _min: Evolution_methodMinAggregateOutputType | null
    _max: Evolution_methodMaxAggregateOutputType | null
  }

  type GetEvolution_methodGroupByPayload<T extends evolution_methodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Evolution_methodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Evolution_methodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Evolution_methodGroupByOutputType[P]>
            : GetScalarType<T[P], Evolution_methodGroupByOutputType[P]>
        }
      >
    >


  export type evolution_methodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    evolutions?: boolean | evolution_method$evolutionsArgs<ExtArgs>
    _count?: boolean | Evolution_methodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolution_method"]>



  export type evolution_methodSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type evolution_methodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["evolution_method"]>
  export type evolution_methodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolutions?: boolean | evolution_method$evolutionsArgs<ExtArgs>
    _count?: boolean | Evolution_methodCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $evolution_methodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "evolution_method"
    objects: {
      evolutions: Prisma.$evolutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["evolution_method"]>
    composites: {}
  }

  type evolution_methodGetPayload<S extends boolean | null | undefined | evolution_methodDefaultArgs> = $Result.GetResult<Prisma.$evolution_methodPayload, S>

  type evolution_methodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<evolution_methodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Evolution_methodCountAggregateInputType | true
    }

  export interface evolution_methodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['evolution_method'], meta: { name: 'evolution_method' } }
    /**
     * Find zero or one Evolution_method that matches the filter.
     * @param {evolution_methodFindUniqueArgs} args - Arguments to find a Evolution_method
     * @example
     * // Get one Evolution_method
     * const evolution_method = await prisma.evolution_method.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends evolution_methodFindUniqueArgs>(args: SelectSubset<T, evolution_methodFindUniqueArgs<ExtArgs>>): Prisma__evolution_methodClient<$Result.GetResult<Prisma.$evolution_methodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Evolution_method that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {evolution_methodFindUniqueOrThrowArgs} args - Arguments to find a Evolution_method
     * @example
     * // Get one Evolution_method
     * const evolution_method = await prisma.evolution_method.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends evolution_methodFindUniqueOrThrowArgs>(args: SelectSubset<T, evolution_methodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__evolution_methodClient<$Result.GetResult<Prisma.$evolution_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evolution_method that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolution_methodFindFirstArgs} args - Arguments to find a Evolution_method
     * @example
     * // Get one Evolution_method
     * const evolution_method = await prisma.evolution_method.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends evolution_methodFindFirstArgs>(args?: SelectSubset<T, evolution_methodFindFirstArgs<ExtArgs>>): Prisma__evolution_methodClient<$Result.GetResult<Prisma.$evolution_methodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evolution_method that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolution_methodFindFirstOrThrowArgs} args - Arguments to find a Evolution_method
     * @example
     * // Get one Evolution_method
     * const evolution_method = await prisma.evolution_method.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends evolution_methodFindFirstOrThrowArgs>(args?: SelectSubset<T, evolution_methodFindFirstOrThrowArgs<ExtArgs>>): Prisma__evolution_methodClient<$Result.GetResult<Prisma.$evolution_methodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Evolution_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolution_methodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evolution_methods
     * const evolution_methods = await prisma.evolution_method.findMany()
     * 
     * // Get first 10 Evolution_methods
     * const evolution_methods = await prisma.evolution_method.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evolution_methodWithIdOnly = await prisma.evolution_method.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends evolution_methodFindManyArgs>(args?: SelectSubset<T, evolution_methodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$evolution_methodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Evolution_method.
     * @param {evolution_methodCreateArgs} args - Arguments to create a Evolution_method.
     * @example
     * // Create one Evolution_method
     * const Evolution_method = await prisma.evolution_method.create({
     *   data: {
     *     // ... data to create a Evolution_method
     *   }
     * })
     * 
     */
    create<T extends evolution_methodCreateArgs>(args: SelectSubset<T, evolution_methodCreateArgs<ExtArgs>>): Prisma__evolution_methodClient<$Result.GetResult<Prisma.$evolution_methodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Evolution_methods.
     * @param {evolution_methodCreateManyArgs} args - Arguments to create many Evolution_methods.
     * @example
     * // Create many Evolution_methods
     * const evolution_method = await prisma.evolution_method.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends evolution_methodCreateManyArgs>(args?: SelectSubset<T, evolution_methodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Evolution_method.
     * @param {evolution_methodDeleteArgs} args - Arguments to delete one Evolution_method.
     * @example
     * // Delete one Evolution_method
     * const Evolution_method = await prisma.evolution_method.delete({
     *   where: {
     *     // ... filter to delete one Evolution_method
     *   }
     * })
     * 
     */
    delete<T extends evolution_methodDeleteArgs>(args: SelectSubset<T, evolution_methodDeleteArgs<ExtArgs>>): Prisma__evolution_methodClient<$Result.GetResult<Prisma.$evolution_methodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Evolution_method.
     * @param {evolution_methodUpdateArgs} args - Arguments to update one Evolution_method.
     * @example
     * // Update one Evolution_method
     * const evolution_method = await prisma.evolution_method.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends evolution_methodUpdateArgs>(args: SelectSubset<T, evolution_methodUpdateArgs<ExtArgs>>): Prisma__evolution_methodClient<$Result.GetResult<Prisma.$evolution_methodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Evolution_methods.
     * @param {evolution_methodDeleteManyArgs} args - Arguments to filter Evolution_methods to delete.
     * @example
     * // Delete a few Evolution_methods
     * const { count } = await prisma.evolution_method.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends evolution_methodDeleteManyArgs>(args?: SelectSubset<T, evolution_methodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evolution_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolution_methodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evolution_methods
     * const evolution_method = await prisma.evolution_method.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends evolution_methodUpdateManyArgs>(args: SelectSubset<T, evolution_methodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evolution_method.
     * @param {evolution_methodUpsertArgs} args - Arguments to update or create a Evolution_method.
     * @example
     * // Update or create a Evolution_method
     * const evolution_method = await prisma.evolution_method.upsert({
     *   create: {
     *     // ... data to create a Evolution_method
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evolution_method we want to update
     *   }
     * })
     */
    upsert<T extends evolution_methodUpsertArgs>(args: SelectSubset<T, evolution_methodUpsertArgs<ExtArgs>>): Prisma__evolution_methodClient<$Result.GetResult<Prisma.$evolution_methodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Evolution_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolution_methodCountArgs} args - Arguments to filter Evolution_methods to count.
     * @example
     * // Count the number of Evolution_methods
     * const count = await prisma.evolution_method.count({
     *   where: {
     *     // ... the filter for the Evolution_methods we want to count
     *   }
     * })
    **/
    count<T extends evolution_methodCountArgs>(
      args?: Subset<T, evolution_methodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Evolution_methodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evolution_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Evolution_methodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Evolution_methodAggregateArgs>(args: Subset<T, Evolution_methodAggregateArgs>): Prisma.PrismaPromise<GetEvolution_methodAggregateType<T>>

    /**
     * Group by Evolution_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolution_methodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends evolution_methodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: evolution_methodGroupByArgs['orderBy'] }
        : { orderBy?: evolution_methodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, evolution_methodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvolution_methodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the evolution_method model
   */
  readonly fields: evolution_methodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for evolution_method.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__evolution_methodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evolutions<T extends evolution_method$evolutionsArgs<ExtArgs> = {}>(args?: Subset<T, evolution_method$evolutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$evolutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the evolution_method model
   */
  interface evolution_methodFieldRefs {
    readonly id: FieldRef<"evolution_method", 'Int'>
    readonly createdAt: FieldRef<"evolution_method", 'DateTime'>
    readonly updatedAt: FieldRef<"evolution_method", 'DateTime'>
    readonly status: FieldRef<"evolution_method", 'String'>
  }
    

  // Custom InputTypes
  /**
   * evolution_method findUnique
   */
  export type evolution_methodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_method
     */
    select?: evolution_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_method
     */
    omit?: evolution_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_methodInclude<ExtArgs> | null
    /**
     * Filter, which evolution_method to fetch.
     */
    where: evolution_methodWhereUniqueInput
  }

  /**
   * evolution_method findUniqueOrThrow
   */
  export type evolution_methodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_method
     */
    select?: evolution_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_method
     */
    omit?: evolution_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_methodInclude<ExtArgs> | null
    /**
     * Filter, which evolution_method to fetch.
     */
    where: evolution_methodWhereUniqueInput
  }

  /**
   * evolution_method findFirst
   */
  export type evolution_methodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_method
     */
    select?: evolution_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_method
     */
    omit?: evolution_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_methodInclude<ExtArgs> | null
    /**
     * Filter, which evolution_method to fetch.
     */
    where?: evolution_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evolution_methods to fetch.
     */
    orderBy?: evolution_methodOrderByWithRelationInput | evolution_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for evolution_methods.
     */
    cursor?: evolution_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evolution_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evolution_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of evolution_methods.
     */
    distinct?: Evolution_methodScalarFieldEnum | Evolution_methodScalarFieldEnum[]
  }

  /**
   * evolution_method findFirstOrThrow
   */
  export type evolution_methodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_method
     */
    select?: evolution_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_method
     */
    omit?: evolution_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_methodInclude<ExtArgs> | null
    /**
     * Filter, which evolution_method to fetch.
     */
    where?: evolution_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evolution_methods to fetch.
     */
    orderBy?: evolution_methodOrderByWithRelationInput | evolution_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for evolution_methods.
     */
    cursor?: evolution_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evolution_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evolution_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of evolution_methods.
     */
    distinct?: Evolution_methodScalarFieldEnum | Evolution_methodScalarFieldEnum[]
  }

  /**
   * evolution_method findMany
   */
  export type evolution_methodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_method
     */
    select?: evolution_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_method
     */
    omit?: evolution_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_methodInclude<ExtArgs> | null
    /**
     * Filter, which evolution_methods to fetch.
     */
    where?: evolution_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evolution_methods to fetch.
     */
    orderBy?: evolution_methodOrderByWithRelationInput | evolution_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing evolution_methods.
     */
    cursor?: evolution_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evolution_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evolution_methods.
     */
    skip?: number
    distinct?: Evolution_methodScalarFieldEnum | Evolution_methodScalarFieldEnum[]
  }

  /**
   * evolution_method create
   */
  export type evolution_methodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_method
     */
    select?: evolution_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_method
     */
    omit?: evolution_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_methodInclude<ExtArgs> | null
    /**
     * The data needed to create a evolution_method.
     */
    data?: XOR<evolution_methodCreateInput, evolution_methodUncheckedCreateInput>
  }

  /**
   * evolution_method createMany
   */
  export type evolution_methodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many evolution_methods.
     */
    data: evolution_methodCreateManyInput | evolution_methodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * evolution_method update
   */
  export type evolution_methodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_method
     */
    select?: evolution_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_method
     */
    omit?: evolution_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_methodInclude<ExtArgs> | null
    /**
     * The data needed to update a evolution_method.
     */
    data: XOR<evolution_methodUpdateInput, evolution_methodUncheckedUpdateInput>
    /**
     * Choose, which evolution_method to update.
     */
    where: evolution_methodWhereUniqueInput
  }

  /**
   * evolution_method updateMany
   */
  export type evolution_methodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update evolution_methods.
     */
    data: XOR<evolution_methodUpdateManyMutationInput, evolution_methodUncheckedUpdateManyInput>
    /**
     * Filter which evolution_methods to update
     */
    where?: evolution_methodWhereInput
    /**
     * Limit how many evolution_methods to update.
     */
    limit?: number
  }

  /**
   * evolution_method upsert
   */
  export type evolution_methodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_method
     */
    select?: evolution_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_method
     */
    omit?: evolution_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_methodInclude<ExtArgs> | null
    /**
     * The filter to search for the evolution_method to update in case it exists.
     */
    where: evolution_methodWhereUniqueInput
    /**
     * In case the evolution_method found by the `where` argument doesn't exist, create a new evolution_method with this data.
     */
    create: XOR<evolution_methodCreateInput, evolution_methodUncheckedCreateInput>
    /**
     * In case the evolution_method was found with the provided `where` argument, update it with this data.
     */
    update: XOR<evolution_methodUpdateInput, evolution_methodUncheckedUpdateInput>
  }

  /**
   * evolution_method delete
   */
  export type evolution_methodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_method
     */
    select?: evolution_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_method
     */
    omit?: evolution_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_methodInclude<ExtArgs> | null
    /**
     * Filter which evolution_method to delete.
     */
    where: evolution_methodWhereUniqueInput
  }

  /**
   * evolution_method deleteMany
   */
  export type evolution_methodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which evolution_methods to delete
     */
    where?: evolution_methodWhereInput
    /**
     * Limit how many evolution_methods to delete.
     */
    limit?: number
  }

  /**
   * evolution_method.evolutions
   */
  export type evolution_method$evolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution
     */
    select?: evolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution
     */
    omit?: evolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolutionInclude<ExtArgs> | null
    where?: evolutionWhereInput
    orderBy?: evolutionOrderByWithRelationInput | evolutionOrderByWithRelationInput[]
    cursor?: evolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvolutionScalarFieldEnum | EvolutionScalarFieldEnum[]
  }

  /**
   * evolution_method without action
   */
  export type evolution_methodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_method
     */
    select?: evolution_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_method
     */
    omit?: evolution_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_methodInclude<ExtArgs> | null
  }


  /**
   * Model evolution
   */

  export type AggregateEvolution = {
    _count: EvolutionCountAggregateOutputType | null
    _avg: EvolutionAvgAggregateOutputType | null
    _sum: EvolutionSumAggregateOutputType | null
    _min: EvolutionMinAggregateOutputType | null
    _max: EvolutionMaxAggregateOutputType | null
  }

  export type EvolutionAvgAggregateOutputType = {
    id: number | null
    level: number | null
    evolutionMethodId: number | null
    pokemonFormStartId: number | null
    pokemonFormEndId: number | null
    evolutionInfoId: number | null
  }

  export type EvolutionSumAggregateOutputType = {
    id: number | null
    level: number | null
    evolutionMethodId: number | null
    pokemonFormStartId: number | null
    pokemonFormEndId: number | null
    evolutionInfoId: number | null
  }

  export type EvolutionMinAggregateOutputType = {
    id: number | null
    level: number | null
    evolutionMethodId: number | null
    pokemonFormStartId: number | null
    pokemonFormEndId: number | null
    evolutionInfoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type EvolutionMaxAggregateOutputType = {
    id: number | null
    level: number | null
    evolutionMethodId: number | null
    pokemonFormStartId: number | null
    pokemonFormEndId: number | null
    evolutionInfoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type EvolutionCountAggregateOutputType = {
    id: number
    level: number
    evolutionMethodId: number
    pokemonFormStartId: number
    pokemonFormEndId: number
    evolutionInfoId: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type EvolutionAvgAggregateInputType = {
    id?: true
    level?: true
    evolutionMethodId?: true
    pokemonFormStartId?: true
    pokemonFormEndId?: true
    evolutionInfoId?: true
  }

  export type EvolutionSumAggregateInputType = {
    id?: true
    level?: true
    evolutionMethodId?: true
    pokemonFormStartId?: true
    pokemonFormEndId?: true
    evolutionInfoId?: true
  }

  export type EvolutionMinAggregateInputType = {
    id?: true
    level?: true
    evolutionMethodId?: true
    pokemonFormStartId?: true
    pokemonFormEndId?: true
    evolutionInfoId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type EvolutionMaxAggregateInputType = {
    id?: true
    level?: true
    evolutionMethodId?: true
    pokemonFormStartId?: true
    pokemonFormEndId?: true
    evolutionInfoId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type EvolutionCountAggregateInputType = {
    id?: true
    level?: true
    evolutionMethodId?: true
    pokemonFormStartId?: true
    pokemonFormEndId?: true
    evolutionInfoId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type EvolutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which evolution to aggregate.
     */
    where?: evolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evolutions to fetch.
     */
    orderBy?: evolutionOrderByWithRelationInput | evolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: evolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned evolutions
    **/
    _count?: true | EvolutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvolutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvolutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvolutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvolutionMaxAggregateInputType
  }

  export type GetEvolutionAggregateType<T extends EvolutionAggregateArgs> = {
        [P in keyof T & keyof AggregateEvolution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvolution[P]>
      : GetScalarType<T[P], AggregateEvolution[P]>
  }




  export type evolutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: evolutionWhereInput
    orderBy?: evolutionOrderByWithAggregationInput | evolutionOrderByWithAggregationInput[]
    by: EvolutionScalarFieldEnum[] | EvolutionScalarFieldEnum
    having?: evolutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvolutionCountAggregateInputType | true
    _avg?: EvolutionAvgAggregateInputType
    _sum?: EvolutionSumAggregateInputType
    _min?: EvolutionMinAggregateInputType
    _max?: EvolutionMaxAggregateInputType
  }

  export type EvolutionGroupByOutputType = {
    id: number
    level: number | null
    evolutionMethodId: number
    pokemonFormStartId: number
    pokemonFormEndId: number
    evolutionInfoId: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: EvolutionCountAggregateOutputType | null
    _avg: EvolutionAvgAggregateOutputType | null
    _sum: EvolutionSumAggregateOutputType | null
    _min: EvolutionMinAggregateOutputType | null
    _max: EvolutionMaxAggregateOutputType | null
  }

  type GetEvolutionGroupByPayload<T extends evolutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvolutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvolutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvolutionGroupByOutputType[P]>
            : GetScalarType<T[P], EvolutionGroupByOutputType[P]>
        }
      >
    >


  export type evolutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    evolutionMethodId?: boolean
    pokemonFormStartId?: boolean
    pokemonFormEndId?: boolean
    evolutionInfoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    evolutionInfo?: boolean | evolution_infoDefaultArgs<ExtArgs>
    evolutionMethod?: boolean | evolution_methodDefaultArgs<ExtArgs>
    pokemonEnd?: boolean | pokemon_formDefaultArgs<ExtArgs>
    pokemonStart?: boolean | pokemon_formDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolution"]>



  export type evolutionSelectScalar = {
    id?: boolean
    level?: boolean
    evolutionMethodId?: boolean
    pokemonFormStartId?: boolean
    pokemonFormEndId?: boolean
    evolutionInfoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type evolutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "level" | "evolutionMethodId" | "pokemonFormStartId" | "pokemonFormEndId" | "evolutionInfoId" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["evolution"]>
  export type evolutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolutionInfo?: boolean | evolution_infoDefaultArgs<ExtArgs>
    evolutionMethod?: boolean | evolution_methodDefaultArgs<ExtArgs>
    pokemonEnd?: boolean | pokemon_formDefaultArgs<ExtArgs>
    pokemonStart?: boolean | pokemon_formDefaultArgs<ExtArgs>
  }

  export type $evolutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "evolution"
    objects: {
      evolutionInfo: Prisma.$evolution_infoPayload<ExtArgs>
      evolutionMethod: Prisma.$evolution_methodPayload<ExtArgs>
      pokemonEnd: Prisma.$pokemon_formPayload<ExtArgs>
      pokemonStart: Prisma.$pokemon_formPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      level: number | null
      evolutionMethodId: number
      pokemonFormStartId: number
      pokemonFormEndId: number
      evolutionInfoId: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["evolution"]>
    composites: {}
  }

  type evolutionGetPayload<S extends boolean | null | undefined | evolutionDefaultArgs> = $Result.GetResult<Prisma.$evolutionPayload, S>

  type evolutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<evolutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvolutionCountAggregateInputType | true
    }

  export interface evolutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['evolution'], meta: { name: 'evolution' } }
    /**
     * Find zero or one Evolution that matches the filter.
     * @param {evolutionFindUniqueArgs} args - Arguments to find a Evolution
     * @example
     * // Get one Evolution
     * const evolution = await prisma.evolution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends evolutionFindUniqueArgs>(args: SelectSubset<T, evolutionFindUniqueArgs<ExtArgs>>): Prisma__evolutionClient<$Result.GetResult<Prisma.$evolutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Evolution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {evolutionFindUniqueOrThrowArgs} args - Arguments to find a Evolution
     * @example
     * // Get one Evolution
     * const evolution = await prisma.evolution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends evolutionFindUniqueOrThrowArgs>(args: SelectSubset<T, evolutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__evolutionClient<$Result.GetResult<Prisma.$evolutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evolution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolutionFindFirstArgs} args - Arguments to find a Evolution
     * @example
     * // Get one Evolution
     * const evolution = await prisma.evolution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends evolutionFindFirstArgs>(args?: SelectSubset<T, evolutionFindFirstArgs<ExtArgs>>): Prisma__evolutionClient<$Result.GetResult<Prisma.$evolutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evolution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolutionFindFirstOrThrowArgs} args - Arguments to find a Evolution
     * @example
     * // Get one Evolution
     * const evolution = await prisma.evolution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends evolutionFindFirstOrThrowArgs>(args?: SelectSubset<T, evolutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__evolutionClient<$Result.GetResult<Prisma.$evolutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Evolutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evolutions
     * const evolutions = await prisma.evolution.findMany()
     * 
     * // Get first 10 Evolutions
     * const evolutions = await prisma.evolution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evolutionWithIdOnly = await prisma.evolution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends evolutionFindManyArgs>(args?: SelectSubset<T, evolutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$evolutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Evolution.
     * @param {evolutionCreateArgs} args - Arguments to create a Evolution.
     * @example
     * // Create one Evolution
     * const Evolution = await prisma.evolution.create({
     *   data: {
     *     // ... data to create a Evolution
     *   }
     * })
     * 
     */
    create<T extends evolutionCreateArgs>(args: SelectSubset<T, evolutionCreateArgs<ExtArgs>>): Prisma__evolutionClient<$Result.GetResult<Prisma.$evolutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Evolutions.
     * @param {evolutionCreateManyArgs} args - Arguments to create many Evolutions.
     * @example
     * // Create many Evolutions
     * const evolution = await prisma.evolution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends evolutionCreateManyArgs>(args?: SelectSubset<T, evolutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Evolution.
     * @param {evolutionDeleteArgs} args - Arguments to delete one Evolution.
     * @example
     * // Delete one Evolution
     * const Evolution = await prisma.evolution.delete({
     *   where: {
     *     // ... filter to delete one Evolution
     *   }
     * })
     * 
     */
    delete<T extends evolutionDeleteArgs>(args: SelectSubset<T, evolutionDeleteArgs<ExtArgs>>): Prisma__evolutionClient<$Result.GetResult<Prisma.$evolutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Evolution.
     * @param {evolutionUpdateArgs} args - Arguments to update one Evolution.
     * @example
     * // Update one Evolution
     * const evolution = await prisma.evolution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends evolutionUpdateArgs>(args: SelectSubset<T, evolutionUpdateArgs<ExtArgs>>): Prisma__evolutionClient<$Result.GetResult<Prisma.$evolutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Evolutions.
     * @param {evolutionDeleteManyArgs} args - Arguments to filter Evolutions to delete.
     * @example
     * // Delete a few Evolutions
     * const { count } = await prisma.evolution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends evolutionDeleteManyArgs>(args?: SelectSubset<T, evolutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evolutions
     * const evolution = await prisma.evolution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends evolutionUpdateManyArgs>(args: SelectSubset<T, evolutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evolution.
     * @param {evolutionUpsertArgs} args - Arguments to update or create a Evolution.
     * @example
     * // Update or create a Evolution
     * const evolution = await prisma.evolution.upsert({
     *   create: {
     *     // ... data to create a Evolution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evolution we want to update
     *   }
     * })
     */
    upsert<T extends evolutionUpsertArgs>(args: SelectSubset<T, evolutionUpsertArgs<ExtArgs>>): Prisma__evolutionClient<$Result.GetResult<Prisma.$evolutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Evolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolutionCountArgs} args - Arguments to filter Evolutions to count.
     * @example
     * // Count the number of Evolutions
     * const count = await prisma.evolution.count({
     *   where: {
     *     // ... the filter for the Evolutions we want to count
     *   }
     * })
    **/
    count<T extends evolutionCountArgs>(
      args?: Subset<T, evolutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvolutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvolutionAggregateArgs>(args: Subset<T, EvolutionAggregateArgs>): Prisma.PrismaPromise<GetEvolutionAggregateType<T>>

    /**
     * Group by Evolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends evolutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: evolutionGroupByArgs['orderBy'] }
        : { orderBy?: evolutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, evolutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvolutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the evolution model
   */
  readonly fields: evolutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for evolution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__evolutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evolutionInfo<T extends evolution_infoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, evolution_infoDefaultArgs<ExtArgs>>): Prisma__evolution_infoClient<$Result.GetResult<Prisma.$evolution_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    evolutionMethod<T extends evolution_methodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, evolution_methodDefaultArgs<ExtArgs>>): Prisma__evolution_methodClient<$Result.GetResult<Prisma.$evolution_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemonEnd<T extends pokemon_formDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_formDefaultArgs<ExtArgs>>): Prisma__pokemon_formClient<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemonStart<T extends pokemon_formDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_formDefaultArgs<ExtArgs>>): Prisma__pokemon_formClient<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the evolution model
   */
  interface evolutionFieldRefs {
    readonly id: FieldRef<"evolution", 'Int'>
    readonly level: FieldRef<"evolution", 'Int'>
    readonly evolutionMethodId: FieldRef<"evolution", 'Int'>
    readonly pokemonFormStartId: FieldRef<"evolution", 'Int'>
    readonly pokemonFormEndId: FieldRef<"evolution", 'Int'>
    readonly evolutionInfoId: FieldRef<"evolution", 'Int'>
    readonly createdAt: FieldRef<"evolution", 'DateTime'>
    readonly updatedAt: FieldRef<"evolution", 'DateTime'>
    readonly status: FieldRef<"evolution", 'String'>
  }
    

  // Custom InputTypes
  /**
   * evolution findUnique
   */
  export type evolutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution
     */
    select?: evolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution
     */
    omit?: evolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolutionInclude<ExtArgs> | null
    /**
     * Filter, which evolution to fetch.
     */
    where: evolutionWhereUniqueInput
  }

  /**
   * evolution findUniqueOrThrow
   */
  export type evolutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution
     */
    select?: evolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution
     */
    omit?: evolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolutionInclude<ExtArgs> | null
    /**
     * Filter, which evolution to fetch.
     */
    where: evolutionWhereUniqueInput
  }

  /**
   * evolution findFirst
   */
  export type evolutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution
     */
    select?: evolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution
     */
    omit?: evolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolutionInclude<ExtArgs> | null
    /**
     * Filter, which evolution to fetch.
     */
    where?: evolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evolutions to fetch.
     */
    orderBy?: evolutionOrderByWithRelationInput | evolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for evolutions.
     */
    cursor?: evolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of evolutions.
     */
    distinct?: EvolutionScalarFieldEnum | EvolutionScalarFieldEnum[]
  }

  /**
   * evolution findFirstOrThrow
   */
  export type evolutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution
     */
    select?: evolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution
     */
    omit?: evolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolutionInclude<ExtArgs> | null
    /**
     * Filter, which evolution to fetch.
     */
    where?: evolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evolutions to fetch.
     */
    orderBy?: evolutionOrderByWithRelationInput | evolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for evolutions.
     */
    cursor?: evolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of evolutions.
     */
    distinct?: EvolutionScalarFieldEnum | EvolutionScalarFieldEnum[]
  }

  /**
   * evolution findMany
   */
  export type evolutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution
     */
    select?: evolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution
     */
    omit?: evolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolutionInclude<ExtArgs> | null
    /**
     * Filter, which evolutions to fetch.
     */
    where?: evolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evolutions to fetch.
     */
    orderBy?: evolutionOrderByWithRelationInput | evolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing evolutions.
     */
    cursor?: evolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evolutions.
     */
    skip?: number
    distinct?: EvolutionScalarFieldEnum | EvolutionScalarFieldEnum[]
  }

  /**
   * evolution create
   */
  export type evolutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution
     */
    select?: evolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution
     */
    omit?: evolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolutionInclude<ExtArgs> | null
    /**
     * The data needed to create a evolution.
     */
    data: XOR<evolutionCreateInput, evolutionUncheckedCreateInput>
  }

  /**
   * evolution createMany
   */
  export type evolutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many evolutions.
     */
    data: evolutionCreateManyInput | evolutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * evolution update
   */
  export type evolutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution
     */
    select?: evolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution
     */
    omit?: evolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolutionInclude<ExtArgs> | null
    /**
     * The data needed to update a evolution.
     */
    data: XOR<evolutionUpdateInput, evolutionUncheckedUpdateInput>
    /**
     * Choose, which evolution to update.
     */
    where: evolutionWhereUniqueInput
  }

  /**
   * evolution updateMany
   */
  export type evolutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update evolutions.
     */
    data: XOR<evolutionUpdateManyMutationInput, evolutionUncheckedUpdateManyInput>
    /**
     * Filter which evolutions to update
     */
    where?: evolutionWhereInput
    /**
     * Limit how many evolutions to update.
     */
    limit?: number
  }

  /**
   * evolution upsert
   */
  export type evolutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution
     */
    select?: evolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution
     */
    omit?: evolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolutionInclude<ExtArgs> | null
    /**
     * The filter to search for the evolution to update in case it exists.
     */
    where: evolutionWhereUniqueInput
    /**
     * In case the evolution found by the `where` argument doesn't exist, create a new evolution with this data.
     */
    create: XOR<evolutionCreateInput, evolutionUncheckedCreateInput>
    /**
     * In case the evolution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<evolutionUpdateInput, evolutionUncheckedUpdateInput>
  }

  /**
   * evolution delete
   */
  export type evolutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution
     */
    select?: evolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution
     */
    omit?: evolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolutionInclude<ExtArgs> | null
    /**
     * Filter which evolution to delete.
     */
    where: evolutionWhereUniqueInput
  }

  /**
   * evolution deleteMany
   */
  export type evolutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which evolutions to delete
     */
    where?: evolutionWhereInput
    /**
     * Limit how many evolutions to delete.
     */
    limit?: number
  }

  /**
   * evolution without action
   */
  export type evolutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution
     */
    select?: evolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution
     */
    omit?: evolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolutionInclude<ExtArgs> | null
  }


  /**
   * Model evolution_info
   */

  export type AggregateEvolution_info = {
    _count: Evolution_infoCountAggregateOutputType | null
    _avg: Evolution_infoAvgAggregateOutputType | null
    _sum: Evolution_infoSumAggregateOutputType | null
    _min: Evolution_infoMinAggregateOutputType | null
    _max: Evolution_infoMaxAggregateOutputType | null
  }

  export type Evolution_infoAvgAggregateOutputType = {
    id: number | null
  }

  export type Evolution_infoSumAggregateOutputType = {
    id: number | null
  }

  export type Evolution_infoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Evolution_infoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Evolution_infoCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Evolution_infoAvgAggregateInputType = {
    id?: true
  }

  export type Evolution_infoSumAggregateInputType = {
    id?: true
  }

  export type Evolution_infoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Evolution_infoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Evolution_infoCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Evolution_infoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which evolution_info to aggregate.
     */
    where?: evolution_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evolution_infos to fetch.
     */
    orderBy?: evolution_infoOrderByWithRelationInput | evolution_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: evolution_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evolution_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evolution_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned evolution_infos
    **/
    _count?: true | Evolution_infoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Evolution_infoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Evolution_infoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Evolution_infoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Evolution_infoMaxAggregateInputType
  }

  export type GetEvolution_infoAggregateType<T extends Evolution_infoAggregateArgs> = {
        [P in keyof T & keyof AggregateEvolution_info]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvolution_info[P]>
      : GetScalarType<T[P], AggregateEvolution_info[P]>
  }




  export type evolution_infoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: evolution_infoWhereInput
    orderBy?: evolution_infoOrderByWithAggregationInput | evolution_infoOrderByWithAggregationInput[]
    by: Evolution_infoScalarFieldEnum[] | Evolution_infoScalarFieldEnum
    having?: evolution_infoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Evolution_infoCountAggregateInputType | true
    _avg?: Evolution_infoAvgAggregateInputType
    _sum?: Evolution_infoSumAggregateInputType
    _min?: Evolution_infoMinAggregateInputType
    _max?: Evolution_infoMaxAggregateInputType
  }

  export type Evolution_infoGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Evolution_infoCountAggregateOutputType | null
    _avg: Evolution_infoAvgAggregateOutputType | null
    _sum: Evolution_infoSumAggregateOutputType | null
    _min: Evolution_infoMinAggregateOutputType | null
    _max: Evolution_infoMaxAggregateOutputType | null
  }

  type GetEvolution_infoGroupByPayload<T extends evolution_infoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Evolution_infoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Evolution_infoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Evolution_infoGroupByOutputType[P]>
            : GetScalarType<T[P], Evolution_infoGroupByOutputType[P]>
        }
      >
    >


  export type evolution_infoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    evolutions?: boolean | evolution_info$evolutionsArgs<ExtArgs>
    _count?: boolean | Evolution_infoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolution_info"]>



  export type evolution_infoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type evolution_infoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["evolution_info"]>
  export type evolution_infoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolutions?: boolean | evolution_info$evolutionsArgs<ExtArgs>
    _count?: boolean | Evolution_infoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $evolution_infoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "evolution_info"
    objects: {
      evolutions: Prisma.$evolutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["evolution_info"]>
    composites: {}
  }

  type evolution_infoGetPayload<S extends boolean | null | undefined | evolution_infoDefaultArgs> = $Result.GetResult<Prisma.$evolution_infoPayload, S>

  type evolution_infoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<evolution_infoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Evolution_infoCountAggregateInputType | true
    }

  export interface evolution_infoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['evolution_info'], meta: { name: 'evolution_info' } }
    /**
     * Find zero or one Evolution_info that matches the filter.
     * @param {evolution_infoFindUniqueArgs} args - Arguments to find a Evolution_info
     * @example
     * // Get one Evolution_info
     * const evolution_info = await prisma.evolution_info.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends evolution_infoFindUniqueArgs>(args: SelectSubset<T, evolution_infoFindUniqueArgs<ExtArgs>>): Prisma__evolution_infoClient<$Result.GetResult<Prisma.$evolution_infoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Evolution_info that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {evolution_infoFindUniqueOrThrowArgs} args - Arguments to find a Evolution_info
     * @example
     * // Get one Evolution_info
     * const evolution_info = await prisma.evolution_info.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends evolution_infoFindUniqueOrThrowArgs>(args: SelectSubset<T, evolution_infoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__evolution_infoClient<$Result.GetResult<Prisma.$evolution_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evolution_info that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolution_infoFindFirstArgs} args - Arguments to find a Evolution_info
     * @example
     * // Get one Evolution_info
     * const evolution_info = await prisma.evolution_info.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends evolution_infoFindFirstArgs>(args?: SelectSubset<T, evolution_infoFindFirstArgs<ExtArgs>>): Prisma__evolution_infoClient<$Result.GetResult<Prisma.$evolution_infoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evolution_info that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolution_infoFindFirstOrThrowArgs} args - Arguments to find a Evolution_info
     * @example
     * // Get one Evolution_info
     * const evolution_info = await prisma.evolution_info.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends evolution_infoFindFirstOrThrowArgs>(args?: SelectSubset<T, evolution_infoFindFirstOrThrowArgs<ExtArgs>>): Prisma__evolution_infoClient<$Result.GetResult<Prisma.$evolution_infoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Evolution_infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolution_infoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evolution_infos
     * const evolution_infos = await prisma.evolution_info.findMany()
     * 
     * // Get first 10 Evolution_infos
     * const evolution_infos = await prisma.evolution_info.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evolution_infoWithIdOnly = await prisma.evolution_info.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends evolution_infoFindManyArgs>(args?: SelectSubset<T, evolution_infoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$evolution_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Evolution_info.
     * @param {evolution_infoCreateArgs} args - Arguments to create a Evolution_info.
     * @example
     * // Create one Evolution_info
     * const Evolution_info = await prisma.evolution_info.create({
     *   data: {
     *     // ... data to create a Evolution_info
     *   }
     * })
     * 
     */
    create<T extends evolution_infoCreateArgs>(args: SelectSubset<T, evolution_infoCreateArgs<ExtArgs>>): Prisma__evolution_infoClient<$Result.GetResult<Prisma.$evolution_infoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Evolution_infos.
     * @param {evolution_infoCreateManyArgs} args - Arguments to create many Evolution_infos.
     * @example
     * // Create many Evolution_infos
     * const evolution_info = await prisma.evolution_info.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends evolution_infoCreateManyArgs>(args?: SelectSubset<T, evolution_infoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Evolution_info.
     * @param {evolution_infoDeleteArgs} args - Arguments to delete one Evolution_info.
     * @example
     * // Delete one Evolution_info
     * const Evolution_info = await prisma.evolution_info.delete({
     *   where: {
     *     // ... filter to delete one Evolution_info
     *   }
     * })
     * 
     */
    delete<T extends evolution_infoDeleteArgs>(args: SelectSubset<T, evolution_infoDeleteArgs<ExtArgs>>): Prisma__evolution_infoClient<$Result.GetResult<Prisma.$evolution_infoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Evolution_info.
     * @param {evolution_infoUpdateArgs} args - Arguments to update one Evolution_info.
     * @example
     * // Update one Evolution_info
     * const evolution_info = await prisma.evolution_info.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends evolution_infoUpdateArgs>(args: SelectSubset<T, evolution_infoUpdateArgs<ExtArgs>>): Prisma__evolution_infoClient<$Result.GetResult<Prisma.$evolution_infoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Evolution_infos.
     * @param {evolution_infoDeleteManyArgs} args - Arguments to filter Evolution_infos to delete.
     * @example
     * // Delete a few Evolution_infos
     * const { count } = await prisma.evolution_info.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends evolution_infoDeleteManyArgs>(args?: SelectSubset<T, evolution_infoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evolution_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolution_infoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evolution_infos
     * const evolution_info = await prisma.evolution_info.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends evolution_infoUpdateManyArgs>(args: SelectSubset<T, evolution_infoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evolution_info.
     * @param {evolution_infoUpsertArgs} args - Arguments to update or create a Evolution_info.
     * @example
     * // Update or create a Evolution_info
     * const evolution_info = await prisma.evolution_info.upsert({
     *   create: {
     *     // ... data to create a Evolution_info
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evolution_info we want to update
     *   }
     * })
     */
    upsert<T extends evolution_infoUpsertArgs>(args: SelectSubset<T, evolution_infoUpsertArgs<ExtArgs>>): Prisma__evolution_infoClient<$Result.GetResult<Prisma.$evolution_infoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Evolution_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolution_infoCountArgs} args - Arguments to filter Evolution_infos to count.
     * @example
     * // Count the number of Evolution_infos
     * const count = await prisma.evolution_info.count({
     *   where: {
     *     // ... the filter for the Evolution_infos we want to count
     *   }
     * })
    **/
    count<T extends evolution_infoCountArgs>(
      args?: Subset<T, evolution_infoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Evolution_infoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evolution_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Evolution_infoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Evolution_infoAggregateArgs>(args: Subset<T, Evolution_infoAggregateArgs>): Prisma.PrismaPromise<GetEvolution_infoAggregateType<T>>

    /**
     * Group by Evolution_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evolution_infoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends evolution_infoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: evolution_infoGroupByArgs['orderBy'] }
        : { orderBy?: evolution_infoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, evolution_infoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvolution_infoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the evolution_info model
   */
  readonly fields: evolution_infoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for evolution_info.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__evolution_infoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evolutions<T extends evolution_info$evolutionsArgs<ExtArgs> = {}>(args?: Subset<T, evolution_info$evolutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$evolutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the evolution_info model
   */
  interface evolution_infoFieldRefs {
    readonly id: FieldRef<"evolution_info", 'Int'>
    readonly createdAt: FieldRef<"evolution_info", 'DateTime'>
    readonly updatedAt: FieldRef<"evolution_info", 'DateTime'>
    readonly status: FieldRef<"evolution_info", 'String'>
  }
    

  // Custom InputTypes
  /**
   * evolution_info findUnique
   */
  export type evolution_infoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_info
     */
    select?: evolution_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_info
     */
    omit?: evolution_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_infoInclude<ExtArgs> | null
    /**
     * Filter, which evolution_info to fetch.
     */
    where: evolution_infoWhereUniqueInput
  }

  /**
   * evolution_info findUniqueOrThrow
   */
  export type evolution_infoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_info
     */
    select?: evolution_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_info
     */
    omit?: evolution_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_infoInclude<ExtArgs> | null
    /**
     * Filter, which evolution_info to fetch.
     */
    where: evolution_infoWhereUniqueInput
  }

  /**
   * evolution_info findFirst
   */
  export type evolution_infoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_info
     */
    select?: evolution_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_info
     */
    omit?: evolution_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_infoInclude<ExtArgs> | null
    /**
     * Filter, which evolution_info to fetch.
     */
    where?: evolution_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evolution_infos to fetch.
     */
    orderBy?: evolution_infoOrderByWithRelationInput | evolution_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for evolution_infos.
     */
    cursor?: evolution_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evolution_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evolution_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of evolution_infos.
     */
    distinct?: Evolution_infoScalarFieldEnum | Evolution_infoScalarFieldEnum[]
  }

  /**
   * evolution_info findFirstOrThrow
   */
  export type evolution_infoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_info
     */
    select?: evolution_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_info
     */
    omit?: evolution_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_infoInclude<ExtArgs> | null
    /**
     * Filter, which evolution_info to fetch.
     */
    where?: evolution_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evolution_infos to fetch.
     */
    orderBy?: evolution_infoOrderByWithRelationInput | evolution_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for evolution_infos.
     */
    cursor?: evolution_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evolution_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evolution_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of evolution_infos.
     */
    distinct?: Evolution_infoScalarFieldEnum | Evolution_infoScalarFieldEnum[]
  }

  /**
   * evolution_info findMany
   */
  export type evolution_infoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_info
     */
    select?: evolution_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_info
     */
    omit?: evolution_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_infoInclude<ExtArgs> | null
    /**
     * Filter, which evolution_infos to fetch.
     */
    where?: evolution_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evolution_infos to fetch.
     */
    orderBy?: evolution_infoOrderByWithRelationInput | evolution_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing evolution_infos.
     */
    cursor?: evolution_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evolution_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evolution_infos.
     */
    skip?: number
    distinct?: Evolution_infoScalarFieldEnum | Evolution_infoScalarFieldEnum[]
  }

  /**
   * evolution_info create
   */
  export type evolution_infoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_info
     */
    select?: evolution_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_info
     */
    omit?: evolution_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_infoInclude<ExtArgs> | null
    /**
     * The data needed to create a evolution_info.
     */
    data?: XOR<evolution_infoCreateInput, evolution_infoUncheckedCreateInput>
  }

  /**
   * evolution_info createMany
   */
  export type evolution_infoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many evolution_infos.
     */
    data: evolution_infoCreateManyInput | evolution_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * evolution_info update
   */
  export type evolution_infoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_info
     */
    select?: evolution_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_info
     */
    omit?: evolution_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_infoInclude<ExtArgs> | null
    /**
     * The data needed to update a evolution_info.
     */
    data: XOR<evolution_infoUpdateInput, evolution_infoUncheckedUpdateInput>
    /**
     * Choose, which evolution_info to update.
     */
    where: evolution_infoWhereUniqueInput
  }

  /**
   * evolution_info updateMany
   */
  export type evolution_infoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update evolution_infos.
     */
    data: XOR<evolution_infoUpdateManyMutationInput, evolution_infoUncheckedUpdateManyInput>
    /**
     * Filter which evolution_infos to update
     */
    where?: evolution_infoWhereInput
    /**
     * Limit how many evolution_infos to update.
     */
    limit?: number
  }

  /**
   * evolution_info upsert
   */
  export type evolution_infoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_info
     */
    select?: evolution_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_info
     */
    omit?: evolution_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_infoInclude<ExtArgs> | null
    /**
     * The filter to search for the evolution_info to update in case it exists.
     */
    where: evolution_infoWhereUniqueInput
    /**
     * In case the evolution_info found by the `where` argument doesn't exist, create a new evolution_info with this data.
     */
    create: XOR<evolution_infoCreateInput, evolution_infoUncheckedCreateInput>
    /**
     * In case the evolution_info was found with the provided `where` argument, update it with this data.
     */
    update: XOR<evolution_infoUpdateInput, evolution_infoUncheckedUpdateInput>
  }

  /**
   * evolution_info delete
   */
  export type evolution_infoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_info
     */
    select?: evolution_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_info
     */
    omit?: evolution_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_infoInclude<ExtArgs> | null
    /**
     * Filter which evolution_info to delete.
     */
    where: evolution_infoWhereUniqueInput
  }

  /**
   * evolution_info deleteMany
   */
  export type evolution_infoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which evolution_infos to delete
     */
    where?: evolution_infoWhereInput
    /**
     * Limit how many evolution_infos to delete.
     */
    limit?: number
  }

  /**
   * evolution_info.evolutions
   */
  export type evolution_info$evolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution
     */
    select?: evolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution
     */
    omit?: evolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolutionInclude<ExtArgs> | null
    where?: evolutionWhereInput
    orderBy?: evolutionOrderByWithRelationInput | evolutionOrderByWithRelationInput[]
    cursor?: evolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvolutionScalarFieldEnum | EvolutionScalarFieldEnum[]
  }

  /**
   * evolution_info without action
   */
  export type evolution_infoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evolution_info
     */
    select?: evolution_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the evolution_info
     */
    omit?: evolution_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evolution_infoInclude<ExtArgs> | null
  }


  /**
   * Model egg_group
   */

  export type AggregateEgg_group = {
    _count: Egg_groupCountAggregateOutputType | null
    _avg: Egg_groupAvgAggregateOutputType | null
    _sum: Egg_groupSumAggregateOutputType | null
    _min: Egg_groupMinAggregateOutputType | null
    _max: Egg_groupMaxAggregateOutputType | null
  }

  export type Egg_groupAvgAggregateOutputType = {
    id: number | null
  }

  export type Egg_groupSumAggregateOutputType = {
    id: number | null
  }

  export type Egg_groupMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Egg_groupMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Egg_groupCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Egg_groupAvgAggregateInputType = {
    id?: true
  }

  export type Egg_groupSumAggregateInputType = {
    id?: true
  }

  export type Egg_groupMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Egg_groupMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Egg_groupCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Egg_groupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which egg_group to aggregate.
     */
    where?: egg_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of egg_groups to fetch.
     */
    orderBy?: egg_groupOrderByWithRelationInput | egg_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: egg_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` egg_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` egg_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned egg_groups
    **/
    _count?: true | Egg_groupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Egg_groupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Egg_groupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Egg_groupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Egg_groupMaxAggregateInputType
  }

  export type GetEgg_groupAggregateType<T extends Egg_groupAggregateArgs> = {
        [P in keyof T & keyof AggregateEgg_group]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEgg_group[P]>
      : GetScalarType<T[P], AggregateEgg_group[P]>
  }




  export type egg_groupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: egg_groupWhereInput
    orderBy?: egg_groupOrderByWithAggregationInput | egg_groupOrderByWithAggregationInput[]
    by: Egg_groupScalarFieldEnum[] | Egg_groupScalarFieldEnum
    having?: egg_groupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Egg_groupCountAggregateInputType | true
    _avg?: Egg_groupAvgAggregateInputType
    _sum?: Egg_groupSumAggregateInputType
    _min?: Egg_groupMinAggregateInputType
    _max?: Egg_groupMaxAggregateInputType
  }

  export type Egg_groupGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Egg_groupCountAggregateOutputType | null
    _avg: Egg_groupAvgAggregateOutputType | null
    _sum: Egg_groupSumAggregateOutputType | null
    _min: Egg_groupMinAggregateOutputType | null
    _max: Egg_groupMaxAggregateOutputType | null
  }

  type GetEgg_groupGroupByPayload<T extends egg_groupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Egg_groupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Egg_groupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Egg_groupGroupByOutputType[P]>
            : GetScalarType<T[P], Egg_groupGroupByOutputType[P]>
        }
      >
    >


  export type egg_groupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    eggGroupOrders?: boolean | egg_group$eggGroupOrdersArgs<ExtArgs>
    _count?: boolean | Egg_groupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["egg_group"]>



  export type egg_groupSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type egg_groupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["egg_group"]>
  export type egg_groupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eggGroupOrders?: boolean | egg_group$eggGroupOrdersArgs<ExtArgs>
    _count?: boolean | Egg_groupCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $egg_groupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "egg_group"
    objects: {
      eggGroupOrders: Prisma.$egg_group_orderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["egg_group"]>
    composites: {}
  }

  type egg_groupGetPayload<S extends boolean | null | undefined | egg_groupDefaultArgs> = $Result.GetResult<Prisma.$egg_groupPayload, S>

  type egg_groupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<egg_groupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Egg_groupCountAggregateInputType | true
    }

  export interface egg_groupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['egg_group'], meta: { name: 'egg_group' } }
    /**
     * Find zero or one Egg_group that matches the filter.
     * @param {egg_groupFindUniqueArgs} args - Arguments to find a Egg_group
     * @example
     * // Get one Egg_group
     * const egg_group = await prisma.egg_group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends egg_groupFindUniqueArgs>(args: SelectSubset<T, egg_groupFindUniqueArgs<ExtArgs>>): Prisma__egg_groupClient<$Result.GetResult<Prisma.$egg_groupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Egg_group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {egg_groupFindUniqueOrThrowArgs} args - Arguments to find a Egg_group
     * @example
     * // Get one Egg_group
     * const egg_group = await prisma.egg_group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends egg_groupFindUniqueOrThrowArgs>(args: SelectSubset<T, egg_groupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__egg_groupClient<$Result.GetResult<Prisma.$egg_groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Egg_group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {egg_groupFindFirstArgs} args - Arguments to find a Egg_group
     * @example
     * // Get one Egg_group
     * const egg_group = await prisma.egg_group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends egg_groupFindFirstArgs>(args?: SelectSubset<T, egg_groupFindFirstArgs<ExtArgs>>): Prisma__egg_groupClient<$Result.GetResult<Prisma.$egg_groupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Egg_group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {egg_groupFindFirstOrThrowArgs} args - Arguments to find a Egg_group
     * @example
     * // Get one Egg_group
     * const egg_group = await prisma.egg_group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends egg_groupFindFirstOrThrowArgs>(args?: SelectSubset<T, egg_groupFindFirstOrThrowArgs<ExtArgs>>): Prisma__egg_groupClient<$Result.GetResult<Prisma.$egg_groupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Egg_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {egg_groupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Egg_groups
     * const egg_groups = await prisma.egg_group.findMany()
     * 
     * // Get first 10 Egg_groups
     * const egg_groups = await prisma.egg_group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const egg_groupWithIdOnly = await prisma.egg_group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends egg_groupFindManyArgs>(args?: SelectSubset<T, egg_groupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$egg_groupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Egg_group.
     * @param {egg_groupCreateArgs} args - Arguments to create a Egg_group.
     * @example
     * // Create one Egg_group
     * const Egg_group = await prisma.egg_group.create({
     *   data: {
     *     // ... data to create a Egg_group
     *   }
     * })
     * 
     */
    create<T extends egg_groupCreateArgs>(args: SelectSubset<T, egg_groupCreateArgs<ExtArgs>>): Prisma__egg_groupClient<$Result.GetResult<Prisma.$egg_groupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Egg_groups.
     * @param {egg_groupCreateManyArgs} args - Arguments to create many Egg_groups.
     * @example
     * // Create many Egg_groups
     * const egg_group = await prisma.egg_group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends egg_groupCreateManyArgs>(args?: SelectSubset<T, egg_groupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Egg_group.
     * @param {egg_groupDeleteArgs} args - Arguments to delete one Egg_group.
     * @example
     * // Delete one Egg_group
     * const Egg_group = await prisma.egg_group.delete({
     *   where: {
     *     // ... filter to delete one Egg_group
     *   }
     * })
     * 
     */
    delete<T extends egg_groupDeleteArgs>(args: SelectSubset<T, egg_groupDeleteArgs<ExtArgs>>): Prisma__egg_groupClient<$Result.GetResult<Prisma.$egg_groupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Egg_group.
     * @param {egg_groupUpdateArgs} args - Arguments to update one Egg_group.
     * @example
     * // Update one Egg_group
     * const egg_group = await prisma.egg_group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends egg_groupUpdateArgs>(args: SelectSubset<T, egg_groupUpdateArgs<ExtArgs>>): Prisma__egg_groupClient<$Result.GetResult<Prisma.$egg_groupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Egg_groups.
     * @param {egg_groupDeleteManyArgs} args - Arguments to filter Egg_groups to delete.
     * @example
     * // Delete a few Egg_groups
     * const { count } = await prisma.egg_group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends egg_groupDeleteManyArgs>(args?: SelectSubset<T, egg_groupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Egg_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {egg_groupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Egg_groups
     * const egg_group = await prisma.egg_group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends egg_groupUpdateManyArgs>(args: SelectSubset<T, egg_groupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Egg_group.
     * @param {egg_groupUpsertArgs} args - Arguments to update or create a Egg_group.
     * @example
     * // Update or create a Egg_group
     * const egg_group = await prisma.egg_group.upsert({
     *   create: {
     *     // ... data to create a Egg_group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Egg_group we want to update
     *   }
     * })
     */
    upsert<T extends egg_groupUpsertArgs>(args: SelectSubset<T, egg_groupUpsertArgs<ExtArgs>>): Prisma__egg_groupClient<$Result.GetResult<Prisma.$egg_groupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Egg_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {egg_groupCountArgs} args - Arguments to filter Egg_groups to count.
     * @example
     * // Count the number of Egg_groups
     * const count = await prisma.egg_group.count({
     *   where: {
     *     // ... the filter for the Egg_groups we want to count
     *   }
     * })
    **/
    count<T extends egg_groupCountArgs>(
      args?: Subset<T, egg_groupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Egg_groupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Egg_group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Egg_groupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Egg_groupAggregateArgs>(args: Subset<T, Egg_groupAggregateArgs>): Prisma.PrismaPromise<GetEgg_groupAggregateType<T>>

    /**
     * Group by Egg_group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {egg_groupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends egg_groupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: egg_groupGroupByArgs['orderBy'] }
        : { orderBy?: egg_groupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, egg_groupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEgg_groupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the egg_group model
   */
  readonly fields: egg_groupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for egg_group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__egg_groupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eggGroupOrders<T extends egg_group$eggGroupOrdersArgs<ExtArgs> = {}>(args?: Subset<T, egg_group$eggGroupOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$egg_group_orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the egg_group model
   */
  interface egg_groupFieldRefs {
    readonly id: FieldRef<"egg_group", 'Int'>
    readonly createdAt: FieldRef<"egg_group", 'DateTime'>
    readonly updatedAt: FieldRef<"egg_group", 'DateTime'>
    readonly status: FieldRef<"egg_group", 'String'>
  }
    

  // Custom InputTypes
  /**
   * egg_group findUnique
   */
  export type egg_groupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group
     */
    select?: egg_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group
     */
    omit?: egg_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_groupInclude<ExtArgs> | null
    /**
     * Filter, which egg_group to fetch.
     */
    where: egg_groupWhereUniqueInput
  }

  /**
   * egg_group findUniqueOrThrow
   */
  export type egg_groupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group
     */
    select?: egg_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group
     */
    omit?: egg_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_groupInclude<ExtArgs> | null
    /**
     * Filter, which egg_group to fetch.
     */
    where: egg_groupWhereUniqueInput
  }

  /**
   * egg_group findFirst
   */
  export type egg_groupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group
     */
    select?: egg_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group
     */
    omit?: egg_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_groupInclude<ExtArgs> | null
    /**
     * Filter, which egg_group to fetch.
     */
    where?: egg_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of egg_groups to fetch.
     */
    orderBy?: egg_groupOrderByWithRelationInput | egg_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for egg_groups.
     */
    cursor?: egg_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` egg_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` egg_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of egg_groups.
     */
    distinct?: Egg_groupScalarFieldEnum | Egg_groupScalarFieldEnum[]
  }

  /**
   * egg_group findFirstOrThrow
   */
  export type egg_groupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group
     */
    select?: egg_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group
     */
    omit?: egg_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_groupInclude<ExtArgs> | null
    /**
     * Filter, which egg_group to fetch.
     */
    where?: egg_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of egg_groups to fetch.
     */
    orderBy?: egg_groupOrderByWithRelationInput | egg_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for egg_groups.
     */
    cursor?: egg_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` egg_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` egg_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of egg_groups.
     */
    distinct?: Egg_groupScalarFieldEnum | Egg_groupScalarFieldEnum[]
  }

  /**
   * egg_group findMany
   */
  export type egg_groupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group
     */
    select?: egg_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group
     */
    omit?: egg_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_groupInclude<ExtArgs> | null
    /**
     * Filter, which egg_groups to fetch.
     */
    where?: egg_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of egg_groups to fetch.
     */
    orderBy?: egg_groupOrderByWithRelationInput | egg_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing egg_groups.
     */
    cursor?: egg_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` egg_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` egg_groups.
     */
    skip?: number
    distinct?: Egg_groupScalarFieldEnum | Egg_groupScalarFieldEnum[]
  }

  /**
   * egg_group create
   */
  export type egg_groupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group
     */
    select?: egg_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group
     */
    omit?: egg_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_groupInclude<ExtArgs> | null
    /**
     * The data needed to create a egg_group.
     */
    data?: XOR<egg_groupCreateInput, egg_groupUncheckedCreateInput>
  }

  /**
   * egg_group createMany
   */
  export type egg_groupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many egg_groups.
     */
    data: egg_groupCreateManyInput | egg_groupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * egg_group update
   */
  export type egg_groupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group
     */
    select?: egg_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group
     */
    omit?: egg_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_groupInclude<ExtArgs> | null
    /**
     * The data needed to update a egg_group.
     */
    data: XOR<egg_groupUpdateInput, egg_groupUncheckedUpdateInput>
    /**
     * Choose, which egg_group to update.
     */
    where: egg_groupWhereUniqueInput
  }

  /**
   * egg_group updateMany
   */
  export type egg_groupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update egg_groups.
     */
    data: XOR<egg_groupUpdateManyMutationInput, egg_groupUncheckedUpdateManyInput>
    /**
     * Filter which egg_groups to update
     */
    where?: egg_groupWhereInput
    /**
     * Limit how many egg_groups to update.
     */
    limit?: number
  }

  /**
   * egg_group upsert
   */
  export type egg_groupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group
     */
    select?: egg_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group
     */
    omit?: egg_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_groupInclude<ExtArgs> | null
    /**
     * The filter to search for the egg_group to update in case it exists.
     */
    where: egg_groupWhereUniqueInput
    /**
     * In case the egg_group found by the `where` argument doesn't exist, create a new egg_group with this data.
     */
    create: XOR<egg_groupCreateInput, egg_groupUncheckedCreateInput>
    /**
     * In case the egg_group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<egg_groupUpdateInput, egg_groupUncheckedUpdateInput>
  }

  /**
   * egg_group delete
   */
  export type egg_groupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group
     */
    select?: egg_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group
     */
    omit?: egg_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_groupInclude<ExtArgs> | null
    /**
     * Filter which egg_group to delete.
     */
    where: egg_groupWhereUniqueInput
  }

  /**
   * egg_group deleteMany
   */
  export type egg_groupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which egg_groups to delete
     */
    where?: egg_groupWhereInput
    /**
     * Limit how many egg_groups to delete.
     */
    limit?: number
  }

  /**
   * egg_group.eggGroupOrders
   */
  export type egg_group$eggGroupOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group_order
     */
    select?: egg_group_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group_order
     */
    omit?: egg_group_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_group_orderInclude<ExtArgs> | null
    where?: egg_group_orderWhereInput
    orderBy?: egg_group_orderOrderByWithRelationInput | egg_group_orderOrderByWithRelationInput[]
    cursor?: egg_group_orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Egg_group_orderScalarFieldEnum | Egg_group_orderScalarFieldEnum[]
  }

  /**
   * egg_group without action
   */
  export type egg_groupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group
     */
    select?: egg_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group
     */
    omit?: egg_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_groupInclude<ExtArgs> | null
  }


  /**
   * Model egg_group_order
   */

  export type AggregateEgg_group_order = {
    _count: Egg_group_orderCountAggregateOutputType | null
    _avg: Egg_group_orderAvgAggregateOutputType | null
    _sum: Egg_group_orderSumAggregateOutputType | null
    _min: Egg_group_orderMinAggregateOutputType | null
    _max: Egg_group_orderMaxAggregateOutputType | null
  }

  export type Egg_group_orderAvgAggregateOutputType = {
    pokemonInfoId: number | null
    eggGroupId: number | null
    order: number | null
  }

  export type Egg_group_orderSumAggregateOutputType = {
    pokemonInfoId: number | null
    eggGroupId: number | null
    order: number | null
  }

  export type Egg_group_orderMinAggregateOutputType = {
    pokemonInfoId: number | null
    eggGroupId: number | null
    order: number | null
  }

  export type Egg_group_orderMaxAggregateOutputType = {
    pokemonInfoId: number | null
    eggGroupId: number | null
    order: number | null
  }

  export type Egg_group_orderCountAggregateOutputType = {
    pokemonInfoId: number
    eggGroupId: number
    order: number
    _all: number
  }


  export type Egg_group_orderAvgAggregateInputType = {
    pokemonInfoId?: true
    eggGroupId?: true
    order?: true
  }

  export type Egg_group_orderSumAggregateInputType = {
    pokemonInfoId?: true
    eggGroupId?: true
    order?: true
  }

  export type Egg_group_orderMinAggregateInputType = {
    pokemonInfoId?: true
    eggGroupId?: true
    order?: true
  }

  export type Egg_group_orderMaxAggregateInputType = {
    pokemonInfoId?: true
    eggGroupId?: true
    order?: true
  }

  export type Egg_group_orderCountAggregateInputType = {
    pokemonInfoId?: true
    eggGroupId?: true
    order?: true
    _all?: true
  }

  export type Egg_group_orderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which egg_group_order to aggregate.
     */
    where?: egg_group_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of egg_group_orders to fetch.
     */
    orderBy?: egg_group_orderOrderByWithRelationInput | egg_group_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: egg_group_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` egg_group_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` egg_group_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned egg_group_orders
    **/
    _count?: true | Egg_group_orderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Egg_group_orderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Egg_group_orderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Egg_group_orderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Egg_group_orderMaxAggregateInputType
  }

  export type GetEgg_group_orderAggregateType<T extends Egg_group_orderAggregateArgs> = {
        [P in keyof T & keyof AggregateEgg_group_order]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEgg_group_order[P]>
      : GetScalarType<T[P], AggregateEgg_group_order[P]>
  }




  export type egg_group_orderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: egg_group_orderWhereInput
    orderBy?: egg_group_orderOrderByWithAggregationInput | egg_group_orderOrderByWithAggregationInput[]
    by: Egg_group_orderScalarFieldEnum[] | Egg_group_orderScalarFieldEnum
    having?: egg_group_orderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Egg_group_orderCountAggregateInputType | true
    _avg?: Egg_group_orderAvgAggregateInputType
    _sum?: Egg_group_orderSumAggregateInputType
    _min?: Egg_group_orderMinAggregateInputType
    _max?: Egg_group_orderMaxAggregateInputType
  }

  export type Egg_group_orderGroupByOutputType = {
    pokemonInfoId: number
    eggGroupId: number
    order: number
    _count: Egg_group_orderCountAggregateOutputType | null
    _avg: Egg_group_orderAvgAggregateOutputType | null
    _sum: Egg_group_orderSumAggregateOutputType | null
    _min: Egg_group_orderMinAggregateOutputType | null
    _max: Egg_group_orderMaxAggregateOutputType | null
  }

  type GetEgg_group_orderGroupByPayload<T extends egg_group_orderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Egg_group_orderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Egg_group_orderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Egg_group_orderGroupByOutputType[P]>
            : GetScalarType<T[P], Egg_group_orderGroupByOutputType[P]>
        }
      >
    >


  export type egg_group_orderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pokemonInfoId?: boolean
    eggGroupId?: boolean
    order?: boolean
    eggGroup?: boolean | egg_groupDefaultArgs<ExtArgs>
    pokemonInfo?: boolean | pokemon_infoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["egg_group_order"]>



  export type egg_group_orderSelectScalar = {
    pokemonInfoId?: boolean
    eggGroupId?: boolean
    order?: boolean
  }

  export type egg_group_orderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pokemonInfoId" | "eggGroupId" | "order", ExtArgs["result"]["egg_group_order"]>
  export type egg_group_orderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eggGroup?: boolean | egg_groupDefaultArgs<ExtArgs>
    pokemonInfo?: boolean | pokemon_infoDefaultArgs<ExtArgs>
  }

  export type $egg_group_orderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "egg_group_order"
    objects: {
      eggGroup: Prisma.$egg_groupPayload<ExtArgs>
      pokemonInfo: Prisma.$pokemon_infoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      pokemonInfoId: number
      eggGroupId: number
      order: number
    }, ExtArgs["result"]["egg_group_order"]>
    composites: {}
  }

  type egg_group_orderGetPayload<S extends boolean | null | undefined | egg_group_orderDefaultArgs> = $Result.GetResult<Prisma.$egg_group_orderPayload, S>

  type egg_group_orderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<egg_group_orderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Egg_group_orderCountAggregateInputType | true
    }

  export interface egg_group_orderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['egg_group_order'], meta: { name: 'egg_group_order' } }
    /**
     * Find zero or one Egg_group_order that matches the filter.
     * @param {egg_group_orderFindUniqueArgs} args - Arguments to find a Egg_group_order
     * @example
     * // Get one Egg_group_order
     * const egg_group_order = await prisma.egg_group_order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends egg_group_orderFindUniqueArgs>(args: SelectSubset<T, egg_group_orderFindUniqueArgs<ExtArgs>>): Prisma__egg_group_orderClient<$Result.GetResult<Prisma.$egg_group_orderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Egg_group_order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {egg_group_orderFindUniqueOrThrowArgs} args - Arguments to find a Egg_group_order
     * @example
     * // Get one Egg_group_order
     * const egg_group_order = await prisma.egg_group_order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends egg_group_orderFindUniqueOrThrowArgs>(args: SelectSubset<T, egg_group_orderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__egg_group_orderClient<$Result.GetResult<Prisma.$egg_group_orderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Egg_group_order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {egg_group_orderFindFirstArgs} args - Arguments to find a Egg_group_order
     * @example
     * // Get one Egg_group_order
     * const egg_group_order = await prisma.egg_group_order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends egg_group_orderFindFirstArgs>(args?: SelectSubset<T, egg_group_orderFindFirstArgs<ExtArgs>>): Prisma__egg_group_orderClient<$Result.GetResult<Prisma.$egg_group_orderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Egg_group_order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {egg_group_orderFindFirstOrThrowArgs} args - Arguments to find a Egg_group_order
     * @example
     * // Get one Egg_group_order
     * const egg_group_order = await prisma.egg_group_order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends egg_group_orderFindFirstOrThrowArgs>(args?: SelectSubset<T, egg_group_orderFindFirstOrThrowArgs<ExtArgs>>): Prisma__egg_group_orderClient<$Result.GetResult<Prisma.$egg_group_orderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Egg_group_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {egg_group_orderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Egg_group_orders
     * const egg_group_orders = await prisma.egg_group_order.findMany()
     * 
     * // Get first 10 Egg_group_orders
     * const egg_group_orders = await prisma.egg_group_order.findMany({ take: 10 })
     * 
     * // Only select the `pokemonInfoId`
     * const egg_group_orderWithPokemonInfoIdOnly = await prisma.egg_group_order.findMany({ select: { pokemonInfoId: true } })
     * 
     */
    findMany<T extends egg_group_orderFindManyArgs>(args?: SelectSubset<T, egg_group_orderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$egg_group_orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Egg_group_order.
     * @param {egg_group_orderCreateArgs} args - Arguments to create a Egg_group_order.
     * @example
     * // Create one Egg_group_order
     * const Egg_group_order = await prisma.egg_group_order.create({
     *   data: {
     *     // ... data to create a Egg_group_order
     *   }
     * })
     * 
     */
    create<T extends egg_group_orderCreateArgs>(args: SelectSubset<T, egg_group_orderCreateArgs<ExtArgs>>): Prisma__egg_group_orderClient<$Result.GetResult<Prisma.$egg_group_orderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Egg_group_orders.
     * @param {egg_group_orderCreateManyArgs} args - Arguments to create many Egg_group_orders.
     * @example
     * // Create many Egg_group_orders
     * const egg_group_order = await prisma.egg_group_order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends egg_group_orderCreateManyArgs>(args?: SelectSubset<T, egg_group_orderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Egg_group_order.
     * @param {egg_group_orderDeleteArgs} args - Arguments to delete one Egg_group_order.
     * @example
     * // Delete one Egg_group_order
     * const Egg_group_order = await prisma.egg_group_order.delete({
     *   where: {
     *     // ... filter to delete one Egg_group_order
     *   }
     * })
     * 
     */
    delete<T extends egg_group_orderDeleteArgs>(args: SelectSubset<T, egg_group_orderDeleteArgs<ExtArgs>>): Prisma__egg_group_orderClient<$Result.GetResult<Prisma.$egg_group_orderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Egg_group_order.
     * @param {egg_group_orderUpdateArgs} args - Arguments to update one Egg_group_order.
     * @example
     * // Update one Egg_group_order
     * const egg_group_order = await prisma.egg_group_order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends egg_group_orderUpdateArgs>(args: SelectSubset<T, egg_group_orderUpdateArgs<ExtArgs>>): Prisma__egg_group_orderClient<$Result.GetResult<Prisma.$egg_group_orderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Egg_group_orders.
     * @param {egg_group_orderDeleteManyArgs} args - Arguments to filter Egg_group_orders to delete.
     * @example
     * // Delete a few Egg_group_orders
     * const { count } = await prisma.egg_group_order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends egg_group_orderDeleteManyArgs>(args?: SelectSubset<T, egg_group_orderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Egg_group_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {egg_group_orderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Egg_group_orders
     * const egg_group_order = await prisma.egg_group_order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends egg_group_orderUpdateManyArgs>(args: SelectSubset<T, egg_group_orderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Egg_group_order.
     * @param {egg_group_orderUpsertArgs} args - Arguments to update or create a Egg_group_order.
     * @example
     * // Update or create a Egg_group_order
     * const egg_group_order = await prisma.egg_group_order.upsert({
     *   create: {
     *     // ... data to create a Egg_group_order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Egg_group_order we want to update
     *   }
     * })
     */
    upsert<T extends egg_group_orderUpsertArgs>(args: SelectSubset<T, egg_group_orderUpsertArgs<ExtArgs>>): Prisma__egg_group_orderClient<$Result.GetResult<Prisma.$egg_group_orderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Egg_group_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {egg_group_orderCountArgs} args - Arguments to filter Egg_group_orders to count.
     * @example
     * // Count the number of Egg_group_orders
     * const count = await prisma.egg_group_order.count({
     *   where: {
     *     // ... the filter for the Egg_group_orders we want to count
     *   }
     * })
    **/
    count<T extends egg_group_orderCountArgs>(
      args?: Subset<T, egg_group_orderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Egg_group_orderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Egg_group_order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Egg_group_orderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Egg_group_orderAggregateArgs>(args: Subset<T, Egg_group_orderAggregateArgs>): Prisma.PrismaPromise<GetEgg_group_orderAggregateType<T>>

    /**
     * Group by Egg_group_order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {egg_group_orderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends egg_group_orderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: egg_group_orderGroupByArgs['orderBy'] }
        : { orderBy?: egg_group_orderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, egg_group_orderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEgg_group_orderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the egg_group_order model
   */
  readonly fields: egg_group_orderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for egg_group_order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__egg_group_orderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eggGroup<T extends egg_groupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, egg_groupDefaultArgs<ExtArgs>>): Prisma__egg_groupClient<$Result.GetResult<Prisma.$egg_groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemonInfo<T extends pokemon_infoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_infoDefaultArgs<ExtArgs>>): Prisma__pokemon_infoClient<$Result.GetResult<Prisma.$pokemon_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the egg_group_order model
   */
  interface egg_group_orderFieldRefs {
    readonly pokemonInfoId: FieldRef<"egg_group_order", 'Int'>
    readonly eggGroupId: FieldRef<"egg_group_order", 'Int'>
    readonly order: FieldRef<"egg_group_order", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * egg_group_order findUnique
   */
  export type egg_group_orderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group_order
     */
    select?: egg_group_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group_order
     */
    omit?: egg_group_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_group_orderInclude<ExtArgs> | null
    /**
     * Filter, which egg_group_order to fetch.
     */
    where: egg_group_orderWhereUniqueInput
  }

  /**
   * egg_group_order findUniqueOrThrow
   */
  export type egg_group_orderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group_order
     */
    select?: egg_group_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group_order
     */
    omit?: egg_group_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_group_orderInclude<ExtArgs> | null
    /**
     * Filter, which egg_group_order to fetch.
     */
    where: egg_group_orderWhereUniqueInput
  }

  /**
   * egg_group_order findFirst
   */
  export type egg_group_orderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group_order
     */
    select?: egg_group_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group_order
     */
    omit?: egg_group_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_group_orderInclude<ExtArgs> | null
    /**
     * Filter, which egg_group_order to fetch.
     */
    where?: egg_group_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of egg_group_orders to fetch.
     */
    orderBy?: egg_group_orderOrderByWithRelationInput | egg_group_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for egg_group_orders.
     */
    cursor?: egg_group_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` egg_group_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` egg_group_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of egg_group_orders.
     */
    distinct?: Egg_group_orderScalarFieldEnum | Egg_group_orderScalarFieldEnum[]
  }

  /**
   * egg_group_order findFirstOrThrow
   */
  export type egg_group_orderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group_order
     */
    select?: egg_group_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group_order
     */
    omit?: egg_group_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_group_orderInclude<ExtArgs> | null
    /**
     * Filter, which egg_group_order to fetch.
     */
    where?: egg_group_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of egg_group_orders to fetch.
     */
    orderBy?: egg_group_orderOrderByWithRelationInput | egg_group_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for egg_group_orders.
     */
    cursor?: egg_group_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` egg_group_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` egg_group_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of egg_group_orders.
     */
    distinct?: Egg_group_orderScalarFieldEnum | Egg_group_orderScalarFieldEnum[]
  }

  /**
   * egg_group_order findMany
   */
  export type egg_group_orderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group_order
     */
    select?: egg_group_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group_order
     */
    omit?: egg_group_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_group_orderInclude<ExtArgs> | null
    /**
     * Filter, which egg_group_orders to fetch.
     */
    where?: egg_group_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of egg_group_orders to fetch.
     */
    orderBy?: egg_group_orderOrderByWithRelationInput | egg_group_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing egg_group_orders.
     */
    cursor?: egg_group_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` egg_group_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` egg_group_orders.
     */
    skip?: number
    distinct?: Egg_group_orderScalarFieldEnum | Egg_group_orderScalarFieldEnum[]
  }

  /**
   * egg_group_order create
   */
  export type egg_group_orderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group_order
     */
    select?: egg_group_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group_order
     */
    omit?: egg_group_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_group_orderInclude<ExtArgs> | null
    /**
     * The data needed to create a egg_group_order.
     */
    data: XOR<egg_group_orderCreateInput, egg_group_orderUncheckedCreateInput>
  }

  /**
   * egg_group_order createMany
   */
  export type egg_group_orderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many egg_group_orders.
     */
    data: egg_group_orderCreateManyInput | egg_group_orderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * egg_group_order update
   */
  export type egg_group_orderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group_order
     */
    select?: egg_group_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group_order
     */
    omit?: egg_group_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_group_orderInclude<ExtArgs> | null
    /**
     * The data needed to update a egg_group_order.
     */
    data: XOR<egg_group_orderUpdateInput, egg_group_orderUncheckedUpdateInput>
    /**
     * Choose, which egg_group_order to update.
     */
    where: egg_group_orderWhereUniqueInput
  }

  /**
   * egg_group_order updateMany
   */
  export type egg_group_orderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update egg_group_orders.
     */
    data: XOR<egg_group_orderUpdateManyMutationInput, egg_group_orderUncheckedUpdateManyInput>
    /**
     * Filter which egg_group_orders to update
     */
    where?: egg_group_orderWhereInput
    /**
     * Limit how many egg_group_orders to update.
     */
    limit?: number
  }

  /**
   * egg_group_order upsert
   */
  export type egg_group_orderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group_order
     */
    select?: egg_group_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group_order
     */
    omit?: egg_group_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_group_orderInclude<ExtArgs> | null
    /**
     * The filter to search for the egg_group_order to update in case it exists.
     */
    where: egg_group_orderWhereUniqueInput
    /**
     * In case the egg_group_order found by the `where` argument doesn't exist, create a new egg_group_order with this data.
     */
    create: XOR<egg_group_orderCreateInput, egg_group_orderUncheckedCreateInput>
    /**
     * In case the egg_group_order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<egg_group_orderUpdateInput, egg_group_orderUncheckedUpdateInput>
  }

  /**
   * egg_group_order delete
   */
  export type egg_group_orderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group_order
     */
    select?: egg_group_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group_order
     */
    omit?: egg_group_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_group_orderInclude<ExtArgs> | null
    /**
     * Filter which egg_group_order to delete.
     */
    where: egg_group_orderWhereUniqueInput
  }

  /**
   * egg_group_order deleteMany
   */
  export type egg_group_orderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which egg_group_orders to delete
     */
    where?: egg_group_orderWhereInput
    /**
     * Limit how many egg_group_orders to delete.
     */
    limit?: number
  }

  /**
   * egg_group_order without action
   */
  export type egg_group_orderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the egg_group_order
     */
    select?: egg_group_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the egg_group_order
     */
    omit?: egg_group_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: egg_group_orderInclude<ExtArgs> | null
  }


  /**
   * Model type
   */

  export type AggregateType = {
    _count: TypeCountAggregateOutputType | null
    _avg: TypeAvgAggregateOutputType | null
    _sum: TypeSumAggregateOutputType | null
    _min: TypeMinAggregateOutputType | null
    _max: TypeMaxAggregateOutputType | null
  }

  export type TypeAvgAggregateOutputType = {
    id: number | null
  }

  export type TypeSumAggregateOutputType = {
    id: number | null
  }

  export type TypeMinAggregateOutputType = {
    id: number | null
    color: string | null
    iconName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type TypeMaxAggregateOutputType = {
    id: number | null
    color: string | null
    iconName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type TypeCountAggregateOutputType = {
    id: number
    color: number
    iconName: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type TypeAvgAggregateInputType = {
    id?: true
  }

  export type TypeSumAggregateInputType = {
    id?: true
  }

  export type TypeMinAggregateInputType = {
    id?: true
    color?: true
    iconName?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type TypeMaxAggregateInputType = {
    id?: true
    color?: true
    iconName?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type TypeCountAggregateInputType = {
    id?: true
    color?: true
    iconName?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type TypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which type to aggregate.
     */
    where?: typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of types to fetch.
     */
    orderBy?: typeOrderByWithRelationInput | typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned types
    **/
    _count?: true | TypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeMaxAggregateInputType
  }

  export type GetTypeAggregateType<T extends TypeAggregateArgs> = {
        [P in keyof T & keyof AggregateType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateType[P]>
      : GetScalarType<T[P], AggregateType[P]>
  }




  export type typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: typeWhereInput
    orderBy?: typeOrderByWithAggregationInput | typeOrderByWithAggregationInput[]
    by: TypeScalarFieldEnum[] | TypeScalarFieldEnum
    having?: typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeCountAggregateInputType | true
    _avg?: TypeAvgAggregateInputType
    _sum?: TypeSumAggregateInputType
    _min?: TypeMinAggregateInputType
    _max?: TypeMaxAggregateInputType
  }

  export type TypeGroupByOutputType = {
    id: number
    color: string
    iconName: string
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: TypeCountAggregateOutputType | null
    _avg: TypeAvgAggregateOutputType | null
    _sum: TypeSumAggregateOutputType | null
    _min: TypeMinAggregateOutputType | null
    _max: TypeMaxAggregateOutputType | null
  }

  type GetTypeGroupByPayload<T extends typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeGroupByOutputType[P]>
            : GetScalarType<T[P], TypeGroupByOutputType[P]>
        }
      >
    >


  export type typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    color?: boolean
    iconName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    capacityInfos?: boolean | type$capacityInfosArgs<ExtArgs>
    typeOrders?: boolean | type$typeOrdersArgs<ExtArgs>
    _count?: boolean | TypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["type"]>



  export type typeSelectScalar = {
    id?: boolean
    color?: boolean
    iconName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "color" | "iconName" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["type"]>
  export type typeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfos?: boolean | type$capacityInfosArgs<ExtArgs>
    typeOrders?: boolean | type$typeOrdersArgs<ExtArgs>
    _count?: boolean | TypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "type"
    objects: {
      capacityInfos: Prisma.$capacity_infoPayload<ExtArgs>[]
      typeOrders: Prisma.$type_orderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      color: string
      iconName: string
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["type"]>
    composites: {}
  }

  type typeGetPayload<S extends boolean | null | undefined | typeDefaultArgs> = $Result.GetResult<Prisma.$typePayload, S>

  type typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TypeCountAggregateInputType | true
    }

  export interface typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['type'], meta: { name: 'type' } }
    /**
     * Find zero or one Type that matches the filter.
     * @param {typeFindUniqueArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends typeFindUniqueArgs>(args: SelectSubset<T, typeFindUniqueArgs<ExtArgs>>): Prisma__typeClient<$Result.GetResult<Prisma.$typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {typeFindUniqueOrThrowArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends typeFindUniqueOrThrowArgs>(args: SelectSubset<T, typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__typeClient<$Result.GetResult<Prisma.$typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typeFindFirstArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends typeFindFirstArgs>(args?: SelectSubset<T, typeFindFirstArgs<ExtArgs>>): Prisma__typeClient<$Result.GetResult<Prisma.$typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typeFindFirstOrThrowArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends typeFindFirstOrThrowArgs>(args?: SelectSubset<T, typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__typeClient<$Result.GetResult<Prisma.$typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Types
     * const types = await prisma.type.findMany()
     * 
     * // Get first 10 Types
     * const types = await prisma.type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typeWithIdOnly = await prisma.type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends typeFindManyArgs>(args?: SelectSubset<T, typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Type.
     * @param {typeCreateArgs} args - Arguments to create a Type.
     * @example
     * // Create one Type
     * const Type = await prisma.type.create({
     *   data: {
     *     // ... data to create a Type
     *   }
     * })
     * 
     */
    create<T extends typeCreateArgs>(args: SelectSubset<T, typeCreateArgs<ExtArgs>>): Prisma__typeClient<$Result.GetResult<Prisma.$typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Types.
     * @param {typeCreateManyArgs} args - Arguments to create many Types.
     * @example
     * // Create many Types
     * const type = await prisma.type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends typeCreateManyArgs>(args?: SelectSubset<T, typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Type.
     * @param {typeDeleteArgs} args - Arguments to delete one Type.
     * @example
     * // Delete one Type
     * const Type = await prisma.type.delete({
     *   where: {
     *     // ... filter to delete one Type
     *   }
     * })
     * 
     */
    delete<T extends typeDeleteArgs>(args: SelectSubset<T, typeDeleteArgs<ExtArgs>>): Prisma__typeClient<$Result.GetResult<Prisma.$typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Type.
     * @param {typeUpdateArgs} args - Arguments to update one Type.
     * @example
     * // Update one Type
     * const type = await prisma.type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends typeUpdateArgs>(args: SelectSubset<T, typeUpdateArgs<ExtArgs>>): Prisma__typeClient<$Result.GetResult<Prisma.$typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Types.
     * @param {typeDeleteManyArgs} args - Arguments to filter Types to delete.
     * @example
     * // Delete a few Types
     * const { count } = await prisma.type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends typeDeleteManyArgs>(args?: SelectSubset<T, typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Types
     * const type = await prisma.type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends typeUpdateManyArgs>(args: SelectSubset<T, typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Type.
     * @param {typeUpsertArgs} args - Arguments to update or create a Type.
     * @example
     * // Update or create a Type
     * const type = await prisma.type.upsert({
     *   create: {
     *     // ... data to create a Type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Type we want to update
     *   }
     * })
     */
    upsert<T extends typeUpsertArgs>(args: SelectSubset<T, typeUpsertArgs<ExtArgs>>): Prisma__typeClient<$Result.GetResult<Prisma.$typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typeCountArgs} args - Arguments to filter Types to count.
     * @example
     * // Count the number of Types
     * const count = await prisma.type.count({
     *   where: {
     *     // ... the filter for the Types we want to count
     *   }
     * })
    **/
    count<T extends typeCountArgs>(
      args?: Subset<T, typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeAggregateArgs>(args: Subset<T, TypeAggregateArgs>): Prisma.PrismaPromise<GetTypeAggregateType<T>>

    /**
     * Group by Type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: typeGroupByArgs['orderBy'] }
        : { orderBy?: typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the type model
   */
  readonly fields: typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capacityInfos<T extends type$capacityInfosArgs<ExtArgs> = {}>(args?: Subset<T, type$capacityInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    typeOrders<T extends type$typeOrdersArgs<ExtArgs> = {}>(args?: Subset<T, type$typeOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$type_orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the type model
   */
  interface typeFieldRefs {
    readonly id: FieldRef<"type", 'Int'>
    readonly color: FieldRef<"type", 'String'>
    readonly iconName: FieldRef<"type", 'String'>
    readonly createdAt: FieldRef<"type", 'DateTime'>
    readonly updatedAt: FieldRef<"type", 'DateTime'>
    readonly status: FieldRef<"type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * type findUnique
   */
  export type typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type
     */
    select?: typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type
     */
    omit?: typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typeInclude<ExtArgs> | null
    /**
     * Filter, which type to fetch.
     */
    where: typeWhereUniqueInput
  }

  /**
   * type findUniqueOrThrow
   */
  export type typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type
     */
    select?: typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type
     */
    omit?: typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typeInclude<ExtArgs> | null
    /**
     * Filter, which type to fetch.
     */
    where: typeWhereUniqueInput
  }

  /**
   * type findFirst
   */
  export type typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type
     */
    select?: typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type
     */
    omit?: typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typeInclude<ExtArgs> | null
    /**
     * Filter, which type to fetch.
     */
    where?: typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of types to fetch.
     */
    orderBy?: typeOrderByWithRelationInput | typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for types.
     */
    cursor?: typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of types.
     */
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * type findFirstOrThrow
   */
  export type typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type
     */
    select?: typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type
     */
    omit?: typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typeInclude<ExtArgs> | null
    /**
     * Filter, which type to fetch.
     */
    where?: typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of types to fetch.
     */
    orderBy?: typeOrderByWithRelationInput | typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for types.
     */
    cursor?: typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of types.
     */
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * type findMany
   */
  export type typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type
     */
    select?: typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type
     */
    omit?: typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typeInclude<ExtArgs> | null
    /**
     * Filter, which types to fetch.
     */
    where?: typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of types to fetch.
     */
    orderBy?: typeOrderByWithRelationInput | typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing types.
     */
    cursor?: typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` types.
     */
    skip?: number
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * type create
   */
  export type typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type
     */
    select?: typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type
     */
    omit?: typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typeInclude<ExtArgs> | null
    /**
     * The data needed to create a type.
     */
    data: XOR<typeCreateInput, typeUncheckedCreateInput>
  }

  /**
   * type createMany
   */
  export type typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many types.
     */
    data: typeCreateManyInput | typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * type update
   */
  export type typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type
     */
    select?: typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type
     */
    omit?: typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typeInclude<ExtArgs> | null
    /**
     * The data needed to update a type.
     */
    data: XOR<typeUpdateInput, typeUncheckedUpdateInput>
    /**
     * Choose, which type to update.
     */
    where: typeWhereUniqueInput
  }

  /**
   * type updateMany
   */
  export type typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update types.
     */
    data: XOR<typeUpdateManyMutationInput, typeUncheckedUpdateManyInput>
    /**
     * Filter which types to update
     */
    where?: typeWhereInput
    /**
     * Limit how many types to update.
     */
    limit?: number
  }

  /**
   * type upsert
   */
  export type typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type
     */
    select?: typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type
     */
    omit?: typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typeInclude<ExtArgs> | null
    /**
     * The filter to search for the type to update in case it exists.
     */
    where: typeWhereUniqueInput
    /**
     * In case the type found by the `where` argument doesn't exist, create a new type with this data.
     */
    create: XOR<typeCreateInput, typeUncheckedCreateInput>
    /**
     * In case the type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<typeUpdateInput, typeUncheckedUpdateInput>
  }

  /**
   * type delete
   */
  export type typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type
     */
    select?: typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type
     */
    omit?: typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typeInclude<ExtArgs> | null
    /**
     * Filter which type to delete.
     */
    where: typeWhereUniqueInput
  }

  /**
   * type deleteMany
   */
  export type typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which types to delete
     */
    where?: typeWhereInput
    /**
     * Limit how many types to delete.
     */
    limit?: number
  }

  /**
   * type.capacityInfos
   */
  export type type$capacityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    where?: capacity_infoWhereInput
    orderBy?: capacity_infoOrderByWithRelationInput | capacity_infoOrderByWithRelationInput[]
    cursor?: capacity_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Capacity_infoScalarFieldEnum | Capacity_infoScalarFieldEnum[]
  }

  /**
   * type.typeOrders
   */
  export type type$typeOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_order
     */
    select?: type_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_order
     */
    omit?: type_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_orderInclude<ExtArgs> | null
    where?: type_orderWhereInput
    orderBy?: type_orderOrderByWithRelationInput | type_orderOrderByWithRelationInput[]
    cursor?: type_orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Type_orderScalarFieldEnum | Type_orderScalarFieldEnum[]
  }

  /**
   * type without action
   */
  export type typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type
     */
    select?: typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type
     */
    omit?: typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typeInclude<ExtArgs> | null
  }


  /**
   * Model type_order
   */

  export type AggregateType_order = {
    _count: Type_orderCountAggregateOutputType | null
    _avg: Type_orderAvgAggregateOutputType | null
    _sum: Type_orderSumAggregateOutputType | null
    _min: Type_orderMinAggregateOutputType | null
    _max: Type_orderMaxAggregateOutputType | null
  }

  export type Type_orderAvgAggregateOutputType = {
    typeId: number | null
    pokemonInfoId: number | null
    order: number | null
  }

  export type Type_orderSumAggregateOutputType = {
    typeId: number | null
    pokemonInfoId: number | null
    order: number | null
  }

  export type Type_orderMinAggregateOutputType = {
    typeId: number | null
    pokemonInfoId: number | null
    order: number | null
  }

  export type Type_orderMaxAggregateOutputType = {
    typeId: number | null
    pokemonInfoId: number | null
    order: number | null
  }

  export type Type_orderCountAggregateOutputType = {
    typeId: number
    pokemonInfoId: number
    order: number
    _all: number
  }


  export type Type_orderAvgAggregateInputType = {
    typeId?: true
    pokemonInfoId?: true
    order?: true
  }

  export type Type_orderSumAggregateInputType = {
    typeId?: true
    pokemonInfoId?: true
    order?: true
  }

  export type Type_orderMinAggregateInputType = {
    typeId?: true
    pokemonInfoId?: true
    order?: true
  }

  export type Type_orderMaxAggregateInputType = {
    typeId?: true
    pokemonInfoId?: true
    order?: true
  }

  export type Type_orderCountAggregateInputType = {
    typeId?: true
    pokemonInfoId?: true
    order?: true
    _all?: true
  }

  export type Type_orderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which type_order to aggregate.
     */
    where?: type_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_orders to fetch.
     */
    orderBy?: type_orderOrderByWithRelationInput | type_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: type_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned type_orders
    **/
    _count?: true | Type_orderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Type_orderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Type_orderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Type_orderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Type_orderMaxAggregateInputType
  }

  export type GetType_orderAggregateType<T extends Type_orderAggregateArgs> = {
        [P in keyof T & keyof AggregateType_order]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateType_order[P]>
      : GetScalarType<T[P], AggregateType_order[P]>
  }




  export type type_orderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: type_orderWhereInput
    orderBy?: type_orderOrderByWithAggregationInput | type_orderOrderByWithAggregationInput[]
    by: Type_orderScalarFieldEnum[] | Type_orderScalarFieldEnum
    having?: type_orderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Type_orderCountAggregateInputType | true
    _avg?: Type_orderAvgAggregateInputType
    _sum?: Type_orderSumAggregateInputType
    _min?: Type_orderMinAggregateInputType
    _max?: Type_orderMaxAggregateInputType
  }

  export type Type_orderGroupByOutputType = {
    typeId: number
    pokemonInfoId: number
    order: number
    _count: Type_orderCountAggregateOutputType | null
    _avg: Type_orderAvgAggregateOutputType | null
    _sum: Type_orderSumAggregateOutputType | null
    _min: Type_orderMinAggregateOutputType | null
    _max: Type_orderMaxAggregateOutputType | null
  }

  type GetType_orderGroupByPayload<T extends type_orderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Type_orderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Type_orderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Type_orderGroupByOutputType[P]>
            : GetScalarType<T[P], Type_orderGroupByOutputType[P]>
        }
      >
    >


  export type type_orderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    typeId?: boolean
    pokemonInfoId?: boolean
    order?: boolean
    pokemonInfo?: boolean | pokemon_infoDefaultArgs<ExtArgs>
    type?: boolean | typeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["type_order"]>



  export type type_orderSelectScalar = {
    typeId?: boolean
    pokemonInfoId?: boolean
    order?: boolean
  }

  export type type_orderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"typeId" | "pokemonInfoId" | "order", ExtArgs["result"]["type_order"]>
  export type type_orderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemonInfo?: boolean | pokemon_infoDefaultArgs<ExtArgs>
    type?: boolean | typeDefaultArgs<ExtArgs>
  }

  export type $type_orderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "type_order"
    objects: {
      pokemonInfo: Prisma.$pokemon_infoPayload<ExtArgs>
      type: Prisma.$typePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      typeId: number
      pokemonInfoId: number
      order: number
    }, ExtArgs["result"]["type_order"]>
    composites: {}
  }

  type type_orderGetPayload<S extends boolean | null | undefined | type_orderDefaultArgs> = $Result.GetResult<Prisma.$type_orderPayload, S>

  type type_orderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<type_orderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Type_orderCountAggregateInputType | true
    }

  export interface type_orderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['type_order'], meta: { name: 'type_order' } }
    /**
     * Find zero or one Type_order that matches the filter.
     * @param {type_orderFindUniqueArgs} args - Arguments to find a Type_order
     * @example
     * // Get one Type_order
     * const type_order = await prisma.type_order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends type_orderFindUniqueArgs>(args: SelectSubset<T, type_orderFindUniqueArgs<ExtArgs>>): Prisma__type_orderClient<$Result.GetResult<Prisma.$type_orderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Type_order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {type_orderFindUniqueOrThrowArgs} args - Arguments to find a Type_order
     * @example
     * // Get one Type_order
     * const type_order = await prisma.type_order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends type_orderFindUniqueOrThrowArgs>(args: SelectSubset<T, type_orderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__type_orderClient<$Result.GetResult<Prisma.$type_orderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Type_order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_orderFindFirstArgs} args - Arguments to find a Type_order
     * @example
     * // Get one Type_order
     * const type_order = await prisma.type_order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends type_orderFindFirstArgs>(args?: SelectSubset<T, type_orderFindFirstArgs<ExtArgs>>): Prisma__type_orderClient<$Result.GetResult<Prisma.$type_orderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Type_order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_orderFindFirstOrThrowArgs} args - Arguments to find a Type_order
     * @example
     * // Get one Type_order
     * const type_order = await prisma.type_order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends type_orderFindFirstOrThrowArgs>(args?: SelectSubset<T, type_orderFindFirstOrThrowArgs<ExtArgs>>): Prisma__type_orderClient<$Result.GetResult<Prisma.$type_orderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Type_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_orderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Type_orders
     * const type_orders = await prisma.type_order.findMany()
     * 
     * // Get first 10 Type_orders
     * const type_orders = await prisma.type_order.findMany({ take: 10 })
     * 
     * // Only select the `typeId`
     * const type_orderWithTypeIdOnly = await prisma.type_order.findMany({ select: { typeId: true } })
     * 
     */
    findMany<T extends type_orderFindManyArgs>(args?: SelectSubset<T, type_orderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$type_orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Type_order.
     * @param {type_orderCreateArgs} args - Arguments to create a Type_order.
     * @example
     * // Create one Type_order
     * const Type_order = await prisma.type_order.create({
     *   data: {
     *     // ... data to create a Type_order
     *   }
     * })
     * 
     */
    create<T extends type_orderCreateArgs>(args: SelectSubset<T, type_orderCreateArgs<ExtArgs>>): Prisma__type_orderClient<$Result.GetResult<Prisma.$type_orderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Type_orders.
     * @param {type_orderCreateManyArgs} args - Arguments to create many Type_orders.
     * @example
     * // Create many Type_orders
     * const type_order = await prisma.type_order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends type_orderCreateManyArgs>(args?: SelectSubset<T, type_orderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Type_order.
     * @param {type_orderDeleteArgs} args - Arguments to delete one Type_order.
     * @example
     * // Delete one Type_order
     * const Type_order = await prisma.type_order.delete({
     *   where: {
     *     // ... filter to delete one Type_order
     *   }
     * })
     * 
     */
    delete<T extends type_orderDeleteArgs>(args: SelectSubset<T, type_orderDeleteArgs<ExtArgs>>): Prisma__type_orderClient<$Result.GetResult<Prisma.$type_orderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Type_order.
     * @param {type_orderUpdateArgs} args - Arguments to update one Type_order.
     * @example
     * // Update one Type_order
     * const type_order = await prisma.type_order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends type_orderUpdateArgs>(args: SelectSubset<T, type_orderUpdateArgs<ExtArgs>>): Prisma__type_orderClient<$Result.GetResult<Prisma.$type_orderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Type_orders.
     * @param {type_orderDeleteManyArgs} args - Arguments to filter Type_orders to delete.
     * @example
     * // Delete a few Type_orders
     * const { count } = await prisma.type_order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends type_orderDeleteManyArgs>(args?: SelectSubset<T, type_orderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Type_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_orderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Type_orders
     * const type_order = await prisma.type_order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends type_orderUpdateManyArgs>(args: SelectSubset<T, type_orderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Type_order.
     * @param {type_orderUpsertArgs} args - Arguments to update or create a Type_order.
     * @example
     * // Update or create a Type_order
     * const type_order = await prisma.type_order.upsert({
     *   create: {
     *     // ... data to create a Type_order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Type_order we want to update
     *   }
     * })
     */
    upsert<T extends type_orderUpsertArgs>(args: SelectSubset<T, type_orderUpsertArgs<ExtArgs>>): Prisma__type_orderClient<$Result.GetResult<Prisma.$type_orderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Type_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_orderCountArgs} args - Arguments to filter Type_orders to count.
     * @example
     * // Count the number of Type_orders
     * const count = await prisma.type_order.count({
     *   where: {
     *     // ... the filter for the Type_orders we want to count
     *   }
     * })
    **/
    count<T extends type_orderCountArgs>(
      args?: Subset<T, type_orderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Type_orderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Type_order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Type_orderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Type_orderAggregateArgs>(args: Subset<T, Type_orderAggregateArgs>): Prisma.PrismaPromise<GetType_orderAggregateType<T>>

    /**
     * Group by Type_order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_orderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends type_orderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: type_orderGroupByArgs['orderBy'] }
        : { orderBy?: type_orderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, type_orderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetType_orderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the type_order model
   */
  readonly fields: type_orderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for type_order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__type_orderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pokemonInfo<T extends pokemon_infoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_infoDefaultArgs<ExtArgs>>): Prisma__pokemon_infoClient<$Result.GetResult<Prisma.$pokemon_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    type<T extends typeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, typeDefaultArgs<ExtArgs>>): Prisma__typeClient<$Result.GetResult<Prisma.$typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the type_order model
   */
  interface type_orderFieldRefs {
    readonly typeId: FieldRef<"type_order", 'Int'>
    readonly pokemonInfoId: FieldRef<"type_order", 'Int'>
    readonly order: FieldRef<"type_order", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * type_order findUnique
   */
  export type type_orderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_order
     */
    select?: type_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_order
     */
    omit?: type_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_orderInclude<ExtArgs> | null
    /**
     * Filter, which type_order to fetch.
     */
    where: type_orderWhereUniqueInput
  }

  /**
   * type_order findUniqueOrThrow
   */
  export type type_orderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_order
     */
    select?: type_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_order
     */
    omit?: type_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_orderInclude<ExtArgs> | null
    /**
     * Filter, which type_order to fetch.
     */
    where: type_orderWhereUniqueInput
  }

  /**
   * type_order findFirst
   */
  export type type_orderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_order
     */
    select?: type_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_order
     */
    omit?: type_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_orderInclude<ExtArgs> | null
    /**
     * Filter, which type_order to fetch.
     */
    where?: type_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_orders to fetch.
     */
    orderBy?: type_orderOrderByWithRelationInput | type_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for type_orders.
     */
    cursor?: type_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of type_orders.
     */
    distinct?: Type_orderScalarFieldEnum | Type_orderScalarFieldEnum[]
  }

  /**
   * type_order findFirstOrThrow
   */
  export type type_orderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_order
     */
    select?: type_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_order
     */
    omit?: type_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_orderInclude<ExtArgs> | null
    /**
     * Filter, which type_order to fetch.
     */
    where?: type_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_orders to fetch.
     */
    orderBy?: type_orderOrderByWithRelationInput | type_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for type_orders.
     */
    cursor?: type_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of type_orders.
     */
    distinct?: Type_orderScalarFieldEnum | Type_orderScalarFieldEnum[]
  }

  /**
   * type_order findMany
   */
  export type type_orderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_order
     */
    select?: type_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_order
     */
    omit?: type_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_orderInclude<ExtArgs> | null
    /**
     * Filter, which type_orders to fetch.
     */
    where?: type_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_orders to fetch.
     */
    orderBy?: type_orderOrderByWithRelationInput | type_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing type_orders.
     */
    cursor?: type_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_orders.
     */
    skip?: number
    distinct?: Type_orderScalarFieldEnum | Type_orderScalarFieldEnum[]
  }

  /**
   * type_order create
   */
  export type type_orderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_order
     */
    select?: type_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_order
     */
    omit?: type_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_orderInclude<ExtArgs> | null
    /**
     * The data needed to create a type_order.
     */
    data: XOR<type_orderCreateInput, type_orderUncheckedCreateInput>
  }

  /**
   * type_order createMany
   */
  export type type_orderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many type_orders.
     */
    data: type_orderCreateManyInput | type_orderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * type_order update
   */
  export type type_orderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_order
     */
    select?: type_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_order
     */
    omit?: type_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_orderInclude<ExtArgs> | null
    /**
     * The data needed to update a type_order.
     */
    data: XOR<type_orderUpdateInput, type_orderUncheckedUpdateInput>
    /**
     * Choose, which type_order to update.
     */
    where: type_orderWhereUniqueInput
  }

  /**
   * type_order updateMany
   */
  export type type_orderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update type_orders.
     */
    data: XOR<type_orderUpdateManyMutationInput, type_orderUncheckedUpdateManyInput>
    /**
     * Filter which type_orders to update
     */
    where?: type_orderWhereInput
    /**
     * Limit how many type_orders to update.
     */
    limit?: number
  }

  /**
   * type_order upsert
   */
  export type type_orderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_order
     */
    select?: type_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_order
     */
    omit?: type_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_orderInclude<ExtArgs> | null
    /**
     * The filter to search for the type_order to update in case it exists.
     */
    where: type_orderWhereUniqueInput
    /**
     * In case the type_order found by the `where` argument doesn't exist, create a new type_order with this data.
     */
    create: XOR<type_orderCreateInput, type_orderUncheckedCreateInput>
    /**
     * In case the type_order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<type_orderUpdateInput, type_orderUncheckedUpdateInput>
  }

  /**
   * type_order delete
   */
  export type type_orderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_order
     */
    select?: type_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_order
     */
    omit?: type_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_orderInclude<ExtArgs> | null
    /**
     * Filter which type_order to delete.
     */
    where: type_orderWhereUniqueInput
  }

  /**
   * type_order deleteMany
   */
  export type type_orderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which type_orders to delete
     */
    where?: type_orderWhereInput
    /**
     * Limit how many type_orders to delete.
     */
    limit?: number
  }

  /**
   * type_order without action
   */
  export type type_orderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_order
     */
    select?: type_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_order
     */
    omit?: type_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_orderInclude<ExtArgs> | null
  }


  /**
   * Model national_number
   */

  export type AggregateNational_number = {
    _count: National_numberCountAggregateOutputType | null
    _avg: National_numberAvgAggregateOutputType | null
    _sum: National_numberSumAggregateOutputType | null
    _min: National_numberMinAggregateOutputType | null
    _max: National_numberMaxAggregateOutputType | null
  }

  export type National_numberAvgAggregateOutputType = {
    groupGameId: number | null
    pokemonId: number | null
    number: number | null
  }

  export type National_numberSumAggregateOutputType = {
    groupGameId: number | null
    pokemonId: number | null
    number: number | null
  }

  export type National_numberMinAggregateOutputType = {
    groupGameId: number | null
    pokemonId: number | null
    number: number | null
  }

  export type National_numberMaxAggregateOutputType = {
    groupGameId: number | null
    pokemonId: number | null
    number: number | null
  }

  export type National_numberCountAggregateOutputType = {
    groupGameId: number
    pokemonId: number
    number: number
    _all: number
  }


  export type National_numberAvgAggregateInputType = {
    groupGameId?: true
    pokemonId?: true
    number?: true
  }

  export type National_numberSumAggregateInputType = {
    groupGameId?: true
    pokemonId?: true
    number?: true
  }

  export type National_numberMinAggregateInputType = {
    groupGameId?: true
    pokemonId?: true
    number?: true
  }

  export type National_numberMaxAggregateInputType = {
    groupGameId?: true
    pokemonId?: true
    number?: true
  }

  export type National_numberCountAggregateInputType = {
    groupGameId?: true
    pokemonId?: true
    number?: true
    _all?: true
  }

  export type National_numberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which national_number to aggregate.
     */
    where?: national_numberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of national_numbers to fetch.
     */
    orderBy?: national_numberOrderByWithRelationInput | national_numberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: national_numberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` national_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` national_numbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned national_numbers
    **/
    _count?: true | National_numberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: National_numberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: National_numberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: National_numberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: National_numberMaxAggregateInputType
  }

  export type GetNational_numberAggregateType<T extends National_numberAggregateArgs> = {
        [P in keyof T & keyof AggregateNational_number]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNational_number[P]>
      : GetScalarType<T[P], AggregateNational_number[P]>
  }




  export type national_numberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: national_numberWhereInput
    orderBy?: national_numberOrderByWithAggregationInput | national_numberOrderByWithAggregationInput[]
    by: National_numberScalarFieldEnum[] | National_numberScalarFieldEnum
    having?: national_numberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: National_numberCountAggregateInputType | true
    _avg?: National_numberAvgAggregateInputType
    _sum?: National_numberSumAggregateInputType
    _min?: National_numberMinAggregateInputType
    _max?: National_numberMaxAggregateInputType
  }

  export type National_numberGroupByOutputType = {
    groupGameId: number
    pokemonId: number
    number: number
    _count: National_numberCountAggregateOutputType | null
    _avg: National_numberAvgAggregateOutputType | null
    _sum: National_numberSumAggregateOutputType | null
    _min: National_numberMinAggregateOutputType | null
    _max: National_numberMaxAggregateOutputType | null
  }

  type GetNational_numberGroupByPayload<T extends national_numberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<National_numberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof National_numberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], National_numberGroupByOutputType[P]>
            : GetScalarType<T[P], National_numberGroupByOutputType[P]>
        }
      >
    >


  export type national_numberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    groupGameId?: boolean
    pokemonId?: boolean
    number?: boolean
    groupGame?: boolean | group_gameDefaultArgs<ExtArgs>
    pokemon?: boolean | pokemonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["national_number"]>



  export type national_numberSelectScalar = {
    groupGameId?: boolean
    pokemonId?: boolean
    number?: boolean
  }

  export type national_numberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"groupGameId" | "pokemonId" | "number", ExtArgs["result"]["national_number"]>
  export type national_numberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupGame?: boolean | group_gameDefaultArgs<ExtArgs>
    pokemon?: boolean | pokemonDefaultArgs<ExtArgs>
  }

  export type $national_numberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "national_number"
    objects: {
      groupGame: Prisma.$group_gamePayload<ExtArgs>
      pokemon: Prisma.$pokemonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      groupGameId: number
      pokemonId: number
      number: number
    }, ExtArgs["result"]["national_number"]>
    composites: {}
  }

  type national_numberGetPayload<S extends boolean | null | undefined | national_numberDefaultArgs> = $Result.GetResult<Prisma.$national_numberPayload, S>

  type national_numberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<national_numberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: National_numberCountAggregateInputType | true
    }

  export interface national_numberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['national_number'], meta: { name: 'national_number' } }
    /**
     * Find zero or one National_number that matches the filter.
     * @param {national_numberFindUniqueArgs} args - Arguments to find a National_number
     * @example
     * // Get one National_number
     * const national_number = await prisma.national_number.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends national_numberFindUniqueArgs>(args: SelectSubset<T, national_numberFindUniqueArgs<ExtArgs>>): Prisma__national_numberClient<$Result.GetResult<Prisma.$national_numberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one National_number that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {national_numberFindUniqueOrThrowArgs} args - Arguments to find a National_number
     * @example
     * // Get one National_number
     * const national_number = await prisma.national_number.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends national_numberFindUniqueOrThrowArgs>(args: SelectSubset<T, national_numberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__national_numberClient<$Result.GetResult<Prisma.$national_numberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first National_number that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {national_numberFindFirstArgs} args - Arguments to find a National_number
     * @example
     * // Get one National_number
     * const national_number = await prisma.national_number.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends national_numberFindFirstArgs>(args?: SelectSubset<T, national_numberFindFirstArgs<ExtArgs>>): Prisma__national_numberClient<$Result.GetResult<Prisma.$national_numberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first National_number that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {national_numberFindFirstOrThrowArgs} args - Arguments to find a National_number
     * @example
     * // Get one National_number
     * const national_number = await prisma.national_number.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends national_numberFindFirstOrThrowArgs>(args?: SelectSubset<T, national_numberFindFirstOrThrowArgs<ExtArgs>>): Prisma__national_numberClient<$Result.GetResult<Prisma.$national_numberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more National_numbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {national_numberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all National_numbers
     * const national_numbers = await prisma.national_number.findMany()
     * 
     * // Get first 10 National_numbers
     * const national_numbers = await prisma.national_number.findMany({ take: 10 })
     * 
     * // Only select the `groupGameId`
     * const national_numberWithGroupGameIdOnly = await prisma.national_number.findMany({ select: { groupGameId: true } })
     * 
     */
    findMany<T extends national_numberFindManyArgs>(args?: SelectSubset<T, national_numberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$national_numberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a National_number.
     * @param {national_numberCreateArgs} args - Arguments to create a National_number.
     * @example
     * // Create one National_number
     * const National_number = await prisma.national_number.create({
     *   data: {
     *     // ... data to create a National_number
     *   }
     * })
     * 
     */
    create<T extends national_numberCreateArgs>(args: SelectSubset<T, national_numberCreateArgs<ExtArgs>>): Prisma__national_numberClient<$Result.GetResult<Prisma.$national_numberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many National_numbers.
     * @param {national_numberCreateManyArgs} args - Arguments to create many National_numbers.
     * @example
     * // Create many National_numbers
     * const national_number = await prisma.national_number.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends national_numberCreateManyArgs>(args?: SelectSubset<T, national_numberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a National_number.
     * @param {national_numberDeleteArgs} args - Arguments to delete one National_number.
     * @example
     * // Delete one National_number
     * const National_number = await prisma.national_number.delete({
     *   where: {
     *     // ... filter to delete one National_number
     *   }
     * })
     * 
     */
    delete<T extends national_numberDeleteArgs>(args: SelectSubset<T, national_numberDeleteArgs<ExtArgs>>): Prisma__national_numberClient<$Result.GetResult<Prisma.$national_numberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one National_number.
     * @param {national_numberUpdateArgs} args - Arguments to update one National_number.
     * @example
     * // Update one National_number
     * const national_number = await prisma.national_number.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends national_numberUpdateArgs>(args: SelectSubset<T, national_numberUpdateArgs<ExtArgs>>): Prisma__national_numberClient<$Result.GetResult<Prisma.$national_numberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more National_numbers.
     * @param {national_numberDeleteManyArgs} args - Arguments to filter National_numbers to delete.
     * @example
     * // Delete a few National_numbers
     * const { count } = await prisma.national_number.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends national_numberDeleteManyArgs>(args?: SelectSubset<T, national_numberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more National_numbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {national_numberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many National_numbers
     * const national_number = await prisma.national_number.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends national_numberUpdateManyArgs>(args: SelectSubset<T, national_numberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one National_number.
     * @param {national_numberUpsertArgs} args - Arguments to update or create a National_number.
     * @example
     * // Update or create a National_number
     * const national_number = await prisma.national_number.upsert({
     *   create: {
     *     // ... data to create a National_number
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the National_number we want to update
     *   }
     * })
     */
    upsert<T extends national_numberUpsertArgs>(args: SelectSubset<T, national_numberUpsertArgs<ExtArgs>>): Prisma__national_numberClient<$Result.GetResult<Prisma.$national_numberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of National_numbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {national_numberCountArgs} args - Arguments to filter National_numbers to count.
     * @example
     * // Count the number of National_numbers
     * const count = await prisma.national_number.count({
     *   where: {
     *     // ... the filter for the National_numbers we want to count
     *   }
     * })
    **/
    count<T extends national_numberCountArgs>(
      args?: Subset<T, national_numberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], National_numberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a National_number.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {National_numberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends National_numberAggregateArgs>(args: Subset<T, National_numberAggregateArgs>): Prisma.PrismaPromise<GetNational_numberAggregateType<T>>

    /**
     * Group by National_number.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {national_numberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends national_numberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: national_numberGroupByArgs['orderBy'] }
        : { orderBy?: national_numberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, national_numberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNational_numberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the national_number model
   */
  readonly fields: national_numberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for national_number.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__national_numberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    groupGame<T extends group_gameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, group_gameDefaultArgs<ExtArgs>>): Prisma__group_gameClient<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemon<T extends pokemonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemonDefaultArgs<ExtArgs>>): Prisma__pokemonClient<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the national_number model
   */
  interface national_numberFieldRefs {
    readonly groupGameId: FieldRef<"national_number", 'Int'>
    readonly pokemonId: FieldRef<"national_number", 'Int'>
    readonly number: FieldRef<"national_number", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * national_number findUnique
   */
  export type national_numberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the national_number
     */
    select?: national_numberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the national_number
     */
    omit?: national_numberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: national_numberInclude<ExtArgs> | null
    /**
     * Filter, which national_number to fetch.
     */
    where: national_numberWhereUniqueInput
  }

  /**
   * national_number findUniqueOrThrow
   */
  export type national_numberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the national_number
     */
    select?: national_numberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the national_number
     */
    omit?: national_numberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: national_numberInclude<ExtArgs> | null
    /**
     * Filter, which national_number to fetch.
     */
    where: national_numberWhereUniqueInput
  }

  /**
   * national_number findFirst
   */
  export type national_numberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the national_number
     */
    select?: national_numberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the national_number
     */
    omit?: national_numberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: national_numberInclude<ExtArgs> | null
    /**
     * Filter, which national_number to fetch.
     */
    where?: national_numberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of national_numbers to fetch.
     */
    orderBy?: national_numberOrderByWithRelationInput | national_numberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for national_numbers.
     */
    cursor?: national_numberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` national_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` national_numbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of national_numbers.
     */
    distinct?: National_numberScalarFieldEnum | National_numberScalarFieldEnum[]
  }

  /**
   * national_number findFirstOrThrow
   */
  export type national_numberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the national_number
     */
    select?: national_numberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the national_number
     */
    omit?: national_numberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: national_numberInclude<ExtArgs> | null
    /**
     * Filter, which national_number to fetch.
     */
    where?: national_numberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of national_numbers to fetch.
     */
    orderBy?: national_numberOrderByWithRelationInput | national_numberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for national_numbers.
     */
    cursor?: national_numberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` national_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` national_numbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of national_numbers.
     */
    distinct?: National_numberScalarFieldEnum | National_numberScalarFieldEnum[]
  }

  /**
   * national_number findMany
   */
  export type national_numberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the national_number
     */
    select?: national_numberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the national_number
     */
    omit?: national_numberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: national_numberInclude<ExtArgs> | null
    /**
     * Filter, which national_numbers to fetch.
     */
    where?: national_numberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of national_numbers to fetch.
     */
    orderBy?: national_numberOrderByWithRelationInput | national_numberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing national_numbers.
     */
    cursor?: national_numberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` national_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` national_numbers.
     */
    skip?: number
    distinct?: National_numberScalarFieldEnum | National_numberScalarFieldEnum[]
  }

  /**
   * national_number create
   */
  export type national_numberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the national_number
     */
    select?: national_numberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the national_number
     */
    omit?: national_numberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: national_numberInclude<ExtArgs> | null
    /**
     * The data needed to create a national_number.
     */
    data: XOR<national_numberCreateInput, national_numberUncheckedCreateInput>
  }

  /**
   * national_number createMany
   */
  export type national_numberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many national_numbers.
     */
    data: national_numberCreateManyInput | national_numberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * national_number update
   */
  export type national_numberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the national_number
     */
    select?: national_numberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the national_number
     */
    omit?: national_numberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: national_numberInclude<ExtArgs> | null
    /**
     * The data needed to update a national_number.
     */
    data: XOR<national_numberUpdateInput, national_numberUncheckedUpdateInput>
    /**
     * Choose, which national_number to update.
     */
    where: national_numberWhereUniqueInput
  }

  /**
   * national_number updateMany
   */
  export type national_numberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update national_numbers.
     */
    data: XOR<national_numberUpdateManyMutationInput, national_numberUncheckedUpdateManyInput>
    /**
     * Filter which national_numbers to update
     */
    where?: national_numberWhereInput
    /**
     * Limit how many national_numbers to update.
     */
    limit?: number
  }

  /**
   * national_number upsert
   */
  export type national_numberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the national_number
     */
    select?: national_numberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the national_number
     */
    omit?: national_numberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: national_numberInclude<ExtArgs> | null
    /**
     * The filter to search for the national_number to update in case it exists.
     */
    where: national_numberWhereUniqueInput
    /**
     * In case the national_number found by the `where` argument doesn't exist, create a new national_number with this data.
     */
    create: XOR<national_numberCreateInput, national_numberUncheckedCreateInput>
    /**
     * In case the national_number was found with the provided `where` argument, update it with this data.
     */
    update: XOR<national_numberUpdateInput, national_numberUncheckedUpdateInput>
  }

  /**
   * national_number delete
   */
  export type national_numberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the national_number
     */
    select?: national_numberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the national_number
     */
    omit?: national_numberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: national_numberInclude<ExtArgs> | null
    /**
     * Filter which national_number to delete.
     */
    where: national_numberWhereUniqueInput
  }

  /**
   * national_number deleteMany
   */
  export type national_numberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which national_numbers to delete
     */
    where?: national_numberWhereInput
    /**
     * Limit how many national_numbers to delete.
     */
    limit?: number
  }

  /**
   * national_number without action
   */
  export type national_numberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the national_number
     */
    select?: national_numberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the national_number
     */
    omit?: national_numberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: national_numberInclude<ExtArgs> | null
  }


  /**
   * Model land
   */

  export type AggregateLand = {
    _count: LandCountAggregateOutputType | null
    _avg: LandAvgAggregateOutputType | null
    _sum: LandSumAggregateOutputType | null
    _min: LandMinAggregateOutputType | null
    _max: LandMaxAggregateOutputType | null
  }

  export type LandAvgAggregateOutputType = {
    id: number | null
  }

  export type LandSumAggregateOutputType = {
    id: number | null
  }

  export type LandMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type LandMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type LandCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type LandAvgAggregateInputType = {
    id?: true
  }

  export type LandSumAggregateInputType = {
    id?: true
  }

  export type LandMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type LandMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type LandCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type LandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which land to aggregate.
     */
    where?: landWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lands to fetch.
     */
    orderBy?: landOrderByWithRelationInput | landOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: landWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lands
    **/
    _count?: true | LandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandMaxAggregateInputType
  }

  export type GetLandAggregateType<T extends LandAggregateArgs> = {
        [P in keyof T & keyof AggregateLand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLand[P]>
      : GetScalarType<T[P], AggregateLand[P]>
  }




  export type landGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: landWhereInput
    orderBy?: landOrderByWithAggregationInput | landOrderByWithAggregationInput[]
    by: LandScalarFieldEnum[] | LandScalarFieldEnum
    having?: landScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandCountAggregateInputType | true
    _avg?: LandAvgAggregateInputType
    _sum?: LandSumAggregateInputType
    _min?: LandMinAggregateInputType
    _max?: LandMaxAggregateInputType
  }

  export type LandGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: LandCountAggregateOutputType | null
    _avg: LandAvgAggregateOutputType | null
    _sum: LandSumAggregateOutputType | null
    _min: LandMinAggregateOutputType | null
    _max: LandMaxAggregateOutputType | null
  }

  type GetLandGroupByPayload<T extends landGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandGroupByOutputType[P]>
            : GetScalarType<T[P], LandGroupByOutputType[P]>
        }
      >
    >


  export type landSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    game_group_game?: boolean | land$game_group_gameArgs<ExtArgs>
    _count?: boolean | LandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["land"]>



  export type landSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type landOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["land"]>
  export type landInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game_group_game?: boolean | land$game_group_gameArgs<ExtArgs>
    _count?: boolean | LandCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $landPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "land"
    objects: {
      game_group_game: Prisma.$game_group_gamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["land"]>
    composites: {}
  }

  type landGetPayload<S extends boolean | null | undefined | landDefaultArgs> = $Result.GetResult<Prisma.$landPayload, S>

  type landCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<landFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LandCountAggregateInputType | true
    }

  export interface landDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['land'], meta: { name: 'land' } }
    /**
     * Find zero or one Land that matches the filter.
     * @param {landFindUniqueArgs} args - Arguments to find a Land
     * @example
     * // Get one Land
     * const land = await prisma.land.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends landFindUniqueArgs>(args: SelectSubset<T, landFindUniqueArgs<ExtArgs>>): Prisma__landClient<$Result.GetResult<Prisma.$landPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Land that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {landFindUniqueOrThrowArgs} args - Arguments to find a Land
     * @example
     * // Get one Land
     * const land = await prisma.land.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends landFindUniqueOrThrowArgs>(args: SelectSubset<T, landFindUniqueOrThrowArgs<ExtArgs>>): Prisma__landClient<$Result.GetResult<Prisma.$landPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Land that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landFindFirstArgs} args - Arguments to find a Land
     * @example
     * // Get one Land
     * const land = await prisma.land.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends landFindFirstArgs>(args?: SelectSubset<T, landFindFirstArgs<ExtArgs>>): Prisma__landClient<$Result.GetResult<Prisma.$landPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Land that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landFindFirstOrThrowArgs} args - Arguments to find a Land
     * @example
     * // Get one Land
     * const land = await prisma.land.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends landFindFirstOrThrowArgs>(args?: SelectSubset<T, landFindFirstOrThrowArgs<ExtArgs>>): Prisma__landClient<$Result.GetResult<Prisma.$landPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lands
     * const lands = await prisma.land.findMany()
     * 
     * // Get first 10 Lands
     * const lands = await prisma.land.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const landWithIdOnly = await prisma.land.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends landFindManyArgs>(args?: SelectSubset<T, landFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Land.
     * @param {landCreateArgs} args - Arguments to create a Land.
     * @example
     * // Create one Land
     * const Land = await prisma.land.create({
     *   data: {
     *     // ... data to create a Land
     *   }
     * })
     * 
     */
    create<T extends landCreateArgs>(args: SelectSubset<T, landCreateArgs<ExtArgs>>): Prisma__landClient<$Result.GetResult<Prisma.$landPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lands.
     * @param {landCreateManyArgs} args - Arguments to create many Lands.
     * @example
     * // Create many Lands
     * const land = await prisma.land.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends landCreateManyArgs>(args?: SelectSubset<T, landCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Land.
     * @param {landDeleteArgs} args - Arguments to delete one Land.
     * @example
     * // Delete one Land
     * const Land = await prisma.land.delete({
     *   where: {
     *     // ... filter to delete one Land
     *   }
     * })
     * 
     */
    delete<T extends landDeleteArgs>(args: SelectSubset<T, landDeleteArgs<ExtArgs>>): Prisma__landClient<$Result.GetResult<Prisma.$landPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Land.
     * @param {landUpdateArgs} args - Arguments to update one Land.
     * @example
     * // Update one Land
     * const land = await prisma.land.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends landUpdateArgs>(args: SelectSubset<T, landUpdateArgs<ExtArgs>>): Prisma__landClient<$Result.GetResult<Prisma.$landPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lands.
     * @param {landDeleteManyArgs} args - Arguments to filter Lands to delete.
     * @example
     * // Delete a few Lands
     * const { count } = await prisma.land.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends landDeleteManyArgs>(args?: SelectSubset<T, landDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lands
     * const land = await prisma.land.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends landUpdateManyArgs>(args: SelectSubset<T, landUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Land.
     * @param {landUpsertArgs} args - Arguments to update or create a Land.
     * @example
     * // Update or create a Land
     * const land = await prisma.land.upsert({
     *   create: {
     *     // ... data to create a Land
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Land we want to update
     *   }
     * })
     */
    upsert<T extends landUpsertArgs>(args: SelectSubset<T, landUpsertArgs<ExtArgs>>): Prisma__landClient<$Result.GetResult<Prisma.$landPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landCountArgs} args - Arguments to filter Lands to count.
     * @example
     * // Count the number of Lands
     * const count = await prisma.land.count({
     *   where: {
     *     // ... the filter for the Lands we want to count
     *   }
     * })
    **/
    count<T extends landCountArgs>(
      args?: Subset<T, landCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Land.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandAggregateArgs>(args: Subset<T, LandAggregateArgs>): Prisma.PrismaPromise<GetLandAggregateType<T>>

    /**
     * Group by Land.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends landGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: landGroupByArgs['orderBy'] }
        : { orderBy?: landGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, landGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the land model
   */
  readonly fields: landFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for land.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__landClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game_group_game<T extends land$game_group_gameArgs<ExtArgs> = {}>(args?: Subset<T, land$game_group_gameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_group_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the land model
   */
  interface landFieldRefs {
    readonly id: FieldRef<"land", 'Int'>
    readonly createdAt: FieldRef<"land", 'DateTime'>
    readonly updatedAt: FieldRef<"land", 'DateTime'>
    readonly status: FieldRef<"land", 'String'>
  }
    

  // Custom InputTypes
  /**
   * land findUnique
   */
  export type landFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land
     */
    select?: landSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land
     */
    omit?: landOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landInclude<ExtArgs> | null
    /**
     * Filter, which land to fetch.
     */
    where: landWhereUniqueInput
  }

  /**
   * land findUniqueOrThrow
   */
  export type landFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land
     */
    select?: landSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land
     */
    omit?: landOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landInclude<ExtArgs> | null
    /**
     * Filter, which land to fetch.
     */
    where: landWhereUniqueInput
  }

  /**
   * land findFirst
   */
  export type landFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land
     */
    select?: landSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land
     */
    omit?: landOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landInclude<ExtArgs> | null
    /**
     * Filter, which land to fetch.
     */
    where?: landWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lands to fetch.
     */
    orderBy?: landOrderByWithRelationInput | landOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lands.
     */
    cursor?: landWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lands.
     */
    distinct?: LandScalarFieldEnum | LandScalarFieldEnum[]
  }

  /**
   * land findFirstOrThrow
   */
  export type landFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land
     */
    select?: landSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land
     */
    omit?: landOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landInclude<ExtArgs> | null
    /**
     * Filter, which land to fetch.
     */
    where?: landWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lands to fetch.
     */
    orderBy?: landOrderByWithRelationInput | landOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lands.
     */
    cursor?: landWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lands.
     */
    distinct?: LandScalarFieldEnum | LandScalarFieldEnum[]
  }

  /**
   * land findMany
   */
  export type landFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land
     */
    select?: landSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land
     */
    omit?: landOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landInclude<ExtArgs> | null
    /**
     * Filter, which lands to fetch.
     */
    where?: landWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lands to fetch.
     */
    orderBy?: landOrderByWithRelationInput | landOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lands.
     */
    cursor?: landWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lands.
     */
    skip?: number
    distinct?: LandScalarFieldEnum | LandScalarFieldEnum[]
  }

  /**
   * land create
   */
  export type landCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land
     */
    select?: landSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land
     */
    omit?: landOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landInclude<ExtArgs> | null
    /**
     * The data needed to create a land.
     */
    data?: XOR<landCreateInput, landUncheckedCreateInput>
  }

  /**
   * land createMany
   */
  export type landCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lands.
     */
    data: landCreateManyInput | landCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * land update
   */
  export type landUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land
     */
    select?: landSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land
     */
    omit?: landOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landInclude<ExtArgs> | null
    /**
     * The data needed to update a land.
     */
    data: XOR<landUpdateInput, landUncheckedUpdateInput>
    /**
     * Choose, which land to update.
     */
    where: landWhereUniqueInput
  }

  /**
   * land updateMany
   */
  export type landUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lands.
     */
    data: XOR<landUpdateManyMutationInput, landUncheckedUpdateManyInput>
    /**
     * Filter which lands to update
     */
    where?: landWhereInput
    /**
     * Limit how many lands to update.
     */
    limit?: number
  }

  /**
   * land upsert
   */
  export type landUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land
     */
    select?: landSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land
     */
    omit?: landOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landInclude<ExtArgs> | null
    /**
     * The filter to search for the land to update in case it exists.
     */
    where: landWhereUniqueInput
    /**
     * In case the land found by the `where` argument doesn't exist, create a new land with this data.
     */
    create: XOR<landCreateInput, landUncheckedCreateInput>
    /**
     * In case the land was found with the provided `where` argument, update it with this data.
     */
    update: XOR<landUpdateInput, landUncheckedUpdateInput>
  }

  /**
   * land delete
   */
  export type landDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land
     */
    select?: landSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land
     */
    omit?: landOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landInclude<ExtArgs> | null
    /**
     * Filter which land to delete.
     */
    where: landWhereUniqueInput
  }

  /**
   * land deleteMany
   */
  export type landDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lands to delete
     */
    where?: landWhereInput
    /**
     * Limit how many lands to delete.
     */
    limit?: number
  }

  /**
   * land.game_group_game
   */
  export type land$game_group_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_group_game
     */
    select?: game_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_group_game
     */
    omit?: game_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_group_gameInclude<ExtArgs> | null
    where?: game_group_gameWhereInput
    orderBy?: game_group_gameOrderByWithRelationInput | game_group_gameOrderByWithRelationInput[]
    cursor?: game_group_gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Game_group_gameScalarFieldEnum | Game_group_gameScalarFieldEnum[]
  }

  /**
   * land without action
   */
  export type landDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land
     */
    select?: landSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land
     */
    omit?: landOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landInclude<ExtArgs> | null
  }


  /**
   * Model capacity
   */

  export type AggregateCapacity = {
    _count: CapacityCountAggregateOutputType | null
    _avg: CapacityAvgAggregateOutputType | null
    _sum: CapacitySumAggregateOutputType | null
    _min: CapacityMinAggregateOutputType | null
    _max: CapacityMaxAggregateOutputType | null
  }

  export type CapacityAvgAggregateOutputType = {
    id: number | null
  }

  export type CapacitySumAggregateOutputType = {
    id: number | null
  }

  export type CapacityMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type CapacityMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type CapacityCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type CapacityAvgAggregateInputType = {
    id?: true
  }

  export type CapacitySumAggregateInputType = {
    id?: true
  }

  export type CapacityMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type CapacityMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type CapacityCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type CapacityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capacity to aggregate.
     */
    where?: capacityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacities to fetch.
     */
    orderBy?: capacityOrderByWithRelationInput | capacityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: capacityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned capacities
    **/
    _count?: true | CapacityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CapacityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CapacitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CapacityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CapacityMaxAggregateInputType
  }

  export type GetCapacityAggregateType<T extends CapacityAggregateArgs> = {
        [P in keyof T & keyof AggregateCapacity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapacity[P]>
      : GetScalarType<T[P], AggregateCapacity[P]>
  }




  export type capacityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacityWhereInput
    orderBy?: capacityOrderByWithAggregationInput | capacityOrderByWithAggregationInput[]
    by: CapacityScalarFieldEnum[] | CapacityScalarFieldEnum
    having?: capacityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CapacityCountAggregateInputType | true
    _avg?: CapacityAvgAggregateInputType
    _sum?: CapacitySumAggregateInputType
    _min?: CapacityMinAggregateInputType
    _max?: CapacityMaxAggregateInputType
  }

  export type CapacityGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: CapacityCountAggregateOutputType | null
    _avg: CapacityAvgAggregateOutputType | null
    _sum: CapacitySumAggregateOutputType | null
    _min: CapacityMinAggregateOutputType | null
    _max: CapacityMaxAggregateOutputType | null
  }

  type GetCapacityGroupByPayload<T extends capacityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CapacityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CapacityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CapacityGroupByOutputType[P]>
            : GetScalarType<T[P], CapacityGroupByOutputType[P]>
        }
      >
    >


  export type capacitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    capacityInfos?: boolean | capacity$capacityInfosArgs<ExtArgs>
    skillObtations?: boolean | capacity$skillObtationsArgs<ExtArgs>
    _count?: boolean | CapacityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capacity"]>



  export type capacitySelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type capacityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["capacity"]>
  export type capacityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfos?: boolean | capacity$capacityInfosArgs<ExtArgs>
    skillObtations?: boolean | capacity$skillObtationsArgs<ExtArgs>
    _count?: boolean | CapacityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $capacityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "capacity"
    objects: {
      capacityInfos: Prisma.$capacity_infoPayload<ExtArgs>[]
      skillObtations: Prisma.$skill_obtationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["capacity"]>
    composites: {}
  }

  type capacityGetPayload<S extends boolean | null | undefined | capacityDefaultArgs> = $Result.GetResult<Prisma.$capacityPayload, S>

  type capacityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<capacityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CapacityCountAggregateInputType | true
    }

  export interface capacityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['capacity'], meta: { name: 'capacity' } }
    /**
     * Find zero or one Capacity that matches the filter.
     * @param {capacityFindUniqueArgs} args - Arguments to find a Capacity
     * @example
     * // Get one Capacity
     * const capacity = await prisma.capacity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends capacityFindUniqueArgs>(args: SelectSubset<T, capacityFindUniqueArgs<ExtArgs>>): Prisma__capacityClient<$Result.GetResult<Prisma.$capacityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Capacity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {capacityFindUniqueOrThrowArgs} args - Arguments to find a Capacity
     * @example
     * // Get one Capacity
     * const capacity = await prisma.capacity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends capacityFindUniqueOrThrowArgs>(args: SelectSubset<T, capacityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__capacityClient<$Result.GetResult<Prisma.$capacityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capacity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacityFindFirstArgs} args - Arguments to find a Capacity
     * @example
     * // Get one Capacity
     * const capacity = await prisma.capacity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends capacityFindFirstArgs>(args?: SelectSubset<T, capacityFindFirstArgs<ExtArgs>>): Prisma__capacityClient<$Result.GetResult<Prisma.$capacityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capacity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacityFindFirstOrThrowArgs} args - Arguments to find a Capacity
     * @example
     * // Get one Capacity
     * const capacity = await prisma.capacity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends capacityFindFirstOrThrowArgs>(args?: SelectSubset<T, capacityFindFirstOrThrowArgs<ExtArgs>>): Prisma__capacityClient<$Result.GetResult<Prisma.$capacityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Capacities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Capacities
     * const capacities = await prisma.capacity.findMany()
     * 
     * // Get first 10 Capacities
     * const capacities = await prisma.capacity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capacityWithIdOnly = await prisma.capacity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends capacityFindManyArgs>(args?: SelectSubset<T, capacityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Capacity.
     * @param {capacityCreateArgs} args - Arguments to create a Capacity.
     * @example
     * // Create one Capacity
     * const Capacity = await prisma.capacity.create({
     *   data: {
     *     // ... data to create a Capacity
     *   }
     * })
     * 
     */
    create<T extends capacityCreateArgs>(args: SelectSubset<T, capacityCreateArgs<ExtArgs>>): Prisma__capacityClient<$Result.GetResult<Prisma.$capacityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Capacities.
     * @param {capacityCreateManyArgs} args - Arguments to create many Capacities.
     * @example
     * // Create many Capacities
     * const capacity = await prisma.capacity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends capacityCreateManyArgs>(args?: SelectSubset<T, capacityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Capacity.
     * @param {capacityDeleteArgs} args - Arguments to delete one Capacity.
     * @example
     * // Delete one Capacity
     * const Capacity = await prisma.capacity.delete({
     *   where: {
     *     // ... filter to delete one Capacity
     *   }
     * })
     * 
     */
    delete<T extends capacityDeleteArgs>(args: SelectSubset<T, capacityDeleteArgs<ExtArgs>>): Prisma__capacityClient<$Result.GetResult<Prisma.$capacityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Capacity.
     * @param {capacityUpdateArgs} args - Arguments to update one Capacity.
     * @example
     * // Update one Capacity
     * const capacity = await prisma.capacity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends capacityUpdateArgs>(args: SelectSubset<T, capacityUpdateArgs<ExtArgs>>): Prisma__capacityClient<$Result.GetResult<Prisma.$capacityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Capacities.
     * @param {capacityDeleteManyArgs} args - Arguments to filter Capacities to delete.
     * @example
     * // Delete a few Capacities
     * const { count } = await prisma.capacity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends capacityDeleteManyArgs>(args?: SelectSubset<T, capacityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capacities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Capacities
     * const capacity = await prisma.capacity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends capacityUpdateManyArgs>(args: SelectSubset<T, capacityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Capacity.
     * @param {capacityUpsertArgs} args - Arguments to update or create a Capacity.
     * @example
     * // Update or create a Capacity
     * const capacity = await prisma.capacity.upsert({
     *   create: {
     *     // ... data to create a Capacity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Capacity we want to update
     *   }
     * })
     */
    upsert<T extends capacityUpsertArgs>(args: SelectSubset<T, capacityUpsertArgs<ExtArgs>>): Prisma__capacityClient<$Result.GetResult<Prisma.$capacityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Capacities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacityCountArgs} args - Arguments to filter Capacities to count.
     * @example
     * // Count the number of Capacities
     * const count = await prisma.capacity.count({
     *   where: {
     *     // ... the filter for the Capacities we want to count
     *   }
     * })
    **/
    count<T extends capacityCountArgs>(
      args?: Subset<T, capacityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CapacityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Capacity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapacityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CapacityAggregateArgs>(args: Subset<T, CapacityAggregateArgs>): Prisma.PrismaPromise<GetCapacityAggregateType<T>>

    /**
     * Group by Capacity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends capacityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: capacityGroupByArgs['orderBy'] }
        : { orderBy?: capacityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, capacityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapacityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the capacity model
   */
  readonly fields: capacityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for capacity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__capacityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capacityInfos<T extends capacity$capacityInfosArgs<ExtArgs> = {}>(args?: Subset<T, capacity$capacityInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skillObtations<T extends capacity$skillObtationsArgs<ExtArgs> = {}>(args?: Subset<T, capacity$skillObtationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skill_obtationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the capacity model
   */
  interface capacityFieldRefs {
    readonly id: FieldRef<"capacity", 'Int'>
    readonly createdAt: FieldRef<"capacity", 'DateTime'>
    readonly updatedAt: FieldRef<"capacity", 'DateTime'>
    readonly status: FieldRef<"capacity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * capacity findUnique
   */
  export type capacityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity
     */
    select?: capacitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity
     */
    omit?: capacityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacityInclude<ExtArgs> | null
    /**
     * Filter, which capacity to fetch.
     */
    where: capacityWhereUniqueInput
  }

  /**
   * capacity findUniqueOrThrow
   */
  export type capacityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity
     */
    select?: capacitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity
     */
    omit?: capacityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacityInclude<ExtArgs> | null
    /**
     * Filter, which capacity to fetch.
     */
    where: capacityWhereUniqueInput
  }

  /**
   * capacity findFirst
   */
  export type capacityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity
     */
    select?: capacitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity
     */
    omit?: capacityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacityInclude<ExtArgs> | null
    /**
     * Filter, which capacity to fetch.
     */
    where?: capacityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacities to fetch.
     */
    orderBy?: capacityOrderByWithRelationInput | capacityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capacities.
     */
    cursor?: capacityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capacities.
     */
    distinct?: CapacityScalarFieldEnum | CapacityScalarFieldEnum[]
  }

  /**
   * capacity findFirstOrThrow
   */
  export type capacityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity
     */
    select?: capacitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity
     */
    omit?: capacityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacityInclude<ExtArgs> | null
    /**
     * Filter, which capacity to fetch.
     */
    where?: capacityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacities to fetch.
     */
    orderBy?: capacityOrderByWithRelationInput | capacityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capacities.
     */
    cursor?: capacityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capacities.
     */
    distinct?: CapacityScalarFieldEnum | CapacityScalarFieldEnum[]
  }

  /**
   * capacity findMany
   */
  export type capacityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity
     */
    select?: capacitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity
     */
    omit?: capacityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacityInclude<ExtArgs> | null
    /**
     * Filter, which capacities to fetch.
     */
    where?: capacityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacities to fetch.
     */
    orderBy?: capacityOrderByWithRelationInput | capacityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing capacities.
     */
    cursor?: capacityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacities.
     */
    skip?: number
    distinct?: CapacityScalarFieldEnum | CapacityScalarFieldEnum[]
  }

  /**
   * capacity create
   */
  export type capacityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity
     */
    select?: capacitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity
     */
    omit?: capacityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacityInclude<ExtArgs> | null
    /**
     * The data needed to create a capacity.
     */
    data?: XOR<capacityCreateInput, capacityUncheckedCreateInput>
  }

  /**
   * capacity createMany
   */
  export type capacityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many capacities.
     */
    data: capacityCreateManyInput | capacityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * capacity update
   */
  export type capacityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity
     */
    select?: capacitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity
     */
    omit?: capacityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacityInclude<ExtArgs> | null
    /**
     * The data needed to update a capacity.
     */
    data: XOR<capacityUpdateInput, capacityUncheckedUpdateInput>
    /**
     * Choose, which capacity to update.
     */
    where: capacityWhereUniqueInput
  }

  /**
   * capacity updateMany
   */
  export type capacityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update capacities.
     */
    data: XOR<capacityUpdateManyMutationInput, capacityUncheckedUpdateManyInput>
    /**
     * Filter which capacities to update
     */
    where?: capacityWhereInput
    /**
     * Limit how many capacities to update.
     */
    limit?: number
  }

  /**
   * capacity upsert
   */
  export type capacityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity
     */
    select?: capacitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity
     */
    omit?: capacityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacityInclude<ExtArgs> | null
    /**
     * The filter to search for the capacity to update in case it exists.
     */
    where: capacityWhereUniqueInput
    /**
     * In case the capacity found by the `where` argument doesn't exist, create a new capacity with this data.
     */
    create: XOR<capacityCreateInput, capacityUncheckedCreateInput>
    /**
     * In case the capacity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<capacityUpdateInput, capacityUncheckedUpdateInput>
  }

  /**
   * capacity delete
   */
  export type capacityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity
     */
    select?: capacitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity
     */
    omit?: capacityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacityInclude<ExtArgs> | null
    /**
     * Filter which capacity to delete.
     */
    where: capacityWhereUniqueInput
  }

  /**
   * capacity deleteMany
   */
  export type capacityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capacities to delete
     */
    where?: capacityWhereInput
    /**
     * Limit how many capacities to delete.
     */
    limit?: number
  }

  /**
   * capacity.capacityInfos
   */
  export type capacity$capacityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    where?: capacity_infoWhereInput
    orderBy?: capacity_infoOrderByWithRelationInput | capacity_infoOrderByWithRelationInput[]
    cursor?: capacity_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Capacity_infoScalarFieldEnum | Capacity_infoScalarFieldEnum[]
  }

  /**
   * capacity.skillObtations
   */
  export type capacity$skillObtationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation
     */
    select?: skill_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation
     */
    omit?: skill_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtationInclude<ExtArgs> | null
    where?: skill_obtationWhereInput
    orderBy?: skill_obtationOrderByWithRelationInput | skill_obtationOrderByWithRelationInput[]
    cursor?: skill_obtationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Skill_obtationScalarFieldEnum | Skill_obtationScalarFieldEnum[]
  }

  /**
   * capacity without action
   */
  export type capacityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity
     */
    select?: capacitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity
     */
    omit?: capacityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacityInclude<ExtArgs> | null
  }


  /**
   * Model capacity_effect
   */

  export type AggregateCapacity_effect = {
    _count: Capacity_effectCountAggregateOutputType | null
    _avg: Capacity_effectAvgAggregateOutputType | null
    _sum: Capacity_effectSumAggregateOutputType | null
    _min: Capacity_effectMinAggregateOutputType | null
    _max: Capacity_effectMaxAggregateOutputType | null
  }

  export type Capacity_effectAvgAggregateOutputType = {
    id: number | null
  }

  export type Capacity_effectSumAggregateOutputType = {
    id: number | null
  }

  export type Capacity_effectMinAggregateOutputType = {
    id: number | null
    zEffect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Capacity_effectMaxAggregateOutputType = {
    id: number | null
    zEffect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Capacity_effectCountAggregateOutputType = {
    id: number
    zEffect: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Capacity_effectAvgAggregateInputType = {
    id?: true
  }

  export type Capacity_effectSumAggregateInputType = {
    id?: true
  }

  export type Capacity_effectMinAggregateInputType = {
    id?: true
    zEffect?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Capacity_effectMaxAggregateInputType = {
    id?: true
    zEffect?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Capacity_effectCountAggregateInputType = {
    id?: true
    zEffect?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Capacity_effectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capacity_effect to aggregate.
     */
    where?: capacity_effectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_effects to fetch.
     */
    orderBy?: capacity_effectOrderByWithRelationInput | capacity_effectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: capacity_effectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_effects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_effects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned capacity_effects
    **/
    _count?: true | Capacity_effectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Capacity_effectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Capacity_effectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Capacity_effectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Capacity_effectMaxAggregateInputType
  }

  export type GetCapacity_effectAggregateType<T extends Capacity_effectAggregateArgs> = {
        [P in keyof T & keyof AggregateCapacity_effect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapacity_effect[P]>
      : GetScalarType<T[P], AggregateCapacity_effect[P]>
  }




  export type capacity_effectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacity_effectWhereInput
    orderBy?: capacity_effectOrderByWithAggregationInput | capacity_effectOrderByWithAggregationInput[]
    by: Capacity_effectScalarFieldEnum[] | Capacity_effectScalarFieldEnum
    having?: capacity_effectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Capacity_effectCountAggregateInputType | true
    _avg?: Capacity_effectAvgAggregateInputType
    _sum?: Capacity_effectSumAggregateInputType
    _min?: Capacity_effectMinAggregateInputType
    _max?: Capacity_effectMaxAggregateInputType
  }

  export type Capacity_effectGroupByOutputType = {
    id: number
    zEffect: boolean
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Capacity_effectCountAggregateOutputType | null
    _avg: Capacity_effectAvgAggregateOutputType | null
    _sum: Capacity_effectSumAggregateOutputType | null
    _min: Capacity_effectMinAggregateOutputType | null
    _max: Capacity_effectMaxAggregateOutputType | null
  }

  type GetCapacity_effectGroupByPayload<T extends capacity_effectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Capacity_effectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Capacity_effectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Capacity_effectGroupByOutputType[P]>
            : GetScalarType<T[P], Capacity_effectGroupByOutputType[P]>
        }
      >
    >


  export type capacity_effectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zEffect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    capacityInfos?: boolean | capacity_effect$capacityInfosArgs<ExtArgs>
    capacityZInfos?: boolean | capacity_effect$capacityZInfosArgs<ExtArgs>
    _count?: boolean | Capacity_effectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capacity_effect"]>



  export type capacity_effectSelectScalar = {
    id?: boolean
    zEffect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type capacity_effectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "zEffect" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["capacity_effect"]>
  export type capacity_effectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfos?: boolean | capacity_effect$capacityInfosArgs<ExtArgs>
    capacityZInfos?: boolean | capacity_effect$capacityZInfosArgs<ExtArgs>
    _count?: boolean | Capacity_effectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $capacity_effectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "capacity_effect"
    objects: {
      capacityInfos: Prisma.$capacity_infoPayload<ExtArgs>[]
      capacityZInfos: Prisma.$capacity_infoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      zEffect: boolean
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["capacity_effect"]>
    composites: {}
  }

  type capacity_effectGetPayload<S extends boolean | null | undefined | capacity_effectDefaultArgs> = $Result.GetResult<Prisma.$capacity_effectPayload, S>

  type capacity_effectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<capacity_effectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Capacity_effectCountAggregateInputType | true
    }

  export interface capacity_effectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['capacity_effect'], meta: { name: 'capacity_effect' } }
    /**
     * Find zero or one Capacity_effect that matches the filter.
     * @param {capacity_effectFindUniqueArgs} args - Arguments to find a Capacity_effect
     * @example
     * // Get one Capacity_effect
     * const capacity_effect = await prisma.capacity_effect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends capacity_effectFindUniqueArgs>(args: SelectSubset<T, capacity_effectFindUniqueArgs<ExtArgs>>): Prisma__capacity_effectClient<$Result.GetResult<Prisma.$capacity_effectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Capacity_effect that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {capacity_effectFindUniqueOrThrowArgs} args - Arguments to find a Capacity_effect
     * @example
     * // Get one Capacity_effect
     * const capacity_effect = await prisma.capacity_effect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends capacity_effectFindUniqueOrThrowArgs>(args: SelectSubset<T, capacity_effectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__capacity_effectClient<$Result.GetResult<Prisma.$capacity_effectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capacity_effect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_effectFindFirstArgs} args - Arguments to find a Capacity_effect
     * @example
     * // Get one Capacity_effect
     * const capacity_effect = await prisma.capacity_effect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends capacity_effectFindFirstArgs>(args?: SelectSubset<T, capacity_effectFindFirstArgs<ExtArgs>>): Prisma__capacity_effectClient<$Result.GetResult<Prisma.$capacity_effectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capacity_effect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_effectFindFirstOrThrowArgs} args - Arguments to find a Capacity_effect
     * @example
     * // Get one Capacity_effect
     * const capacity_effect = await prisma.capacity_effect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends capacity_effectFindFirstOrThrowArgs>(args?: SelectSubset<T, capacity_effectFindFirstOrThrowArgs<ExtArgs>>): Prisma__capacity_effectClient<$Result.GetResult<Prisma.$capacity_effectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Capacity_effects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_effectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Capacity_effects
     * const capacity_effects = await prisma.capacity_effect.findMany()
     * 
     * // Get first 10 Capacity_effects
     * const capacity_effects = await prisma.capacity_effect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capacity_effectWithIdOnly = await prisma.capacity_effect.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends capacity_effectFindManyArgs>(args?: SelectSubset<T, capacity_effectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacity_effectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Capacity_effect.
     * @param {capacity_effectCreateArgs} args - Arguments to create a Capacity_effect.
     * @example
     * // Create one Capacity_effect
     * const Capacity_effect = await prisma.capacity_effect.create({
     *   data: {
     *     // ... data to create a Capacity_effect
     *   }
     * })
     * 
     */
    create<T extends capacity_effectCreateArgs>(args: SelectSubset<T, capacity_effectCreateArgs<ExtArgs>>): Prisma__capacity_effectClient<$Result.GetResult<Prisma.$capacity_effectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Capacity_effects.
     * @param {capacity_effectCreateManyArgs} args - Arguments to create many Capacity_effects.
     * @example
     * // Create many Capacity_effects
     * const capacity_effect = await prisma.capacity_effect.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends capacity_effectCreateManyArgs>(args?: SelectSubset<T, capacity_effectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Capacity_effect.
     * @param {capacity_effectDeleteArgs} args - Arguments to delete one Capacity_effect.
     * @example
     * // Delete one Capacity_effect
     * const Capacity_effect = await prisma.capacity_effect.delete({
     *   where: {
     *     // ... filter to delete one Capacity_effect
     *   }
     * })
     * 
     */
    delete<T extends capacity_effectDeleteArgs>(args: SelectSubset<T, capacity_effectDeleteArgs<ExtArgs>>): Prisma__capacity_effectClient<$Result.GetResult<Prisma.$capacity_effectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Capacity_effect.
     * @param {capacity_effectUpdateArgs} args - Arguments to update one Capacity_effect.
     * @example
     * // Update one Capacity_effect
     * const capacity_effect = await prisma.capacity_effect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends capacity_effectUpdateArgs>(args: SelectSubset<T, capacity_effectUpdateArgs<ExtArgs>>): Prisma__capacity_effectClient<$Result.GetResult<Prisma.$capacity_effectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Capacity_effects.
     * @param {capacity_effectDeleteManyArgs} args - Arguments to filter Capacity_effects to delete.
     * @example
     * // Delete a few Capacity_effects
     * const { count } = await prisma.capacity_effect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends capacity_effectDeleteManyArgs>(args?: SelectSubset<T, capacity_effectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capacity_effects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_effectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Capacity_effects
     * const capacity_effect = await prisma.capacity_effect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends capacity_effectUpdateManyArgs>(args: SelectSubset<T, capacity_effectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Capacity_effect.
     * @param {capacity_effectUpsertArgs} args - Arguments to update or create a Capacity_effect.
     * @example
     * // Update or create a Capacity_effect
     * const capacity_effect = await prisma.capacity_effect.upsert({
     *   create: {
     *     // ... data to create a Capacity_effect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Capacity_effect we want to update
     *   }
     * })
     */
    upsert<T extends capacity_effectUpsertArgs>(args: SelectSubset<T, capacity_effectUpsertArgs<ExtArgs>>): Prisma__capacity_effectClient<$Result.GetResult<Prisma.$capacity_effectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Capacity_effects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_effectCountArgs} args - Arguments to filter Capacity_effects to count.
     * @example
     * // Count the number of Capacity_effects
     * const count = await prisma.capacity_effect.count({
     *   where: {
     *     // ... the filter for the Capacity_effects we want to count
     *   }
     * })
    **/
    count<T extends capacity_effectCountArgs>(
      args?: Subset<T, capacity_effectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Capacity_effectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Capacity_effect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Capacity_effectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Capacity_effectAggregateArgs>(args: Subset<T, Capacity_effectAggregateArgs>): Prisma.PrismaPromise<GetCapacity_effectAggregateType<T>>

    /**
     * Group by Capacity_effect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_effectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends capacity_effectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: capacity_effectGroupByArgs['orderBy'] }
        : { orderBy?: capacity_effectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, capacity_effectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapacity_effectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the capacity_effect model
   */
  readonly fields: capacity_effectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for capacity_effect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__capacity_effectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capacityInfos<T extends capacity_effect$capacityInfosArgs<ExtArgs> = {}>(args?: Subset<T, capacity_effect$capacityInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    capacityZInfos<T extends capacity_effect$capacityZInfosArgs<ExtArgs> = {}>(args?: Subset<T, capacity_effect$capacityZInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the capacity_effect model
   */
  interface capacity_effectFieldRefs {
    readonly id: FieldRef<"capacity_effect", 'Int'>
    readonly zEffect: FieldRef<"capacity_effect", 'Boolean'>
    readonly createdAt: FieldRef<"capacity_effect", 'DateTime'>
    readonly updatedAt: FieldRef<"capacity_effect", 'DateTime'>
    readonly status: FieldRef<"capacity_effect", 'String'>
  }
    

  // Custom InputTypes
  /**
   * capacity_effect findUnique
   */
  export type capacity_effectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_effect
     */
    select?: capacity_effectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_effect
     */
    omit?: capacity_effectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_effectInclude<ExtArgs> | null
    /**
     * Filter, which capacity_effect to fetch.
     */
    where: capacity_effectWhereUniqueInput
  }

  /**
   * capacity_effect findUniqueOrThrow
   */
  export type capacity_effectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_effect
     */
    select?: capacity_effectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_effect
     */
    omit?: capacity_effectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_effectInclude<ExtArgs> | null
    /**
     * Filter, which capacity_effect to fetch.
     */
    where: capacity_effectWhereUniqueInput
  }

  /**
   * capacity_effect findFirst
   */
  export type capacity_effectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_effect
     */
    select?: capacity_effectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_effect
     */
    omit?: capacity_effectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_effectInclude<ExtArgs> | null
    /**
     * Filter, which capacity_effect to fetch.
     */
    where?: capacity_effectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_effects to fetch.
     */
    orderBy?: capacity_effectOrderByWithRelationInput | capacity_effectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capacity_effects.
     */
    cursor?: capacity_effectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_effects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_effects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capacity_effects.
     */
    distinct?: Capacity_effectScalarFieldEnum | Capacity_effectScalarFieldEnum[]
  }

  /**
   * capacity_effect findFirstOrThrow
   */
  export type capacity_effectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_effect
     */
    select?: capacity_effectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_effect
     */
    omit?: capacity_effectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_effectInclude<ExtArgs> | null
    /**
     * Filter, which capacity_effect to fetch.
     */
    where?: capacity_effectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_effects to fetch.
     */
    orderBy?: capacity_effectOrderByWithRelationInput | capacity_effectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capacity_effects.
     */
    cursor?: capacity_effectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_effects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_effects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capacity_effects.
     */
    distinct?: Capacity_effectScalarFieldEnum | Capacity_effectScalarFieldEnum[]
  }

  /**
   * capacity_effect findMany
   */
  export type capacity_effectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_effect
     */
    select?: capacity_effectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_effect
     */
    omit?: capacity_effectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_effectInclude<ExtArgs> | null
    /**
     * Filter, which capacity_effects to fetch.
     */
    where?: capacity_effectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_effects to fetch.
     */
    orderBy?: capacity_effectOrderByWithRelationInput | capacity_effectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing capacity_effects.
     */
    cursor?: capacity_effectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_effects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_effects.
     */
    skip?: number
    distinct?: Capacity_effectScalarFieldEnum | Capacity_effectScalarFieldEnum[]
  }

  /**
   * capacity_effect create
   */
  export type capacity_effectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_effect
     */
    select?: capacity_effectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_effect
     */
    omit?: capacity_effectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_effectInclude<ExtArgs> | null
    /**
     * The data needed to create a capacity_effect.
     */
    data: XOR<capacity_effectCreateInput, capacity_effectUncheckedCreateInput>
  }

  /**
   * capacity_effect createMany
   */
  export type capacity_effectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many capacity_effects.
     */
    data: capacity_effectCreateManyInput | capacity_effectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * capacity_effect update
   */
  export type capacity_effectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_effect
     */
    select?: capacity_effectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_effect
     */
    omit?: capacity_effectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_effectInclude<ExtArgs> | null
    /**
     * The data needed to update a capacity_effect.
     */
    data: XOR<capacity_effectUpdateInput, capacity_effectUncheckedUpdateInput>
    /**
     * Choose, which capacity_effect to update.
     */
    where: capacity_effectWhereUniqueInput
  }

  /**
   * capacity_effect updateMany
   */
  export type capacity_effectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update capacity_effects.
     */
    data: XOR<capacity_effectUpdateManyMutationInput, capacity_effectUncheckedUpdateManyInput>
    /**
     * Filter which capacity_effects to update
     */
    where?: capacity_effectWhereInput
    /**
     * Limit how many capacity_effects to update.
     */
    limit?: number
  }

  /**
   * capacity_effect upsert
   */
  export type capacity_effectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_effect
     */
    select?: capacity_effectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_effect
     */
    omit?: capacity_effectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_effectInclude<ExtArgs> | null
    /**
     * The filter to search for the capacity_effect to update in case it exists.
     */
    where: capacity_effectWhereUniqueInput
    /**
     * In case the capacity_effect found by the `where` argument doesn't exist, create a new capacity_effect with this data.
     */
    create: XOR<capacity_effectCreateInput, capacity_effectUncheckedCreateInput>
    /**
     * In case the capacity_effect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<capacity_effectUpdateInput, capacity_effectUncheckedUpdateInput>
  }

  /**
   * capacity_effect delete
   */
  export type capacity_effectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_effect
     */
    select?: capacity_effectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_effect
     */
    omit?: capacity_effectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_effectInclude<ExtArgs> | null
    /**
     * Filter which capacity_effect to delete.
     */
    where: capacity_effectWhereUniqueInput
  }

  /**
   * capacity_effect deleteMany
   */
  export type capacity_effectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capacity_effects to delete
     */
    where?: capacity_effectWhereInput
    /**
     * Limit how many capacity_effects to delete.
     */
    limit?: number
  }

  /**
   * capacity_effect.capacityInfos
   */
  export type capacity_effect$capacityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    where?: capacity_infoWhereInput
    orderBy?: capacity_infoOrderByWithRelationInput | capacity_infoOrderByWithRelationInput[]
    cursor?: capacity_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Capacity_infoScalarFieldEnum | Capacity_infoScalarFieldEnum[]
  }

  /**
   * capacity_effect.capacityZInfos
   */
  export type capacity_effect$capacityZInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    where?: capacity_infoWhereInput
    orderBy?: capacity_infoOrderByWithRelationInput | capacity_infoOrderByWithRelationInput[]
    cursor?: capacity_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Capacity_infoScalarFieldEnum | Capacity_infoScalarFieldEnum[]
  }

  /**
   * capacity_effect without action
   */
  export type capacity_effectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_effect
     */
    select?: capacity_effectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_effect
     */
    omit?: capacity_effectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_effectInclude<ExtArgs> | null
  }


  /**
   * Model capacity_category
   */

  export type AggregateCapacity_category = {
    _count: Capacity_categoryCountAggregateOutputType | null
    _avg: Capacity_categoryAvgAggregateOutputType | null
    _sum: Capacity_categorySumAggregateOutputType | null
    _min: Capacity_categoryMinAggregateOutputType | null
    _max: Capacity_categoryMaxAggregateOutputType | null
  }

  export type Capacity_categoryAvgAggregateOutputType = {
    id: number | null
  }

  export type Capacity_categorySumAggregateOutputType = {
    id: number | null
  }

  export type Capacity_categoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Capacity_categoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Capacity_categoryCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Capacity_categoryAvgAggregateInputType = {
    id?: true
  }

  export type Capacity_categorySumAggregateInputType = {
    id?: true
  }

  export type Capacity_categoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Capacity_categoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Capacity_categoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Capacity_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capacity_category to aggregate.
     */
    where?: capacity_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_categories to fetch.
     */
    orderBy?: capacity_categoryOrderByWithRelationInput | capacity_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: capacity_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned capacity_categories
    **/
    _count?: true | Capacity_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Capacity_categoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Capacity_categorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Capacity_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Capacity_categoryMaxAggregateInputType
  }

  export type GetCapacity_categoryAggregateType<T extends Capacity_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCapacity_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapacity_category[P]>
      : GetScalarType<T[P], AggregateCapacity_category[P]>
  }




  export type capacity_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacity_categoryWhereInput
    orderBy?: capacity_categoryOrderByWithAggregationInput | capacity_categoryOrderByWithAggregationInput[]
    by: Capacity_categoryScalarFieldEnum[] | Capacity_categoryScalarFieldEnum
    having?: capacity_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Capacity_categoryCountAggregateInputType | true
    _avg?: Capacity_categoryAvgAggregateInputType
    _sum?: Capacity_categorySumAggregateInputType
    _min?: Capacity_categoryMinAggregateInputType
    _max?: Capacity_categoryMaxAggregateInputType
  }

  export type Capacity_categoryGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Capacity_categoryCountAggregateOutputType | null
    _avg: Capacity_categoryAvgAggregateOutputType | null
    _sum: Capacity_categorySumAggregateOutputType | null
    _min: Capacity_categoryMinAggregateOutputType | null
    _max: Capacity_categoryMaxAggregateOutputType | null
  }

  type GetCapacity_categoryGroupByPayload<T extends capacity_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Capacity_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Capacity_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Capacity_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Capacity_categoryGroupByOutputType[P]>
        }
      >
    >


  export type capacity_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    capacityInfos?: boolean | capacity_category$capacityInfosArgs<ExtArgs>
    _count?: boolean | Capacity_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capacity_category"]>



  export type capacity_categorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type capacity_categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["capacity_category"]>
  export type capacity_categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfos?: boolean | capacity_category$capacityInfosArgs<ExtArgs>
    _count?: boolean | Capacity_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $capacity_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "capacity_category"
    objects: {
      capacityInfos: Prisma.$capacity_infoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["capacity_category"]>
    composites: {}
  }

  type capacity_categoryGetPayload<S extends boolean | null | undefined | capacity_categoryDefaultArgs> = $Result.GetResult<Prisma.$capacity_categoryPayload, S>

  type capacity_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<capacity_categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Capacity_categoryCountAggregateInputType | true
    }

  export interface capacity_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['capacity_category'], meta: { name: 'capacity_category' } }
    /**
     * Find zero or one Capacity_category that matches the filter.
     * @param {capacity_categoryFindUniqueArgs} args - Arguments to find a Capacity_category
     * @example
     * // Get one Capacity_category
     * const capacity_category = await prisma.capacity_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends capacity_categoryFindUniqueArgs>(args: SelectSubset<T, capacity_categoryFindUniqueArgs<ExtArgs>>): Prisma__capacity_categoryClient<$Result.GetResult<Prisma.$capacity_categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Capacity_category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {capacity_categoryFindUniqueOrThrowArgs} args - Arguments to find a Capacity_category
     * @example
     * // Get one Capacity_category
     * const capacity_category = await prisma.capacity_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends capacity_categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, capacity_categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__capacity_categoryClient<$Result.GetResult<Prisma.$capacity_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capacity_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_categoryFindFirstArgs} args - Arguments to find a Capacity_category
     * @example
     * // Get one Capacity_category
     * const capacity_category = await prisma.capacity_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends capacity_categoryFindFirstArgs>(args?: SelectSubset<T, capacity_categoryFindFirstArgs<ExtArgs>>): Prisma__capacity_categoryClient<$Result.GetResult<Prisma.$capacity_categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capacity_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_categoryFindFirstOrThrowArgs} args - Arguments to find a Capacity_category
     * @example
     * // Get one Capacity_category
     * const capacity_category = await prisma.capacity_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends capacity_categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, capacity_categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__capacity_categoryClient<$Result.GetResult<Prisma.$capacity_categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Capacity_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Capacity_categories
     * const capacity_categories = await prisma.capacity_category.findMany()
     * 
     * // Get first 10 Capacity_categories
     * const capacity_categories = await prisma.capacity_category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capacity_categoryWithIdOnly = await prisma.capacity_category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends capacity_categoryFindManyArgs>(args?: SelectSubset<T, capacity_categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacity_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Capacity_category.
     * @param {capacity_categoryCreateArgs} args - Arguments to create a Capacity_category.
     * @example
     * // Create one Capacity_category
     * const Capacity_category = await prisma.capacity_category.create({
     *   data: {
     *     // ... data to create a Capacity_category
     *   }
     * })
     * 
     */
    create<T extends capacity_categoryCreateArgs>(args: SelectSubset<T, capacity_categoryCreateArgs<ExtArgs>>): Prisma__capacity_categoryClient<$Result.GetResult<Prisma.$capacity_categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Capacity_categories.
     * @param {capacity_categoryCreateManyArgs} args - Arguments to create many Capacity_categories.
     * @example
     * // Create many Capacity_categories
     * const capacity_category = await prisma.capacity_category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends capacity_categoryCreateManyArgs>(args?: SelectSubset<T, capacity_categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Capacity_category.
     * @param {capacity_categoryDeleteArgs} args - Arguments to delete one Capacity_category.
     * @example
     * // Delete one Capacity_category
     * const Capacity_category = await prisma.capacity_category.delete({
     *   where: {
     *     // ... filter to delete one Capacity_category
     *   }
     * })
     * 
     */
    delete<T extends capacity_categoryDeleteArgs>(args: SelectSubset<T, capacity_categoryDeleteArgs<ExtArgs>>): Prisma__capacity_categoryClient<$Result.GetResult<Prisma.$capacity_categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Capacity_category.
     * @param {capacity_categoryUpdateArgs} args - Arguments to update one Capacity_category.
     * @example
     * // Update one Capacity_category
     * const capacity_category = await prisma.capacity_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends capacity_categoryUpdateArgs>(args: SelectSubset<T, capacity_categoryUpdateArgs<ExtArgs>>): Prisma__capacity_categoryClient<$Result.GetResult<Prisma.$capacity_categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Capacity_categories.
     * @param {capacity_categoryDeleteManyArgs} args - Arguments to filter Capacity_categories to delete.
     * @example
     * // Delete a few Capacity_categories
     * const { count } = await prisma.capacity_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends capacity_categoryDeleteManyArgs>(args?: SelectSubset<T, capacity_categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capacity_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Capacity_categories
     * const capacity_category = await prisma.capacity_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends capacity_categoryUpdateManyArgs>(args: SelectSubset<T, capacity_categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Capacity_category.
     * @param {capacity_categoryUpsertArgs} args - Arguments to update or create a Capacity_category.
     * @example
     * // Update or create a Capacity_category
     * const capacity_category = await prisma.capacity_category.upsert({
     *   create: {
     *     // ... data to create a Capacity_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Capacity_category we want to update
     *   }
     * })
     */
    upsert<T extends capacity_categoryUpsertArgs>(args: SelectSubset<T, capacity_categoryUpsertArgs<ExtArgs>>): Prisma__capacity_categoryClient<$Result.GetResult<Prisma.$capacity_categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Capacity_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_categoryCountArgs} args - Arguments to filter Capacity_categories to count.
     * @example
     * // Count the number of Capacity_categories
     * const count = await prisma.capacity_category.count({
     *   where: {
     *     // ... the filter for the Capacity_categories we want to count
     *   }
     * })
    **/
    count<T extends capacity_categoryCountArgs>(
      args?: Subset<T, capacity_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Capacity_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Capacity_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Capacity_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Capacity_categoryAggregateArgs>(args: Subset<T, Capacity_categoryAggregateArgs>): Prisma.PrismaPromise<GetCapacity_categoryAggregateType<T>>

    /**
     * Group by Capacity_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends capacity_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: capacity_categoryGroupByArgs['orderBy'] }
        : { orderBy?: capacity_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, capacity_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapacity_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the capacity_category model
   */
  readonly fields: capacity_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for capacity_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__capacity_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capacityInfos<T extends capacity_category$capacityInfosArgs<ExtArgs> = {}>(args?: Subset<T, capacity_category$capacityInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the capacity_category model
   */
  interface capacity_categoryFieldRefs {
    readonly id: FieldRef<"capacity_category", 'Int'>
    readonly createdAt: FieldRef<"capacity_category", 'DateTime'>
    readonly updatedAt: FieldRef<"capacity_category", 'DateTime'>
    readonly status: FieldRef<"capacity_category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * capacity_category findUnique
   */
  export type capacity_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_category
     */
    select?: capacity_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_category
     */
    omit?: capacity_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_categoryInclude<ExtArgs> | null
    /**
     * Filter, which capacity_category to fetch.
     */
    where: capacity_categoryWhereUniqueInput
  }

  /**
   * capacity_category findUniqueOrThrow
   */
  export type capacity_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_category
     */
    select?: capacity_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_category
     */
    omit?: capacity_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_categoryInclude<ExtArgs> | null
    /**
     * Filter, which capacity_category to fetch.
     */
    where: capacity_categoryWhereUniqueInput
  }

  /**
   * capacity_category findFirst
   */
  export type capacity_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_category
     */
    select?: capacity_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_category
     */
    omit?: capacity_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_categoryInclude<ExtArgs> | null
    /**
     * Filter, which capacity_category to fetch.
     */
    where?: capacity_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_categories to fetch.
     */
    orderBy?: capacity_categoryOrderByWithRelationInput | capacity_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capacity_categories.
     */
    cursor?: capacity_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capacity_categories.
     */
    distinct?: Capacity_categoryScalarFieldEnum | Capacity_categoryScalarFieldEnum[]
  }

  /**
   * capacity_category findFirstOrThrow
   */
  export type capacity_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_category
     */
    select?: capacity_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_category
     */
    omit?: capacity_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_categoryInclude<ExtArgs> | null
    /**
     * Filter, which capacity_category to fetch.
     */
    where?: capacity_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_categories to fetch.
     */
    orderBy?: capacity_categoryOrderByWithRelationInput | capacity_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capacity_categories.
     */
    cursor?: capacity_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capacity_categories.
     */
    distinct?: Capacity_categoryScalarFieldEnum | Capacity_categoryScalarFieldEnum[]
  }

  /**
   * capacity_category findMany
   */
  export type capacity_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_category
     */
    select?: capacity_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_category
     */
    omit?: capacity_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_categoryInclude<ExtArgs> | null
    /**
     * Filter, which capacity_categories to fetch.
     */
    where?: capacity_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_categories to fetch.
     */
    orderBy?: capacity_categoryOrderByWithRelationInput | capacity_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing capacity_categories.
     */
    cursor?: capacity_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_categories.
     */
    skip?: number
    distinct?: Capacity_categoryScalarFieldEnum | Capacity_categoryScalarFieldEnum[]
  }

  /**
   * capacity_category create
   */
  export type capacity_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_category
     */
    select?: capacity_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_category
     */
    omit?: capacity_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a capacity_category.
     */
    data?: XOR<capacity_categoryCreateInput, capacity_categoryUncheckedCreateInput>
  }

  /**
   * capacity_category createMany
   */
  export type capacity_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many capacity_categories.
     */
    data: capacity_categoryCreateManyInput | capacity_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * capacity_category update
   */
  export type capacity_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_category
     */
    select?: capacity_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_category
     */
    omit?: capacity_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a capacity_category.
     */
    data: XOR<capacity_categoryUpdateInput, capacity_categoryUncheckedUpdateInput>
    /**
     * Choose, which capacity_category to update.
     */
    where: capacity_categoryWhereUniqueInput
  }

  /**
   * capacity_category updateMany
   */
  export type capacity_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update capacity_categories.
     */
    data: XOR<capacity_categoryUpdateManyMutationInput, capacity_categoryUncheckedUpdateManyInput>
    /**
     * Filter which capacity_categories to update
     */
    where?: capacity_categoryWhereInput
    /**
     * Limit how many capacity_categories to update.
     */
    limit?: number
  }

  /**
   * capacity_category upsert
   */
  export type capacity_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_category
     */
    select?: capacity_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_category
     */
    omit?: capacity_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the capacity_category to update in case it exists.
     */
    where: capacity_categoryWhereUniqueInput
    /**
     * In case the capacity_category found by the `where` argument doesn't exist, create a new capacity_category with this data.
     */
    create: XOR<capacity_categoryCreateInput, capacity_categoryUncheckedCreateInput>
    /**
     * In case the capacity_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<capacity_categoryUpdateInput, capacity_categoryUncheckedUpdateInput>
  }

  /**
   * capacity_category delete
   */
  export type capacity_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_category
     */
    select?: capacity_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_category
     */
    omit?: capacity_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_categoryInclude<ExtArgs> | null
    /**
     * Filter which capacity_category to delete.
     */
    where: capacity_categoryWhereUniqueInput
  }

  /**
   * capacity_category deleteMany
   */
  export type capacity_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capacity_categories to delete
     */
    where?: capacity_categoryWhereInput
    /**
     * Limit how many capacity_categories to delete.
     */
    limit?: number
  }

  /**
   * capacity_category.capacityInfos
   */
  export type capacity_category$capacityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    where?: capacity_infoWhereInput
    orderBy?: capacity_infoOrderByWithRelationInput | capacity_infoOrderByWithRelationInput[]
    cursor?: capacity_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Capacity_infoScalarFieldEnum | Capacity_infoScalarFieldEnum[]
  }

  /**
   * capacity_category without action
   */
  export type capacity_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_category
     */
    select?: capacity_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_category
     */
    omit?: capacity_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_categoryInclude<ExtArgs> | null
  }


  /**
   * Model capsule
   */

  export type AggregateCapsule = {
    _count: CapsuleCountAggregateOutputType | null
    _avg: CapsuleAvgAggregateOutputType | null
    _sum: CapsuleSumAggregateOutputType | null
    _min: CapsuleMinAggregateOutputType | null
    _max: CapsuleMaxAggregateOutputType | null
  }

  export type CapsuleAvgAggregateOutputType = {
    id: number | null
  }

  export type CapsuleSumAggregateOutputType = {
    id: number | null
  }

  export type CapsuleMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type CapsuleMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type CapsuleCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type CapsuleAvgAggregateInputType = {
    id?: true
  }

  export type CapsuleSumAggregateInputType = {
    id?: true
  }

  export type CapsuleMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type CapsuleMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type CapsuleCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type CapsuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capsule to aggregate.
     */
    where?: capsuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capsules to fetch.
     */
    orderBy?: capsuleOrderByWithRelationInput | capsuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: capsuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capsules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capsules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned capsules
    **/
    _count?: true | CapsuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CapsuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CapsuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CapsuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CapsuleMaxAggregateInputType
  }

  export type GetCapsuleAggregateType<T extends CapsuleAggregateArgs> = {
        [P in keyof T & keyof AggregateCapsule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapsule[P]>
      : GetScalarType<T[P], AggregateCapsule[P]>
  }




  export type capsuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capsuleWhereInput
    orderBy?: capsuleOrderByWithAggregationInput | capsuleOrderByWithAggregationInput[]
    by: CapsuleScalarFieldEnum[] | CapsuleScalarFieldEnum
    having?: capsuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CapsuleCountAggregateInputType | true
    _avg?: CapsuleAvgAggregateInputType
    _sum?: CapsuleSumAggregateInputType
    _min?: CapsuleMinAggregateInputType
    _max?: CapsuleMaxAggregateInputType
  }

  export type CapsuleGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: CapsuleCountAggregateOutputType | null
    _avg: CapsuleAvgAggregateOutputType | null
    _sum: CapsuleSumAggregateOutputType | null
    _min: CapsuleMinAggregateOutputType | null
    _max: CapsuleMaxAggregateOutputType | null
  }

  type GetCapsuleGroupByPayload<T extends capsuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CapsuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CapsuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CapsuleGroupByOutputType[P]>
            : GetScalarType<T[P], CapsuleGroupByOutputType[P]>
        }
      >
    >


  export type capsuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    capsule_game_capacity_info?: boolean | capsule$capsule_game_capacity_infoArgs<ExtArgs>
    _count?: boolean | CapsuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capsule"]>



  export type capsuleSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type capsuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["capsule"]>
  export type capsuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capsule_game_capacity_info?: boolean | capsule$capsule_game_capacity_infoArgs<ExtArgs>
    _count?: boolean | CapsuleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $capsulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "capsule"
    objects: {
      capsule_game_capacity_info: Prisma.$capsule_game_capacity_infoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["capsule"]>
    composites: {}
  }

  type capsuleGetPayload<S extends boolean | null | undefined | capsuleDefaultArgs> = $Result.GetResult<Prisma.$capsulePayload, S>

  type capsuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<capsuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CapsuleCountAggregateInputType | true
    }

  export interface capsuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['capsule'], meta: { name: 'capsule' } }
    /**
     * Find zero or one Capsule that matches the filter.
     * @param {capsuleFindUniqueArgs} args - Arguments to find a Capsule
     * @example
     * // Get one Capsule
     * const capsule = await prisma.capsule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends capsuleFindUniqueArgs>(args: SelectSubset<T, capsuleFindUniqueArgs<ExtArgs>>): Prisma__capsuleClient<$Result.GetResult<Prisma.$capsulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Capsule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {capsuleFindUniqueOrThrowArgs} args - Arguments to find a Capsule
     * @example
     * // Get one Capsule
     * const capsule = await prisma.capsule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends capsuleFindUniqueOrThrowArgs>(args: SelectSubset<T, capsuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__capsuleClient<$Result.GetResult<Prisma.$capsulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capsule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capsuleFindFirstArgs} args - Arguments to find a Capsule
     * @example
     * // Get one Capsule
     * const capsule = await prisma.capsule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends capsuleFindFirstArgs>(args?: SelectSubset<T, capsuleFindFirstArgs<ExtArgs>>): Prisma__capsuleClient<$Result.GetResult<Prisma.$capsulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capsule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capsuleFindFirstOrThrowArgs} args - Arguments to find a Capsule
     * @example
     * // Get one Capsule
     * const capsule = await prisma.capsule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends capsuleFindFirstOrThrowArgs>(args?: SelectSubset<T, capsuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__capsuleClient<$Result.GetResult<Prisma.$capsulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Capsules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capsuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Capsules
     * const capsules = await prisma.capsule.findMany()
     * 
     * // Get first 10 Capsules
     * const capsules = await prisma.capsule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capsuleWithIdOnly = await prisma.capsule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends capsuleFindManyArgs>(args?: SelectSubset<T, capsuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capsulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Capsule.
     * @param {capsuleCreateArgs} args - Arguments to create a Capsule.
     * @example
     * // Create one Capsule
     * const Capsule = await prisma.capsule.create({
     *   data: {
     *     // ... data to create a Capsule
     *   }
     * })
     * 
     */
    create<T extends capsuleCreateArgs>(args: SelectSubset<T, capsuleCreateArgs<ExtArgs>>): Prisma__capsuleClient<$Result.GetResult<Prisma.$capsulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Capsules.
     * @param {capsuleCreateManyArgs} args - Arguments to create many Capsules.
     * @example
     * // Create many Capsules
     * const capsule = await prisma.capsule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends capsuleCreateManyArgs>(args?: SelectSubset<T, capsuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Capsule.
     * @param {capsuleDeleteArgs} args - Arguments to delete one Capsule.
     * @example
     * // Delete one Capsule
     * const Capsule = await prisma.capsule.delete({
     *   where: {
     *     // ... filter to delete one Capsule
     *   }
     * })
     * 
     */
    delete<T extends capsuleDeleteArgs>(args: SelectSubset<T, capsuleDeleteArgs<ExtArgs>>): Prisma__capsuleClient<$Result.GetResult<Prisma.$capsulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Capsule.
     * @param {capsuleUpdateArgs} args - Arguments to update one Capsule.
     * @example
     * // Update one Capsule
     * const capsule = await prisma.capsule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends capsuleUpdateArgs>(args: SelectSubset<T, capsuleUpdateArgs<ExtArgs>>): Prisma__capsuleClient<$Result.GetResult<Prisma.$capsulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Capsules.
     * @param {capsuleDeleteManyArgs} args - Arguments to filter Capsules to delete.
     * @example
     * // Delete a few Capsules
     * const { count } = await prisma.capsule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends capsuleDeleteManyArgs>(args?: SelectSubset<T, capsuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capsules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capsuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Capsules
     * const capsule = await prisma.capsule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends capsuleUpdateManyArgs>(args: SelectSubset<T, capsuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Capsule.
     * @param {capsuleUpsertArgs} args - Arguments to update or create a Capsule.
     * @example
     * // Update or create a Capsule
     * const capsule = await prisma.capsule.upsert({
     *   create: {
     *     // ... data to create a Capsule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Capsule we want to update
     *   }
     * })
     */
    upsert<T extends capsuleUpsertArgs>(args: SelectSubset<T, capsuleUpsertArgs<ExtArgs>>): Prisma__capsuleClient<$Result.GetResult<Prisma.$capsulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Capsules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capsuleCountArgs} args - Arguments to filter Capsules to count.
     * @example
     * // Count the number of Capsules
     * const count = await prisma.capsule.count({
     *   where: {
     *     // ... the filter for the Capsules we want to count
     *   }
     * })
    **/
    count<T extends capsuleCountArgs>(
      args?: Subset<T, capsuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CapsuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Capsule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapsuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CapsuleAggregateArgs>(args: Subset<T, CapsuleAggregateArgs>): Prisma.PrismaPromise<GetCapsuleAggregateType<T>>

    /**
     * Group by Capsule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capsuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends capsuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: capsuleGroupByArgs['orderBy'] }
        : { orderBy?: capsuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, capsuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapsuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the capsule model
   */
  readonly fields: capsuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for capsule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__capsuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capsule_game_capacity_info<T extends capsule$capsule_game_capacity_infoArgs<ExtArgs> = {}>(args?: Subset<T, capsule$capsule_game_capacity_infoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capsule_game_capacity_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the capsule model
   */
  interface capsuleFieldRefs {
    readonly id: FieldRef<"capsule", 'Int'>
    readonly createdAt: FieldRef<"capsule", 'DateTime'>
    readonly updatedAt: FieldRef<"capsule", 'DateTime'>
    readonly status: FieldRef<"capsule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * capsule findUnique
   */
  export type capsuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule
     */
    select?: capsuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule
     */
    omit?: capsuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsuleInclude<ExtArgs> | null
    /**
     * Filter, which capsule to fetch.
     */
    where: capsuleWhereUniqueInput
  }

  /**
   * capsule findUniqueOrThrow
   */
  export type capsuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule
     */
    select?: capsuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule
     */
    omit?: capsuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsuleInclude<ExtArgs> | null
    /**
     * Filter, which capsule to fetch.
     */
    where: capsuleWhereUniqueInput
  }

  /**
   * capsule findFirst
   */
  export type capsuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule
     */
    select?: capsuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule
     */
    omit?: capsuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsuleInclude<ExtArgs> | null
    /**
     * Filter, which capsule to fetch.
     */
    where?: capsuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capsules to fetch.
     */
    orderBy?: capsuleOrderByWithRelationInput | capsuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capsules.
     */
    cursor?: capsuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capsules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capsules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capsules.
     */
    distinct?: CapsuleScalarFieldEnum | CapsuleScalarFieldEnum[]
  }

  /**
   * capsule findFirstOrThrow
   */
  export type capsuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule
     */
    select?: capsuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule
     */
    omit?: capsuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsuleInclude<ExtArgs> | null
    /**
     * Filter, which capsule to fetch.
     */
    where?: capsuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capsules to fetch.
     */
    orderBy?: capsuleOrderByWithRelationInput | capsuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capsules.
     */
    cursor?: capsuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capsules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capsules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capsules.
     */
    distinct?: CapsuleScalarFieldEnum | CapsuleScalarFieldEnum[]
  }

  /**
   * capsule findMany
   */
  export type capsuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule
     */
    select?: capsuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule
     */
    omit?: capsuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsuleInclude<ExtArgs> | null
    /**
     * Filter, which capsules to fetch.
     */
    where?: capsuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capsules to fetch.
     */
    orderBy?: capsuleOrderByWithRelationInput | capsuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing capsules.
     */
    cursor?: capsuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capsules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capsules.
     */
    skip?: number
    distinct?: CapsuleScalarFieldEnum | CapsuleScalarFieldEnum[]
  }

  /**
   * capsule create
   */
  export type capsuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule
     */
    select?: capsuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule
     */
    omit?: capsuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsuleInclude<ExtArgs> | null
    /**
     * The data needed to create a capsule.
     */
    data?: XOR<capsuleCreateInput, capsuleUncheckedCreateInput>
  }

  /**
   * capsule createMany
   */
  export type capsuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many capsules.
     */
    data: capsuleCreateManyInput | capsuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * capsule update
   */
  export type capsuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule
     */
    select?: capsuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule
     */
    omit?: capsuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsuleInclude<ExtArgs> | null
    /**
     * The data needed to update a capsule.
     */
    data: XOR<capsuleUpdateInput, capsuleUncheckedUpdateInput>
    /**
     * Choose, which capsule to update.
     */
    where: capsuleWhereUniqueInput
  }

  /**
   * capsule updateMany
   */
  export type capsuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update capsules.
     */
    data: XOR<capsuleUpdateManyMutationInput, capsuleUncheckedUpdateManyInput>
    /**
     * Filter which capsules to update
     */
    where?: capsuleWhereInput
    /**
     * Limit how many capsules to update.
     */
    limit?: number
  }

  /**
   * capsule upsert
   */
  export type capsuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule
     */
    select?: capsuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule
     */
    omit?: capsuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsuleInclude<ExtArgs> | null
    /**
     * The filter to search for the capsule to update in case it exists.
     */
    where: capsuleWhereUniqueInput
    /**
     * In case the capsule found by the `where` argument doesn't exist, create a new capsule with this data.
     */
    create: XOR<capsuleCreateInput, capsuleUncheckedCreateInput>
    /**
     * In case the capsule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<capsuleUpdateInput, capsuleUncheckedUpdateInput>
  }

  /**
   * capsule delete
   */
  export type capsuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule
     */
    select?: capsuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule
     */
    omit?: capsuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsuleInclude<ExtArgs> | null
    /**
     * Filter which capsule to delete.
     */
    where: capsuleWhereUniqueInput
  }

  /**
   * capsule deleteMany
   */
  export type capsuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capsules to delete
     */
    where?: capsuleWhereInput
    /**
     * Limit how many capsules to delete.
     */
    limit?: number
  }

  /**
   * capsule.capsule_game_capacity_info
   */
  export type capsule$capsule_game_capacity_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule_game_capacity_info
     */
    select?: capsule_game_capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule_game_capacity_info
     */
    omit?: capsule_game_capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsule_game_capacity_infoInclude<ExtArgs> | null
    where?: capsule_game_capacity_infoWhereInput
    orderBy?: capsule_game_capacity_infoOrderByWithRelationInput | capsule_game_capacity_infoOrderByWithRelationInput[]
    cursor?: capsule_game_capacity_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Capsule_game_capacity_infoScalarFieldEnum | Capsule_game_capacity_infoScalarFieldEnum[]
  }

  /**
   * capsule without action
   */
  export type capsuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule
     */
    select?: capsuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule
     */
    omit?: capsuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsuleInclude<ExtArgs> | null
  }


  /**
   * Model detail
   */

  export type AggregateDetail = {
    _count: DetailCountAggregateOutputType | null
    _avg: DetailAvgAggregateOutputType | null
    _sum: DetailSumAggregateOutputType | null
    _min: DetailMinAggregateOutputType | null
    _max: DetailMaxAggregateOutputType | null
  }

  export type DetailAvgAggregateOutputType = {
    id: number | null
  }

  export type DetailSumAggregateOutputType = {
    id: number | null
  }

  export type DetailMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type DetailMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type DetailCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type DetailAvgAggregateInputType = {
    id?: true
  }

  export type DetailSumAggregateInputType = {
    id?: true
  }

  export type DetailMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type DetailMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type DetailCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type DetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail to aggregate.
     */
    where?: detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of details to fetch.
     */
    orderBy?: detailOrderByWithRelationInput | detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned details
    **/
    _count?: true | DetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetailMaxAggregateInputType
  }

  export type GetDetailAggregateType<T extends DetailAggregateArgs> = {
        [P in keyof T & keyof AggregateDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetail[P]>
      : GetScalarType<T[P], AggregateDetail[P]>
  }




  export type detailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detailWhereInput
    orderBy?: detailOrderByWithAggregationInput | detailOrderByWithAggregationInput[]
    by: DetailScalarFieldEnum[] | DetailScalarFieldEnum
    having?: detailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetailCountAggregateInputType | true
    _avg?: DetailAvgAggregateInputType
    _sum?: DetailSumAggregateInputType
    _min?: DetailMinAggregateInputType
    _max?: DetailMaxAggregateInputType
  }

  export type DetailGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: DetailCountAggregateOutputType | null
    _avg: DetailAvgAggregateOutputType | null
    _sum: DetailSumAggregateOutputType | null
    _min: DetailMinAggregateOutputType | null
    _max: DetailMaxAggregateOutputType | null
  }

  type GetDetailGroupByPayload<T extends detailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetailGroupByOutputType[P]>
            : GetScalarType<T[P], DetailGroupByOutputType[P]>
        }
      >
    >


  export type detailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    conditionRates?: boolean | detail$conditionRatesArgs<ExtArgs>
    detailRates?: boolean | detail$detailRatesArgs<ExtArgs>
    _count?: boolean | DetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detail"]>



  export type detailSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type detailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["detail"]>
  export type detailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conditionRates?: boolean | detail$conditionRatesArgs<ExtArgs>
    detailRates?: boolean | detail$detailRatesArgs<ExtArgs>
    _count?: boolean | DetailCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $detailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "detail"
    objects: {
      conditionRates: Prisma.$ratePayload<ExtArgs>[]
      detailRates: Prisma.$ratePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["detail"]>
    composites: {}
  }

  type detailGetPayload<S extends boolean | null | undefined | detailDefaultArgs> = $Result.GetResult<Prisma.$detailPayload, S>

  type detailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<detailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DetailCountAggregateInputType | true
    }

  export interface detailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detail'], meta: { name: 'detail' } }
    /**
     * Find zero or one Detail that matches the filter.
     * @param {detailFindUniqueArgs} args - Arguments to find a Detail
     * @example
     * // Get one Detail
     * const detail = await prisma.detail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends detailFindUniqueArgs>(args: SelectSubset<T, detailFindUniqueArgs<ExtArgs>>): Prisma__detailClient<$Result.GetResult<Prisma.$detailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Detail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {detailFindUniqueOrThrowArgs} args - Arguments to find a Detail
     * @example
     * // Get one Detail
     * const detail = await prisma.detail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends detailFindUniqueOrThrowArgs>(args: SelectSubset<T, detailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__detailClient<$Result.GetResult<Prisma.$detailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Detail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detailFindFirstArgs} args - Arguments to find a Detail
     * @example
     * // Get one Detail
     * const detail = await prisma.detail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends detailFindFirstArgs>(args?: SelectSubset<T, detailFindFirstArgs<ExtArgs>>): Prisma__detailClient<$Result.GetResult<Prisma.$detailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Detail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detailFindFirstOrThrowArgs} args - Arguments to find a Detail
     * @example
     * // Get one Detail
     * const detail = await prisma.detail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends detailFindFirstOrThrowArgs>(args?: SelectSubset<T, detailFindFirstOrThrowArgs<ExtArgs>>): Prisma__detailClient<$Result.GetResult<Prisma.$detailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Details
     * const details = await prisma.detail.findMany()
     * 
     * // Get first 10 Details
     * const details = await prisma.detail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detailWithIdOnly = await prisma.detail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends detailFindManyArgs>(args?: SelectSubset<T, detailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Detail.
     * @param {detailCreateArgs} args - Arguments to create a Detail.
     * @example
     * // Create one Detail
     * const Detail = await prisma.detail.create({
     *   data: {
     *     // ... data to create a Detail
     *   }
     * })
     * 
     */
    create<T extends detailCreateArgs>(args: SelectSubset<T, detailCreateArgs<ExtArgs>>): Prisma__detailClient<$Result.GetResult<Prisma.$detailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Details.
     * @param {detailCreateManyArgs} args - Arguments to create many Details.
     * @example
     * // Create many Details
     * const detail = await prisma.detail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends detailCreateManyArgs>(args?: SelectSubset<T, detailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Detail.
     * @param {detailDeleteArgs} args - Arguments to delete one Detail.
     * @example
     * // Delete one Detail
     * const Detail = await prisma.detail.delete({
     *   where: {
     *     // ... filter to delete one Detail
     *   }
     * })
     * 
     */
    delete<T extends detailDeleteArgs>(args: SelectSubset<T, detailDeleteArgs<ExtArgs>>): Prisma__detailClient<$Result.GetResult<Prisma.$detailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Detail.
     * @param {detailUpdateArgs} args - Arguments to update one Detail.
     * @example
     * // Update one Detail
     * const detail = await prisma.detail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends detailUpdateArgs>(args: SelectSubset<T, detailUpdateArgs<ExtArgs>>): Prisma__detailClient<$Result.GetResult<Prisma.$detailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Details.
     * @param {detailDeleteManyArgs} args - Arguments to filter Details to delete.
     * @example
     * // Delete a few Details
     * const { count } = await prisma.detail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends detailDeleteManyArgs>(args?: SelectSubset<T, detailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Details
     * const detail = await prisma.detail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends detailUpdateManyArgs>(args: SelectSubset<T, detailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detail.
     * @param {detailUpsertArgs} args - Arguments to update or create a Detail.
     * @example
     * // Update or create a Detail
     * const detail = await prisma.detail.upsert({
     *   create: {
     *     // ... data to create a Detail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detail we want to update
     *   }
     * })
     */
    upsert<T extends detailUpsertArgs>(args: SelectSubset<T, detailUpsertArgs<ExtArgs>>): Prisma__detailClient<$Result.GetResult<Prisma.$detailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detailCountArgs} args - Arguments to filter Details to count.
     * @example
     * // Count the number of Details
     * const count = await prisma.detail.count({
     *   where: {
     *     // ... the filter for the Details we want to count
     *   }
     * })
    **/
    count<T extends detailCountArgs>(
      args?: Subset<T, detailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetailAggregateArgs>(args: Subset<T, DetailAggregateArgs>): Prisma.PrismaPromise<GetDetailAggregateType<T>>

    /**
     * Group by Detail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detailGroupByArgs['orderBy'] }
        : { orderBy?: detailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detail model
   */
  readonly fields: detailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conditionRates<T extends detail$conditionRatesArgs<ExtArgs> = {}>(args?: Subset<T, detail$conditionRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    detailRates<T extends detail$detailRatesArgs<ExtArgs> = {}>(args?: Subset<T, detail$detailRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the detail model
   */
  interface detailFieldRefs {
    readonly id: FieldRef<"detail", 'Int'>
    readonly createdAt: FieldRef<"detail", 'DateTime'>
    readonly updatedAt: FieldRef<"detail", 'DateTime'>
    readonly status: FieldRef<"detail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * detail findUnique
   */
  export type detailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail
     */
    select?: detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detail
     */
    omit?: detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detailInclude<ExtArgs> | null
    /**
     * Filter, which detail to fetch.
     */
    where: detailWhereUniqueInput
  }

  /**
   * detail findUniqueOrThrow
   */
  export type detailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail
     */
    select?: detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detail
     */
    omit?: detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detailInclude<ExtArgs> | null
    /**
     * Filter, which detail to fetch.
     */
    where: detailWhereUniqueInput
  }

  /**
   * detail findFirst
   */
  export type detailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail
     */
    select?: detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detail
     */
    omit?: detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detailInclude<ExtArgs> | null
    /**
     * Filter, which detail to fetch.
     */
    where?: detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of details to fetch.
     */
    orderBy?: detailOrderByWithRelationInput | detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for details.
     */
    cursor?: detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of details.
     */
    distinct?: DetailScalarFieldEnum | DetailScalarFieldEnum[]
  }

  /**
   * detail findFirstOrThrow
   */
  export type detailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail
     */
    select?: detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detail
     */
    omit?: detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detailInclude<ExtArgs> | null
    /**
     * Filter, which detail to fetch.
     */
    where?: detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of details to fetch.
     */
    orderBy?: detailOrderByWithRelationInput | detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for details.
     */
    cursor?: detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of details.
     */
    distinct?: DetailScalarFieldEnum | DetailScalarFieldEnum[]
  }

  /**
   * detail findMany
   */
  export type detailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail
     */
    select?: detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detail
     */
    omit?: detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detailInclude<ExtArgs> | null
    /**
     * Filter, which details to fetch.
     */
    where?: detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of details to fetch.
     */
    orderBy?: detailOrderByWithRelationInput | detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing details.
     */
    cursor?: detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` details.
     */
    skip?: number
    distinct?: DetailScalarFieldEnum | DetailScalarFieldEnum[]
  }

  /**
   * detail create
   */
  export type detailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail
     */
    select?: detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detail
     */
    omit?: detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detailInclude<ExtArgs> | null
    /**
     * The data needed to create a detail.
     */
    data?: XOR<detailCreateInput, detailUncheckedCreateInput>
  }

  /**
   * detail createMany
   */
  export type detailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many details.
     */
    data: detailCreateManyInput | detailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * detail update
   */
  export type detailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail
     */
    select?: detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detail
     */
    omit?: detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detailInclude<ExtArgs> | null
    /**
     * The data needed to update a detail.
     */
    data: XOR<detailUpdateInput, detailUncheckedUpdateInput>
    /**
     * Choose, which detail to update.
     */
    where: detailWhereUniqueInput
  }

  /**
   * detail updateMany
   */
  export type detailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update details.
     */
    data: XOR<detailUpdateManyMutationInput, detailUncheckedUpdateManyInput>
    /**
     * Filter which details to update
     */
    where?: detailWhereInput
    /**
     * Limit how many details to update.
     */
    limit?: number
  }

  /**
   * detail upsert
   */
  export type detailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail
     */
    select?: detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detail
     */
    omit?: detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detailInclude<ExtArgs> | null
    /**
     * The filter to search for the detail to update in case it exists.
     */
    where: detailWhereUniqueInput
    /**
     * In case the detail found by the `where` argument doesn't exist, create a new detail with this data.
     */
    create: XOR<detailCreateInput, detailUncheckedCreateInput>
    /**
     * In case the detail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detailUpdateInput, detailUncheckedUpdateInput>
  }

  /**
   * detail delete
   */
  export type detailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail
     */
    select?: detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detail
     */
    omit?: detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detailInclude<ExtArgs> | null
    /**
     * Filter which detail to delete.
     */
    where: detailWhereUniqueInput
  }

  /**
   * detail deleteMany
   */
  export type detailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which details to delete
     */
    where?: detailWhereInput
    /**
     * Limit how many details to delete.
     */
    limit?: number
  }

  /**
   * detail.conditionRates
   */
  export type detail$conditionRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate
     */
    select?: rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate
     */
    omit?: rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rateInclude<ExtArgs> | null
    where?: rateWhereInput
    orderBy?: rateOrderByWithRelationInput | rateOrderByWithRelationInput[]
    cursor?: rateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RateScalarFieldEnum | RateScalarFieldEnum[]
  }

  /**
   * detail.detailRates
   */
  export type detail$detailRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate
     */
    select?: rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate
     */
    omit?: rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rateInclude<ExtArgs> | null
    where?: rateWhereInput
    orderBy?: rateOrderByWithRelationInput | rateOrderByWithRelationInput[]
    cursor?: rateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RateScalarFieldEnum | RateScalarFieldEnum[]
  }

  /**
   * detail without action
   */
  export type detailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail
     */
    select?: detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detail
     */
    omit?: detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detailInclude<ExtArgs> | null
  }


  /**
   * Model effect_outside_fight
   */

  export type AggregateEffect_outside_fight = {
    _count: Effect_outside_fightCountAggregateOutputType | null
    _avg: Effect_outside_fightAvgAggregateOutputType | null
    _sum: Effect_outside_fightSumAggregateOutputType | null
    _min: Effect_outside_fightMinAggregateOutputType | null
    _max: Effect_outside_fightMaxAggregateOutputType | null
  }

  export type Effect_outside_fightAvgAggregateOutputType = {
    id: number | null
  }

  export type Effect_outside_fightSumAggregateOutputType = {
    id: number | null
  }

  export type Effect_outside_fightMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Effect_outside_fightMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Effect_outside_fightCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Effect_outside_fightAvgAggregateInputType = {
    id?: true
  }

  export type Effect_outside_fightSumAggregateInputType = {
    id?: true
  }

  export type Effect_outside_fightMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Effect_outside_fightMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Effect_outside_fightCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Effect_outside_fightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which effect_outside_fight to aggregate.
     */
    where?: effect_outside_fightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of effect_outside_fights to fetch.
     */
    orderBy?: effect_outside_fightOrderByWithRelationInput | effect_outside_fightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: effect_outside_fightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` effect_outside_fights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` effect_outside_fights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned effect_outside_fights
    **/
    _count?: true | Effect_outside_fightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Effect_outside_fightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Effect_outside_fightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Effect_outside_fightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Effect_outside_fightMaxAggregateInputType
  }

  export type GetEffect_outside_fightAggregateType<T extends Effect_outside_fightAggregateArgs> = {
        [P in keyof T & keyof AggregateEffect_outside_fight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEffect_outside_fight[P]>
      : GetScalarType<T[P], AggregateEffect_outside_fight[P]>
  }




  export type effect_outside_fightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: effect_outside_fightWhereInput
    orderBy?: effect_outside_fightOrderByWithAggregationInput | effect_outside_fightOrderByWithAggregationInput[]
    by: Effect_outside_fightScalarFieldEnum[] | Effect_outside_fightScalarFieldEnum
    having?: effect_outside_fightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Effect_outside_fightCountAggregateInputType | true
    _avg?: Effect_outside_fightAvgAggregateInputType
    _sum?: Effect_outside_fightSumAggregateInputType
    _min?: Effect_outside_fightMinAggregateInputType
    _max?: Effect_outside_fightMaxAggregateInputType
  }

  export type Effect_outside_fightGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Effect_outside_fightCountAggregateOutputType | null
    _avg: Effect_outside_fightAvgAggregateOutputType | null
    _sum: Effect_outside_fightSumAggregateOutputType | null
    _min: Effect_outside_fightMinAggregateOutputType | null
    _max: Effect_outside_fightMaxAggregateOutputType | null
  }

  type GetEffect_outside_fightGroupByPayload<T extends effect_outside_fightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Effect_outside_fightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Effect_outside_fightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Effect_outside_fightGroupByOutputType[P]>
            : GetScalarType<T[P], Effect_outside_fightGroupByOutputType[P]>
        }
      >
    >


  export type effect_outside_fightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    abilityInfos?: boolean | effect_outside_fight$abilityInfosArgs<ExtArgs>
    capacityInfos?: boolean | effect_outside_fight$capacityInfosArgs<ExtArgs>
    _count?: boolean | Effect_outside_fightCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["effect_outside_fight"]>



  export type effect_outside_fightSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type effect_outside_fightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["effect_outside_fight"]>
  export type effect_outside_fightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abilityInfos?: boolean | effect_outside_fight$abilityInfosArgs<ExtArgs>
    capacityInfos?: boolean | effect_outside_fight$capacityInfosArgs<ExtArgs>
    _count?: boolean | Effect_outside_fightCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $effect_outside_fightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "effect_outside_fight"
    objects: {
      abilityInfos: Prisma.$ability_infoPayload<ExtArgs>[]
      capacityInfos: Prisma.$capacity_infoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["effect_outside_fight"]>
    composites: {}
  }

  type effect_outside_fightGetPayload<S extends boolean | null | undefined | effect_outside_fightDefaultArgs> = $Result.GetResult<Prisma.$effect_outside_fightPayload, S>

  type effect_outside_fightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<effect_outside_fightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Effect_outside_fightCountAggregateInputType | true
    }

  export interface effect_outside_fightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['effect_outside_fight'], meta: { name: 'effect_outside_fight' } }
    /**
     * Find zero or one Effect_outside_fight that matches the filter.
     * @param {effect_outside_fightFindUniqueArgs} args - Arguments to find a Effect_outside_fight
     * @example
     * // Get one Effect_outside_fight
     * const effect_outside_fight = await prisma.effect_outside_fight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends effect_outside_fightFindUniqueArgs>(args: SelectSubset<T, effect_outside_fightFindUniqueArgs<ExtArgs>>): Prisma__effect_outside_fightClient<$Result.GetResult<Prisma.$effect_outside_fightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Effect_outside_fight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {effect_outside_fightFindUniqueOrThrowArgs} args - Arguments to find a Effect_outside_fight
     * @example
     * // Get one Effect_outside_fight
     * const effect_outside_fight = await prisma.effect_outside_fight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends effect_outside_fightFindUniqueOrThrowArgs>(args: SelectSubset<T, effect_outside_fightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__effect_outside_fightClient<$Result.GetResult<Prisma.$effect_outside_fightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Effect_outside_fight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {effect_outside_fightFindFirstArgs} args - Arguments to find a Effect_outside_fight
     * @example
     * // Get one Effect_outside_fight
     * const effect_outside_fight = await prisma.effect_outside_fight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends effect_outside_fightFindFirstArgs>(args?: SelectSubset<T, effect_outside_fightFindFirstArgs<ExtArgs>>): Prisma__effect_outside_fightClient<$Result.GetResult<Prisma.$effect_outside_fightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Effect_outside_fight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {effect_outside_fightFindFirstOrThrowArgs} args - Arguments to find a Effect_outside_fight
     * @example
     * // Get one Effect_outside_fight
     * const effect_outside_fight = await prisma.effect_outside_fight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends effect_outside_fightFindFirstOrThrowArgs>(args?: SelectSubset<T, effect_outside_fightFindFirstOrThrowArgs<ExtArgs>>): Prisma__effect_outside_fightClient<$Result.GetResult<Prisma.$effect_outside_fightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Effect_outside_fights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {effect_outside_fightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Effect_outside_fights
     * const effect_outside_fights = await prisma.effect_outside_fight.findMany()
     * 
     * // Get first 10 Effect_outside_fights
     * const effect_outside_fights = await prisma.effect_outside_fight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const effect_outside_fightWithIdOnly = await prisma.effect_outside_fight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends effect_outside_fightFindManyArgs>(args?: SelectSubset<T, effect_outside_fightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$effect_outside_fightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Effect_outside_fight.
     * @param {effect_outside_fightCreateArgs} args - Arguments to create a Effect_outside_fight.
     * @example
     * // Create one Effect_outside_fight
     * const Effect_outside_fight = await prisma.effect_outside_fight.create({
     *   data: {
     *     // ... data to create a Effect_outside_fight
     *   }
     * })
     * 
     */
    create<T extends effect_outside_fightCreateArgs>(args: SelectSubset<T, effect_outside_fightCreateArgs<ExtArgs>>): Prisma__effect_outside_fightClient<$Result.GetResult<Prisma.$effect_outside_fightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Effect_outside_fights.
     * @param {effect_outside_fightCreateManyArgs} args - Arguments to create many Effect_outside_fights.
     * @example
     * // Create many Effect_outside_fights
     * const effect_outside_fight = await prisma.effect_outside_fight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends effect_outside_fightCreateManyArgs>(args?: SelectSubset<T, effect_outside_fightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Effect_outside_fight.
     * @param {effect_outside_fightDeleteArgs} args - Arguments to delete one Effect_outside_fight.
     * @example
     * // Delete one Effect_outside_fight
     * const Effect_outside_fight = await prisma.effect_outside_fight.delete({
     *   where: {
     *     // ... filter to delete one Effect_outside_fight
     *   }
     * })
     * 
     */
    delete<T extends effect_outside_fightDeleteArgs>(args: SelectSubset<T, effect_outside_fightDeleteArgs<ExtArgs>>): Prisma__effect_outside_fightClient<$Result.GetResult<Prisma.$effect_outside_fightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Effect_outside_fight.
     * @param {effect_outside_fightUpdateArgs} args - Arguments to update one Effect_outside_fight.
     * @example
     * // Update one Effect_outside_fight
     * const effect_outside_fight = await prisma.effect_outside_fight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends effect_outside_fightUpdateArgs>(args: SelectSubset<T, effect_outside_fightUpdateArgs<ExtArgs>>): Prisma__effect_outside_fightClient<$Result.GetResult<Prisma.$effect_outside_fightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Effect_outside_fights.
     * @param {effect_outside_fightDeleteManyArgs} args - Arguments to filter Effect_outside_fights to delete.
     * @example
     * // Delete a few Effect_outside_fights
     * const { count } = await prisma.effect_outside_fight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends effect_outside_fightDeleteManyArgs>(args?: SelectSubset<T, effect_outside_fightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Effect_outside_fights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {effect_outside_fightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Effect_outside_fights
     * const effect_outside_fight = await prisma.effect_outside_fight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends effect_outside_fightUpdateManyArgs>(args: SelectSubset<T, effect_outside_fightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Effect_outside_fight.
     * @param {effect_outside_fightUpsertArgs} args - Arguments to update or create a Effect_outside_fight.
     * @example
     * // Update or create a Effect_outside_fight
     * const effect_outside_fight = await prisma.effect_outside_fight.upsert({
     *   create: {
     *     // ... data to create a Effect_outside_fight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Effect_outside_fight we want to update
     *   }
     * })
     */
    upsert<T extends effect_outside_fightUpsertArgs>(args: SelectSubset<T, effect_outside_fightUpsertArgs<ExtArgs>>): Prisma__effect_outside_fightClient<$Result.GetResult<Prisma.$effect_outside_fightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Effect_outside_fights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {effect_outside_fightCountArgs} args - Arguments to filter Effect_outside_fights to count.
     * @example
     * // Count the number of Effect_outside_fights
     * const count = await prisma.effect_outside_fight.count({
     *   where: {
     *     // ... the filter for the Effect_outside_fights we want to count
     *   }
     * })
    **/
    count<T extends effect_outside_fightCountArgs>(
      args?: Subset<T, effect_outside_fightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Effect_outside_fightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Effect_outside_fight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Effect_outside_fightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Effect_outside_fightAggregateArgs>(args: Subset<T, Effect_outside_fightAggregateArgs>): Prisma.PrismaPromise<GetEffect_outside_fightAggregateType<T>>

    /**
     * Group by Effect_outside_fight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {effect_outside_fightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends effect_outside_fightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: effect_outside_fightGroupByArgs['orderBy'] }
        : { orderBy?: effect_outside_fightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, effect_outside_fightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEffect_outside_fightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the effect_outside_fight model
   */
  readonly fields: effect_outside_fightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for effect_outside_fight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__effect_outside_fightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    abilityInfos<T extends effect_outside_fight$abilityInfosArgs<ExtArgs> = {}>(args?: Subset<T, effect_outside_fight$abilityInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ability_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    capacityInfos<T extends effect_outside_fight$capacityInfosArgs<ExtArgs> = {}>(args?: Subset<T, effect_outside_fight$capacityInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the effect_outside_fight model
   */
  interface effect_outside_fightFieldRefs {
    readonly id: FieldRef<"effect_outside_fight", 'Int'>
    readonly createdAt: FieldRef<"effect_outside_fight", 'DateTime'>
    readonly updatedAt: FieldRef<"effect_outside_fight", 'DateTime'>
    readonly status: FieldRef<"effect_outside_fight", 'String'>
  }
    

  // Custom InputTypes
  /**
   * effect_outside_fight findUnique
   */
  export type effect_outside_fightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the effect_outside_fight
     */
    select?: effect_outside_fightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the effect_outside_fight
     */
    omit?: effect_outside_fightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: effect_outside_fightInclude<ExtArgs> | null
    /**
     * Filter, which effect_outside_fight to fetch.
     */
    where: effect_outside_fightWhereUniqueInput
  }

  /**
   * effect_outside_fight findUniqueOrThrow
   */
  export type effect_outside_fightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the effect_outside_fight
     */
    select?: effect_outside_fightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the effect_outside_fight
     */
    omit?: effect_outside_fightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: effect_outside_fightInclude<ExtArgs> | null
    /**
     * Filter, which effect_outside_fight to fetch.
     */
    where: effect_outside_fightWhereUniqueInput
  }

  /**
   * effect_outside_fight findFirst
   */
  export type effect_outside_fightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the effect_outside_fight
     */
    select?: effect_outside_fightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the effect_outside_fight
     */
    omit?: effect_outside_fightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: effect_outside_fightInclude<ExtArgs> | null
    /**
     * Filter, which effect_outside_fight to fetch.
     */
    where?: effect_outside_fightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of effect_outside_fights to fetch.
     */
    orderBy?: effect_outside_fightOrderByWithRelationInput | effect_outside_fightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for effect_outside_fights.
     */
    cursor?: effect_outside_fightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` effect_outside_fights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` effect_outside_fights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of effect_outside_fights.
     */
    distinct?: Effect_outside_fightScalarFieldEnum | Effect_outside_fightScalarFieldEnum[]
  }

  /**
   * effect_outside_fight findFirstOrThrow
   */
  export type effect_outside_fightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the effect_outside_fight
     */
    select?: effect_outside_fightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the effect_outside_fight
     */
    omit?: effect_outside_fightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: effect_outside_fightInclude<ExtArgs> | null
    /**
     * Filter, which effect_outside_fight to fetch.
     */
    where?: effect_outside_fightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of effect_outside_fights to fetch.
     */
    orderBy?: effect_outside_fightOrderByWithRelationInput | effect_outside_fightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for effect_outside_fights.
     */
    cursor?: effect_outside_fightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` effect_outside_fights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` effect_outside_fights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of effect_outside_fights.
     */
    distinct?: Effect_outside_fightScalarFieldEnum | Effect_outside_fightScalarFieldEnum[]
  }

  /**
   * effect_outside_fight findMany
   */
  export type effect_outside_fightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the effect_outside_fight
     */
    select?: effect_outside_fightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the effect_outside_fight
     */
    omit?: effect_outside_fightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: effect_outside_fightInclude<ExtArgs> | null
    /**
     * Filter, which effect_outside_fights to fetch.
     */
    where?: effect_outside_fightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of effect_outside_fights to fetch.
     */
    orderBy?: effect_outside_fightOrderByWithRelationInput | effect_outside_fightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing effect_outside_fights.
     */
    cursor?: effect_outside_fightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` effect_outside_fights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` effect_outside_fights.
     */
    skip?: number
    distinct?: Effect_outside_fightScalarFieldEnum | Effect_outside_fightScalarFieldEnum[]
  }

  /**
   * effect_outside_fight create
   */
  export type effect_outside_fightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the effect_outside_fight
     */
    select?: effect_outside_fightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the effect_outside_fight
     */
    omit?: effect_outside_fightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: effect_outside_fightInclude<ExtArgs> | null
    /**
     * The data needed to create a effect_outside_fight.
     */
    data?: XOR<effect_outside_fightCreateInput, effect_outside_fightUncheckedCreateInput>
  }

  /**
   * effect_outside_fight createMany
   */
  export type effect_outside_fightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many effect_outside_fights.
     */
    data: effect_outside_fightCreateManyInput | effect_outside_fightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * effect_outside_fight update
   */
  export type effect_outside_fightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the effect_outside_fight
     */
    select?: effect_outside_fightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the effect_outside_fight
     */
    omit?: effect_outside_fightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: effect_outside_fightInclude<ExtArgs> | null
    /**
     * The data needed to update a effect_outside_fight.
     */
    data: XOR<effect_outside_fightUpdateInput, effect_outside_fightUncheckedUpdateInput>
    /**
     * Choose, which effect_outside_fight to update.
     */
    where: effect_outside_fightWhereUniqueInput
  }

  /**
   * effect_outside_fight updateMany
   */
  export type effect_outside_fightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update effect_outside_fights.
     */
    data: XOR<effect_outside_fightUpdateManyMutationInput, effect_outside_fightUncheckedUpdateManyInput>
    /**
     * Filter which effect_outside_fights to update
     */
    where?: effect_outside_fightWhereInput
    /**
     * Limit how many effect_outside_fights to update.
     */
    limit?: number
  }

  /**
   * effect_outside_fight upsert
   */
  export type effect_outside_fightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the effect_outside_fight
     */
    select?: effect_outside_fightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the effect_outside_fight
     */
    omit?: effect_outside_fightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: effect_outside_fightInclude<ExtArgs> | null
    /**
     * The filter to search for the effect_outside_fight to update in case it exists.
     */
    where: effect_outside_fightWhereUniqueInput
    /**
     * In case the effect_outside_fight found by the `where` argument doesn't exist, create a new effect_outside_fight with this data.
     */
    create: XOR<effect_outside_fightCreateInput, effect_outside_fightUncheckedCreateInput>
    /**
     * In case the effect_outside_fight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<effect_outside_fightUpdateInput, effect_outside_fightUncheckedUpdateInput>
  }

  /**
   * effect_outside_fight delete
   */
  export type effect_outside_fightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the effect_outside_fight
     */
    select?: effect_outside_fightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the effect_outside_fight
     */
    omit?: effect_outside_fightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: effect_outside_fightInclude<ExtArgs> | null
    /**
     * Filter which effect_outside_fight to delete.
     */
    where: effect_outside_fightWhereUniqueInput
  }

  /**
   * effect_outside_fight deleteMany
   */
  export type effect_outside_fightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which effect_outside_fights to delete
     */
    where?: effect_outside_fightWhereInput
    /**
     * Limit how many effect_outside_fights to delete.
     */
    limit?: number
  }

  /**
   * effect_outside_fight.abilityInfos
   */
  export type effect_outside_fight$abilityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ability_info
     */
    select?: ability_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ability_info
     */
    omit?: ability_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ability_infoInclude<ExtArgs> | null
    where?: ability_infoWhereInput
    orderBy?: ability_infoOrderByWithRelationInput | ability_infoOrderByWithRelationInput[]
    cursor?: ability_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ability_infoScalarFieldEnum | Ability_infoScalarFieldEnum[]
  }

  /**
   * effect_outside_fight.capacityInfos
   */
  export type effect_outside_fight$capacityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    where?: capacity_infoWhereInput
    orderBy?: capacity_infoOrderByWithRelationInput | capacity_infoOrderByWithRelationInput[]
    cursor?: capacity_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Capacity_infoScalarFieldEnum | Capacity_infoScalarFieldEnum[]
  }

  /**
   * effect_outside_fight without action
   */
  export type effect_outside_fightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the effect_outside_fight
     */
    select?: effect_outside_fightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the effect_outside_fight
     */
    omit?: effect_outside_fightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: effect_outside_fightInclude<ExtArgs> | null
  }


  /**
   * Model influence
   */

  export type AggregateInfluence = {
    _count: InfluenceCountAggregateOutputType | null
    _avg: InfluenceAvgAggregateOutputType | null
    _sum: InfluenceSumAggregateOutputType | null
    _min: InfluenceMinAggregateOutputType | null
    _max: InfluenceMaxAggregateOutputType | null
  }

  export type InfluenceAvgAggregateOutputType = {
    id: number | null
  }

  export type InfluenceSumAggregateOutputType = {
    id: number | null
  }

  export type InfluenceMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type InfluenceMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type InfluenceCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type InfluenceAvgAggregateInputType = {
    id?: true
  }

  export type InfluenceSumAggregateInputType = {
    id?: true
  }

  export type InfluenceMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type InfluenceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type InfluenceCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type InfluenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which influence to aggregate.
     */
    where?: influenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of influences to fetch.
     */
    orderBy?: influenceOrderByWithRelationInput | influenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: influenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` influences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` influences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned influences
    **/
    _count?: true | InfluenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InfluenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InfluenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfluenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfluenceMaxAggregateInputType
  }

  export type GetInfluenceAggregateType<T extends InfluenceAggregateArgs> = {
        [P in keyof T & keyof AggregateInfluence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfluence[P]>
      : GetScalarType<T[P], AggregateInfluence[P]>
  }




  export type influenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: influenceWhereInput
    orderBy?: influenceOrderByWithAggregationInput | influenceOrderByWithAggregationInput[]
    by: InfluenceScalarFieldEnum[] | InfluenceScalarFieldEnum
    having?: influenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfluenceCountAggregateInputType | true
    _avg?: InfluenceAvgAggregateInputType
    _sum?: InfluenceSumAggregateInputType
    _min?: InfluenceMinAggregateInputType
    _max?: InfluenceMaxAggregateInputType
  }

  export type InfluenceGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: InfluenceCountAggregateOutputType | null
    _avg: InfluenceAvgAggregateOutputType | null
    _sum: InfluenceSumAggregateOutputType | null
    _min: InfluenceMinAggregateOutputType | null
    _max: InfluenceMaxAggregateOutputType | null
  }

  type GetInfluenceGroupByPayload<T extends influenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InfluenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfluenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfluenceGroupByOutputType[P]>
            : GetScalarType<T[P], InfluenceGroupByOutputType[P]>
        }
      >
    >


  export type influenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    capacityInfoInfluences?: boolean | influence$capacityInfoInfluencesArgs<ExtArgs>
    _count?: boolean | InfluenceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["influence"]>



  export type influenceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type influenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["influence"]>
  export type influenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfoInfluences?: boolean | influence$capacityInfoInfluencesArgs<ExtArgs>
    _count?: boolean | InfluenceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $influencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "influence"
    objects: {
      capacityInfoInfluences: Prisma.$capacity_info_influencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["influence"]>
    composites: {}
  }

  type influenceGetPayload<S extends boolean | null | undefined | influenceDefaultArgs> = $Result.GetResult<Prisma.$influencePayload, S>

  type influenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<influenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InfluenceCountAggregateInputType | true
    }

  export interface influenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['influence'], meta: { name: 'influence' } }
    /**
     * Find zero or one Influence that matches the filter.
     * @param {influenceFindUniqueArgs} args - Arguments to find a Influence
     * @example
     * // Get one Influence
     * const influence = await prisma.influence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends influenceFindUniqueArgs>(args: SelectSubset<T, influenceFindUniqueArgs<ExtArgs>>): Prisma__influenceClient<$Result.GetResult<Prisma.$influencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Influence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {influenceFindUniqueOrThrowArgs} args - Arguments to find a Influence
     * @example
     * // Get one Influence
     * const influence = await prisma.influence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends influenceFindUniqueOrThrowArgs>(args: SelectSubset<T, influenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__influenceClient<$Result.GetResult<Prisma.$influencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Influence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {influenceFindFirstArgs} args - Arguments to find a Influence
     * @example
     * // Get one Influence
     * const influence = await prisma.influence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends influenceFindFirstArgs>(args?: SelectSubset<T, influenceFindFirstArgs<ExtArgs>>): Prisma__influenceClient<$Result.GetResult<Prisma.$influencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Influence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {influenceFindFirstOrThrowArgs} args - Arguments to find a Influence
     * @example
     * // Get one Influence
     * const influence = await prisma.influence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends influenceFindFirstOrThrowArgs>(args?: SelectSubset<T, influenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__influenceClient<$Result.GetResult<Prisma.$influencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Influences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {influenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Influences
     * const influences = await prisma.influence.findMany()
     * 
     * // Get first 10 Influences
     * const influences = await prisma.influence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const influenceWithIdOnly = await prisma.influence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends influenceFindManyArgs>(args?: SelectSubset<T, influenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$influencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Influence.
     * @param {influenceCreateArgs} args - Arguments to create a Influence.
     * @example
     * // Create one Influence
     * const Influence = await prisma.influence.create({
     *   data: {
     *     // ... data to create a Influence
     *   }
     * })
     * 
     */
    create<T extends influenceCreateArgs>(args: SelectSubset<T, influenceCreateArgs<ExtArgs>>): Prisma__influenceClient<$Result.GetResult<Prisma.$influencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Influences.
     * @param {influenceCreateManyArgs} args - Arguments to create many Influences.
     * @example
     * // Create many Influences
     * const influence = await prisma.influence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends influenceCreateManyArgs>(args?: SelectSubset<T, influenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Influence.
     * @param {influenceDeleteArgs} args - Arguments to delete one Influence.
     * @example
     * // Delete one Influence
     * const Influence = await prisma.influence.delete({
     *   where: {
     *     // ... filter to delete one Influence
     *   }
     * })
     * 
     */
    delete<T extends influenceDeleteArgs>(args: SelectSubset<T, influenceDeleteArgs<ExtArgs>>): Prisma__influenceClient<$Result.GetResult<Prisma.$influencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Influence.
     * @param {influenceUpdateArgs} args - Arguments to update one Influence.
     * @example
     * // Update one Influence
     * const influence = await prisma.influence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends influenceUpdateArgs>(args: SelectSubset<T, influenceUpdateArgs<ExtArgs>>): Prisma__influenceClient<$Result.GetResult<Prisma.$influencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Influences.
     * @param {influenceDeleteManyArgs} args - Arguments to filter Influences to delete.
     * @example
     * // Delete a few Influences
     * const { count } = await prisma.influence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends influenceDeleteManyArgs>(args?: SelectSubset<T, influenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Influences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {influenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Influences
     * const influence = await prisma.influence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends influenceUpdateManyArgs>(args: SelectSubset<T, influenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Influence.
     * @param {influenceUpsertArgs} args - Arguments to update or create a Influence.
     * @example
     * // Update or create a Influence
     * const influence = await prisma.influence.upsert({
     *   create: {
     *     // ... data to create a Influence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Influence we want to update
     *   }
     * })
     */
    upsert<T extends influenceUpsertArgs>(args: SelectSubset<T, influenceUpsertArgs<ExtArgs>>): Prisma__influenceClient<$Result.GetResult<Prisma.$influencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Influences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {influenceCountArgs} args - Arguments to filter Influences to count.
     * @example
     * // Count the number of Influences
     * const count = await prisma.influence.count({
     *   where: {
     *     // ... the filter for the Influences we want to count
     *   }
     * })
    **/
    count<T extends influenceCountArgs>(
      args?: Subset<T, influenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfluenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Influence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfluenceAggregateArgs>(args: Subset<T, InfluenceAggregateArgs>): Prisma.PrismaPromise<GetInfluenceAggregateType<T>>

    /**
     * Group by Influence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {influenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends influenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: influenceGroupByArgs['orderBy'] }
        : { orderBy?: influenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, influenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfluenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the influence model
   */
  readonly fields: influenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for influence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__influenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capacityInfoInfluences<T extends influence$capacityInfoInfluencesArgs<ExtArgs> = {}>(args?: Subset<T, influence$capacityInfoInfluencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacity_info_influencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the influence model
   */
  interface influenceFieldRefs {
    readonly id: FieldRef<"influence", 'Int'>
    readonly createdAt: FieldRef<"influence", 'DateTime'>
    readonly updatedAt: FieldRef<"influence", 'DateTime'>
    readonly status: FieldRef<"influence", 'String'>
  }
    

  // Custom InputTypes
  /**
   * influence findUnique
   */
  export type influenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the influence
     */
    select?: influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the influence
     */
    omit?: influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: influenceInclude<ExtArgs> | null
    /**
     * Filter, which influence to fetch.
     */
    where: influenceWhereUniqueInput
  }

  /**
   * influence findUniqueOrThrow
   */
  export type influenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the influence
     */
    select?: influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the influence
     */
    omit?: influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: influenceInclude<ExtArgs> | null
    /**
     * Filter, which influence to fetch.
     */
    where: influenceWhereUniqueInput
  }

  /**
   * influence findFirst
   */
  export type influenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the influence
     */
    select?: influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the influence
     */
    omit?: influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: influenceInclude<ExtArgs> | null
    /**
     * Filter, which influence to fetch.
     */
    where?: influenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of influences to fetch.
     */
    orderBy?: influenceOrderByWithRelationInput | influenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for influences.
     */
    cursor?: influenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` influences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` influences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of influences.
     */
    distinct?: InfluenceScalarFieldEnum | InfluenceScalarFieldEnum[]
  }

  /**
   * influence findFirstOrThrow
   */
  export type influenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the influence
     */
    select?: influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the influence
     */
    omit?: influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: influenceInclude<ExtArgs> | null
    /**
     * Filter, which influence to fetch.
     */
    where?: influenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of influences to fetch.
     */
    orderBy?: influenceOrderByWithRelationInput | influenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for influences.
     */
    cursor?: influenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` influences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` influences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of influences.
     */
    distinct?: InfluenceScalarFieldEnum | InfluenceScalarFieldEnum[]
  }

  /**
   * influence findMany
   */
  export type influenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the influence
     */
    select?: influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the influence
     */
    omit?: influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: influenceInclude<ExtArgs> | null
    /**
     * Filter, which influences to fetch.
     */
    where?: influenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of influences to fetch.
     */
    orderBy?: influenceOrderByWithRelationInput | influenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing influences.
     */
    cursor?: influenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` influences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` influences.
     */
    skip?: number
    distinct?: InfluenceScalarFieldEnum | InfluenceScalarFieldEnum[]
  }

  /**
   * influence create
   */
  export type influenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the influence
     */
    select?: influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the influence
     */
    omit?: influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: influenceInclude<ExtArgs> | null
    /**
     * The data needed to create a influence.
     */
    data?: XOR<influenceCreateInput, influenceUncheckedCreateInput>
  }

  /**
   * influence createMany
   */
  export type influenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many influences.
     */
    data: influenceCreateManyInput | influenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * influence update
   */
  export type influenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the influence
     */
    select?: influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the influence
     */
    omit?: influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: influenceInclude<ExtArgs> | null
    /**
     * The data needed to update a influence.
     */
    data: XOR<influenceUpdateInput, influenceUncheckedUpdateInput>
    /**
     * Choose, which influence to update.
     */
    where: influenceWhereUniqueInput
  }

  /**
   * influence updateMany
   */
  export type influenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update influences.
     */
    data: XOR<influenceUpdateManyMutationInput, influenceUncheckedUpdateManyInput>
    /**
     * Filter which influences to update
     */
    where?: influenceWhereInput
    /**
     * Limit how many influences to update.
     */
    limit?: number
  }

  /**
   * influence upsert
   */
  export type influenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the influence
     */
    select?: influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the influence
     */
    omit?: influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: influenceInclude<ExtArgs> | null
    /**
     * The filter to search for the influence to update in case it exists.
     */
    where: influenceWhereUniqueInput
    /**
     * In case the influence found by the `where` argument doesn't exist, create a new influence with this data.
     */
    create: XOR<influenceCreateInput, influenceUncheckedCreateInput>
    /**
     * In case the influence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<influenceUpdateInput, influenceUncheckedUpdateInput>
  }

  /**
   * influence delete
   */
  export type influenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the influence
     */
    select?: influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the influence
     */
    omit?: influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: influenceInclude<ExtArgs> | null
    /**
     * Filter which influence to delete.
     */
    where: influenceWhereUniqueInput
  }

  /**
   * influence deleteMany
   */
  export type influenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which influences to delete
     */
    where?: influenceWhereInput
    /**
     * Limit how many influences to delete.
     */
    limit?: number
  }

  /**
   * influence.capacityInfoInfluences
   */
  export type influence$capacityInfoInfluencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info_influence
     */
    select?: capacity_info_influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info_influence
     */
    omit?: capacity_info_influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_info_influenceInclude<ExtArgs> | null
    where?: capacity_info_influenceWhereInput
    orderBy?: capacity_info_influenceOrderByWithRelationInput | capacity_info_influenceOrderByWithRelationInput[]
    cursor?: capacity_info_influenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Capacity_info_influenceScalarFieldEnum | Capacity_info_influenceScalarFieldEnum[]
  }

  /**
   * influence without action
   */
  export type influenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the influence
     */
    select?: influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the influence
     */
    omit?: influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: influenceInclude<ExtArgs> | null
  }


  /**
   * Model location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number | null
  }

  export type LocationSumAggregateOutputType = {
    id: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which location to aggregate.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type locationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: locationWhereInput
    orderBy?: locationOrderByWithAggregationInput | locationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: locationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends locationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type locationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    locationZones?: boolean | location$locationZonesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>



  export type locationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type locationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["location"]>
  export type locationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationZones?: boolean | location$locationZonesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $locationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "location"
    objects: {
      locationZones: Prisma.$location_zonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type locationGetPayload<S extends boolean | null | undefined | locationDefaultArgs> = $Result.GetResult<Prisma.$locationPayload, S>

  type locationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<locationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface locationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['location'], meta: { name: 'location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {locationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends locationFindUniqueArgs>(args: SelectSubset<T, locationFindUniqueArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {locationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends locationFindUniqueOrThrowArgs>(args: SelectSubset<T, locationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends locationFindFirstArgs>(args?: SelectSubset<T, locationFindFirstArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends locationFindFirstOrThrowArgs>(args?: SelectSubset<T, locationFindFirstOrThrowArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends locationFindManyArgs>(args?: SelectSubset<T, locationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {locationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends locationCreateArgs>(args: SelectSubset<T, locationCreateArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {locationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends locationCreateManyArgs>(args?: SelectSubset<T, locationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Location.
     * @param {locationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends locationDeleteArgs>(args: SelectSubset<T, locationDeleteArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {locationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends locationUpdateArgs>(args: SelectSubset<T, locationUpdateArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {locationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends locationDeleteManyArgs>(args?: SelectSubset<T, locationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends locationUpdateManyArgs>(args: SelectSubset<T, locationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {locationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends locationUpsertArgs>(args: SelectSubset<T, locationUpsertArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationCountArgs>(
      args?: Subset<T, locationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends locationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: locationGroupByArgs['orderBy'] }
        : { orderBy?: locationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, locationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the location model
   */
  readonly fields: locationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__locationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locationZones<T extends location$locationZonesArgs<ExtArgs> = {}>(args?: Subset<T, location$locationZonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$location_zonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the location model
   */
  interface locationFieldRefs {
    readonly id: FieldRef<"location", 'Int'>
    readonly createdAt: FieldRef<"location", 'DateTime'>
    readonly updatedAt: FieldRef<"location", 'DateTime'>
    readonly status: FieldRef<"location", 'String'>
  }
    

  // Custom InputTypes
  /**
   * location findUnique
   */
  export type locationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location findUniqueOrThrow
   */
  export type locationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location findFirst
   */
  export type locationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * location findFirstOrThrow
   */
  export type locationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * location findMany
   */
  export type locationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * location create
   */
  export type locationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * The data needed to create a location.
     */
    data?: XOR<locationCreateInput, locationUncheckedCreateInput>
  }

  /**
   * location createMany
   */
  export type locationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many locations.
     */
    data: locationCreateManyInput | locationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * location update
   */
  export type locationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * The data needed to update a location.
     */
    data: XOR<locationUpdateInput, locationUncheckedUpdateInput>
    /**
     * Choose, which location to update.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location updateMany
   */
  export type locationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update locations.
     */
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationWhereInput
    /**
     * Limit how many locations to update.
     */
    limit?: number
  }

  /**
   * location upsert
   */
  export type locationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * The filter to search for the location to update in case it exists.
     */
    where: locationWhereUniqueInput
    /**
     * In case the location found by the `where` argument doesn't exist, create a new location with this data.
     */
    create: XOR<locationCreateInput, locationUncheckedCreateInput>
    /**
     * In case the location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<locationUpdateInput, locationUncheckedUpdateInput>
  }

  /**
   * location delete
   */
  export type locationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter which location to delete.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location deleteMany
   */
  export type locationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locations to delete
     */
    where?: locationWhereInput
    /**
     * Limit how many locations to delete.
     */
    limit?: number
  }

  /**
   * location.locationZones
   */
  export type location$locationZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_zone
     */
    select?: location_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location_zone
     */
    omit?: location_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_zoneInclude<ExtArgs> | null
    where?: location_zoneWhereInput
    orderBy?: location_zoneOrderByWithRelationInput | location_zoneOrderByWithRelationInput[]
    cursor?: location_zoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Location_zoneScalarFieldEnum | Location_zoneScalarFieldEnum[]
  }

  /**
   * location without action
   */
  export type locationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
  }


  /**
   * Model zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneAvgAggregateOutputType = {
    id: number | null
  }

  export type ZoneSumAggregateOutputType = {
    id: number | null
  }

  export type ZoneMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type ZoneAvgAggregateInputType = {
    id?: true
  }

  export type ZoneSumAggregateInputType = {
    id?: true
  }

  export type ZoneMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zone to aggregate.
     */
    where?: zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type zoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zoneWhereInput
    orderBy?: zoneOrderByWithAggregationInput | zoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: zoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _avg?: ZoneAvgAggregateInputType
    _sum?: ZoneSumAggregateInputType
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends zoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type zoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    locationZones?: boolean | zone$locationZonesArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>



  export type zoneSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type zoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["zone"]>
  export type zoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationZones?: boolean | zone$locationZonesArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $zonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "zone"
    objects: {
      locationZones: Prisma.$location_zonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type zoneGetPayload<S extends boolean | null | undefined | zoneDefaultArgs> = $Result.GetResult<Prisma.$zonePayload, S>

  type zoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<zoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface zoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['zone'], meta: { name: 'zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {zoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends zoneFindUniqueArgs>(args: SelectSubset<T, zoneFindUniqueArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {zoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends zoneFindUniqueOrThrowArgs>(args: SelectSubset<T, zoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends zoneFindFirstArgs>(args?: SelectSubset<T, zoneFindFirstArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends zoneFindFirstOrThrowArgs>(args?: SelectSubset<T, zoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends zoneFindManyArgs>(args?: SelectSubset<T, zoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zone.
     * @param {zoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends zoneCreateArgs>(args: SelectSubset<T, zoneCreateArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zones.
     * @param {zoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends zoneCreateManyArgs>(args?: SelectSubset<T, zoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Zone.
     * @param {zoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends zoneDeleteArgs>(args: SelectSubset<T, zoneDeleteArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zone.
     * @param {zoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends zoneUpdateArgs>(args: SelectSubset<T, zoneUpdateArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zones.
     * @param {zoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends zoneDeleteManyArgs>(args?: SelectSubset<T, zoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends zoneUpdateManyArgs>(args: SelectSubset<T, zoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Zone.
     * @param {zoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends zoneUpsertArgs>(args: SelectSubset<T, zoneUpsertArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends zoneCountArgs>(
      args?: Subset<T, zoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends zoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: zoneGroupByArgs['orderBy'] }
        : { orderBy?: zoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, zoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the zone model
   */
  readonly fields: zoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__zoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locationZones<T extends zone$locationZonesArgs<ExtArgs> = {}>(args?: Subset<T, zone$locationZonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$location_zonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the zone model
   */
  interface zoneFieldRefs {
    readonly id: FieldRef<"zone", 'Int'>
    readonly createdAt: FieldRef<"zone", 'DateTime'>
    readonly updatedAt: FieldRef<"zone", 'DateTime'>
    readonly status: FieldRef<"zone", 'String'>
  }
    

  // Custom InputTypes
  /**
   * zone findUnique
   */
  export type zoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zone to fetch.
     */
    where: zoneWhereUniqueInput
  }

  /**
   * zone findUniqueOrThrow
   */
  export type zoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zone to fetch.
     */
    where: zoneWhereUniqueInput
  }

  /**
   * zone findFirst
   */
  export type zoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zone to fetch.
     */
    where?: zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zones.
     */
    cursor?: zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * zone findFirstOrThrow
   */
  export type zoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zone to fetch.
     */
    where?: zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zones.
     */
    cursor?: zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * zone findMany
   */
  export type zoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zones to fetch.
     */
    where?: zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing zones.
     */
    cursor?: zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * zone create
   */
  export type zoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * The data needed to create a zone.
     */
    data?: XOR<zoneCreateInput, zoneUncheckedCreateInput>
  }

  /**
   * zone createMany
   */
  export type zoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many zones.
     */
    data: zoneCreateManyInput | zoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * zone update
   */
  export type zoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * The data needed to update a zone.
     */
    data: XOR<zoneUpdateInput, zoneUncheckedUpdateInput>
    /**
     * Choose, which zone to update.
     */
    where: zoneWhereUniqueInput
  }

  /**
   * zone updateMany
   */
  export type zoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update zones.
     */
    data: XOR<zoneUpdateManyMutationInput, zoneUncheckedUpdateManyInput>
    /**
     * Filter which zones to update
     */
    where?: zoneWhereInput
    /**
     * Limit how many zones to update.
     */
    limit?: number
  }

  /**
   * zone upsert
   */
  export type zoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * The filter to search for the zone to update in case it exists.
     */
    where: zoneWhereUniqueInput
    /**
     * In case the zone found by the `where` argument doesn't exist, create a new zone with this data.
     */
    create: XOR<zoneCreateInput, zoneUncheckedCreateInput>
    /**
     * In case the zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<zoneUpdateInput, zoneUncheckedUpdateInput>
  }

  /**
   * zone delete
   */
  export type zoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter which zone to delete.
     */
    where: zoneWhereUniqueInput
  }

  /**
   * zone deleteMany
   */
  export type zoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zones to delete
     */
    where?: zoneWhereInput
    /**
     * Limit how many zones to delete.
     */
    limit?: number
  }

  /**
   * zone.locationZones
   */
  export type zone$locationZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_zone
     */
    select?: location_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location_zone
     */
    omit?: location_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_zoneInclude<ExtArgs> | null
    where?: location_zoneWhereInput
    orderBy?: location_zoneOrderByWithRelationInput | location_zoneOrderByWithRelationInput[]
    cursor?: location_zoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Location_zoneScalarFieldEnum | Location_zoneScalarFieldEnum[]
  }

  /**
   * zone without action
   */
  export type zoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
  }


  /**
   * Model location_zone
   */

  export type AggregateLocation_zone = {
    _count: Location_zoneCountAggregateOutputType | null
    _avg: Location_zoneAvgAggregateOutputType | null
    _sum: Location_zoneSumAggregateOutputType | null
    _min: Location_zoneMinAggregateOutputType | null
    _max: Location_zoneMaxAggregateOutputType | null
  }

  export type Location_zoneAvgAggregateOutputType = {
    id: number | null
    locationId: number | null
    zoneId: number | null
  }

  export type Location_zoneSumAggregateOutputType = {
    id: number | null
    locationId: number | null
    zoneId: number | null
  }

  export type Location_zoneMinAggregateOutputType = {
    id: number | null
    locationId: number | null
    zoneId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Location_zoneMaxAggregateOutputType = {
    id: number | null
    locationId: number | null
    zoneId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Location_zoneCountAggregateOutputType = {
    id: number
    locationId: number
    zoneId: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Location_zoneAvgAggregateInputType = {
    id?: true
    locationId?: true
    zoneId?: true
  }

  export type Location_zoneSumAggregateInputType = {
    id?: true
    locationId?: true
    zoneId?: true
  }

  export type Location_zoneMinAggregateInputType = {
    id?: true
    locationId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Location_zoneMaxAggregateInputType = {
    id?: true
    locationId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Location_zoneCountAggregateInputType = {
    id?: true
    locationId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Location_zoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which location_zone to aggregate.
     */
    where?: location_zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_zones to fetch.
     */
    orderBy?: location_zoneOrderByWithRelationInput | location_zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: location_zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned location_zones
    **/
    _count?: true | Location_zoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Location_zoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Location_zoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Location_zoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Location_zoneMaxAggregateInputType
  }

  export type GetLocation_zoneAggregateType<T extends Location_zoneAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation_zone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation_zone[P]>
      : GetScalarType<T[P], AggregateLocation_zone[P]>
  }




  export type location_zoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: location_zoneWhereInput
    orderBy?: location_zoneOrderByWithAggregationInput | location_zoneOrderByWithAggregationInput[]
    by: Location_zoneScalarFieldEnum[] | Location_zoneScalarFieldEnum
    having?: location_zoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Location_zoneCountAggregateInputType | true
    _avg?: Location_zoneAvgAggregateInputType
    _sum?: Location_zoneSumAggregateInputType
    _min?: Location_zoneMinAggregateInputType
    _max?: Location_zoneMaxAggregateInputType
  }

  export type Location_zoneGroupByOutputType = {
    id: number
    locationId: number
    zoneId: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Location_zoneCountAggregateOutputType | null
    _avg: Location_zoneAvgAggregateOutputType | null
    _sum: Location_zoneSumAggregateOutputType | null
    _min: Location_zoneMinAggregateOutputType | null
    _max: Location_zoneMaxAggregateOutputType | null
  }

  type GetLocation_zoneGroupByPayload<T extends location_zoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Location_zoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Location_zoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Location_zoneGroupByOutputType[P]>
            : GetScalarType<T[P], Location_zoneGroupByOutputType[P]>
        }
      >
    >


  export type location_zoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    location?: boolean | locationDefaultArgs<ExtArgs>
    zone?: boolean | zoneDefaultArgs<ExtArgs>
    pokemonRatingGames?: boolean | location_zone$pokemonRatingGamesArgs<ExtArgs>
    _count?: boolean | Location_zoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location_zone"]>



  export type location_zoneSelectScalar = {
    id?: boolean
    locationId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type location_zoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "zoneId" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["location_zone"]>
  export type location_zoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | locationDefaultArgs<ExtArgs>
    zone?: boolean | zoneDefaultArgs<ExtArgs>
    pokemonRatingGames?: boolean | location_zone$pokemonRatingGamesArgs<ExtArgs>
    _count?: boolean | Location_zoneCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $location_zonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "location_zone"
    objects: {
      location: Prisma.$locationPayload<ExtArgs>
      zone: Prisma.$zonePayload<ExtArgs>
      pokemonRatingGames: Prisma.$pokemon_game_locationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      locationId: number
      zoneId: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["location_zone"]>
    composites: {}
  }

  type location_zoneGetPayload<S extends boolean | null | undefined | location_zoneDefaultArgs> = $Result.GetResult<Prisma.$location_zonePayload, S>

  type location_zoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<location_zoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Location_zoneCountAggregateInputType | true
    }

  export interface location_zoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['location_zone'], meta: { name: 'location_zone' } }
    /**
     * Find zero or one Location_zone that matches the filter.
     * @param {location_zoneFindUniqueArgs} args - Arguments to find a Location_zone
     * @example
     * // Get one Location_zone
     * const location_zone = await prisma.location_zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends location_zoneFindUniqueArgs>(args: SelectSubset<T, location_zoneFindUniqueArgs<ExtArgs>>): Prisma__location_zoneClient<$Result.GetResult<Prisma.$location_zonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location_zone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {location_zoneFindUniqueOrThrowArgs} args - Arguments to find a Location_zone
     * @example
     * // Get one Location_zone
     * const location_zone = await prisma.location_zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends location_zoneFindUniqueOrThrowArgs>(args: SelectSubset<T, location_zoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__location_zoneClient<$Result.GetResult<Prisma.$location_zonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location_zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_zoneFindFirstArgs} args - Arguments to find a Location_zone
     * @example
     * // Get one Location_zone
     * const location_zone = await prisma.location_zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends location_zoneFindFirstArgs>(args?: SelectSubset<T, location_zoneFindFirstArgs<ExtArgs>>): Prisma__location_zoneClient<$Result.GetResult<Prisma.$location_zonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location_zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_zoneFindFirstOrThrowArgs} args - Arguments to find a Location_zone
     * @example
     * // Get one Location_zone
     * const location_zone = await prisma.location_zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends location_zoneFindFirstOrThrowArgs>(args?: SelectSubset<T, location_zoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__location_zoneClient<$Result.GetResult<Prisma.$location_zonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Location_zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_zoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Location_zones
     * const location_zones = await prisma.location_zone.findMany()
     * 
     * // Get first 10 Location_zones
     * const location_zones = await prisma.location_zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const location_zoneWithIdOnly = await prisma.location_zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends location_zoneFindManyArgs>(args?: SelectSubset<T, location_zoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$location_zonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location_zone.
     * @param {location_zoneCreateArgs} args - Arguments to create a Location_zone.
     * @example
     * // Create one Location_zone
     * const Location_zone = await prisma.location_zone.create({
     *   data: {
     *     // ... data to create a Location_zone
     *   }
     * })
     * 
     */
    create<T extends location_zoneCreateArgs>(args: SelectSubset<T, location_zoneCreateArgs<ExtArgs>>): Prisma__location_zoneClient<$Result.GetResult<Prisma.$location_zonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Location_zones.
     * @param {location_zoneCreateManyArgs} args - Arguments to create many Location_zones.
     * @example
     * // Create many Location_zones
     * const location_zone = await prisma.location_zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends location_zoneCreateManyArgs>(args?: SelectSubset<T, location_zoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Location_zone.
     * @param {location_zoneDeleteArgs} args - Arguments to delete one Location_zone.
     * @example
     * // Delete one Location_zone
     * const Location_zone = await prisma.location_zone.delete({
     *   where: {
     *     // ... filter to delete one Location_zone
     *   }
     * })
     * 
     */
    delete<T extends location_zoneDeleteArgs>(args: SelectSubset<T, location_zoneDeleteArgs<ExtArgs>>): Prisma__location_zoneClient<$Result.GetResult<Prisma.$location_zonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location_zone.
     * @param {location_zoneUpdateArgs} args - Arguments to update one Location_zone.
     * @example
     * // Update one Location_zone
     * const location_zone = await prisma.location_zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends location_zoneUpdateArgs>(args: SelectSubset<T, location_zoneUpdateArgs<ExtArgs>>): Prisma__location_zoneClient<$Result.GetResult<Prisma.$location_zonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Location_zones.
     * @param {location_zoneDeleteManyArgs} args - Arguments to filter Location_zones to delete.
     * @example
     * // Delete a few Location_zones
     * const { count } = await prisma.location_zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends location_zoneDeleteManyArgs>(args?: SelectSubset<T, location_zoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Location_zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_zoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Location_zones
     * const location_zone = await prisma.location_zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends location_zoneUpdateManyArgs>(args: SelectSubset<T, location_zoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location_zone.
     * @param {location_zoneUpsertArgs} args - Arguments to update or create a Location_zone.
     * @example
     * // Update or create a Location_zone
     * const location_zone = await prisma.location_zone.upsert({
     *   create: {
     *     // ... data to create a Location_zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location_zone we want to update
     *   }
     * })
     */
    upsert<T extends location_zoneUpsertArgs>(args: SelectSubset<T, location_zoneUpsertArgs<ExtArgs>>): Prisma__location_zoneClient<$Result.GetResult<Prisma.$location_zonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Location_zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_zoneCountArgs} args - Arguments to filter Location_zones to count.
     * @example
     * // Count the number of Location_zones
     * const count = await prisma.location_zone.count({
     *   where: {
     *     // ... the filter for the Location_zones we want to count
     *   }
     * })
    **/
    count<T extends location_zoneCountArgs>(
      args?: Subset<T, location_zoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Location_zoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location_zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Location_zoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Location_zoneAggregateArgs>(args: Subset<T, Location_zoneAggregateArgs>): Prisma.PrismaPromise<GetLocation_zoneAggregateType<T>>

    /**
     * Group by Location_zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_zoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends location_zoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: location_zoneGroupByArgs['orderBy'] }
        : { orderBy?: location_zoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, location_zoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocation_zoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the location_zone model
   */
  readonly fields: location_zoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for location_zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__location_zoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends locationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, locationDefaultArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    zone<T extends zoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, zoneDefaultArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemonRatingGames<T extends location_zone$pokemonRatingGamesArgs<ExtArgs> = {}>(args?: Subset<T, location_zone$pokemonRatingGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_game_locationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the location_zone model
   */
  interface location_zoneFieldRefs {
    readonly id: FieldRef<"location_zone", 'Int'>
    readonly locationId: FieldRef<"location_zone", 'Int'>
    readonly zoneId: FieldRef<"location_zone", 'Int'>
    readonly createdAt: FieldRef<"location_zone", 'DateTime'>
    readonly updatedAt: FieldRef<"location_zone", 'DateTime'>
    readonly status: FieldRef<"location_zone", 'String'>
  }
    

  // Custom InputTypes
  /**
   * location_zone findUnique
   */
  export type location_zoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_zone
     */
    select?: location_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location_zone
     */
    omit?: location_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_zoneInclude<ExtArgs> | null
    /**
     * Filter, which location_zone to fetch.
     */
    where: location_zoneWhereUniqueInput
  }

  /**
   * location_zone findUniqueOrThrow
   */
  export type location_zoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_zone
     */
    select?: location_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location_zone
     */
    omit?: location_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_zoneInclude<ExtArgs> | null
    /**
     * Filter, which location_zone to fetch.
     */
    where: location_zoneWhereUniqueInput
  }

  /**
   * location_zone findFirst
   */
  export type location_zoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_zone
     */
    select?: location_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location_zone
     */
    omit?: location_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_zoneInclude<ExtArgs> | null
    /**
     * Filter, which location_zone to fetch.
     */
    where?: location_zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_zones to fetch.
     */
    orderBy?: location_zoneOrderByWithRelationInput | location_zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for location_zones.
     */
    cursor?: location_zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of location_zones.
     */
    distinct?: Location_zoneScalarFieldEnum | Location_zoneScalarFieldEnum[]
  }

  /**
   * location_zone findFirstOrThrow
   */
  export type location_zoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_zone
     */
    select?: location_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location_zone
     */
    omit?: location_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_zoneInclude<ExtArgs> | null
    /**
     * Filter, which location_zone to fetch.
     */
    where?: location_zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_zones to fetch.
     */
    orderBy?: location_zoneOrderByWithRelationInput | location_zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for location_zones.
     */
    cursor?: location_zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of location_zones.
     */
    distinct?: Location_zoneScalarFieldEnum | Location_zoneScalarFieldEnum[]
  }

  /**
   * location_zone findMany
   */
  export type location_zoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_zone
     */
    select?: location_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location_zone
     */
    omit?: location_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_zoneInclude<ExtArgs> | null
    /**
     * Filter, which location_zones to fetch.
     */
    where?: location_zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_zones to fetch.
     */
    orderBy?: location_zoneOrderByWithRelationInput | location_zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing location_zones.
     */
    cursor?: location_zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_zones.
     */
    skip?: number
    distinct?: Location_zoneScalarFieldEnum | Location_zoneScalarFieldEnum[]
  }

  /**
   * location_zone create
   */
  export type location_zoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_zone
     */
    select?: location_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location_zone
     */
    omit?: location_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_zoneInclude<ExtArgs> | null
    /**
     * The data needed to create a location_zone.
     */
    data: XOR<location_zoneCreateInput, location_zoneUncheckedCreateInput>
  }

  /**
   * location_zone createMany
   */
  export type location_zoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many location_zones.
     */
    data: location_zoneCreateManyInput | location_zoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * location_zone update
   */
  export type location_zoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_zone
     */
    select?: location_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location_zone
     */
    omit?: location_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_zoneInclude<ExtArgs> | null
    /**
     * The data needed to update a location_zone.
     */
    data: XOR<location_zoneUpdateInput, location_zoneUncheckedUpdateInput>
    /**
     * Choose, which location_zone to update.
     */
    where: location_zoneWhereUniqueInput
  }

  /**
   * location_zone updateMany
   */
  export type location_zoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update location_zones.
     */
    data: XOR<location_zoneUpdateManyMutationInput, location_zoneUncheckedUpdateManyInput>
    /**
     * Filter which location_zones to update
     */
    where?: location_zoneWhereInput
    /**
     * Limit how many location_zones to update.
     */
    limit?: number
  }

  /**
   * location_zone upsert
   */
  export type location_zoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_zone
     */
    select?: location_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location_zone
     */
    omit?: location_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_zoneInclude<ExtArgs> | null
    /**
     * The filter to search for the location_zone to update in case it exists.
     */
    where: location_zoneWhereUniqueInput
    /**
     * In case the location_zone found by the `where` argument doesn't exist, create a new location_zone with this data.
     */
    create: XOR<location_zoneCreateInput, location_zoneUncheckedCreateInput>
    /**
     * In case the location_zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<location_zoneUpdateInput, location_zoneUncheckedUpdateInput>
  }

  /**
   * location_zone delete
   */
  export type location_zoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_zone
     */
    select?: location_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location_zone
     */
    omit?: location_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_zoneInclude<ExtArgs> | null
    /**
     * Filter which location_zone to delete.
     */
    where: location_zoneWhereUniqueInput
  }

  /**
   * location_zone deleteMany
   */
  export type location_zoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which location_zones to delete
     */
    where?: location_zoneWhereInput
    /**
     * Limit how many location_zones to delete.
     */
    limit?: number
  }

  /**
   * location_zone.pokemonRatingGames
   */
  export type location_zone$pokemonRatingGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
    where?: pokemon_game_locationWhereInput
    orderBy?: pokemon_game_locationOrderByWithRelationInput | pokemon_game_locationOrderByWithRelationInput[]
    cursor?: pokemon_game_locationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pokemon_game_locationScalarFieldEnum | Pokemon_game_locationScalarFieldEnum[]
  }

  /**
   * location_zone without action
   */
  export type location_zoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_zone
     */
    select?: location_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location_zone
     */
    omit?: location_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_zoneInclude<ExtArgs> | null
  }


  /**
   * Model meteo
   */

  export type AggregateMeteo = {
    _count: MeteoCountAggregateOutputType | null
    _avg: MeteoAvgAggregateOutputType | null
    _sum: MeteoSumAggregateOutputType | null
    _min: MeteoMinAggregateOutputType | null
    _max: MeteoMaxAggregateOutputType | null
  }

  export type MeteoAvgAggregateOutputType = {
    id: number | null
  }

  export type MeteoSumAggregateOutputType = {
    id: number | null
  }

  export type MeteoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type MeteoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type MeteoCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type MeteoAvgAggregateInputType = {
    id?: true
  }

  export type MeteoSumAggregateInputType = {
    id?: true
  }

  export type MeteoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type MeteoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type MeteoCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type MeteoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meteo to aggregate.
     */
    where?: meteoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meteos to fetch.
     */
    orderBy?: meteoOrderByWithRelationInput | meteoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: meteoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meteos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meteos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meteos
    **/
    _count?: true | MeteoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeteoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeteoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeteoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeteoMaxAggregateInputType
  }

  export type GetMeteoAggregateType<T extends MeteoAggregateArgs> = {
        [P in keyof T & keyof AggregateMeteo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeteo[P]>
      : GetScalarType<T[P], AggregateMeteo[P]>
  }




  export type meteoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meteoWhereInput
    orderBy?: meteoOrderByWithAggregationInput | meteoOrderByWithAggregationInput[]
    by: MeteoScalarFieldEnum[] | MeteoScalarFieldEnum
    having?: meteoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeteoCountAggregateInputType | true
    _avg?: MeteoAvgAggregateInputType
    _sum?: MeteoSumAggregateInputType
    _min?: MeteoMinAggregateInputType
    _max?: MeteoMaxAggregateInputType
  }

  export type MeteoGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: MeteoCountAggregateOutputType | null
    _avg: MeteoAvgAggregateOutputType | null
    _sum: MeteoSumAggregateOutputType | null
    _min: MeteoMinAggregateOutputType | null
    _max: MeteoMaxAggregateOutputType | null
  }

  type GetMeteoGroupByPayload<T extends meteoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeteoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeteoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeteoGroupByOutputType[P]>
            : GetScalarType<T[P], MeteoGroupByOutputType[P]>
        }
      >
    >


  export type meteoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    rates?: boolean | meteo$ratesArgs<ExtArgs>
    _count?: boolean | MeteoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meteo"]>



  export type meteoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type meteoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["meteo"]>
  export type meteoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rates?: boolean | meteo$ratesArgs<ExtArgs>
    _count?: boolean | MeteoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $meteoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "meteo"
    objects: {
      rates: Prisma.$ratePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["meteo"]>
    composites: {}
  }

  type meteoGetPayload<S extends boolean | null | undefined | meteoDefaultArgs> = $Result.GetResult<Prisma.$meteoPayload, S>

  type meteoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<meteoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeteoCountAggregateInputType | true
    }

  export interface meteoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meteo'], meta: { name: 'meteo' } }
    /**
     * Find zero or one Meteo that matches the filter.
     * @param {meteoFindUniqueArgs} args - Arguments to find a Meteo
     * @example
     * // Get one Meteo
     * const meteo = await prisma.meteo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends meteoFindUniqueArgs>(args: SelectSubset<T, meteoFindUniqueArgs<ExtArgs>>): Prisma__meteoClient<$Result.GetResult<Prisma.$meteoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Meteo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {meteoFindUniqueOrThrowArgs} args - Arguments to find a Meteo
     * @example
     * // Get one Meteo
     * const meteo = await prisma.meteo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends meteoFindUniqueOrThrowArgs>(args: SelectSubset<T, meteoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__meteoClient<$Result.GetResult<Prisma.$meteoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meteo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meteoFindFirstArgs} args - Arguments to find a Meteo
     * @example
     * // Get one Meteo
     * const meteo = await prisma.meteo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends meteoFindFirstArgs>(args?: SelectSubset<T, meteoFindFirstArgs<ExtArgs>>): Prisma__meteoClient<$Result.GetResult<Prisma.$meteoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meteo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meteoFindFirstOrThrowArgs} args - Arguments to find a Meteo
     * @example
     * // Get one Meteo
     * const meteo = await prisma.meteo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends meteoFindFirstOrThrowArgs>(args?: SelectSubset<T, meteoFindFirstOrThrowArgs<ExtArgs>>): Prisma__meteoClient<$Result.GetResult<Prisma.$meteoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Meteos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meteoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meteos
     * const meteos = await prisma.meteo.findMany()
     * 
     * // Get first 10 Meteos
     * const meteos = await prisma.meteo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meteoWithIdOnly = await prisma.meteo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends meteoFindManyArgs>(args?: SelectSubset<T, meteoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meteoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Meteo.
     * @param {meteoCreateArgs} args - Arguments to create a Meteo.
     * @example
     * // Create one Meteo
     * const Meteo = await prisma.meteo.create({
     *   data: {
     *     // ... data to create a Meteo
     *   }
     * })
     * 
     */
    create<T extends meteoCreateArgs>(args: SelectSubset<T, meteoCreateArgs<ExtArgs>>): Prisma__meteoClient<$Result.GetResult<Prisma.$meteoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Meteos.
     * @param {meteoCreateManyArgs} args - Arguments to create many Meteos.
     * @example
     * // Create many Meteos
     * const meteo = await prisma.meteo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends meteoCreateManyArgs>(args?: SelectSubset<T, meteoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meteo.
     * @param {meteoDeleteArgs} args - Arguments to delete one Meteo.
     * @example
     * // Delete one Meteo
     * const Meteo = await prisma.meteo.delete({
     *   where: {
     *     // ... filter to delete one Meteo
     *   }
     * })
     * 
     */
    delete<T extends meteoDeleteArgs>(args: SelectSubset<T, meteoDeleteArgs<ExtArgs>>): Prisma__meteoClient<$Result.GetResult<Prisma.$meteoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Meteo.
     * @param {meteoUpdateArgs} args - Arguments to update one Meteo.
     * @example
     * // Update one Meteo
     * const meteo = await prisma.meteo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends meteoUpdateArgs>(args: SelectSubset<T, meteoUpdateArgs<ExtArgs>>): Prisma__meteoClient<$Result.GetResult<Prisma.$meteoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Meteos.
     * @param {meteoDeleteManyArgs} args - Arguments to filter Meteos to delete.
     * @example
     * // Delete a few Meteos
     * const { count } = await prisma.meteo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends meteoDeleteManyArgs>(args?: SelectSubset<T, meteoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meteos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meteoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meteos
     * const meteo = await prisma.meteo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends meteoUpdateManyArgs>(args: SelectSubset<T, meteoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meteo.
     * @param {meteoUpsertArgs} args - Arguments to update or create a Meteo.
     * @example
     * // Update or create a Meteo
     * const meteo = await prisma.meteo.upsert({
     *   create: {
     *     // ... data to create a Meteo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meteo we want to update
     *   }
     * })
     */
    upsert<T extends meteoUpsertArgs>(args: SelectSubset<T, meteoUpsertArgs<ExtArgs>>): Prisma__meteoClient<$Result.GetResult<Prisma.$meteoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Meteos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meteoCountArgs} args - Arguments to filter Meteos to count.
     * @example
     * // Count the number of Meteos
     * const count = await prisma.meteo.count({
     *   where: {
     *     // ... the filter for the Meteos we want to count
     *   }
     * })
    **/
    count<T extends meteoCountArgs>(
      args?: Subset<T, meteoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeteoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meteo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeteoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeteoAggregateArgs>(args: Subset<T, MeteoAggregateArgs>): Prisma.PrismaPromise<GetMeteoAggregateType<T>>

    /**
     * Group by Meteo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meteoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends meteoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: meteoGroupByArgs['orderBy'] }
        : { orderBy?: meteoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, meteoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeteoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the meteo model
   */
  readonly fields: meteoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meteo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__meteoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rates<T extends meteo$ratesArgs<ExtArgs> = {}>(args?: Subset<T, meteo$ratesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the meteo model
   */
  interface meteoFieldRefs {
    readonly id: FieldRef<"meteo", 'Int'>
    readonly createdAt: FieldRef<"meteo", 'DateTime'>
    readonly updatedAt: FieldRef<"meteo", 'DateTime'>
    readonly status: FieldRef<"meteo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * meteo findUnique
   */
  export type meteoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meteo
     */
    select?: meteoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meteo
     */
    omit?: meteoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meteoInclude<ExtArgs> | null
    /**
     * Filter, which meteo to fetch.
     */
    where: meteoWhereUniqueInput
  }

  /**
   * meteo findUniqueOrThrow
   */
  export type meteoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meteo
     */
    select?: meteoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meteo
     */
    omit?: meteoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meteoInclude<ExtArgs> | null
    /**
     * Filter, which meteo to fetch.
     */
    where: meteoWhereUniqueInput
  }

  /**
   * meteo findFirst
   */
  export type meteoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meteo
     */
    select?: meteoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meteo
     */
    omit?: meteoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meteoInclude<ExtArgs> | null
    /**
     * Filter, which meteo to fetch.
     */
    where?: meteoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meteos to fetch.
     */
    orderBy?: meteoOrderByWithRelationInput | meteoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meteos.
     */
    cursor?: meteoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meteos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meteos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meteos.
     */
    distinct?: MeteoScalarFieldEnum | MeteoScalarFieldEnum[]
  }

  /**
   * meteo findFirstOrThrow
   */
  export type meteoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meteo
     */
    select?: meteoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meteo
     */
    omit?: meteoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meteoInclude<ExtArgs> | null
    /**
     * Filter, which meteo to fetch.
     */
    where?: meteoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meteos to fetch.
     */
    orderBy?: meteoOrderByWithRelationInput | meteoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meteos.
     */
    cursor?: meteoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meteos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meteos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meteos.
     */
    distinct?: MeteoScalarFieldEnum | MeteoScalarFieldEnum[]
  }

  /**
   * meteo findMany
   */
  export type meteoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meteo
     */
    select?: meteoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meteo
     */
    omit?: meteoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meteoInclude<ExtArgs> | null
    /**
     * Filter, which meteos to fetch.
     */
    where?: meteoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meteos to fetch.
     */
    orderBy?: meteoOrderByWithRelationInput | meteoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meteos.
     */
    cursor?: meteoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meteos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meteos.
     */
    skip?: number
    distinct?: MeteoScalarFieldEnum | MeteoScalarFieldEnum[]
  }

  /**
   * meteo create
   */
  export type meteoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meteo
     */
    select?: meteoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meteo
     */
    omit?: meteoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meteoInclude<ExtArgs> | null
    /**
     * The data needed to create a meteo.
     */
    data?: XOR<meteoCreateInput, meteoUncheckedCreateInput>
  }

  /**
   * meteo createMany
   */
  export type meteoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meteos.
     */
    data: meteoCreateManyInput | meteoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * meteo update
   */
  export type meteoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meteo
     */
    select?: meteoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meteo
     */
    omit?: meteoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meteoInclude<ExtArgs> | null
    /**
     * The data needed to update a meteo.
     */
    data: XOR<meteoUpdateInput, meteoUncheckedUpdateInput>
    /**
     * Choose, which meteo to update.
     */
    where: meteoWhereUniqueInput
  }

  /**
   * meteo updateMany
   */
  export type meteoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meteos.
     */
    data: XOR<meteoUpdateManyMutationInput, meteoUncheckedUpdateManyInput>
    /**
     * Filter which meteos to update
     */
    where?: meteoWhereInput
    /**
     * Limit how many meteos to update.
     */
    limit?: number
  }

  /**
   * meteo upsert
   */
  export type meteoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meteo
     */
    select?: meteoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meteo
     */
    omit?: meteoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meteoInclude<ExtArgs> | null
    /**
     * The filter to search for the meteo to update in case it exists.
     */
    where: meteoWhereUniqueInput
    /**
     * In case the meteo found by the `where` argument doesn't exist, create a new meteo with this data.
     */
    create: XOR<meteoCreateInput, meteoUncheckedCreateInput>
    /**
     * In case the meteo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<meteoUpdateInput, meteoUncheckedUpdateInput>
  }

  /**
   * meteo delete
   */
  export type meteoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meteo
     */
    select?: meteoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meteo
     */
    omit?: meteoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meteoInclude<ExtArgs> | null
    /**
     * Filter which meteo to delete.
     */
    where: meteoWhereUniqueInput
  }

  /**
   * meteo deleteMany
   */
  export type meteoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meteos to delete
     */
    where?: meteoWhereInput
    /**
     * Limit how many meteos to delete.
     */
    limit?: number
  }

  /**
   * meteo.rates
   */
  export type meteo$ratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate
     */
    select?: rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate
     */
    omit?: rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rateInclude<ExtArgs> | null
    where?: rateWhereInput
    orderBy?: rateOrderByWithRelationInput | rateOrderByWithRelationInput[]
    cursor?: rateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RateScalarFieldEnum | RateScalarFieldEnum[]
  }

  /**
   * meteo without action
   */
  export type meteoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meteo
     */
    select?: meteoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meteo
     */
    omit?: meteoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meteoInclude<ExtArgs> | null
  }


  /**
   * Model pokemon_obtation
   */

  export type AggregatePokemon_obtation = {
    _count: Pokemon_obtationCountAggregateOutputType | null
    _avg: Pokemon_obtationAvgAggregateOutputType | null
    _sum: Pokemon_obtationSumAggregateOutputType | null
    _min: Pokemon_obtationMinAggregateOutputType | null
    _max: Pokemon_obtationMaxAggregateOutputType | null
  }

  export type Pokemon_obtationAvgAggregateOutputType = {
    id: number | null
  }

  export type Pokemon_obtationSumAggregateOutputType = {
    id: number | null
  }

  export type Pokemon_obtationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Pokemon_obtationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Pokemon_obtationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Pokemon_obtationAvgAggregateInputType = {
    id?: true
  }

  export type Pokemon_obtationSumAggregateInputType = {
    id?: true
  }

  export type Pokemon_obtationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Pokemon_obtationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Pokemon_obtationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Pokemon_obtationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokemon_obtation to aggregate.
     */
    where?: pokemon_obtationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_obtations to fetch.
     */
    orderBy?: pokemon_obtationOrderByWithRelationInput | pokemon_obtationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pokemon_obtationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_obtations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_obtations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pokemon_obtations
    **/
    _count?: true | Pokemon_obtationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pokemon_obtationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pokemon_obtationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pokemon_obtationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pokemon_obtationMaxAggregateInputType
  }

  export type GetPokemon_obtationAggregateType<T extends Pokemon_obtationAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemon_obtation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemon_obtation[P]>
      : GetScalarType<T[P], AggregatePokemon_obtation[P]>
  }




  export type pokemon_obtationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_obtationWhereInput
    orderBy?: pokemon_obtationOrderByWithAggregationInput | pokemon_obtationOrderByWithAggregationInput[]
    by: Pokemon_obtationScalarFieldEnum[] | Pokemon_obtationScalarFieldEnum
    having?: pokemon_obtationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pokemon_obtationCountAggregateInputType | true
    _avg?: Pokemon_obtationAvgAggregateInputType
    _sum?: Pokemon_obtationSumAggregateInputType
    _min?: Pokemon_obtationMinAggregateInputType
    _max?: Pokemon_obtationMaxAggregateInputType
  }

  export type Pokemon_obtationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Pokemon_obtationCountAggregateOutputType | null
    _avg: Pokemon_obtationAvgAggregateOutputType | null
    _sum: Pokemon_obtationSumAggregateOutputType | null
    _min: Pokemon_obtationMinAggregateOutputType | null
    _max: Pokemon_obtationMaxAggregateOutputType | null
  }

  type GetPokemon_obtationGroupByPayload<T extends pokemon_obtationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pokemon_obtationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pokemon_obtationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pokemon_obtationGroupByOutputType[P]>
            : GetScalarType<T[P], Pokemon_obtationGroupByOutputType[P]>
        }
      >
    >


  export type pokemon_obtationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    pokemonRatingGames?: boolean | pokemon_obtation$pokemonRatingGamesArgs<ExtArgs>
    _count?: boolean | Pokemon_obtationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemon_obtation"]>



  export type pokemon_obtationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type pokemon_obtationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["pokemon_obtation"]>
  export type pokemon_obtationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemonRatingGames?: boolean | pokemon_obtation$pokemonRatingGamesArgs<ExtArgs>
    _count?: boolean | Pokemon_obtationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $pokemon_obtationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pokemon_obtation"
    objects: {
      pokemonRatingGames: Prisma.$pokemon_game_locationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["pokemon_obtation"]>
    composites: {}
  }

  type pokemon_obtationGetPayload<S extends boolean | null | undefined | pokemon_obtationDefaultArgs> = $Result.GetResult<Prisma.$pokemon_obtationPayload, S>

  type pokemon_obtationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pokemon_obtationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pokemon_obtationCountAggregateInputType | true
    }

  export interface pokemon_obtationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pokemon_obtation'], meta: { name: 'pokemon_obtation' } }
    /**
     * Find zero or one Pokemon_obtation that matches the filter.
     * @param {pokemon_obtationFindUniqueArgs} args - Arguments to find a Pokemon_obtation
     * @example
     * // Get one Pokemon_obtation
     * const pokemon_obtation = await prisma.pokemon_obtation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pokemon_obtationFindUniqueArgs>(args: SelectSubset<T, pokemon_obtationFindUniqueArgs<ExtArgs>>): Prisma__pokemon_obtationClient<$Result.GetResult<Prisma.$pokemon_obtationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pokemon_obtation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pokemon_obtationFindUniqueOrThrowArgs} args - Arguments to find a Pokemon_obtation
     * @example
     * // Get one Pokemon_obtation
     * const pokemon_obtation = await prisma.pokemon_obtation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pokemon_obtationFindUniqueOrThrowArgs>(args: SelectSubset<T, pokemon_obtationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pokemon_obtationClient<$Result.GetResult<Prisma.$pokemon_obtationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon_obtation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_obtationFindFirstArgs} args - Arguments to find a Pokemon_obtation
     * @example
     * // Get one Pokemon_obtation
     * const pokemon_obtation = await prisma.pokemon_obtation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pokemon_obtationFindFirstArgs>(args?: SelectSubset<T, pokemon_obtationFindFirstArgs<ExtArgs>>): Prisma__pokemon_obtationClient<$Result.GetResult<Prisma.$pokemon_obtationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon_obtation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_obtationFindFirstOrThrowArgs} args - Arguments to find a Pokemon_obtation
     * @example
     * // Get one Pokemon_obtation
     * const pokemon_obtation = await prisma.pokemon_obtation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pokemon_obtationFindFirstOrThrowArgs>(args?: SelectSubset<T, pokemon_obtationFindFirstOrThrowArgs<ExtArgs>>): Prisma__pokemon_obtationClient<$Result.GetResult<Prisma.$pokemon_obtationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pokemon_obtations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_obtationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pokemon_obtations
     * const pokemon_obtations = await prisma.pokemon_obtation.findMany()
     * 
     * // Get first 10 Pokemon_obtations
     * const pokemon_obtations = await prisma.pokemon_obtation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokemon_obtationWithIdOnly = await prisma.pokemon_obtation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pokemon_obtationFindManyArgs>(args?: SelectSubset<T, pokemon_obtationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_obtationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pokemon_obtation.
     * @param {pokemon_obtationCreateArgs} args - Arguments to create a Pokemon_obtation.
     * @example
     * // Create one Pokemon_obtation
     * const Pokemon_obtation = await prisma.pokemon_obtation.create({
     *   data: {
     *     // ... data to create a Pokemon_obtation
     *   }
     * })
     * 
     */
    create<T extends pokemon_obtationCreateArgs>(args: SelectSubset<T, pokemon_obtationCreateArgs<ExtArgs>>): Prisma__pokemon_obtationClient<$Result.GetResult<Prisma.$pokemon_obtationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pokemon_obtations.
     * @param {pokemon_obtationCreateManyArgs} args - Arguments to create many Pokemon_obtations.
     * @example
     * // Create many Pokemon_obtations
     * const pokemon_obtation = await prisma.pokemon_obtation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pokemon_obtationCreateManyArgs>(args?: SelectSubset<T, pokemon_obtationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pokemon_obtation.
     * @param {pokemon_obtationDeleteArgs} args - Arguments to delete one Pokemon_obtation.
     * @example
     * // Delete one Pokemon_obtation
     * const Pokemon_obtation = await prisma.pokemon_obtation.delete({
     *   where: {
     *     // ... filter to delete one Pokemon_obtation
     *   }
     * })
     * 
     */
    delete<T extends pokemon_obtationDeleteArgs>(args: SelectSubset<T, pokemon_obtationDeleteArgs<ExtArgs>>): Prisma__pokemon_obtationClient<$Result.GetResult<Prisma.$pokemon_obtationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pokemon_obtation.
     * @param {pokemon_obtationUpdateArgs} args - Arguments to update one Pokemon_obtation.
     * @example
     * // Update one Pokemon_obtation
     * const pokemon_obtation = await prisma.pokemon_obtation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pokemon_obtationUpdateArgs>(args: SelectSubset<T, pokemon_obtationUpdateArgs<ExtArgs>>): Prisma__pokemon_obtationClient<$Result.GetResult<Prisma.$pokemon_obtationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pokemon_obtations.
     * @param {pokemon_obtationDeleteManyArgs} args - Arguments to filter Pokemon_obtations to delete.
     * @example
     * // Delete a few Pokemon_obtations
     * const { count } = await prisma.pokemon_obtation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pokemon_obtationDeleteManyArgs>(args?: SelectSubset<T, pokemon_obtationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pokemon_obtations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_obtationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pokemon_obtations
     * const pokemon_obtation = await prisma.pokemon_obtation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pokemon_obtationUpdateManyArgs>(args: SelectSubset<T, pokemon_obtationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pokemon_obtation.
     * @param {pokemon_obtationUpsertArgs} args - Arguments to update or create a Pokemon_obtation.
     * @example
     * // Update or create a Pokemon_obtation
     * const pokemon_obtation = await prisma.pokemon_obtation.upsert({
     *   create: {
     *     // ... data to create a Pokemon_obtation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pokemon_obtation we want to update
     *   }
     * })
     */
    upsert<T extends pokemon_obtationUpsertArgs>(args: SelectSubset<T, pokemon_obtationUpsertArgs<ExtArgs>>): Prisma__pokemon_obtationClient<$Result.GetResult<Prisma.$pokemon_obtationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pokemon_obtations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_obtationCountArgs} args - Arguments to filter Pokemon_obtations to count.
     * @example
     * // Count the number of Pokemon_obtations
     * const count = await prisma.pokemon_obtation.count({
     *   where: {
     *     // ... the filter for the Pokemon_obtations we want to count
     *   }
     * })
    **/
    count<T extends pokemon_obtationCountArgs>(
      args?: Subset<T, pokemon_obtationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pokemon_obtationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pokemon_obtation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pokemon_obtationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pokemon_obtationAggregateArgs>(args: Subset<T, Pokemon_obtationAggregateArgs>): Prisma.PrismaPromise<GetPokemon_obtationAggregateType<T>>

    /**
     * Group by Pokemon_obtation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_obtationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pokemon_obtationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pokemon_obtationGroupByArgs['orderBy'] }
        : { orderBy?: pokemon_obtationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pokemon_obtationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemon_obtationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pokemon_obtation model
   */
  readonly fields: pokemon_obtationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pokemon_obtation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pokemon_obtationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pokemonRatingGames<T extends pokemon_obtation$pokemonRatingGamesArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_obtation$pokemonRatingGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_game_locationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pokemon_obtation model
   */
  interface pokemon_obtationFieldRefs {
    readonly id: FieldRef<"pokemon_obtation", 'Int'>
    readonly createdAt: FieldRef<"pokemon_obtation", 'DateTime'>
    readonly updatedAt: FieldRef<"pokemon_obtation", 'DateTime'>
    readonly status: FieldRef<"pokemon_obtation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pokemon_obtation findUnique
   */
  export type pokemon_obtationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_obtation
     */
    select?: pokemon_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_obtation
     */
    omit?: pokemon_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_obtationInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_obtation to fetch.
     */
    where: pokemon_obtationWhereUniqueInput
  }

  /**
   * pokemon_obtation findUniqueOrThrow
   */
  export type pokemon_obtationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_obtation
     */
    select?: pokemon_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_obtation
     */
    omit?: pokemon_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_obtationInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_obtation to fetch.
     */
    where: pokemon_obtationWhereUniqueInput
  }

  /**
   * pokemon_obtation findFirst
   */
  export type pokemon_obtationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_obtation
     */
    select?: pokemon_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_obtation
     */
    omit?: pokemon_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_obtationInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_obtation to fetch.
     */
    where?: pokemon_obtationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_obtations to fetch.
     */
    orderBy?: pokemon_obtationOrderByWithRelationInput | pokemon_obtationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokemon_obtations.
     */
    cursor?: pokemon_obtationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_obtations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_obtations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokemon_obtations.
     */
    distinct?: Pokemon_obtationScalarFieldEnum | Pokemon_obtationScalarFieldEnum[]
  }

  /**
   * pokemon_obtation findFirstOrThrow
   */
  export type pokemon_obtationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_obtation
     */
    select?: pokemon_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_obtation
     */
    omit?: pokemon_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_obtationInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_obtation to fetch.
     */
    where?: pokemon_obtationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_obtations to fetch.
     */
    orderBy?: pokemon_obtationOrderByWithRelationInput | pokemon_obtationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokemon_obtations.
     */
    cursor?: pokemon_obtationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_obtations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_obtations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokemon_obtations.
     */
    distinct?: Pokemon_obtationScalarFieldEnum | Pokemon_obtationScalarFieldEnum[]
  }

  /**
   * pokemon_obtation findMany
   */
  export type pokemon_obtationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_obtation
     */
    select?: pokemon_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_obtation
     */
    omit?: pokemon_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_obtationInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_obtations to fetch.
     */
    where?: pokemon_obtationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_obtations to fetch.
     */
    orderBy?: pokemon_obtationOrderByWithRelationInput | pokemon_obtationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pokemon_obtations.
     */
    cursor?: pokemon_obtationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_obtations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_obtations.
     */
    skip?: number
    distinct?: Pokemon_obtationScalarFieldEnum | Pokemon_obtationScalarFieldEnum[]
  }

  /**
   * pokemon_obtation create
   */
  export type pokemon_obtationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_obtation
     */
    select?: pokemon_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_obtation
     */
    omit?: pokemon_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_obtationInclude<ExtArgs> | null
    /**
     * The data needed to create a pokemon_obtation.
     */
    data?: XOR<pokemon_obtationCreateInput, pokemon_obtationUncheckedCreateInput>
  }

  /**
   * pokemon_obtation createMany
   */
  export type pokemon_obtationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pokemon_obtations.
     */
    data: pokemon_obtationCreateManyInput | pokemon_obtationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pokemon_obtation update
   */
  export type pokemon_obtationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_obtation
     */
    select?: pokemon_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_obtation
     */
    omit?: pokemon_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_obtationInclude<ExtArgs> | null
    /**
     * The data needed to update a pokemon_obtation.
     */
    data: XOR<pokemon_obtationUpdateInput, pokemon_obtationUncheckedUpdateInput>
    /**
     * Choose, which pokemon_obtation to update.
     */
    where: pokemon_obtationWhereUniqueInput
  }

  /**
   * pokemon_obtation updateMany
   */
  export type pokemon_obtationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pokemon_obtations.
     */
    data: XOR<pokemon_obtationUpdateManyMutationInput, pokemon_obtationUncheckedUpdateManyInput>
    /**
     * Filter which pokemon_obtations to update
     */
    where?: pokemon_obtationWhereInput
    /**
     * Limit how many pokemon_obtations to update.
     */
    limit?: number
  }

  /**
   * pokemon_obtation upsert
   */
  export type pokemon_obtationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_obtation
     */
    select?: pokemon_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_obtation
     */
    omit?: pokemon_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_obtationInclude<ExtArgs> | null
    /**
     * The filter to search for the pokemon_obtation to update in case it exists.
     */
    where: pokemon_obtationWhereUniqueInput
    /**
     * In case the pokemon_obtation found by the `where` argument doesn't exist, create a new pokemon_obtation with this data.
     */
    create: XOR<pokemon_obtationCreateInput, pokemon_obtationUncheckedCreateInput>
    /**
     * In case the pokemon_obtation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pokemon_obtationUpdateInput, pokemon_obtationUncheckedUpdateInput>
  }

  /**
   * pokemon_obtation delete
   */
  export type pokemon_obtationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_obtation
     */
    select?: pokemon_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_obtation
     */
    omit?: pokemon_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_obtationInclude<ExtArgs> | null
    /**
     * Filter which pokemon_obtation to delete.
     */
    where: pokemon_obtationWhereUniqueInput
  }

  /**
   * pokemon_obtation deleteMany
   */
  export type pokemon_obtationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokemon_obtations to delete
     */
    where?: pokemon_obtationWhereInput
    /**
     * Limit how many pokemon_obtations to delete.
     */
    limit?: number
  }

  /**
   * pokemon_obtation.pokemonRatingGames
   */
  export type pokemon_obtation$pokemonRatingGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
    where?: pokemon_game_locationWhereInput
    orderBy?: pokemon_game_locationOrderByWithRelationInput | pokemon_game_locationOrderByWithRelationInput[]
    cursor?: pokemon_game_locationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pokemon_game_locationScalarFieldEnum | Pokemon_game_locationScalarFieldEnum[]
  }

  /**
   * pokemon_obtation without action
   */
  export type pokemon_obtationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_obtation
     */
    select?: pokemon_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_obtation
     */
    omit?: pokemon_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_obtationInclude<ExtArgs> | null
  }


  /**
   * Model rate
   */

  export type AggregateRate = {
    _count: RateCountAggregateOutputType | null
    _avg: RateAvgAggregateOutputType | null
    _sum: RateSumAggregateOutputType | null
    _min: RateMinAggregateOutputType | null
    _max: RateMaxAggregateOutputType | null
  }

  export type RateAvgAggregateOutputType = {
    id: number | null
    rate: Decimal | null
    minLevel: number | null
    maxLevel: number | null
    limit: number | null
    meteoId: number | null
    detailRateId: number | null
    conditionRateId: number | null
  }

  export type RateSumAggregateOutputType = {
    id: number | null
    rate: Decimal | null
    minLevel: number | null
    maxLevel: number | null
    limit: number | null
    meteoId: number | null
    detailRateId: number | null
    conditionRateId: number | null
  }

  export type RateMinAggregateOutputType = {
    id: number | null
    rate: Decimal | null
    minLevel: number | null
    maxLevel: number | null
    limit: number | null
    meteoId: number | null
    detailRateId: number | null
    conditionRateId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    isAlpha: boolean | null
  }

  export type RateMaxAggregateOutputType = {
    id: number | null
    rate: Decimal | null
    minLevel: number | null
    maxLevel: number | null
    limit: number | null
    meteoId: number | null
    detailRateId: number | null
    conditionRateId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    isAlpha: boolean | null
  }

  export type RateCountAggregateOutputType = {
    id: number
    rate: number
    minLevel: number
    maxLevel: number
    limit: number
    meteoId: number
    detailRateId: number
    conditionRateId: number
    createdAt: number
    updatedAt: number
    status: number
    isAlpha: number
    _all: number
  }


  export type RateAvgAggregateInputType = {
    id?: true
    rate?: true
    minLevel?: true
    maxLevel?: true
    limit?: true
    meteoId?: true
    detailRateId?: true
    conditionRateId?: true
  }

  export type RateSumAggregateInputType = {
    id?: true
    rate?: true
    minLevel?: true
    maxLevel?: true
    limit?: true
    meteoId?: true
    detailRateId?: true
    conditionRateId?: true
  }

  export type RateMinAggregateInputType = {
    id?: true
    rate?: true
    minLevel?: true
    maxLevel?: true
    limit?: true
    meteoId?: true
    detailRateId?: true
    conditionRateId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    isAlpha?: true
  }

  export type RateMaxAggregateInputType = {
    id?: true
    rate?: true
    minLevel?: true
    maxLevel?: true
    limit?: true
    meteoId?: true
    detailRateId?: true
    conditionRateId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    isAlpha?: true
  }

  export type RateCountAggregateInputType = {
    id?: true
    rate?: true
    minLevel?: true
    maxLevel?: true
    limit?: true
    meteoId?: true
    detailRateId?: true
    conditionRateId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    isAlpha?: true
    _all?: true
  }

  export type RateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rate to aggregate.
     */
    where?: rateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rates to fetch.
     */
    orderBy?: rateOrderByWithRelationInput | rateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rates
    **/
    _count?: true | RateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RateMaxAggregateInputType
  }

  export type GetRateAggregateType<T extends RateAggregateArgs> = {
        [P in keyof T & keyof AggregateRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRate[P]>
      : GetScalarType<T[P], AggregateRate[P]>
  }




  export type rateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rateWhereInput
    orderBy?: rateOrderByWithAggregationInput | rateOrderByWithAggregationInput[]
    by: RateScalarFieldEnum[] | RateScalarFieldEnum
    having?: rateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RateCountAggregateInputType | true
    _avg?: RateAvgAggregateInputType
    _sum?: RateSumAggregateInputType
    _min?: RateMinAggregateInputType
    _max?: RateMaxAggregateInputType
  }

  export type RateGroupByOutputType = {
    id: number
    rate: Decimal
    minLevel: number
    maxLevel: number
    limit: number | null
    meteoId: number
    detailRateId: number
    conditionRateId: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    isAlpha: boolean
    _count: RateCountAggregateOutputType | null
    _avg: RateAvgAggregateOutputType | null
    _sum: RateSumAggregateOutputType | null
    _min: RateMinAggregateOutputType | null
    _max: RateMaxAggregateOutputType | null
  }

  type GetRateGroupByPayload<T extends rateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RateGroupByOutputType[P]>
            : GetScalarType<T[P], RateGroupByOutputType[P]>
        }
      >
    >


  export type rateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rate?: boolean
    minLevel?: boolean
    maxLevel?: boolean
    limit?: boolean
    meteoId?: boolean
    detailRateId?: boolean
    conditionRateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    isAlpha?: boolean
    pokemonRatingGames?: boolean | rate$pokemonRatingGamesArgs<ExtArgs>
    conditionRate?: boolean | detailDefaultArgs<ExtArgs>
    detailRate?: boolean | detailDefaultArgs<ExtArgs>
    meteo?: boolean | meteoDefaultArgs<ExtArgs>
    shinyHuntingMethodRates?: boolean | rate$shinyHuntingMethodRatesArgs<ExtArgs>
    _count?: boolean | RateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rate"]>



  export type rateSelectScalar = {
    id?: boolean
    rate?: boolean
    minLevel?: boolean
    maxLevel?: boolean
    limit?: boolean
    meteoId?: boolean
    detailRateId?: boolean
    conditionRateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    isAlpha?: boolean
  }

  export type rateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rate" | "minLevel" | "maxLevel" | "limit" | "meteoId" | "detailRateId" | "conditionRateId" | "createdAt" | "updatedAt" | "status" | "isAlpha", ExtArgs["result"]["rate"]>
  export type rateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemonRatingGames?: boolean | rate$pokemonRatingGamesArgs<ExtArgs>
    conditionRate?: boolean | detailDefaultArgs<ExtArgs>
    detailRate?: boolean | detailDefaultArgs<ExtArgs>
    meteo?: boolean | meteoDefaultArgs<ExtArgs>
    shinyHuntingMethodRates?: boolean | rate$shinyHuntingMethodRatesArgs<ExtArgs>
    _count?: boolean | RateCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ratePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rate"
    objects: {
      pokemonRatingGames: Prisma.$pokemon_game_locationPayload<ExtArgs>[]
      conditionRate: Prisma.$detailPayload<ExtArgs>
      detailRate: Prisma.$detailPayload<ExtArgs>
      meteo: Prisma.$meteoPayload<ExtArgs>
      shinyHuntingMethodRates: Prisma.$shiny_hunting_method_ratePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rate: Prisma.Decimal
      minLevel: number
      maxLevel: number
      limit: number | null
      meteoId: number
      detailRateId: number
      conditionRateId: number
      createdAt: Date
      updatedAt: Date | null
      status: string
      isAlpha: boolean
    }, ExtArgs["result"]["rate"]>
    composites: {}
  }

  type rateGetPayload<S extends boolean | null | undefined | rateDefaultArgs> = $Result.GetResult<Prisma.$ratePayload, S>

  type rateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RateCountAggregateInputType | true
    }

  export interface rateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rate'], meta: { name: 'rate' } }
    /**
     * Find zero or one Rate that matches the filter.
     * @param {rateFindUniqueArgs} args - Arguments to find a Rate
     * @example
     * // Get one Rate
     * const rate = await prisma.rate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rateFindUniqueArgs>(args: SelectSubset<T, rateFindUniqueArgs<ExtArgs>>): Prisma__rateClient<$Result.GetResult<Prisma.$ratePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rateFindUniqueOrThrowArgs} args - Arguments to find a Rate
     * @example
     * // Get one Rate
     * const rate = await prisma.rate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rateFindUniqueOrThrowArgs>(args: SelectSubset<T, rateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rateClient<$Result.GetResult<Prisma.$ratePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rateFindFirstArgs} args - Arguments to find a Rate
     * @example
     * // Get one Rate
     * const rate = await prisma.rate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rateFindFirstArgs>(args?: SelectSubset<T, rateFindFirstArgs<ExtArgs>>): Prisma__rateClient<$Result.GetResult<Prisma.$ratePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rateFindFirstOrThrowArgs} args - Arguments to find a Rate
     * @example
     * // Get one Rate
     * const rate = await prisma.rate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rateFindFirstOrThrowArgs>(args?: SelectSubset<T, rateFindFirstOrThrowArgs<ExtArgs>>): Prisma__rateClient<$Result.GetResult<Prisma.$ratePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rates
     * const rates = await prisma.rate.findMany()
     * 
     * // Get first 10 Rates
     * const rates = await prisma.rate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rateWithIdOnly = await prisma.rate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rateFindManyArgs>(args?: SelectSubset<T, rateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rate.
     * @param {rateCreateArgs} args - Arguments to create a Rate.
     * @example
     * // Create one Rate
     * const Rate = await prisma.rate.create({
     *   data: {
     *     // ... data to create a Rate
     *   }
     * })
     * 
     */
    create<T extends rateCreateArgs>(args: SelectSubset<T, rateCreateArgs<ExtArgs>>): Prisma__rateClient<$Result.GetResult<Prisma.$ratePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rates.
     * @param {rateCreateManyArgs} args - Arguments to create many Rates.
     * @example
     * // Create many Rates
     * const rate = await prisma.rate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rateCreateManyArgs>(args?: SelectSubset<T, rateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rate.
     * @param {rateDeleteArgs} args - Arguments to delete one Rate.
     * @example
     * // Delete one Rate
     * const Rate = await prisma.rate.delete({
     *   where: {
     *     // ... filter to delete one Rate
     *   }
     * })
     * 
     */
    delete<T extends rateDeleteArgs>(args: SelectSubset<T, rateDeleteArgs<ExtArgs>>): Prisma__rateClient<$Result.GetResult<Prisma.$ratePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rate.
     * @param {rateUpdateArgs} args - Arguments to update one Rate.
     * @example
     * // Update one Rate
     * const rate = await prisma.rate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rateUpdateArgs>(args: SelectSubset<T, rateUpdateArgs<ExtArgs>>): Prisma__rateClient<$Result.GetResult<Prisma.$ratePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rates.
     * @param {rateDeleteManyArgs} args - Arguments to filter Rates to delete.
     * @example
     * // Delete a few Rates
     * const { count } = await prisma.rate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rateDeleteManyArgs>(args?: SelectSubset<T, rateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rates
     * const rate = await prisma.rate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rateUpdateManyArgs>(args: SelectSubset<T, rateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rate.
     * @param {rateUpsertArgs} args - Arguments to update or create a Rate.
     * @example
     * // Update or create a Rate
     * const rate = await prisma.rate.upsert({
     *   create: {
     *     // ... data to create a Rate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rate we want to update
     *   }
     * })
     */
    upsert<T extends rateUpsertArgs>(args: SelectSubset<T, rateUpsertArgs<ExtArgs>>): Prisma__rateClient<$Result.GetResult<Prisma.$ratePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rateCountArgs} args - Arguments to filter Rates to count.
     * @example
     * // Count the number of Rates
     * const count = await prisma.rate.count({
     *   where: {
     *     // ... the filter for the Rates we want to count
     *   }
     * })
    **/
    count<T extends rateCountArgs>(
      args?: Subset<T, rateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RateAggregateArgs>(args: Subset<T, RateAggregateArgs>): Prisma.PrismaPromise<GetRateAggregateType<T>>

    /**
     * Group by Rate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rateGroupByArgs['orderBy'] }
        : { orderBy?: rateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rate model
   */
  readonly fields: rateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pokemonRatingGames<T extends rate$pokemonRatingGamesArgs<ExtArgs> = {}>(args?: Subset<T, rate$pokemonRatingGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_game_locationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conditionRate<T extends detailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, detailDefaultArgs<ExtArgs>>): Prisma__detailClient<$Result.GetResult<Prisma.$detailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    detailRate<T extends detailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, detailDefaultArgs<ExtArgs>>): Prisma__detailClient<$Result.GetResult<Prisma.$detailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    meteo<T extends meteoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, meteoDefaultArgs<ExtArgs>>): Prisma__meteoClient<$Result.GetResult<Prisma.$meteoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shinyHuntingMethodRates<T extends rate$shinyHuntingMethodRatesArgs<ExtArgs> = {}>(args?: Subset<T, rate$shinyHuntingMethodRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shiny_hunting_method_ratePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rate model
   */
  interface rateFieldRefs {
    readonly id: FieldRef<"rate", 'Int'>
    readonly rate: FieldRef<"rate", 'Decimal'>
    readonly minLevel: FieldRef<"rate", 'Int'>
    readonly maxLevel: FieldRef<"rate", 'Int'>
    readonly limit: FieldRef<"rate", 'Int'>
    readonly meteoId: FieldRef<"rate", 'Int'>
    readonly detailRateId: FieldRef<"rate", 'Int'>
    readonly conditionRateId: FieldRef<"rate", 'Int'>
    readonly createdAt: FieldRef<"rate", 'DateTime'>
    readonly updatedAt: FieldRef<"rate", 'DateTime'>
    readonly status: FieldRef<"rate", 'String'>
    readonly isAlpha: FieldRef<"rate", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * rate findUnique
   */
  export type rateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate
     */
    select?: rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate
     */
    omit?: rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rateInclude<ExtArgs> | null
    /**
     * Filter, which rate to fetch.
     */
    where: rateWhereUniqueInput
  }

  /**
   * rate findUniqueOrThrow
   */
  export type rateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate
     */
    select?: rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate
     */
    omit?: rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rateInclude<ExtArgs> | null
    /**
     * Filter, which rate to fetch.
     */
    where: rateWhereUniqueInput
  }

  /**
   * rate findFirst
   */
  export type rateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate
     */
    select?: rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate
     */
    omit?: rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rateInclude<ExtArgs> | null
    /**
     * Filter, which rate to fetch.
     */
    where?: rateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rates to fetch.
     */
    orderBy?: rateOrderByWithRelationInput | rateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rates.
     */
    cursor?: rateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rates.
     */
    distinct?: RateScalarFieldEnum | RateScalarFieldEnum[]
  }

  /**
   * rate findFirstOrThrow
   */
  export type rateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate
     */
    select?: rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate
     */
    omit?: rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rateInclude<ExtArgs> | null
    /**
     * Filter, which rate to fetch.
     */
    where?: rateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rates to fetch.
     */
    orderBy?: rateOrderByWithRelationInput | rateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rates.
     */
    cursor?: rateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rates.
     */
    distinct?: RateScalarFieldEnum | RateScalarFieldEnum[]
  }

  /**
   * rate findMany
   */
  export type rateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate
     */
    select?: rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate
     */
    omit?: rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rateInclude<ExtArgs> | null
    /**
     * Filter, which rates to fetch.
     */
    where?: rateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rates to fetch.
     */
    orderBy?: rateOrderByWithRelationInput | rateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rates.
     */
    cursor?: rateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rates.
     */
    skip?: number
    distinct?: RateScalarFieldEnum | RateScalarFieldEnum[]
  }

  /**
   * rate create
   */
  export type rateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate
     */
    select?: rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate
     */
    omit?: rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rateInclude<ExtArgs> | null
    /**
     * The data needed to create a rate.
     */
    data: XOR<rateCreateInput, rateUncheckedCreateInput>
  }

  /**
   * rate createMany
   */
  export type rateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rates.
     */
    data: rateCreateManyInput | rateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rate update
   */
  export type rateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate
     */
    select?: rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate
     */
    omit?: rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rateInclude<ExtArgs> | null
    /**
     * The data needed to update a rate.
     */
    data: XOR<rateUpdateInput, rateUncheckedUpdateInput>
    /**
     * Choose, which rate to update.
     */
    where: rateWhereUniqueInput
  }

  /**
   * rate updateMany
   */
  export type rateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rates.
     */
    data: XOR<rateUpdateManyMutationInput, rateUncheckedUpdateManyInput>
    /**
     * Filter which rates to update
     */
    where?: rateWhereInput
    /**
     * Limit how many rates to update.
     */
    limit?: number
  }

  /**
   * rate upsert
   */
  export type rateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate
     */
    select?: rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate
     */
    omit?: rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rateInclude<ExtArgs> | null
    /**
     * The filter to search for the rate to update in case it exists.
     */
    where: rateWhereUniqueInput
    /**
     * In case the rate found by the `where` argument doesn't exist, create a new rate with this data.
     */
    create: XOR<rateCreateInput, rateUncheckedCreateInput>
    /**
     * In case the rate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rateUpdateInput, rateUncheckedUpdateInput>
  }

  /**
   * rate delete
   */
  export type rateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate
     */
    select?: rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate
     */
    omit?: rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rateInclude<ExtArgs> | null
    /**
     * Filter which rate to delete.
     */
    where: rateWhereUniqueInput
  }

  /**
   * rate deleteMany
   */
  export type rateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rates to delete
     */
    where?: rateWhereInput
    /**
     * Limit how many rates to delete.
     */
    limit?: number
  }

  /**
   * rate.pokemonRatingGames
   */
  export type rate$pokemonRatingGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
    where?: pokemon_game_locationWhereInput
    orderBy?: pokemon_game_locationOrderByWithRelationInput | pokemon_game_locationOrderByWithRelationInput[]
    cursor?: pokemon_game_locationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pokemon_game_locationScalarFieldEnum | Pokemon_game_locationScalarFieldEnum[]
  }

  /**
   * rate.shinyHuntingMethodRates
   */
  export type rate$shinyHuntingMethodRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_rate
     */
    select?: shiny_hunting_method_rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_rate
     */
    omit?: shiny_hunting_method_rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_rateInclude<ExtArgs> | null
    where?: shiny_hunting_method_rateWhereInput
    orderBy?: shiny_hunting_method_rateOrderByWithRelationInput | shiny_hunting_method_rateOrderByWithRelationInput[]
    cursor?: shiny_hunting_method_rateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Shiny_hunting_method_rateScalarFieldEnum | Shiny_hunting_method_rateScalarFieldEnum[]
  }

  /**
   * rate without action
   */
  export type rateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate
     */
    select?: rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate
     */
    omit?: rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rateInclude<ExtArgs> | null
  }


  /**
   * Model shiny_hunting_method_game
   */

  export type AggregateShiny_hunting_method_game = {
    _count: Shiny_hunting_method_gameCountAggregateOutputType | null
    _avg: Shiny_hunting_method_gameAvgAggregateOutputType | null
    _sum: Shiny_hunting_method_gameSumAggregateOutputType | null
    _min: Shiny_hunting_method_gameMinAggregateOutputType | null
    _max: Shiny_hunting_method_gameMaxAggregateOutputType | null
  }

  export type Shiny_hunting_method_gameAvgAggregateOutputType = {
    shinyHuntingMethodId: number | null
    groupGameId: number | null
  }

  export type Shiny_hunting_method_gameSumAggregateOutputType = {
    shinyHuntingMethodId: number | null
    groupGameId: number | null
  }

  export type Shiny_hunting_method_gameMinAggregateOutputType = {
    shinyHuntingMethodId: number | null
    groupGameId: number | null
  }

  export type Shiny_hunting_method_gameMaxAggregateOutputType = {
    shinyHuntingMethodId: number | null
    groupGameId: number | null
  }

  export type Shiny_hunting_method_gameCountAggregateOutputType = {
    shinyHuntingMethodId: number
    groupGameId: number
    _all: number
  }


  export type Shiny_hunting_method_gameAvgAggregateInputType = {
    shinyHuntingMethodId?: true
    groupGameId?: true
  }

  export type Shiny_hunting_method_gameSumAggregateInputType = {
    shinyHuntingMethodId?: true
    groupGameId?: true
  }

  export type Shiny_hunting_method_gameMinAggregateInputType = {
    shinyHuntingMethodId?: true
    groupGameId?: true
  }

  export type Shiny_hunting_method_gameMaxAggregateInputType = {
    shinyHuntingMethodId?: true
    groupGameId?: true
  }

  export type Shiny_hunting_method_gameCountAggregateInputType = {
    shinyHuntingMethodId?: true
    groupGameId?: true
    _all?: true
  }

  export type Shiny_hunting_method_gameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shiny_hunting_method_game to aggregate.
     */
    where?: shiny_hunting_method_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shiny_hunting_method_games to fetch.
     */
    orderBy?: shiny_hunting_method_gameOrderByWithRelationInput | shiny_hunting_method_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: shiny_hunting_method_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shiny_hunting_method_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shiny_hunting_method_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned shiny_hunting_method_games
    **/
    _count?: true | Shiny_hunting_method_gameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Shiny_hunting_method_gameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Shiny_hunting_method_gameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Shiny_hunting_method_gameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Shiny_hunting_method_gameMaxAggregateInputType
  }

  export type GetShiny_hunting_method_gameAggregateType<T extends Shiny_hunting_method_gameAggregateArgs> = {
        [P in keyof T & keyof AggregateShiny_hunting_method_game]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiny_hunting_method_game[P]>
      : GetScalarType<T[P], AggregateShiny_hunting_method_game[P]>
  }




  export type shiny_hunting_method_gameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: shiny_hunting_method_gameWhereInput
    orderBy?: shiny_hunting_method_gameOrderByWithAggregationInput | shiny_hunting_method_gameOrderByWithAggregationInput[]
    by: Shiny_hunting_method_gameScalarFieldEnum[] | Shiny_hunting_method_gameScalarFieldEnum
    having?: shiny_hunting_method_gameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Shiny_hunting_method_gameCountAggregateInputType | true
    _avg?: Shiny_hunting_method_gameAvgAggregateInputType
    _sum?: Shiny_hunting_method_gameSumAggregateInputType
    _min?: Shiny_hunting_method_gameMinAggregateInputType
    _max?: Shiny_hunting_method_gameMaxAggregateInputType
  }

  export type Shiny_hunting_method_gameGroupByOutputType = {
    shinyHuntingMethodId: number
    groupGameId: number
    _count: Shiny_hunting_method_gameCountAggregateOutputType | null
    _avg: Shiny_hunting_method_gameAvgAggregateOutputType | null
    _sum: Shiny_hunting_method_gameSumAggregateOutputType | null
    _min: Shiny_hunting_method_gameMinAggregateOutputType | null
    _max: Shiny_hunting_method_gameMaxAggregateOutputType | null
  }

  type GetShiny_hunting_method_gameGroupByPayload<T extends shiny_hunting_method_gameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Shiny_hunting_method_gameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Shiny_hunting_method_gameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Shiny_hunting_method_gameGroupByOutputType[P]>
            : GetScalarType<T[P], Shiny_hunting_method_gameGroupByOutputType[P]>
        }
      >
    >


  export type shiny_hunting_method_gameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shinyHuntingMethodId?: boolean
    groupGameId?: boolean
    groupGame?: boolean | group_gameDefaultArgs<ExtArgs>
    shinyHuntingMethod?: boolean | shiny_hunting_methodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiny_hunting_method_game"]>



  export type shiny_hunting_method_gameSelectScalar = {
    shinyHuntingMethodId?: boolean
    groupGameId?: boolean
  }

  export type shiny_hunting_method_gameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"shinyHuntingMethodId" | "groupGameId", ExtArgs["result"]["shiny_hunting_method_game"]>
  export type shiny_hunting_method_gameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupGame?: boolean | group_gameDefaultArgs<ExtArgs>
    shinyHuntingMethod?: boolean | shiny_hunting_methodDefaultArgs<ExtArgs>
  }

  export type $shiny_hunting_method_gamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "shiny_hunting_method_game"
    objects: {
      groupGame: Prisma.$group_gamePayload<ExtArgs>
      shinyHuntingMethod: Prisma.$shiny_hunting_methodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      shinyHuntingMethodId: number
      groupGameId: number
    }, ExtArgs["result"]["shiny_hunting_method_game"]>
    composites: {}
  }

  type shiny_hunting_method_gameGetPayload<S extends boolean | null | undefined | shiny_hunting_method_gameDefaultArgs> = $Result.GetResult<Prisma.$shiny_hunting_method_gamePayload, S>

  type shiny_hunting_method_gameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<shiny_hunting_method_gameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Shiny_hunting_method_gameCountAggregateInputType | true
    }

  export interface shiny_hunting_method_gameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shiny_hunting_method_game'], meta: { name: 'shiny_hunting_method_game' } }
    /**
     * Find zero or one Shiny_hunting_method_game that matches the filter.
     * @param {shiny_hunting_method_gameFindUniqueArgs} args - Arguments to find a Shiny_hunting_method_game
     * @example
     * // Get one Shiny_hunting_method_game
     * const shiny_hunting_method_game = await prisma.shiny_hunting_method_game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends shiny_hunting_method_gameFindUniqueArgs>(args: SelectSubset<T, shiny_hunting_method_gameFindUniqueArgs<ExtArgs>>): Prisma__shiny_hunting_method_gameClient<$Result.GetResult<Prisma.$shiny_hunting_method_gamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shiny_hunting_method_game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {shiny_hunting_method_gameFindUniqueOrThrowArgs} args - Arguments to find a Shiny_hunting_method_game
     * @example
     * // Get one Shiny_hunting_method_game
     * const shiny_hunting_method_game = await prisma.shiny_hunting_method_game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends shiny_hunting_method_gameFindUniqueOrThrowArgs>(args: SelectSubset<T, shiny_hunting_method_gameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shiny_hunting_method_gameClient<$Result.GetResult<Prisma.$shiny_hunting_method_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shiny_hunting_method_game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_method_gameFindFirstArgs} args - Arguments to find a Shiny_hunting_method_game
     * @example
     * // Get one Shiny_hunting_method_game
     * const shiny_hunting_method_game = await prisma.shiny_hunting_method_game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends shiny_hunting_method_gameFindFirstArgs>(args?: SelectSubset<T, shiny_hunting_method_gameFindFirstArgs<ExtArgs>>): Prisma__shiny_hunting_method_gameClient<$Result.GetResult<Prisma.$shiny_hunting_method_gamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shiny_hunting_method_game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_method_gameFindFirstOrThrowArgs} args - Arguments to find a Shiny_hunting_method_game
     * @example
     * // Get one Shiny_hunting_method_game
     * const shiny_hunting_method_game = await prisma.shiny_hunting_method_game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends shiny_hunting_method_gameFindFirstOrThrowArgs>(args?: SelectSubset<T, shiny_hunting_method_gameFindFirstOrThrowArgs<ExtArgs>>): Prisma__shiny_hunting_method_gameClient<$Result.GetResult<Prisma.$shiny_hunting_method_gamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shiny_hunting_method_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_method_gameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shiny_hunting_method_games
     * const shiny_hunting_method_games = await prisma.shiny_hunting_method_game.findMany()
     * 
     * // Get first 10 Shiny_hunting_method_games
     * const shiny_hunting_method_games = await prisma.shiny_hunting_method_game.findMany({ take: 10 })
     * 
     * // Only select the `shinyHuntingMethodId`
     * const shiny_hunting_method_gameWithShinyHuntingMethodIdOnly = await prisma.shiny_hunting_method_game.findMany({ select: { shinyHuntingMethodId: true } })
     * 
     */
    findMany<T extends shiny_hunting_method_gameFindManyArgs>(args?: SelectSubset<T, shiny_hunting_method_gameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shiny_hunting_method_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shiny_hunting_method_game.
     * @param {shiny_hunting_method_gameCreateArgs} args - Arguments to create a Shiny_hunting_method_game.
     * @example
     * // Create one Shiny_hunting_method_game
     * const Shiny_hunting_method_game = await prisma.shiny_hunting_method_game.create({
     *   data: {
     *     // ... data to create a Shiny_hunting_method_game
     *   }
     * })
     * 
     */
    create<T extends shiny_hunting_method_gameCreateArgs>(args: SelectSubset<T, shiny_hunting_method_gameCreateArgs<ExtArgs>>): Prisma__shiny_hunting_method_gameClient<$Result.GetResult<Prisma.$shiny_hunting_method_gamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shiny_hunting_method_games.
     * @param {shiny_hunting_method_gameCreateManyArgs} args - Arguments to create many Shiny_hunting_method_games.
     * @example
     * // Create many Shiny_hunting_method_games
     * const shiny_hunting_method_game = await prisma.shiny_hunting_method_game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends shiny_hunting_method_gameCreateManyArgs>(args?: SelectSubset<T, shiny_hunting_method_gameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shiny_hunting_method_game.
     * @param {shiny_hunting_method_gameDeleteArgs} args - Arguments to delete one Shiny_hunting_method_game.
     * @example
     * // Delete one Shiny_hunting_method_game
     * const Shiny_hunting_method_game = await prisma.shiny_hunting_method_game.delete({
     *   where: {
     *     // ... filter to delete one Shiny_hunting_method_game
     *   }
     * })
     * 
     */
    delete<T extends shiny_hunting_method_gameDeleteArgs>(args: SelectSubset<T, shiny_hunting_method_gameDeleteArgs<ExtArgs>>): Prisma__shiny_hunting_method_gameClient<$Result.GetResult<Prisma.$shiny_hunting_method_gamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shiny_hunting_method_game.
     * @param {shiny_hunting_method_gameUpdateArgs} args - Arguments to update one Shiny_hunting_method_game.
     * @example
     * // Update one Shiny_hunting_method_game
     * const shiny_hunting_method_game = await prisma.shiny_hunting_method_game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends shiny_hunting_method_gameUpdateArgs>(args: SelectSubset<T, shiny_hunting_method_gameUpdateArgs<ExtArgs>>): Prisma__shiny_hunting_method_gameClient<$Result.GetResult<Prisma.$shiny_hunting_method_gamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shiny_hunting_method_games.
     * @param {shiny_hunting_method_gameDeleteManyArgs} args - Arguments to filter Shiny_hunting_method_games to delete.
     * @example
     * // Delete a few Shiny_hunting_method_games
     * const { count } = await prisma.shiny_hunting_method_game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends shiny_hunting_method_gameDeleteManyArgs>(args?: SelectSubset<T, shiny_hunting_method_gameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shiny_hunting_method_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_method_gameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shiny_hunting_method_games
     * const shiny_hunting_method_game = await prisma.shiny_hunting_method_game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends shiny_hunting_method_gameUpdateManyArgs>(args: SelectSubset<T, shiny_hunting_method_gameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shiny_hunting_method_game.
     * @param {shiny_hunting_method_gameUpsertArgs} args - Arguments to update or create a Shiny_hunting_method_game.
     * @example
     * // Update or create a Shiny_hunting_method_game
     * const shiny_hunting_method_game = await prisma.shiny_hunting_method_game.upsert({
     *   create: {
     *     // ... data to create a Shiny_hunting_method_game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shiny_hunting_method_game we want to update
     *   }
     * })
     */
    upsert<T extends shiny_hunting_method_gameUpsertArgs>(args: SelectSubset<T, shiny_hunting_method_gameUpsertArgs<ExtArgs>>): Prisma__shiny_hunting_method_gameClient<$Result.GetResult<Prisma.$shiny_hunting_method_gamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shiny_hunting_method_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_method_gameCountArgs} args - Arguments to filter Shiny_hunting_method_games to count.
     * @example
     * // Count the number of Shiny_hunting_method_games
     * const count = await prisma.shiny_hunting_method_game.count({
     *   where: {
     *     // ... the filter for the Shiny_hunting_method_games we want to count
     *   }
     * })
    **/
    count<T extends shiny_hunting_method_gameCountArgs>(
      args?: Subset<T, shiny_hunting_method_gameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Shiny_hunting_method_gameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shiny_hunting_method_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shiny_hunting_method_gameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Shiny_hunting_method_gameAggregateArgs>(args: Subset<T, Shiny_hunting_method_gameAggregateArgs>): Prisma.PrismaPromise<GetShiny_hunting_method_gameAggregateType<T>>

    /**
     * Group by Shiny_hunting_method_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_method_gameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends shiny_hunting_method_gameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: shiny_hunting_method_gameGroupByArgs['orderBy'] }
        : { orderBy?: shiny_hunting_method_gameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, shiny_hunting_method_gameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiny_hunting_method_gameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the shiny_hunting_method_game model
   */
  readonly fields: shiny_hunting_method_gameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for shiny_hunting_method_game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__shiny_hunting_method_gameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    groupGame<T extends group_gameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, group_gameDefaultArgs<ExtArgs>>): Prisma__group_gameClient<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shinyHuntingMethod<T extends shiny_hunting_methodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shiny_hunting_methodDefaultArgs<ExtArgs>>): Prisma__shiny_hunting_methodClient<$Result.GetResult<Prisma.$shiny_hunting_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the shiny_hunting_method_game model
   */
  interface shiny_hunting_method_gameFieldRefs {
    readonly shinyHuntingMethodId: FieldRef<"shiny_hunting_method_game", 'Int'>
    readonly groupGameId: FieldRef<"shiny_hunting_method_game", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * shiny_hunting_method_game findUnique
   */
  export type shiny_hunting_method_gameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_game
     */
    select?: shiny_hunting_method_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_game
     */
    omit?: shiny_hunting_method_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_gameInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_method_game to fetch.
     */
    where: shiny_hunting_method_gameWhereUniqueInput
  }

  /**
   * shiny_hunting_method_game findUniqueOrThrow
   */
  export type shiny_hunting_method_gameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_game
     */
    select?: shiny_hunting_method_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_game
     */
    omit?: shiny_hunting_method_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_gameInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_method_game to fetch.
     */
    where: shiny_hunting_method_gameWhereUniqueInput
  }

  /**
   * shiny_hunting_method_game findFirst
   */
  export type shiny_hunting_method_gameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_game
     */
    select?: shiny_hunting_method_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_game
     */
    omit?: shiny_hunting_method_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_gameInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_method_game to fetch.
     */
    where?: shiny_hunting_method_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shiny_hunting_method_games to fetch.
     */
    orderBy?: shiny_hunting_method_gameOrderByWithRelationInput | shiny_hunting_method_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shiny_hunting_method_games.
     */
    cursor?: shiny_hunting_method_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shiny_hunting_method_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shiny_hunting_method_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shiny_hunting_method_games.
     */
    distinct?: Shiny_hunting_method_gameScalarFieldEnum | Shiny_hunting_method_gameScalarFieldEnum[]
  }

  /**
   * shiny_hunting_method_game findFirstOrThrow
   */
  export type shiny_hunting_method_gameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_game
     */
    select?: shiny_hunting_method_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_game
     */
    omit?: shiny_hunting_method_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_gameInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_method_game to fetch.
     */
    where?: shiny_hunting_method_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shiny_hunting_method_games to fetch.
     */
    orderBy?: shiny_hunting_method_gameOrderByWithRelationInput | shiny_hunting_method_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shiny_hunting_method_games.
     */
    cursor?: shiny_hunting_method_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shiny_hunting_method_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shiny_hunting_method_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shiny_hunting_method_games.
     */
    distinct?: Shiny_hunting_method_gameScalarFieldEnum | Shiny_hunting_method_gameScalarFieldEnum[]
  }

  /**
   * shiny_hunting_method_game findMany
   */
  export type shiny_hunting_method_gameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_game
     */
    select?: shiny_hunting_method_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_game
     */
    omit?: shiny_hunting_method_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_gameInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_method_games to fetch.
     */
    where?: shiny_hunting_method_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shiny_hunting_method_games to fetch.
     */
    orderBy?: shiny_hunting_method_gameOrderByWithRelationInput | shiny_hunting_method_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing shiny_hunting_method_games.
     */
    cursor?: shiny_hunting_method_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shiny_hunting_method_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shiny_hunting_method_games.
     */
    skip?: number
    distinct?: Shiny_hunting_method_gameScalarFieldEnum | Shiny_hunting_method_gameScalarFieldEnum[]
  }

  /**
   * shiny_hunting_method_game create
   */
  export type shiny_hunting_method_gameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_game
     */
    select?: shiny_hunting_method_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_game
     */
    omit?: shiny_hunting_method_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_gameInclude<ExtArgs> | null
    /**
     * The data needed to create a shiny_hunting_method_game.
     */
    data: XOR<shiny_hunting_method_gameCreateInput, shiny_hunting_method_gameUncheckedCreateInput>
  }

  /**
   * shiny_hunting_method_game createMany
   */
  export type shiny_hunting_method_gameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many shiny_hunting_method_games.
     */
    data: shiny_hunting_method_gameCreateManyInput | shiny_hunting_method_gameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * shiny_hunting_method_game update
   */
  export type shiny_hunting_method_gameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_game
     */
    select?: shiny_hunting_method_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_game
     */
    omit?: shiny_hunting_method_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_gameInclude<ExtArgs> | null
    /**
     * The data needed to update a shiny_hunting_method_game.
     */
    data: XOR<shiny_hunting_method_gameUpdateInput, shiny_hunting_method_gameUncheckedUpdateInput>
    /**
     * Choose, which shiny_hunting_method_game to update.
     */
    where: shiny_hunting_method_gameWhereUniqueInput
  }

  /**
   * shiny_hunting_method_game updateMany
   */
  export type shiny_hunting_method_gameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update shiny_hunting_method_games.
     */
    data: XOR<shiny_hunting_method_gameUpdateManyMutationInput, shiny_hunting_method_gameUncheckedUpdateManyInput>
    /**
     * Filter which shiny_hunting_method_games to update
     */
    where?: shiny_hunting_method_gameWhereInput
    /**
     * Limit how many shiny_hunting_method_games to update.
     */
    limit?: number
  }

  /**
   * shiny_hunting_method_game upsert
   */
  export type shiny_hunting_method_gameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_game
     */
    select?: shiny_hunting_method_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_game
     */
    omit?: shiny_hunting_method_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_gameInclude<ExtArgs> | null
    /**
     * The filter to search for the shiny_hunting_method_game to update in case it exists.
     */
    where: shiny_hunting_method_gameWhereUniqueInput
    /**
     * In case the shiny_hunting_method_game found by the `where` argument doesn't exist, create a new shiny_hunting_method_game with this data.
     */
    create: XOR<shiny_hunting_method_gameCreateInput, shiny_hunting_method_gameUncheckedCreateInput>
    /**
     * In case the shiny_hunting_method_game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<shiny_hunting_method_gameUpdateInput, shiny_hunting_method_gameUncheckedUpdateInput>
  }

  /**
   * shiny_hunting_method_game delete
   */
  export type shiny_hunting_method_gameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_game
     */
    select?: shiny_hunting_method_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_game
     */
    omit?: shiny_hunting_method_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_gameInclude<ExtArgs> | null
    /**
     * Filter which shiny_hunting_method_game to delete.
     */
    where: shiny_hunting_method_gameWhereUniqueInput
  }

  /**
   * shiny_hunting_method_game deleteMany
   */
  export type shiny_hunting_method_gameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shiny_hunting_method_games to delete
     */
    where?: shiny_hunting_method_gameWhereInput
    /**
     * Limit how many shiny_hunting_method_games to delete.
     */
    limit?: number
  }

  /**
   * shiny_hunting_method_game without action
   */
  export type shiny_hunting_method_gameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_game
     */
    select?: shiny_hunting_method_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_game
     */
    omit?: shiny_hunting_method_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_gameInclude<ExtArgs> | null
  }


  /**
   * Model shiny_hunting_method_rate
   */

  export type AggregateShiny_hunting_method_rate = {
    _count: Shiny_hunting_method_rateCountAggregateOutputType | null
    _avg: Shiny_hunting_method_rateAvgAggregateOutputType | null
    _sum: Shiny_hunting_method_rateSumAggregateOutputType | null
    _min: Shiny_hunting_method_rateMinAggregateOutputType | null
    _max: Shiny_hunting_method_rateMaxAggregateOutputType | null
  }

  export type Shiny_hunting_method_rateAvgAggregateOutputType = {
    shinyHuntingMethodId: number | null
    rateId: number | null
  }

  export type Shiny_hunting_method_rateSumAggregateOutputType = {
    shinyHuntingMethodId: number | null
    rateId: number | null
  }

  export type Shiny_hunting_method_rateMinAggregateOutputType = {
    shinyHuntingMethodId: number | null
    rateId: number | null
  }

  export type Shiny_hunting_method_rateMaxAggregateOutputType = {
    shinyHuntingMethodId: number | null
    rateId: number | null
  }

  export type Shiny_hunting_method_rateCountAggregateOutputType = {
    shinyHuntingMethodId: number
    rateId: number
    _all: number
  }


  export type Shiny_hunting_method_rateAvgAggregateInputType = {
    shinyHuntingMethodId?: true
    rateId?: true
  }

  export type Shiny_hunting_method_rateSumAggregateInputType = {
    shinyHuntingMethodId?: true
    rateId?: true
  }

  export type Shiny_hunting_method_rateMinAggregateInputType = {
    shinyHuntingMethodId?: true
    rateId?: true
  }

  export type Shiny_hunting_method_rateMaxAggregateInputType = {
    shinyHuntingMethodId?: true
    rateId?: true
  }

  export type Shiny_hunting_method_rateCountAggregateInputType = {
    shinyHuntingMethodId?: true
    rateId?: true
    _all?: true
  }

  export type Shiny_hunting_method_rateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shiny_hunting_method_rate to aggregate.
     */
    where?: shiny_hunting_method_rateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shiny_hunting_method_rates to fetch.
     */
    orderBy?: shiny_hunting_method_rateOrderByWithRelationInput | shiny_hunting_method_rateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: shiny_hunting_method_rateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shiny_hunting_method_rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shiny_hunting_method_rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned shiny_hunting_method_rates
    **/
    _count?: true | Shiny_hunting_method_rateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Shiny_hunting_method_rateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Shiny_hunting_method_rateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Shiny_hunting_method_rateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Shiny_hunting_method_rateMaxAggregateInputType
  }

  export type GetShiny_hunting_method_rateAggregateType<T extends Shiny_hunting_method_rateAggregateArgs> = {
        [P in keyof T & keyof AggregateShiny_hunting_method_rate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiny_hunting_method_rate[P]>
      : GetScalarType<T[P], AggregateShiny_hunting_method_rate[P]>
  }




  export type shiny_hunting_method_rateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: shiny_hunting_method_rateWhereInput
    orderBy?: shiny_hunting_method_rateOrderByWithAggregationInput | shiny_hunting_method_rateOrderByWithAggregationInput[]
    by: Shiny_hunting_method_rateScalarFieldEnum[] | Shiny_hunting_method_rateScalarFieldEnum
    having?: shiny_hunting_method_rateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Shiny_hunting_method_rateCountAggregateInputType | true
    _avg?: Shiny_hunting_method_rateAvgAggregateInputType
    _sum?: Shiny_hunting_method_rateSumAggregateInputType
    _min?: Shiny_hunting_method_rateMinAggregateInputType
    _max?: Shiny_hunting_method_rateMaxAggregateInputType
  }

  export type Shiny_hunting_method_rateGroupByOutputType = {
    shinyHuntingMethodId: number
    rateId: number
    _count: Shiny_hunting_method_rateCountAggregateOutputType | null
    _avg: Shiny_hunting_method_rateAvgAggregateOutputType | null
    _sum: Shiny_hunting_method_rateSumAggregateOutputType | null
    _min: Shiny_hunting_method_rateMinAggregateOutputType | null
    _max: Shiny_hunting_method_rateMaxAggregateOutputType | null
  }

  type GetShiny_hunting_method_rateGroupByPayload<T extends shiny_hunting_method_rateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Shiny_hunting_method_rateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Shiny_hunting_method_rateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Shiny_hunting_method_rateGroupByOutputType[P]>
            : GetScalarType<T[P], Shiny_hunting_method_rateGroupByOutputType[P]>
        }
      >
    >


  export type shiny_hunting_method_rateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shinyHuntingMethodId?: boolean
    rateId?: boolean
    rate?: boolean | rateDefaultArgs<ExtArgs>
    shinyHuntingMethod?: boolean | shiny_hunting_methodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiny_hunting_method_rate"]>



  export type shiny_hunting_method_rateSelectScalar = {
    shinyHuntingMethodId?: boolean
    rateId?: boolean
  }

  export type shiny_hunting_method_rateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"shinyHuntingMethodId" | "rateId", ExtArgs["result"]["shiny_hunting_method_rate"]>
  export type shiny_hunting_method_rateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rate?: boolean | rateDefaultArgs<ExtArgs>
    shinyHuntingMethod?: boolean | shiny_hunting_methodDefaultArgs<ExtArgs>
  }

  export type $shiny_hunting_method_ratePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "shiny_hunting_method_rate"
    objects: {
      rate: Prisma.$ratePayload<ExtArgs>
      shinyHuntingMethod: Prisma.$shiny_hunting_methodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      shinyHuntingMethodId: number
      rateId: number
    }, ExtArgs["result"]["shiny_hunting_method_rate"]>
    composites: {}
  }

  type shiny_hunting_method_rateGetPayload<S extends boolean | null | undefined | shiny_hunting_method_rateDefaultArgs> = $Result.GetResult<Prisma.$shiny_hunting_method_ratePayload, S>

  type shiny_hunting_method_rateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<shiny_hunting_method_rateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Shiny_hunting_method_rateCountAggregateInputType | true
    }

  export interface shiny_hunting_method_rateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shiny_hunting_method_rate'], meta: { name: 'shiny_hunting_method_rate' } }
    /**
     * Find zero or one Shiny_hunting_method_rate that matches the filter.
     * @param {shiny_hunting_method_rateFindUniqueArgs} args - Arguments to find a Shiny_hunting_method_rate
     * @example
     * // Get one Shiny_hunting_method_rate
     * const shiny_hunting_method_rate = await prisma.shiny_hunting_method_rate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends shiny_hunting_method_rateFindUniqueArgs>(args: SelectSubset<T, shiny_hunting_method_rateFindUniqueArgs<ExtArgs>>): Prisma__shiny_hunting_method_rateClient<$Result.GetResult<Prisma.$shiny_hunting_method_ratePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shiny_hunting_method_rate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {shiny_hunting_method_rateFindUniqueOrThrowArgs} args - Arguments to find a Shiny_hunting_method_rate
     * @example
     * // Get one Shiny_hunting_method_rate
     * const shiny_hunting_method_rate = await prisma.shiny_hunting_method_rate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends shiny_hunting_method_rateFindUniqueOrThrowArgs>(args: SelectSubset<T, shiny_hunting_method_rateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shiny_hunting_method_rateClient<$Result.GetResult<Prisma.$shiny_hunting_method_ratePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shiny_hunting_method_rate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_method_rateFindFirstArgs} args - Arguments to find a Shiny_hunting_method_rate
     * @example
     * // Get one Shiny_hunting_method_rate
     * const shiny_hunting_method_rate = await prisma.shiny_hunting_method_rate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends shiny_hunting_method_rateFindFirstArgs>(args?: SelectSubset<T, shiny_hunting_method_rateFindFirstArgs<ExtArgs>>): Prisma__shiny_hunting_method_rateClient<$Result.GetResult<Prisma.$shiny_hunting_method_ratePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shiny_hunting_method_rate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_method_rateFindFirstOrThrowArgs} args - Arguments to find a Shiny_hunting_method_rate
     * @example
     * // Get one Shiny_hunting_method_rate
     * const shiny_hunting_method_rate = await prisma.shiny_hunting_method_rate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends shiny_hunting_method_rateFindFirstOrThrowArgs>(args?: SelectSubset<T, shiny_hunting_method_rateFindFirstOrThrowArgs<ExtArgs>>): Prisma__shiny_hunting_method_rateClient<$Result.GetResult<Prisma.$shiny_hunting_method_ratePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shiny_hunting_method_rates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_method_rateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shiny_hunting_method_rates
     * const shiny_hunting_method_rates = await prisma.shiny_hunting_method_rate.findMany()
     * 
     * // Get first 10 Shiny_hunting_method_rates
     * const shiny_hunting_method_rates = await prisma.shiny_hunting_method_rate.findMany({ take: 10 })
     * 
     * // Only select the `shinyHuntingMethodId`
     * const shiny_hunting_method_rateWithShinyHuntingMethodIdOnly = await prisma.shiny_hunting_method_rate.findMany({ select: { shinyHuntingMethodId: true } })
     * 
     */
    findMany<T extends shiny_hunting_method_rateFindManyArgs>(args?: SelectSubset<T, shiny_hunting_method_rateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shiny_hunting_method_ratePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shiny_hunting_method_rate.
     * @param {shiny_hunting_method_rateCreateArgs} args - Arguments to create a Shiny_hunting_method_rate.
     * @example
     * // Create one Shiny_hunting_method_rate
     * const Shiny_hunting_method_rate = await prisma.shiny_hunting_method_rate.create({
     *   data: {
     *     // ... data to create a Shiny_hunting_method_rate
     *   }
     * })
     * 
     */
    create<T extends shiny_hunting_method_rateCreateArgs>(args: SelectSubset<T, shiny_hunting_method_rateCreateArgs<ExtArgs>>): Prisma__shiny_hunting_method_rateClient<$Result.GetResult<Prisma.$shiny_hunting_method_ratePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shiny_hunting_method_rates.
     * @param {shiny_hunting_method_rateCreateManyArgs} args - Arguments to create many Shiny_hunting_method_rates.
     * @example
     * // Create many Shiny_hunting_method_rates
     * const shiny_hunting_method_rate = await prisma.shiny_hunting_method_rate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends shiny_hunting_method_rateCreateManyArgs>(args?: SelectSubset<T, shiny_hunting_method_rateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shiny_hunting_method_rate.
     * @param {shiny_hunting_method_rateDeleteArgs} args - Arguments to delete one Shiny_hunting_method_rate.
     * @example
     * // Delete one Shiny_hunting_method_rate
     * const Shiny_hunting_method_rate = await prisma.shiny_hunting_method_rate.delete({
     *   where: {
     *     // ... filter to delete one Shiny_hunting_method_rate
     *   }
     * })
     * 
     */
    delete<T extends shiny_hunting_method_rateDeleteArgs>(args: SelectSubset<T, shiny_hunting_method_rateDeleteArgs<ExtArgs>>): Prisma__shiny_hunting_method_rateClient<$Result.GetResult<Prisma.$shiny_hunting_method_ratePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shiny_hunting_method_rate.
     * @param {shiny_hunting_method_rateUpdateArgs} args - Arguments to update one Shiny_hunting_method_rate.
     * @example
     * // Update one Shiny_hunting_method_rate
     * const shiny_hunting_method_rate = await prisma.shiny_hunting_method_rate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends shiny_hunting_method_rateUpdateArgs>(args: SelectSubset<T, shiny_hunting_method_rateUpdateArgs<ExtArgs>>): Prisma__shiny_hunting_method_rateClient<$Result.GetResult<Prisma.$shiny_hunting_method_ratePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shiny_hunting_method_rates.
     * @param {shiny_hunting_method_rateDeleteManyArgs} args - Arguments to filter Shiny_hunting_method_rates to delete.
     * @example
     * // Delete a few Shiny_hunting_method_rates
     * const { count } = await prisma.shiny_hunting_method_rate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends shiny_hunting_method_rateDeleteManyArgs>(args?: SelectSubset<T, shiny_hunting_method_rateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shiny_hunting_method_rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_method_rateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shiny_hunting_method_rates
     * const shiny_hunting_method_rate = await prisma.shiny_hunting_method_rate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends shiny_hunting_method_rateUpdateManyArgs>(args: SelectSubset<T, shiny_hunting_method_rateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shiny_hunting_method_rate.
     * @param {shiny_hunting_method_rateUpsertArgs} args - Arguments to update or create a Shiny_hunting_method_rate.
     * @example
     * // Update or create a Shiny_hunting_method_rate
     * const shiny_hunting_method_rate = await prisma.shiny_hunting_method_rate.upsert({
     *   create: {
     *     // ... data to create a Shiny_hunting_method_rate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shiny_hunting_method_rate we want to update
     *   }
     * })
     */
    upsert<T extends shiny_hunting_method_rateUpsertArgs>(args: SelectSubset<T, shiny_hunting_method_rateUpsertArgs<ExtArgs>>): Prisma__shiny_hunting_method_rateClient<$Result.GetResult<Prisma.$shiny_hunting_method_ratePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shiny_hunting_method_rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_method_rateCountArgs} args - Arguments to filter Shiny_hunting_method_rates to count.
     * @example
     * // Count the number of Shiny_hunting_method_rates
     * const count = await prisma.shiny_hunting_method_rate.count({
     *   where: {
     *     // ... the filter for the Shiny_hunting_method_rates we want to count
     *   }
     * })
    **/
    count<T extends shiny_hunting_method_rateCountArgs>(
      args?: Subset<T, shiny_hunting_method_rateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Shiny_hunting_method_rateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shiny_hunting_method_rate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shiny_hunting_method_rateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Shiny_hunting_method_rateAggregateArgs>(args: Subset<T, Shiny_hunting_method_rateAggregateArgs>): Prisma.PrismaPromise<GetShiny_hunting_method_rateAggregateType<T>>

    /**
     * Group by Shiny_hunting_method_rate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiny_hunting_method_rateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends shiny_hunting_method_rateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: shiny_hunting_method_rateGroupByArgs['orderBy'] }
        : { orderBy?: shiny_hunting_method_rateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, shiny_hunting_method_rateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiny_hunting_method_rateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the shiny_hunting_method_rate model
   */
  readonly fields: shiny_hunting_method_rateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for shiny_hunting_method_rate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__shiny_hunting_method_rateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rate<T extends rateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rateDefaultArgs<ExtArgs>>): Prisma__rateClient<$Result.GetResult<Prisma.$ratePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shinyHuntingMethod<T extends shiny_hunting_methodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shiny_hunting_methodDefaultArgs<ExtArgs>>): Prisma__shiny_hunting_methodClient<$Result.GetResult<Prisma.$shiny_hunting_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the shiny_hunting_method_rate model
   */
  interface shiny_hunting_method_rateFieldRefs {
    readonly shinyHuntingMethodId: FieldRef<"shiny_hunting_method_rate", 'Int'>
    readonly rateId: FieldRef<"shiny_hunting_method_rate", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * shiny_hunting_method_rate findUnique
   */
  export type shiny_hunting_method_rateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_rate
     */
    select?: shiny_hunting_method_rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_rate
     */
    omit?: shiny_hunting_method_rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_rateInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_method_rate to fetch.
     */
    where: shiny_hunting_method_rateWhereUniqueInput
  }

  /**
   * shiny_hunting_method_rate findUniqueOrThrow
   */
  export type shiny_hunting_method_rateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_rate
     */
    select?: shiny_hunting_method_rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_rate
     */
    omit?: shiny_hunting_method_rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_rateInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_method_rate to fetch.
     */
    where: shiny_hunting_method_rateWhereUniqueInput
  }

  /**
   * shiny_hunting_method_rate findFirst
   */
  export type shiny_hunting_method_rateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_rate
     */
    select?: shiny_hunting_method_rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_rate
     */
    omit?: shiny_hunting_method_rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_rateInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_method_rate to fetch.
     */
    where?: shiny_hunting_method_rateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shiny_hunting_method_rates to fetch.
     */
    orderBy?: shiny_hunting_method_rateOrderByWithRelationInput | shiny_hunting_method_rateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shiny_hunting_method_rates.
     */
    cursor?: shiny_hunting_method_rateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shiny_hunting_method_rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shiny_hunting_method_rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shiny_hunting_method_rates.
     */
    distinct?: Shiny_hunting_method_rateScalarFieldEnum | Shiny_hunting_method_rateScalarFieldEnum[]
  }

  /**
   * shiny_hunting_method_rate findFirstOrThrow
   */
  export type shiny_hunting_method_rateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_rate
     */
    select?: shiny_hunting_method_rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_rate
     */
    omit?: shiny_hunting_method_rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_rateInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_method_rate to fetch.
     */
    where?: shiny_hunting_method_rateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shiny_hunting_method_rates to fetch.
     */
    orderBy?: shiny_hunting_method_rateOrderByWithRelationInput | shiny_hunting_method_rateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shiny_hunting_method_rates.
     */
    cursor?: shiny_hunting_method_rateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shiny_hunting_method_rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shiny_hunting_method_rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shiny_hunting_method_rates.
     */
    distinct?: Shiny_hunting_method_rateScalarFieldEnum | Shiny_hunting_method_rateScalarFieldEnum[]
  }

  /**
   * shiny_hunting_method_rate findMany
   */
  export type shiny_hunting_method_rateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_rate
     */
    select?: shiny_hunting_method_rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_rate
     */
    omit?: shiny_hunting_method_rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_rateInclude<ExtArgs> | null
    /**
     * Filter, which shiny_hunting_method_rates to fetch.
     */
    where?: shiny_hunting_method_rateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shiny_hunting_method_rates to fetch.
     */
    orderBy?: shiny_hunting_method_rateOrderByWithRelationInput | shiny_hunting_method_rateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing shiny_hunting_method_rates.
     */
    cursor?: shiny_hunting_method_rateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shiny_hunting_method_rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shiny_hunting_method_rates.
     */
    skip?: number
    distinct?: Shiny_hunting_method_rateScalarFieldEnum | Shiny_hunting_method_rateScalarFieldEnum[]
  }

  /**
   * shiny_hunting_method_rate create
   */
  export type shiny_hunting_method_rateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_rate
     */
    select?: shiny_hunting_method_rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_rate
     */
    omit?: shiny_hunting_method_rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_rateInclude<ExtArgs> | null
    /**
     * The data needed to create a shiny_hunting_method_rate.
     */
    data: XOR<shiny_hunting_method_rateCreateInput, shiny_hunting_method_rateUncheckedCreateInput>
  }

  /**
   * shiny_hunting_method_rate createMany
   */
  export type shiny_hunting_method_rateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many shiny_hunting_method_rates.
     */
    data: shiny_hunting_method_rateCreateManyInput | shiny_hunting_method_rateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * shiny_hunting_method_rate update
   */
  export type shiny_hunting_method_rateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_rate
     */
    select?: shiny_hunting_method_rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_rate
     */
    omit?: shiny_hunting_method_rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_rateInclude<ExtArgs> | null
    /**
     * The data needed to update a shiny_hunting_method_rate.
     */
    data: XOR<shiny_hunting_method_rateUpdateInput, shiny_hunting_method_rateUncheckedUpdateInput>
    /**
     * Choose, which shiny_hunting_method_rate to update.
     */
    where: shiny_hunting_method_rateWhereUniqueInput
  }

  /**
   * shiny_hunting_method_rate updateMany
   */
  export type shiny_hunting_method_rateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update shiny_hunting_method_rates.
     */
    data: XOR<shiny_hunting_method_rateUpdateManyMutationInput, shiny_hunting_method_rateUncheckedUpdateManyInput>
    /**
     * Filter which shiny_hunting_method_rates to update
     */
    where?: shiny_hunting_method_rateWhereInput
    /**
     * Limit how many shiny_hunting_method_rates to update.
     */
    limit?: number
  }

  /**
   * shiny_hunting_method_rate upsert
   */
  export type shiny_hunting_method_rateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_rate
     */
    select?: shiny_hunting_method_rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_rate
     */
    omit?: shiny_hunting_method_rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_rateInclude<ExtArgs> | null
    /**
     * The filter to search for the shiny_hunting_method_rate to update in case it exists.
     */
    where: shiny_hunting_method_rateWhereUniqueInput
    /**
     * In case the shiny_hunting_method_rate found by the `where` argument doesn't exist, create a new shiny_hunting_method_rate with this data.
     */
    create: XOR<shiny_hunting_method_rateCreateInput, shiny_hunting_method_rateUncheckedCreateInput>
    /**
     * In case the shiny_hunting_method_rate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<shiny_hunting_method_rateUpdateInput, shiny_hunting_method_rateUncheckedUpdateInput>
  }

  /**
   * shiny_hunting_method_rate delete
   */
  export type shiny_hunting_method_rateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_rate
     */
    select?: shiny_hunting_method_rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_rate
     */
    omit?: shiny_hunting_method_rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_rateInclude<ExtArgs> | null
    /**
     * Filter which shiny_hunting_method_rate to delete.
     */
    where: shiny_hunting_method_rateWhereUniqueInput
  }

  /**
   * shiny_hunting_method_rate deleteMany
   */
  export type shiny_hunting_method_rateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shiny_hunting_method_rates to delete
     */
    where?: shiny_hunting_method_rateWhereInput
    /**
     * Limit how many shiny_hunting_method_rates to delete.
     */
    limit?: number
  }

  /**
   * shiny_hunting_method_rate without action
   */
  export type shiny_hunting_method_rateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shiny_hunting_method_rate
     */
    select?: shiny_hunting_method_rateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shiny_hunting_method_rate
     */
    omit?: shiny_hunting_method_rateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiny_hunting_method_rateInclude<ExtArgs> | null
  }


  /**
   * Model skill_obtation_type
   */

  export type AggregateSkill_obtation_type = {
    _count: Skill_obtation_typeCountAggregateOutputType | null
    _avg: Skill_obtation_typeAvgAggregateOutputType | null
    _sum: Skill_obtation_typeSumAggregateOutputType | null
    _min: Skill_obtation_typeMinAggregateOutputType | null
    _max: Skill_obtation_typeMaxAggregateOutputType | null
  }

  export type Skill_obtation_typeAvgAggregateOutputType = {
    id: number | null
  }

  export type Skill_obtation_typeSumAggregateOutputType = {
    id: number | null
  }

  export type Skill_obtation_typeMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Skill_obtation_typeMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Skill_obtation_typeCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Skill_obtation_typeAvgAggregateInputType = {
    id?: true
  }

  export type Skill_obtation_typeSumAggregateInputType = {
    id?: true
  }

  export type Skill_obtation_typeMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Skill_obtation_typeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Skill_obtation_typeCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Skill_obtation_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skill_obtation_type to aggregate.
     */
    where?: skill_obtation_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skill_obtation_types to fetch.
     */
    orderBy?: skill_obtation_typeOrderByWithRelationInput | skill_obtation_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skill_obtation_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skill_obtation_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skill_obtation_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skill_obtation_types
    **/
    _count?: true | Skill_obtation_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Skill_obtation_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Skill_obtation_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Skill_obtation_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Skill_obtation_typeMaxAggregateInputType
  }

  export type GetSkill_obtation_typeAggregateType<T extends Skill_obtation_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill_obtation_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill_obtation_type[P]>
      : GetScalarType<T[P], AggregateSkill_obtation_type[P]>
  }




  export type skill_obtation_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skill_obtation_typeWhereInput
    orderBy?: skill_obtation_typeOrderByWithAggregationInput | skill_obtation_typeOrderByWithAggregationInput[]
    by: Skill_obtation_typeScalarFieldEnum[] | Skill_obtation_typeScalarFieldEnum
    having?: skill_obtation_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Skill_obtation_typeCountAggregateInputType | true
    _avg?: Skill_obtation_typeAvgAggregateInputType
    _sum?: Skill_obtation_typeSumAggregateInputType
    _min?: Skill_obtation_typeMinAggregateInputType
    _max?: Skill_obtation_typeMaxAggregateInputType
  }

  export type Skill_obtation_typeGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Skill_obtation_typeCountAggregateOutputType | null
    _avg: Skill_obtation_typeAvgAggregateOutputType | null
    _sum: Skill_obtation_typeSumAggregateOutputType | null
    _min: Skill_obtation_typeMinAggregateOutputType | null
    _max: Skill_obtation_typeMaxAggregateOutputType | null
  }

  type GetSkill_obtation_typeGroupByPayload<T extends skill_obtation_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Skill_obtation_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Skill_obtation_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Skill_obtation_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Skill_obtation_typeGroupByOutputType[P]>
        }
      >
    >


  export type skill_obtation_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    skillObtations?: boolean | skill_obtation_type$skillObtationsArgs<ExtArgs>
    _count?: boolean | Skill_obtation_typeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill_obtation_type"]>



  export type skill_obtation_typeSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type skill_obtation_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["skill_obtation_type"]>
  export type skill_obtation_typeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skillObtations?: boolean | skill_obtation_type$skillObtationsArgs<ExtArgs>
    _count?: boolean | Skill_obtation_typeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $skill_obtation_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "skill_obtation_type"
    objects: {
      skillObtations: Prisma.$skill_obtationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["skill_obtation_type"]>
    composites: {}
  }

  type skill_obtation_typeGetPayload<S extends boolean | null | undefined | skill_obtation_typeDefaultArgs> = $Result.GetResult<Prisma.$skill_obtation_typePayload, S>

  type skill_obtation_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<skill_obtation_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Skill_obtation_typeCountAggregateInputType | true
    }

  export interface skill_obtation_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['skill_obtation_type'], meta: { name: 'skill_obtation_type' } }
    /**
     * Find zero or one Skill_obtation_type that matches the filter.
     * @param {skill_obtation_typeFindUniqueArgs} args - Arguments to find a Skill_obtation_type
     * @example
     * // Get one Skill_obtation_type
     * const skill_obtation_type = await prisma.skill_obtation_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends skill_obtation_typeFindUniqueArgs>(args: SelectSubset<T, skill_obtation_typeFindUniqueArgs<ExtArgs>>): Prisma__skill_obtation_typeClient<$Result.GetResult<Prisma.$skill_obtation_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skill_obtation_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {skill_obtation_typeFindUniqueOrThrowArgs} args - Arguments to find a Skill_obtation_type
     * @example
     * // Get one Skill_obtation_type
     * const skill_obtation_type = await prisma.skill_obtation_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends skill_obtation_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, skill_obtation_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__skill_obtation_typeClient<$Result.GetResult<Prisma.$skill_obtation_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill_obtation_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skill_obtation_typeFindFirstArgs} args - Arguments to find a Skill_obtation_type
     * @example
     * // Get one Skill_obtation_type
     * const skill_obtation_type = await prisma.skill_obtation_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends skill_obtation_typeFindFirstArgs>(args?: SelectSubset<T, skill_obtation_typeFindFirstArgs<ExtArgs>>): Prisma__skill_obtation_typeClient<$Result.GetResult<Prisma.$skill_obtation_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill_obtation_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skill_obtation_typeFindFirstOrThrowArgs} args - Arguments to find a Skill_obtation_type
     * @example
     * // Get one Skill_obtation_type
     * const skill_obtation_type = await prisma.skill_obtation_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends skill_obtation_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, skill_obtation_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__skill_obtation_typeClient<$Result.GetResult<Prisma.$skill_obtation_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skill_obtation_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skill_obtation_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skill_obtation_types
     * const skill_obtation_types = await prisma.skill_obtation_type.findMany()
     * 
     * // Get first 10 Skill_obtation_types
     * const skill_obtation_types = await prisma.skill_obtation_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skill_obtation_typeWithIdOnly = await prisma.skill_obtation_type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends skill_obtation_typeFindManyArgs>(args?: SelectSubset<T, skill_obtation_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skill_obtation_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skill_obtation_type.
     * @param {skill_obtation_typeCreateArgs} args - Arguments to create a Skill_obtation_type.
     * @example
     * // Create one Skill_obtation_type
     * const Skill_obtation_type = await prisma.skill_obtation_type.create({
     *   data: {
     *     // ... data to create a Skill_obtation_type
     *   }
     * })
     * 
     */
    create<T extends skill_obtation_typeCreateArgs>(args: SelectSubset<T, skill_obtation_typeCreateArgs<ExtArgs>>): Prisma__skill_obtation_typeClient<$Result.GetResult<Prisma.$skill_obtation_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skill_obtation_types.
     * @param {skill_obtation_typeCreateManyArgs} args - Arguments to create many Skill_obtation_types.
     * @example
     * // Create many Skill_obtation_types
     * const skill_obtation_type = await prisma.skill_obtation_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends skill_obtation_typeCreateManyArgs>(args?: SelectSubset<T, skill_obtation_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Skill_obtation_type.
     * @param {skill_obtation_typeDeleteArgs} args - Arguments to delete one Skill_obtation_type.
     * @example
     * // Delete one Skill_obtation_type
     * const Skill_obtation_type = await prisma.skill_obtation_type.delete({
     *   where: {
     *     // ... filter to delete one Skill_obtation_type
     *   }
     * })
     * 
     */
    delete<T extends skill_obtation_typeDeleteArgs>(args: SelectSubset<T, skill_obtation_typeDeleteArgs<ExtArgs>>): Prisma__skill_obtation_typeClient<$Result.GetResult<Prisma.$skill_obtation_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skill_obtation_type.
     * @param {skill_obtation_typeUpdateArgs} args - Arguments to update one Skill_obtation_type.
     * @example
     * // Update one Skill_obtation_type
     * const skill_obtation_type = await prisma.skill_obtation_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends skill_obtation_typeUpdateArgs>(args: SelectSubset<T, skill_obtation_typeUpdateArgs<ExtArgs>>): Prisma__skill_obtation_typeClient<$Result.GetResult<Prisma.$skill_obtation_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skill_obtation_types.
     * @param {skill_obtation_typeDeleteManyArgs} args - Arguments to filter Skill_obtation_types to delete.
     * @example
     * // Delete a few Skill_obtation_types
     * const { count } = await prisma.skill_obtation_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends skill_obtation_typeDeleteManyArgs>(args?: SelectSubset<T, skill_obtation_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skill_obtation_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skill_obtation_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skill_obtation_types
     * const skill_obtation_type = await prisma.skill_obtation_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends skill_obtation_typeUpdateManyArgs>(args: SelectSubset<T, skill_obtation_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skill_obtation_type.
     * @param {skill_obtation_typeUpsertArgs} args - Arguments to update or create a Skill_obtation_type.
     * @example
     * // Update or create a Skill_obtation_type
     * const skill_obtation_type = await prisma.skill_obtation_type.upsert({
     *   create: {
     *     // ... data to create a Skill_obtation_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill_obtation_type we want to update
     *   }
     * })
     */
    upsert<T extends skill_obtation_typeUpsertArgs>(args: SelectSubset<T, skill_obtation_typeUpsertArgs<ExtArgs>>): Prisma__skill_obtation_typeClient<$Result.GetResult<Prisma.$skill_obtation_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skill_obtation_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skill_obtation_typeCountArgs} args - Arguments to filter Skill_obtation_types to count.
     * @example
     * // Count the number of Skill_obtation_types
     * const count = await prisma.skill_obtation_type.count({
     *   where: {
     *     // ... the filter for the Skill_obtation_types we want to count
     *   }
     * })
    **/
    count<T extends skill_obtation_typeCountArgs>(
      args?: Subset<T, skill_obtation_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Skill_obtation_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill_obtation_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Skill_obtation_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Skill_obtation_typeAggregateArgs>(args: Subset<T, Skill_obtation_typeAggregateArgs>): Prisma.PrismaPromise<GetSkill_obtation_typeAggregateType<T>>

    /**
     * Group by Skill_obtation_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skill_obtation_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends skill_obtation_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: skill_obtation_typeGroupByArgs['orderBy'] }
        : { orderBy?: skill_obtation_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, skill_obtation_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkill_obtation_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the skill_obtation_type model
   */
  readonly fields: skill_obtation_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for skill_obtation_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__skill_obtation_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skillObtations<T extends skill_obtation_type$skillObtationsArgs<ExtArgs> = {}>(args?: Subset<T, skill_obtation_type$skillObtationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skill_obtationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the skill_obtation_type model
   */
  interface skill_obtation_typeFieldRefs {
    readonly id: FieldRef<"skill_obtation_type", 'Int'>
    readonly createdAt: FieldRef<"skill_obtation_type", 'DateTime'>
    readonly updatedAt: FieldRef<"skill_obtation_type", 'DateTime'>
    readonly status: FieldRef<"skill_obtation_type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * skill_obtation_type findUnique
   */
  export type skill_obtation_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation_type
     */
    select?: skill_obtation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation_type
     */
    omit?: skill_obtation_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtation_typeInclude<ExtArgs> | null
    /**
     * Filter, which skill_obtation_type to fetch.
     */
    where: skill_obtation_typeWhereUniqueInput
  }

  /**
   * skill_obtation_type findUniqueOrThrow
   */
  export type skill_obtation_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation_type
     */
    select?: skill_obtation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation_type
     */
    omit?: skill_obtation_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtation_typeInclude<ExtArgs> | null
    /**
     * Filter, which skill_obtation_type to fetch.
     */
    where: skill_obtation_typeWhereUniqueInput
  }

  /**
   * skill_obtation_type findFirst
   */
  export type skill_obtation_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation_type
     */
    select?: skill_obtation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation_type
     */
    omit?: skill_obtation_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtation_typeInclude<ExtArgs> | null
    /**
     * Filter, which skill_obtation_type to fetch.
     */
    where?: skill_obtation_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skill_obtation_types to fetch.
     */
    orderBy?: skill_obtation_typeOrderByWithRelationInput | skill_obtation_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skill_obtation_types.
     */
    cursor?: skill_obtation_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skill_obtation_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skill_obtation_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skill_obtation_types.
     */
    distinct?: Skill_obtation_typeScalarFieldEnum | Skill_obtation_typeScalarFieldEnum[]
  }

  /**
   * skill_obtation_type findFirstOrThrow
   */
  export type skill_obtation_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation_type
     */
    select?: skill_obtation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation_type
     */
    omit?: skill_obtation_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtation_typeInclude<ExtArgs> | null
    /**
     * Filter, which skill_obtation_type to fetch.
     */
    where?: skill_obtation_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skill_obtation_types to fetch.
     */
    orderBy?: skill_obtation_typeOrderByWithRelationInput | skill_obtation_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skill_obtation_types.
     */
    cursor?: skill_obtation_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skill_obtation_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skill_obtation_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skill_obtation_types.
     */
    distinct?: Skill_obtation_typeScalarFieldEnum | Skill_obtation_typeScalarFieldEnum[]
  }

  /**
   * skill_obtation_type findMany
   */
  export type skill_obtation_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation_type
     */
    select?: skill_obtation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation_type
     */
    omit?: skill_obtation_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtation_typeInclude<ExtArgs> | null
    /**
     * Filter, which skill_obtation_types to fetch.
     */
    where?: skill_obtation_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skill_obtation_types to fetch.
     */
    orderBy?: skill_obtation_typeOrderByWithRelationInput | skill_obtation_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skill_obtation_types.
     */
    cursor?: skill_obtation_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skill_obtation_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skill_obtation_types.
     */
    skip?: number
    distinct?: Skill_obtation_typeScalarFieldEnum | Skill_obtation_typeScalarFieldEnum[]
  }

  /**
   * skill_obtation_type create
   */
  export type skill_obtation_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation_type
     */
    select?: skill_obtation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation_type
     */
    omit?: skill_obtation_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtation_typeInclude<ExtArgs> | null
    /**
     * The data needed to create a skill_obtation_type.
     */
    data?: XOR<skill_obtation_typeCreateInput, skill_obtation_typeUncheckedCreateInput>
  }

  /**
   * skill_obtation_type createMany
   */
  export type skill_obtation_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many skill_obtation_types.
     */
    data: skill_obtation_typeCreateManyInput | skill_obtation_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * skill_obtation_type update
   */
  export type skill_obtation_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation_type
     */
    select?: skill_obtation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation_type
     */
    omit?: skill_obtation_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtation_typeInclude<ExtArgs> | null
    /**
     * The data needed to update a skill_obtation_type.
     */
    data: XOR<skill_obtation_typeUpdateInput, skill_obtation_typeUncheckedUpdateInput>
    /**
     * Choose, which skill_obtation_type to update.
     */
    where: skill_obtation_typeWhereUniqueInput
  }

  /**
   * skill_obtation_type updateMany
   */
  export type skill_obtation_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update skill_obtation_types.
     */
    data: XOR<skill_obtation_typeUpdateManyMutationInput, skill_obtation_typeUncheckedUpdateManyInput>
    /**
     * Filter which skill_obtation_types to update
     */
    where?: skill_obtation_typeWhereInput
    /**
     * Limit how many skill_obtation_types to update.
     */
    limit?: number
  }

  /**
   * skill_obtation_type upsert
   */
  export type skill_obtation_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation_type
     */
    select?: skill_obtation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation_type
     */
    omit?: skill_obtation_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtation_typeInclude<ExtArgs> | null
    /**
     * The filter to search for the skill_obtation_type to update in case it exists.
     */
    where: skill_obtation_typeWhereUniqueInput
    /**
     * In case the skill_obtation_type found by the `where` argument doesn't exist, create a new skill_obtation_type with this data.
     */
    create: XOR<skill_obtation_typeCreateInput, skill_obtation_typeUncheckedCreateInput>
    /**
     * In case the skill_obtation_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skill_obtation_typeUpdateInput, skill_obtation_typeUncheckedUpdateInput>
  }

  /**
   * skill_obtation_type delete
   */
  export type skill_obtation_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation_type
     */
    select?: skill_obtation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation_type
     */
    omit?: skill_obtation_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtation_typeInclude<ExtArgs> | null
    /**
     * Filter which skill_obtation_type to delete.
     */
    where: skill_obtation_typeWhereUniqueInput
  }

  /**
   * skill_obtation_type deleteMany
   */
  export type skill_obtation_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skill_obtation_types to delete
     */
    where?: skill_obtation_typeWhereInput
    /**
     * Limit how many skill_obtation_types to delete.
     */
    limit?: number
  }

  /**
   * skill_obtation_type.skillObtations
   */
  export type skill_obtation_type$skillObtationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation
     */
    select?: skill_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation
     */
    omit?: skill_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtationInclude<ExtArgs> | null
    where?: skill_obtationWhereInput
    orderBy?: skill_obtationOrderByWithRelationInput | skill_obtationOrderByWithRelationInput[]
    cursor?: skill_obtationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Skill_obtationScalarFieldEnum | Skill_obtationScalarFieldEnum[]
  }

  /**
   * skill_obtation_type without action
   */
  export type skill_obtation_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation_type
     */
    select?: skill_obtation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation_type
     */
    omit?: skill_obtation_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtation_typeInclude<ExtArgs> | null
  }


  /**
   * Model statistic
   */

  export type AggregateStatistic = {
    _count: StatisticCountAggregateOutputType | null
    _avg: StatisticAvgAggregateOutputType | null
    _sum: StatisticSumAggregateOutputType | null
    _min: StatisticMinAggregateOutputType | null
    _max: StatisticMaxAggregateOutputType | null
  }

  export type StatisticAvgAggregateOutputType = {
    id: number | null
    pv: number | null
    attack: number | null
    defense: number | null
    specialAttack: number | null
    specialDefense: number | null
    special: number | null
    speed: number | null
  }

  export type StatisticSumAggregateOutputType = {
    id: number | null
    pv: number | null
    attack: number | null
    defense: number | null
    specialAttack: number | null
    specialDefense: number | null
    special: number | null
    speed: number | null
  }

  export type StatisticMinAggregateOutputType = {
    id: number | null
    pv: number | null
    attack: number | null
    defense: number | null
    specialAttack: number | null
    specialDefense: number | null
    special: number | null
    speed: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type StatisticMaxAggregateOutputType = {
    id: number | null
    pv: number | null
    attack: number | null
    defense: number | null
    specialAttack: number | null
    specialDefense: number | null
    special: number | null
    speed: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type StatisticCountAggregateOutputType = {
    id: number
    pv: number
    attack: number
    defense: number
    specialAttack: number
    specialDefense: number
    special: number
    speed: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type StatisticAvgAggregateInputType = {
    id?: true
    pv?: true
    attack?: true
    defense?: true
    specialAttack?: true
    specialDefense?: true
    special?: true
    speed?: true
  }

  export type StatisticSumAggregateInputType = {
    id?: true
    pv?: true
    attack?: true
    defense?: true
    specialAttack?: true
    specialDefense?: true
    special?: true
    speed?: true
  }

  export type StatisticMinAggregateInputType = {
    id?: true
    pv?: true
    attack?: true
    defense?: true
    specialAttack?: true
    specialDefense?: true
    special?: true
    speed?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type StatisticMaxAggregateInputType = {
    id?: true
    pv?: true
    attack?: true
    defense?: true
    specialAttack?: true
    specialDefense?: true
    special?: true
    speed?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type StatisticCountAggregateInputType = {
    id?: true
    pv?: true
    attack?: true
    defense?: true
    specialAttack?: true
    specialDefense?: true
    special?: true
    speed?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type StatisticAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statistic to aggregate.
     */
    where?: statisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statistics to fetch.
     */
    orderBy?: statisticOrderByWithRelationInput | statisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: statisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned statistics
    **/
    _count?: true | StatisticCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatisticAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatisticSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatisticMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatisticMaxAggregateInputType
  }

  export type GetStatisticAggregateType<T extends StatisticAggregateArgs> = {
        [P in keyof T & keyof AggregateStatistic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatistic[P]>
      : GetScalarType<T[P], AggregateStatistic[P]>
  }




  export type statisticGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: statisticWhereInput
    orderBy?: statisticOrderByWithAggregationInput | statisticOrderByWithAggregationInput[]
    by: StatisticScalarFieldEnum[] | StatisticScalarFieldEnum
    having?: statisticScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatisticCountAggregateInputType | true
    _avg?: StatisticAvgAggregateInputType
    _sum?: StatisticSumAggregateInputType
    _min?: StatisticMinAggregateInputType
    _max?: StatisticMaxAggregateInputType
  }

  export type StatisticGroupByOutputType = {
    id: number
    pv: number
    attack: number
    defense: number
    specialAttack: number | null
    specialDefense: number | null
    special: number | null
    speed: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: StatisticCountAggregateOutputType | null
    _avg: StatisticAvgAggregateOutputType | null
    _sum: StatisticSumAggregateOutputType | null
    _min: StatisticMinAggregateOutputType | null
    _max: StatisticMaxAggregateOutputType | null
  }

  type GetStatisticGroupByPayload<T extends statisticGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatisticGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatisticGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatisticGroupByOutputType[P]>
            : GetScalarType<T[P], StatisticGroupByOutputType[P]>
        }
      >
    >


  export type statisticSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pv?: boolean
    attack?: boolean
    defense?: boolean
    specialAttack?: boolean
    specialDefense?: boolean
    special?: boolean
    speed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    statisticGroupGames?: boolean | statistic$statisticGroupGamesArgs<ExtArgs>
    _count?: boolean | StatisticCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statistic"]>



  export type statisticSelectScalar = {
    id?: boolean
    pv?: boolean
    attack?: boolean
    defense?: boolean
    specialAttack?: boolean
    specialDefense?: boolean
    special?: boolean
    speed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type statisticOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pv" | "attack" | "defense" | "specialAttack" | "specialDefense" | "special" | "speed" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["statistic"]>
  export type statisticInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    statisticGroupGames?: boolean | statistic$statisticGroupGamesArgs<ExtArgs>
    _count?: boolean | StatisticCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $statisticPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "statistic"
    objects: {
      statisticGroupGames: Prisma.$statistic_group_gamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pv: number
      attack: number
      defense: number
      specialAttack: number | null
      specialDefense: number | null
      special: number | null
      speed: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["statistic"]>
    composites: {}
  }

  type statisticGetPayload<S extends boolean | null | undefined | statisticDefaultArgs> = $Result.GetResult<Prisma.$statisticPayload, S>

  type statisticCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<statisticFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatisticCountAggregateInputType | true
    }

  export interface statisticDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['statistic'], meta: { name: 'statistic' } }
    /**
     * Find zero or one Statistic that matches the filter.
     * @param {statisticFindUniqueArgs} args - Arguments to find a Statistic
     * @example
     * // Get one Statistic
     * const statistic = await prisma.statistic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends statisticFindUniqueArgs>(args: SelectSubset<T, statisticFindUniqueArgs<ExtArgs>>): Prisma__statisticClient<$Result.GetResult<Prisma.$statisticPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Statistic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {statisticFindUniqueOrThrowArgs} args - Arguments to find a Statistic
     * @example
     * // Get one Statistic
     * const statistic = await prisma.statistic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends statisticFindUniqueOrThrowArgs>(args: SelectSubset<T, statisticFindUniqueOrThrowArgs<ExtArgs>>): Prisma__statisticClient<$Result.GetResult<Prisma.$statisticPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Statistic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statisticFindFirstArgs} args - Arguments to find a Statistic
     * @example
     * // Get one Statistic
     * const statistic = await prisma.statistic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends statisticFindFirstArgs>(args?: SelectSubset<T, statisticFindFirstArgs<ExtArgs>>): Prisma__statisticClient<$Result.GetResult<Prisma.$statisticPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Statistic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statisticFindFirstOrThrowArgs} args - Arguments to find a Statistic
     * @example
     * // Get one Statistic
     * const statistic = await prisma.statistic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends statisticFindFirstOrThrowArgs>(args?: SelectSubset<T, statisticFindFirstOrThrowArgs<ExtArgs>>): Prisma__statisticClient<$Result.GetResult<Prisma.$statisticPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Statistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statisticFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statistics
     * const statistics = await prisma.statistic.findMany()
     * 
     * // Get first 10 Statistics
     * const statistics = await prisma.statistic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statisticWithIdOnly = await prisma.statistic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends statisticFindManyArgs>(args?: SelectSubset<T, statisticFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statisticPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Statistic.
     * @param {statisticCreateArgs} args - Arguments to create a Statistic.
     * @example
     * // Create one Statistic
     * const Statistic = await prisma.statistic.create({
     *   data: {
     *     // ... data to create a Statistic
     *   }
     * })
     * 
     */
    create<T extends statisticCreateArgs>(args: SelectSubset<T, statisticCreateArgs<ExtArgs>>): Prisma__statisticClient<$Result.GetResult<Prisma.$statisticPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Statistics.
     * @param {statisticCreateManyArgs} args - Arguments to create many Statistics.
     * @example
     * // Create many Statistics
     * const statistic = await prisma.statistic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends statisticCreateManyArgs>(args?: SelectSubset<T, statisticCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Statistic.
     * @param {statisticDeleteArgs} args - Arguments to delete one Statistic.
     * @example
     * // Delete one Statistic
     * const Statistic = await prisma.statistic.delete({
     *   where: {
     *     // ... filter to delete one Statistic
     *   }
     * })
     * 
     */
    delete<T extends statisticDeleteArgs>(args: SelectSubset<T, statisticDeleteArgs<ExtArgs>>): Prisma__statisticClient<$Result.GetResult<Prisma.$statisticPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Statistic.
     * @param {statisticUpdateArgs} args - Arguments to update one Statistic.
     * @example
     * // Update one Statistic
     * const statistic = await prisma.statistic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends statisticUpdateArgs>(args: SelectSubset<T, statisticUpdateArgs<ExtArgs>>): Prisma__statisticClient<$Result.GetResult<Prisma.$statisticPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Statistics.
     * @param {statisticDeleteManyArgs} args - Arguments to filter Statistics to delete.
     * @example
     * // Delete a few Statistics
     * const { count } = await prisma.statistic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends statisticDeleteManyArgs>(args?: SelectSubset<T, statisticDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statisticUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statistics
     * const statistic = await prisma.statistic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends statisticUpdateManyArgs>(args: SelectSubset<T, statisticUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Statistic.
     * @param {statisticUpsertArgs} args - Arguments to update or create a Statistic.
     * @example
     * // Update or create a Statistic
     * const statistic = await prisma.statistic.upsert({
     *   create: {
     *     // ... data to create a Statistic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Statistic we want to update
     *   }
     * })
     */
    upsert<T extends statisticUpsertArgs>(args: SelectSubset<T, statisticUpsertArgs<ExtArgs>>): Prisma__statisticClient<$Result.GetResult<Prisma.$statisticPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Statistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statisticCountArgs} args - Arguments to filter Statistics to count.
     * @example
     * // Count the number of Statistics
     * const count = await prisma.statistic.count({
     *   where: {
     *     // ... the filter for the Statistics we want to count
     *   }
     * })
    **/
    count<T extends statisticCountArgs>(
      args?: Subset<T, statisticCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatisticCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Statistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatisticAggregateArgs>(args: Subset<T, StatisticAggregateArgs>): Prisma.PrismaPromise<GetStatisticAggregateType<T>>

    /**
     * Group by Statistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statisticGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends statisticGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: statisticGroupByArgs['orderBy'] }
        : { orderBy?: statisticGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, statisticGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatisticGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the statistic model
   */
  readonly fields: statisticFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for statistic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__statisticClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    statisticGroupGames<T extends statistic$statisticGroupGamesArgs<ExtArgs> = {}>(args?: Subset<T, statistic$statisticGroupGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statistic_group_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the statistic model
   */
  interface statisticFieldRefs {
    readonly id: FieldRef<"statistic", 'Int'>
    readonly pv: FieldRef<"statistic", 'Int'>
    readonly attack: FieldRef<"statistic", 'Int'>
    readonly defense: FieldRef<"statistic", 'Int'>
    readonly specialAttack: FieldRef<"statistic", 'Int'>
    readonly specialDefense: FieldRef<"statistic", 'Int'>
    readonly special: FieldRef<"statistic", 'Int'>
    readonly speed: FieldRef<"statistic", 'Int'>
    readonly createdAt: FieldRef<"statistic", 'DateTime'>
    readonly updatedAt: FieldRef<"statistic", 'DateTime'>
    readonly status: FieldRef<"statistic", 'String'>
  }
    

  // Custom InputTypes
  /**
   * statistic findUnique
   */
  export type statisticFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic
     */
    select?: statisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic
     */
    omit?: statisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statisticInclude<ExtArgs> | null
    /**
     * Filter, which statistic to fetch.
     */
    where: statisticWhereUniqueInput
  }

  /**
   * statistic findUniqueOrThrow
   */
  export type statisticFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic
     */
    select?: statisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic
     */
    omit?: statisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statisticInclude<ExtArgs> | null
    /**
     * Filter, which statistic to fetch.
     */
    where: statisticWhereUniqueInput
  }

  /**
   * statistic findFirst
   */
  export type statisticFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic
     */
    select?: statisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic
     */
    omit?: statisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statisticInclude<ExtArgs> | null
    /**
     * Filter, which statistic to fetch.
     */
    where?: statisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statistics to fetch.
     */
    orderBy?: statisticOrderByWithRelationInput | statisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statistics.
     */
    cursor?: statisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statistics.
     */
    distinct?: StatisticScalarFieldEnum | StatisticScalarFieldEnum[]
  }

  /**
   * statistic findFirstOrThrow
   */
  export type statisticFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic
     */
    select?: statisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic
     */
    omit?: statisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statisticInclude<ExtArgs> | null
    /**
     * Filter, which statistic to fetch.
     */
    where?: statisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statistics to fetch.
     */
    orderBy?: statisticOrderByWithRelationInput | statisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statistics.
     */
    cursor?: statisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statistics.
     */
    distinct?: StatisticScalarFieldEnum | StatisticScalarFieldEnum[]
  }

  /**
   * statistic findMany
   */
  export type statisticFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic
     */
    select?: statisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic
     */
    omit?: statisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statisticInclude<ExtArgs> | null
    /**
     * Filter, which statistics to fetch.
     */
    where?: statisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statistics to fetch.
     */
    orderBy?: statisticOrderByWithRelationInput | statisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing statistics.
     */
    cursor?: statisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statistics.
     */
    skip?: number
    distinct?: StatisticScalarFieldEnum | StatisticScalarFieldEnum[]
  }

  /**
   * statistic create
   */
  export type statisticCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic
     */
    select?: statisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic
     */
    omit?: statisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statisticInclude<ExtArgs> | null
    /**
     * The data needed to create a statistic.
     */
    data: XOR<statisticCreateInput, statisticUncheckedCreateInput>
  }

  /**
   * statistic createMany
   */
  export type statisticCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many statistics.
     */
    data: statisticCreateManyInput | statisticCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * statistic update
   */
  export type statisticUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic
     */
    select?: statisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic
     */
    omit?: statisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statisticInclude<ExtArgs> | null
    /**
     * The data needed to update a statistic.
     */
    data: XOR<statisticUpdateInput, statisticUncheckedUpdateInput>
    /**
     * Choose, which statistic to update.
     */
    where: statisticWhereUniqueInput
  }

  /**
   * statistic updateMany
   */
  export type statisticUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update statistics.
     */
    data: XOR<statisticUpdateManyMutationInput, statisticUncheckedUpdateManyInput>
    /**
     * Filter which statistics to update
     */
    where?: statisticWhereInput
    /**
     * Limit how many statistics to update.
     */
    limit?: number
  }

  /**
   * statistic upsert
   */
  export type statisticUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic
     */
    select?: statisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic
     */
    omit?: statisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statisticInclude<ExtArgs> | null
    /**
     * The filter to search for the statistic to update in case it exists.
     */
    where: statisticWhereUniqueInput
    /**
     * In case the statistic found by the `where` argument doesn't exist, create a new statistic with this data.
     */
    create: XOR<statisticCreateInput, statisticUncheckedCreateInput>
    /**
     * In case the statistic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<statisticUpdateInput, statisticUncheckedUpdateInput>
  }

  /**
   * statistic delete
   */
  export type statisticDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic
     */
    select?: statisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic
     */
    omit?: statisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statisticInclude<ExtArgs> | null
    /**
     * Filter which statistic to delete.
     */
    where: statisticWhereUniqueInput
  }

  /**
   * statistic deleteMany
   */
  export type statisticDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statistics to delete
     */
    where?: statisticWhereInput
    /**
     * Limit how many statistics to delete.
     */
    limit?: number
  }

  /**
   * statistic.statisticGroupGames
   */
  export type statistic$statisticGroupGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic_group_game
     */
    select?: statistic_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic_group_game
     */
    omit?: statistic_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statistic_group_gameInclude<ExtArgs> | null
    where?: statistic_group_gameWhereInput
    orderBy?: statistic_group_gameOrderByWithRelationInput | statistic_group_gameOrderByWithRelationInput[]
    cursor?: statistic_group_gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Statistic_group_gameScalarFieldEnum | Statistic_group_gameScalarFieldEnum[]
  }

  /**
   * statistic without action
   */
  export type statisticDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic
     */
    select?: statisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic
     */
    omit?: statisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statisticInclude<ExtArgs> | null
  }


  /**
   * Model statistic_group_game
   */

  export type AggregateStatistic_group_game = {
    _count: Statistic_group_gameCountAggregateOutputType | null
    _avg: Statistic_group_gameAvgAggregateOutputType | null
    _sum: Statistic_group_gameSumAggregateOutputType | null
    _min: Statistic_group_gameMinAggregateOutputType | null
    _max: Statistic_group_gameMaxAggregateOutputType | null
  }

  export type Statistic_group_gameAvgAggregateOutputType = {
    groupGameId: number | null
    pokemonId: number | null
    statisticId: number | null
  }

  export type Statistic_group_gameSumAggregateOutputType = {
    groupGameId: number | null
    pokemonId: number | null
    statisticId: number | null
  }

  export type Statistic_group_gameMinAggregateOutputType = {
    groupGameId: number | null
    pokemonId: number | null
    statisticId: number | null
  }

  export type Statistic_group_gameMaxAggregateOutputType = {
    groupGameId: number | null
    pokemonId: number | null
    statisticId: number | null
  }

  export type Statistic_group_gameCountAggregateOutputType = {
    groupGameId: number
    pokemonId: number
    statisticId: number
    _all: number
  }


  export type Statistic_group_gameAvgAggregateInputType = {
    groupGameId?: true
    pokemonId?: true
    statisticId?: true
  }

  export type Statistic_group_gameSumAggregateInputType = {
    groupGameId?: true
    pokemonId?: true
    statisticId?: true
  }

  export type Statistic_group_gameMinAggregateInputType = {
    groupGameId?: true
    pokemonId?: true
    statisticId?: true
  }

  export type Statistic_group_gameMaxAggregateInputType = {
    groupGameId?: true
    pokemonId?: true
    statisticId?: true
  }

  export type Statistic_group_gameCountAggregateInputType = {
    groupGameId?: true
    pokemonId?: true
    statisticId?: true
    _all?: true
  }

  export type Statistic_group_gameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statistic_group_game to aggregate.
     */
    where?: statistic_group_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statistic_group_games to fetch.
     */
    orderBy?: statistic_group_gameOrderByWithRelationInput | statistic_group_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: statistic_group_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statistic_group_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statistic_group_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned statistic_group_games
    **/
    _count?: true | Statistic_group_gameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Statistic_group_gameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Statistic_group_gameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Statistic_group_gameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Statistic_group_gameMaxAggregateInputType
  }

  export type GetStatistic_group_gameAggregateType<T extends Statistic_group_gameAggregateArgs> = {
        [P in keyof T & keyof AggregateStatistic_group_game]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatistic_group_game[P]>
      : GetScalarType<T[P], AggregateStatistic_group_game[P]>
  }




  export type statistic_group_gameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: statistic_group_gameWhereInput
    orderBy?: statistic_group_gameOrderByWithAggregationInput | statistic_group_gameOrderByWithAggregationInput[]
    by: Statistic_group_gameScalarFieldEnum[] | Statistic_group_gameScalarFieldEnum
    having?: statistic_group_gameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Statistic_group_gameCountAggregateInputType | true
    _avg?: Statistic_group_gameAvgAggregateInputType
    _sum?: Statistic_group_gameSumAggregateInputType
    _min?: Statistic_group_gameMinAggregateInputType
    _max?: Statistic_group_gameMaxAggregateInputType
  }

  export type Statistic_group_gameGroupByOutputType = {
    groupGameId: number
    pokemonId: number
    statisticId: number
    _count: Statistic_group_gameCountAggregateOutputType | null
    _avg: Statistic_group_gameAvgAggregateOutputType | null
    _sum: Statistic_group_gameSumAggregateOutputType | null
    _min: Statistic_group_gameMinAggregateOutputType | null
    _max: Statistic_group_gameMaxAggregateOutputType | null
  }

  type GetStatistic_group_gameGroupByPayload<T extends statistic_group_gameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Statistic_group_gameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Statistic_group_gameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Statistic_group_gameGroupByOutputType[P]>
            : GetScalarType<T[P], Statistic_group_gameGroupByOutputType[P]>
        }
      >
    >


  export type statistic_group_gameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    groupGameId?: boolean
    pokemonId?: boolean
    statisticId?: boolean
    groupGame?: boolean | group_gameDefaultArgs<ExtArgs>
    pokemon?: boolean | pokemonDefaultArgs<ExtArgs>
    statistic?: boolean | statisticDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statistic_group_game"]>



  export type statistic_group_gameSelectScalar = {
    groupGameId?: boolean
    pokemonId?: boolean
    statisticId?: boolean
  }

  export type statistic_group_gameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"groupGameId" | "pokemonId" | "statisticId", ExtArgs["result"]["statistic_group_game"]>
  export type statistic_group_gameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupGame?: boolean | group_gameDefaultArgs<ExtArgs>
    pokemon?: boolean | pokemonDefaultArgs<ExtArgs>
    statistic?: boolean | statisticDefaultArgs<ExtArgs>
  }

  export type $statistic_group_gamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "statistic_group_game"
    objects: {
      groupGame: Prisma.$group_gamePayload<ExtArgs>
      pokemon: Prisma.$pokemonPayload<ExtArgs>
      statistic: Prisma.$statisticPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      groupGameId: number
      pokemonId: number
      statisticId: number
    }, ExtArgs["result"]["statistic_group_game"]>
    composites: {}
  }

  type statistic_group_gameGetPayload<S extends boolean | null | undefined | statistic_group_gameDefaultArgs> = $Result.GetResult<Prisma.$statistic_group_gamePayload, S>

  type statistic_group_gameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<statistic_group_gameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Statistic_group_gameCountAggregateInputType | true
    }

  export interface statistic_group_gameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['statistic_group_game'], meta: { name: 'statistic_group_game' } }
    /**
     * Find zero or one Statistic_group_game that matches the filter.
     * @param {statistic_group_gameFindUniqueArgs} args - Arguments to find a Statistic_group_game
     * @example
     * // Get one Statistic_group_game
     * const statistic_group_game = await prisma.statistic_group_game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends statistic_group_gameFindUniqueArgs>(args: SelectSubset<T, statistic_group_gameFindUniqueArgs<ExtArgs>>): Prisma__statistic_group_gameClient<$Result.GetResult<Prisma.$statistic_group_gamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Statistic_group_game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {statistic_group_gameFindUniqueOrThrowArgs} args - Arguments to find a Statistic_group_game
     * @example
     * // Get one Statistic_group_game
     * const statistic_group_game = await prisma.statistic_group_game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends statistic_group_gameFindUniqueOrThrowArgs>(args: SelectSubset<T, statistic_group_gameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__statistic_group_gameClient<$Result.GetResult<Prisma.$statistic_group_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Statistic_group_game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statistic_group_gameFindFirstArgs} args - Arguments to find a Statistic_group_game
     * @example
     * // Get one Statistic_group_game
     * const statistic_group_game = await prisma.statistic_group_game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends statistic_group_gameFindFirstArgs>(args?: SelectSubset<T, statistic_group_gameFindFirstArgs<ExtArgs>>): Prisma__statistic_group_gameClient<$Result.GetResult<Prisma.$statistic_group_gamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Statistic_group_game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statistic_group_gameFindFirstOrThrowArgs} args - Arguments to find a Statistic_group_game
     * @example
     * // Get one Statistic_group_game
     * const statistic_group_game = await prisma.statistic_group_game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends statistic_group_gameFindFirstOrThrowArgs>(args?: SelectSubset<T, statistic_group_gameFindFirstOrThrowArgs<ExtArgs>>): Prisma__statistic_group_gameClient<$Result.GetResult<Prisma.$statistic_group_gamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Statistic_group_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statistic_group_gameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statistic_group_games
     * const statistic_group_games = await prisma.statistic_group_game.findMany()
     * 
     * // Get first 10 Statistic_group_games
     * const statistic_group_games = await prisma.statistic_group_game.findMany({ take: 10 })
     * 
     * // Only select the `groupGameId`
     * const statistic_group_gameWithGroupGameIdOnly = await prisma.statistic_group_game.findMany({ select: { groupGameId: true } })
     * 
     */
    findMany<T extends statistic_group_gameFindManyArgs>(args?: SelectSubset<T, statistic_group_gameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statistic_group_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Statistic_group_game.
     * @param {statistic_group_gameCreateArgs} args - Arguments to create a Statistic_group_game.
     * @example
     * // Create one Statistic_group_game
     * const Statistic_group_game = await prisma.statistic_group_game.create({
     *   data: {
     *     // ... data to create a Statistic_group_game
     *   }
     * })
     * 
     */
    create<T extends statistic_group_gameCreateArgs>(args: SelectSubset<T, statistic_group_gameCreateArgs<ExtArgs>>): Prisma__statistic_group_gameClient<$Result.GetResult<Prisma.$statistic_group_gamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Statistic_group_games.
     * @param {statistic_group_gameCreateManyArgs} args - Arguments to create many Statistic_group_games.
     * @example
     * // Create many Statistic_group_games
     * const statistic_group_game = await prisma.statistic_group_game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends statistic_group_gameCreateManyArgs>(args?: SelectSubset<T, statistic_group_gameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Statistic_group_game.
     * @param {statistic_group_gameDeleteArgs} args - Arguments to delete one Statistic_group_game.
     * @example
     * // Delete one Statistic_group_game
     * const Statistic_group_game = await prisma.statistic_group_game.delete({
     *   where: {
     *     // ... filter to delete one Statistic_group_game
     *   }
     * })
     * 
     */
    delete<T extends statistic_group_gameDeleteArgs>(args: SelectSubset<T, statistic_group_gameDeleteArgs<ExtArgs>>): Prisma__statistic_group_gameClient<$Result.GetResult<Prisma.$statistic_group_gamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Statistic_group_game.
     * @param {statistic_group_gameUpdateArgs} args - Arguments to update one Statistic_group_game.
     * @example
     * // Update one Statistic_group_game
     * const statistic_group_game = await prisma.statistic_group_game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends statistic_group_gameUpdateArgs>(args: SelectSubset<T, statistic_group_gameUpdateArgs<ExtArgs>>): Prisma__statistic_group_gameClient<$Result.GetResult<Prisma.$statistic_group_gamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Statistic_group_games.
     * @param {statistic_group_gameDeleteManyArgs} args - Arguments to filter Statistic_group_games to delete.
     * @example
     * // Delete a few Statistic_group_games
     * const { count } = await prisma.statistic_group_game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends statistic_group_gameDeleteManyArgs>(args?: SelectSubset<T, statistic_group_gameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statistic_group_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statistic_group_gameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statistic_group_games
     * const statistic_group_game = await prisma.statistic_group_game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends statistic_group_gameUpdateManyArgs>(args: SelectSubset<T, statistic_group_gameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Statistic_group_game.
     * @param {statistic_group_gameUpsertArgs} args - Arguments to update or create a Statistic_group_game.
     * @example
     * // Update or create a Statistic_group_game
     * const statistic_group_game = await prisma.statistic_group_game.upsert({
     *   create: {
     *     // ... data to create a Statistic_group_game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Statistic_group_game we want to update
     *   }
     * })
     */
    upsert<T extends statistic_group_gameUpsertArgs>(args: SelectSubset<T, statistic_group_gameUpsertArgs<ExtArgs>>): Prisma__statistic_group_gameClient<$Result.GetResult<Prisma.$statistic_group_gamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Statistic_group_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statistic_group_gameCountArgs} args - Arguments to filter Statistic_group_games to count.
     * @example
     * // Count the number of Statistic_group_games
     * const count = await prisma.statistic_group_game.count({
     *   where: {
     *     // ... the filter for the Statistic_group_games we want to count
     *   }
     * })
    **/
    count<T extends statistic_group_gameCountArgs>(
      args?: Subset<T, statistic_group_gameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Statistic_group_gameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Statistic_group_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Statistic_group_gameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Statistic_group_gameAggregateArgs>(args: Subset<T, Statistic_group_gameAggregateArgs>): Prisma.PrismaPromise<GetStatistic_group_gameAggregateType<T>>

    /**
     * Group by Statistic_group_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statistic_group_gameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends statistic_group_gameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: statistic_group_gameGroupByArgs['orderBy'] }
        : { orderBy?: statistic_group_gameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, statistic_group_gameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatistic_group_gameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the statistic_group_game model
   */
  readonly fields: statistic_group_gameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for statistic_group_game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__statistic_group_gameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    groupGame<T extends group_gameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, group_gameDefaultArgs<ExtArgs>>): Prisma__group_gameClient<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemon<T extends pokemonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemonDefaultArgs<ExtArgs>>): Prisma__pokemonClient<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    statistic<T extends statisticDefaultArgs<ExtArgs> = {}>(args?: Subset<T, statisticDefaultArgs<ExtArgs>>): Prisma__statisticClient<$Result.GetResult<Prisma.$statisticPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the statistic_group_game model
   */
  interface statistic_group_gameFieldRefs {
    readonly groupGameId: FieldRef<"statistic_group_game", 'Int'>
    readonly pokemonId: FieldRef<"statistic_group_game", 'Int'>
    readonly statisticId: FieldRef<"statistic_group_game", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * statistic_group_game findUnique
   */
  export type statistic_group_gameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic_group_game
     */
    select?: statistic_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic_group_game
     */
    omit?: statistic_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statistic_group_gameInclude<ExtArgs> | null
    /**
     * Filter, which statistic_group_game to fetch.
     */
    where: statistic_group_gameWhereUniqueInput
  }

  /**
   * statistic_group_game findUniqueOrThrow
   */
  export type statistic_group_gameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic_group_game
     */
    select?: statistic_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic_group_game
     */
    omit?: statistic_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statistic_group_gameInclude<ExtArgs> | null
    /**
     * Filter, which statistic_group_game to fetch.
     */
    where: statistic_group_gameWhereUniqueInput
  }

  /**
   * statistic_group_game findFirst
   */
  export type statistic_group_gameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic_group_game
     */
    select?: statistic_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic_group_game
     */
    omit?: statistic_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statistic_group_gameInclude<ExtArgs> | null
    /**
     * Filter, which statistic_group_game to fetch.
     */
    where?: statistic_group_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statistic_group_games to fetch.
     */
    orderBy?: statistic_group_gameOrderByWithRelationInput | statistic_group_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statistic_group_games.
     */
    cursor?: statistic_group_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statistic_group_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statistic_group_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statistic_group_games.
     */
    distinct?: Statistic_group_gameScalarFieldEnum | Statistic_group_gameScalarFieldEnum[]
  }

  /**
   * statistic_group_game findFirstOrThrow
   */
  export type statistic_group_gameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic_group_game
     */
    select?: statistic_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic_group_game
     */
    omit?: statistic_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statistic_group_gameInclude<ExtArgs> | null
    /**
     * Filter, which statistic_group_game to fetch.
     */
    where?: statistic_group_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statistic_group_games to fetch.
     */
    orderBy?: statistic_group_gameOrderByWithRelationInput | statistic_group_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statistic_group_games.
     */
    cursor?: statistic_group_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statistic_group_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statistic_group_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statistic_group_games.
     */
    distinct?: Statistic_group_gameScalarFieldEnum | Statistic_group_gameScalarFieldEnum[]
  }

  /**
   * statistic_group_game findMany
   */
  export type statistic_group_gameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic_group_game
     */
    select?: statistic_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic_group_game
     */
    omit?: statistic_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statistic_group_gameInclude<ExtArgs> | null
    /**
     * Filter, which statistic_group_games to fetch.
     */
    where?: statistic_group_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statistic_group_games to fetch.
     */
    orderBy?: statistic_group_gameOrderByWithRelationInput | statistic_group_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing statistic_group_games.
     */
    cursor?: statistic_group_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statistic_group_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statistic_group_games.
     */
    skip?: number
    distinct?: Statistic_group_gameScalarFieldEnum | Statistic_group_gameScalarFieldEnum[]
  }

  /**
   * statistic_group_game create
   */
  export type statistic_group_gameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic_group_game
     */
    select?: statistic_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic_group_game
     */
    omit?: statistic_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statistic_group_gameInclude<ExtArgs> | null
    /**
     * The data needed to create a statistic_group_game.
     */
    data: XOR<statistic_group_gameCreateInput, statistic_group_gameUncheckedCreateInput>
  }

  /**
   * statistic_group_game createMany
   */
  export type statistic_group_gameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many statistic_group_games.
     */
    data: statistic_group_gameCreateManyInput | statistic_group_gameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * statistic_group_game update
   */
  export type statistic_group_gameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic_group_game
     */
    select?: statistic_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic_group_game
     */
    omit?: statistic_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statistic_group_gameInclude<ExtArgs> | null
    /**
     * The data needed to update a statistic_group_game.
     */
    data: XOR<statistic_group_gameUpdateInput, statistic_group_gameUncheckedUpdateInput>
    /**
     * Choose, which statistic_group_game to update.
     */
    where: statistic_group_gameWhereUniqueInput
  }

  /**
   * statistic_group_game updateMany
   */
  export type statistic_group_gameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update statistic_group_games.
     */
    data: XOR<statistic_group_gameUpdateManyMutationInput, statistic_group_gameUncheckedUpdateManyInput>
    /**
     * Filter which statistic_group_games to update
     */
    where?: statistic_group_gameWhereInput
    /**
     * Limit how many statistic_group_games to update.
     */
    limit?: number
  }

  /**
   * statistic_group_game upsert
   */
  export type statistic_group_gameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic_group_game
     */
    select?: statistic_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic_group_game
     */
    omit?: statistic_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statistic_group_gameInclude<ExtArgs> | null
    /**
     * The filter to search for the statistic_group_game to update in case it exists.
     */
    where: statistic_group_gameWhereUniqueInput
    /**
     * In case the statistic_group_game found by the `where` argument doesn't exist, create a new statistic_group_game with this data.
     */
    create: XOR<statistic_group_gameCreateInput, statistic_group_gameUncheckedCreateInput>
    /**
     * In case the statistic_group_game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<statistic_group_gameUpdateInput, statistic_group_gameUncheckedUpdateInput>
  }

  /**
   * statistic_group_game delete
   */
  export type statistic_group_gameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic_group_game
     */
    select?: statistic_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic_group_game
     */
    omit?: statistic_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statistic_group_gameInclude<ExtArgs> | null
    /**
     * Filter which statistic_group_game to delete.
     */
    where: statistic_group_gameWhereUniqueInput
  }

  /**
   * statistic_group_game deleteMany
   */
  export type statistic_group_gameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statistic_group_games to delete
     */
    where?: statistic_group_gameWhereInput
    /**
     * Limit how many statistic_group_games to delete.
     */
    limit?: number
  }

  /**
   * statistic_group_game without action
   */
  export type statistic_group_gameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistic_group_game
     */
    select?: statistic_group_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statistic_group_game
     */
    omit?: statistic_group_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statistic_group_gameInclude<ExtArgs> | null
  }


  /**
   * Model target
   */

  export type AggregateTarget = {
    _count: TargetCountAggregateOutputType | null
    _avg: TargetAvgAggregateOutputType | null
    _sum: TargetSumAggregateOutputType | null
    _min: TargetMinAggregateOutputType | null
    _max: TargetMaxAggregateOutputType | null
  }

  export type TargetAvgAggregateOutputType = {
    id: number | null
  }

  export type TargetSumAggregateOutputType = {
    id: number | null
  }

  export type TargetMinAggregateOutputType = {
    id: number | null
    isMultiple: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type TargetMaxAggregateOutputType = {
    id: number | null
    isMultiple: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type TargetCountAggregateOutputType = {
    id: number
    isMultiple: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type TargetAvgAggregateInputType = {
    id?: true
  }

  export type TargetSumAggregateInputType = {
    id?: true
  }

  export type TargetMinAggregateInputType = {
    id?: true
    isMultiple?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type TargetMaxAggregateInputType = {
    id?: true
    isMultiple?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type TargetCountAggregateInputType = {
    id?: true
    isMultiple?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type TargetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which target to aggregate.
     */
    where?: targetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of targets to fetch.
     */
    orderBy?: targetOrderByWithRelationInput | targetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: targetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` targets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned targets
    **/
    _count?: true | TargetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TargetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TargetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TargetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TargetMaxAggregateInputType
  }

  export type GetTargetAggregateType<T extends TargetAggregateArgs> = {
        [P in keyof T & keyof AggregateTarget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTarget[P]>
      : GetScalarType<T[P], AggregateTarget[P]>
  }




  export type targetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: targetWhereInput
    orderBy?: targetOrderByWithAggregationInput | targetOrderByWithAggregationInput[]
    by: TargetScalarFieldEnum[] | TargetScalarFieldEnum
    having?: targetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TargetCountAggregateInputType | true
    _avg?: TargetAvgAggregateInputType
    _sum?: TargetSumAggregateInputType
    _min?: TargetMinAggregateInputType
    _max?: TargetMaxAggregateInputType
  }

  export type TargetGroupByOutputType = {
    id: number
    isMultiple: boolean
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: TargetCountAggregateOutputType | null
    _avg: TargetAvgAggregateOutputType | null
    _sum: TargetSumAggregateOutputType | null
    _min: TargetMinAggregateOutputType | null
    _max: TargetMaxAggregateOutputType | null
  }

  type GetTargetGroupByPayload<T extends targetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TargetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TargetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TargetGroupByOutputType[P]>
            : GetScalarType<T[P], TargetGroupByOutputType[P]>
        }
      >
    >


  export type targetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isMultiple?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    capacityInfos?: boolean | target$capacityInfosArgs<ExtArgs>
    _count?: boolean | TargetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["target"]>



  export type targetSelectScalar = {
    id?: boolean
    isMultiple?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type targetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isMultiple" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["target"]>
  export type targetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfos?: boolean | target$capacityInfosArgs<ExtArgs>
    _count?: boolean | TargetCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $targetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "target"
    objects: {
      capacityInfos: Prisma.$capacity_infoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      isMultiple: boolean
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["target"]>
    composites: {}
  }

  type targetGetPayload<S extends boolean | null | undefined | targetDefaultArgs> = $Result.GetResult<Prisma.$targetPayload, S>

  type targetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<targetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TargetCountAggregateInputType | true
    }

  export interface targetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['target'], meta: { name: 'target' } }
    /**
     * Find zero or one Target that matches the filter.
     * @param {targetFindUniqueArgs} args - Arguments to find a Target
     * @example
     * // Get one Target
     * const target = await prisma.target.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends targetFindUniqueArgs>(args: SelectSubset<T, targetFindUniqueArgs<ExtArgs>>): Prisma__targetClient<$Result.GetResult<Prisma.$targetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Target that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {targetFindUniqueOrThrowArgs} args - Arguments to find a Target
     * @example
     * // Get one Target
     * const target = await prisma.target.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends targetFindUniqueOrThrowArgs>(args: SelectSubset<T, targetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__targetClient<$Result.GetResult<Prisma.$targetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Target that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {targetFindFirstArgs} args - Arguments to find a Target
     * @example
     * // Get one Target
     * const target = await prisma.target.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends targetFindFirstArgs>(args?: SelectSubset<T, targetFindFirstArgs<ExtArgs>>): Prisma__targetClient<$Result.GetResult<Prisma.$targetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Target that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {targetFindFirstOrThrowArgs} args - Arguments to find a Target
     * @example
     * // Get one Target
     * const target = await prisma.target.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends targetFindFirstOrThrowArgs>(args?: SelectSubset<T, targetFindFirstOrThrowArgs<ExtArgs>>): Prisma__targetClient<$Result.GetResult<Prisma.$targetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Targets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {targetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Targets
     * const targets = await prisma.target.findMany()
     * 
     * // Get first 10 Targets
     * const targets = await prisma.target.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const targetWithIdOnly = await prisma.target.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends targetFindManyArgs>(args?: SelectSubset<T, targetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$targetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Target.
     * @param {targetCreateArgs} args - Arguments to create a Target.
     * @example
     * // Create one Target
     * const Target = await prisma.target.create({
     *   data: {
     *     // ... data to create a Target
     *   }
     * })
     * 
     */
    create<T extends targetCreateArgs>(args: SelectSubset<T, targetCreateArgs<ExtArgs>>): Prisma__targetClient<$Result.GetResult<Prisma.$targetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Targets.
     * @param {targetCreateManyArgs} args - Arguments to create many Targets.
     * @example
     * // Create many Targets
     * const target = await prisma.target.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends targetCreateManyArgs>(args?: SelectSubset<T, targetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Target.
     * @param {targetDeleteArgs} args - Arguments to delete one Target.
     * @example
     * // Delete one Target
     * const Target = await prisma.target.delete({
     *   where: {
     *     // ... filter to delete one Target
     *   }
     * })
     * 
     */
    delete<T extends targetDeleteArgs>(args: SelectSubset<T, targetDeleteArgs<ExtArgs>>): Prisma__targetClient<$Result.GetResult<Prisma.$targetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Target.
     * @param {targetUpdateArgs} args - Arguments to update one Target.
     * @example
     * // Update one Target
     * const target = await prisma.target.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends targetUpdateArgs>(args: SelectSubset<T, targetUpdateArgs<ExtArgs>>): Prisma__targetClient<$Result.GetResult<Prisma.$targetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Targets.
     * @param {targetDeleteManyArgs} args - Arguments to filter Targets to delete.
     * @example
     * // Delete a few Targets
     * const { count } = await prisma.target.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends targetDeleteManyArgs>(args?: SelectSubset<T, targetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Targets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {targetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Targets
     * const target = await prisma.target.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends targetUpdateManyArgs>(args: SelectSubset<T, targetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Target.
     * @param {targetUpsertArgs} args - Arguments to update or create a Target.
     * @example
     * // Update or create a Target
     * const target = await prisma.target.upsert({
     *   create: {
     *     // ... data to create a Target
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Target we want to update
     *   }
     * })
     */
    upsert<T extends targetUpsertArgs>(args: SelectSubset<T, targetUpsertArgs<ExtArgs>>): Prisma__targetClient<$Result.GetResult<Prisma.$targetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Targets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {targetCountArgs} args - Arguments to filter Targets to count.
     * @example
     * // Count the number of Targets
     * const count = await prisma.target.count({
     *   where: {
     *     // ... the filter for the Targets we want to count
     *   }
     * })
    **/
    count<T extends targetCountArgs>(
      args?: Subset<T, targetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TargetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Target.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TargetAggregateArgs>(args: Subset<T, TargetAggregateArgs>): Prisma.PrismaPromise<GetTargetAggregateType<T>>

    /**
     * Group by Target.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {targetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends targetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: targetGroupByArgs['orderBy'] }
        : { orderBy?: targetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, targetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTargetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the target model
   */
  readonly fields: targetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for target.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__targetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capacityInfos<T extends target$capacityInfosArgs<ExtArgs> = {}>(args?: Subset<T, target$capacityInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the target model
   */
  interface targetFieldRefs {
    readonly id: FieldRef<"target", 'Int'>
    readonly isMultiple: FieldRef<"target", 'Boolean'>
    readonly createdAt: FieldRef<"target", 'DateTime'>
    readonly updatedAt: FieldRef<"target", 'DateTime'>
    readonly status: FieldRef<"target", 'String'>
  }
    

  // Custom InputTypes
  /**
   * target findUnique
   */
  export type targetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the target
     */
    select?: targetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the target
     */
    omit?: targetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: targetInclude<ExtArgs> | null
    /**
     * Filter, which target to fetch.
     */
    where: targetWhereUniqueInput
  }

  /**
   * target findUniqueOrThrow
   */
  export type targetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the target
     */
    select?: targetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the target
     */
    omit?: targetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: targetInclude<ExtArgs> | null
    /**
     * Filter, which target to fetch.
     */
    where: targetWhereUniqueInput
  }

  /**
   * target findFirst
   */
  export type targetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the target
     */
    select?: targetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the target
     */
    omit?: targetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: targetInclude<ExtArgs> | null
    /**
     * Filter, which target to fetch.
     */
    where?: targetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of targets to fetch.
     */
    orderBy?: targetOrderByWithRelationInput | targetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for targets.
     */
    cursor?: targetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` targets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of targets.
     */
    distinct?: TargetScalarFieldEnum | TargetScalarFieldEnum[]
  }

  /**
   * target findFirstOrThrow
   */
  export type targetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the target
     */
    select?: targetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the target
     */
    omit?: targetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: targetInclude<ExtArgs> | null
    /**
     * Filter, which target to fetch.
     */
    where?: targetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of targets to fetch.
     */
    orderBy?: targetOrderByWithRelationInput | targetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for targets.
     */
    cursor?: targetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` targets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of targets.
     */
    distinct?: TargetScalarFieldEnum | TargetScalarFieldEnum[]
  }

  /**
   * target findMany
   */
  export type targetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the target
     */
    select?: targetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the target
     */
    omit?: targetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: targetInclude<ExtArgs> | null
    /**
     * Filter, which targets to fetch.
     */
    where?: targetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of targets to fetch.
     */
    orderBy?: targetOrderByWithRelationInput | targetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing targets.
     */
    cursor?: targetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` targets.
     */
    skip?: number
    distinct?: TargetScalarFieldEnum | TargetScalarFieldEnum[]
  }

  /**
   * target create
   */
  export type targetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the target
     */
    select?: targetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the target
     */
    omit?: targetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: targetInclude<ExtArgs> | null
    /**
     * The data needed to create a target.
     */
    data: XOR<targetCreateInput, targetUncheckedCreateInput>
  }

  /**
   * target createMany
   */
  export type targetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many targets.
     */
    data: targetCreateManyInput | targetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * target update
   */
  export type targetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the target
     */
    select?: targetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the target
     */
    omit?: targetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: targetInclude<ExtArgs> | null
    /**
     * The data needed to update a target.
     */
    data: XOR<targetUpdateInput, targetUncheckedUpdateInput>
    /**
     * Choose, which target to update.
     */
    where: targetWhereUniqueInput
  }

  /**
   * target updateMany
   */
  export type targetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update targets.
     */
    data: XOR<targetUpdateManyMutationInput, targetUncheckedUpdateManyInput>
    /**
     * Filter which targets to update
     */
    where?: targetWhereInput
    /**
     * Limit how many targets to update.
     */
    limit?: number
  }

  /**
   * target upsert
   */
  export type targetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the target
     */
    select?: targetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the target
     */
    omit?: targetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: targetInclude<ExtArgs> | null
    /**
     * The filter to search for the target to update in case it exists.
     */
    where: targetWhereUniqueInput
    /**
     * In case the target found by the `where` argument doesn't exist, create a new target with this data.
     */
    create: XOR<targetCreateInput, targetUncheckedCreateInput>
    /**
     * In case the target was found with the provided `where` argument, update it with this data.
     */
    update: XOR<targetUpdateInput, targetUncheckedUpdateInput>
  }

  /**
   * target delete
   */
  export type targetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the target
     */
    select?: targetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the target
     */
    omit?: targetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: targetInclude<ExtArgs> | null
    /**
     * Filter which target to delete.
     */
    where: targetWhereUniqueInput
  }

  /**
   * target deleteMany
   */
  export type targetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which targets to delete
     */
    where?: targetWhereInput
    /**
     * Limit how many targets to delete.
     */
    limit?: number
  }

  /**
   * target.capacityInfos
   */
  export type target$capacityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    where?: capacity_infoWhereInput
    orderBy?: capacity_infoOrderByWithRelationInput | capacity_infoOrderByWithRelationInput[]
    cursor?: capacity_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Capacity_infoScalarFieldEnum | Capacity_infoScalarFieldEnum[]
  }

  /**
   * target without action
   */
  export type targetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the target
     */
    select?: targetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the target
     */
    omit?: targetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: targetInclude<ExtArgs> | null
  }


  /**
   * Model capacity_info
   */

  export type AggregateCapacity_info = {
    _count: Capacity_infoCountAggregateOutputType | null
    _avg: Capacity_infoAvgAggregateOutputType | null
    _sum: Capacity_infoSumAggregateOutputType | null
    _min: Capacity_infoMinAggregateOutputType | null
    _max: Capacity_infoMaxAggregateOutputType | null
  }

  export type Capacity_infoAvgAggregateOutputType = {
    id: number | null
    power: number | null
    dynamaxPower: number | null
    precision: number | null
    pp: number | null
    targetId: number | null
    capacityEffectId: number | null
    capacityId: number | null
    capacityEffectZId: number | null
    typeId: number | null
    effectOutsideFightId: number | null
    capacityCategoryId: number | null
  }

  export type Capacity_infoSumAggregateOutputType = {
    id: number | null
    power: number | null
    dynamaxPower: number | null
    precision: number | null
    pp: number | null
    targetId: number | null
    capacityEffectId: number | null
    capacityId: number | null
    capacityEffectZId: number | null
    typeId: number | null
    effectOutsideFightId: number | null
    capacityCategoryId: number | null
  }

  export type Capacity_infoMinAggregateOutputType = {
    id: number | null
    power: number | null
    dynamaxPower: number | null
    precision: number | null
    pp: number | null
    hasBacklash: boolean | null
    targetId: number | null
    capacityEffectId: number | null
    capacityId: number | null
    capacityEffectZId: number | null
    typeId: number | null
    effectOutsideFightId: number | null
    capacityCategoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Capacity_infoMaxAggregateOutputType = {
    id: number | null
    power: number | null
    dynamaxPower: number | null
    precision: number | null
    pp: number | null
    hasBacklash: boolean | null
    targetId: number | null
    capacityEffectId: number | null
    capacityId: number | null
    capacityEffectZId: number | null
    typeId: number | null
    effectOutsideFightId: number | null
    capacityCategoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type Capacity_infoCountAggregateOutputType = {
    id: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: number
    targetId: number
    capacityEffectId: number
    capacityId: number
    capacityEffectZId: number
    typeId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type Capacity_infoAvgAggregateInputType = {
    id?: true
    power?: true
    dynamaxPower?: true
    precision?: true
    pp?: true
    targetId?: true
    capacityEffectId?: true
    capacityId?: true
    capacityEffectZId?: true
    typeId?: true
    effectOutsideFightId?: true
    capacityCategoryId?: true
  }

  export type Capacity_infoSumAggregateInputType = {
    id?: true
    power?: true
    dynamaxPower?: true
    precision?: true
    pp?: true
    targetId?: true
    capacityEffectId?: true
    capacityId?: true
    capacityEffectZId?: true
    typeId?: true
    effectOutsideFightId?: true
    capacityCategoryId?: true
  }

  export type Capacity_infoMinAggregateInputType = {
    id?: true
    power?: true
    dynamaxPower?: true
    precision?: true
    pp?: true
    hasBacklash?: true
    targetId?: true
    capacityEffectId?: true
    capacityId?: true
    capacityEffectZId?: true
    typeId?: true
    effectOutsideFightId?: true
    capacityCategoryId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Capacity_infoMaxAggregateInputType = {
    id?: true
    power?: true
    dynamaxPower?: true
    precision?: true
    pp?: true
    hasBacklash?: true
    targetId?: true
    capacityEffectId?: true
    capacityId?: true
    capacityEffectZId?: true
    typeId?: true
    effectOutsideFightId?: true
    capacityCategoryId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type Capacity_infoCountAggregateInputType = {
    id?: true
    power?: true
    dynamaxPower?: true
    precision?: true
    pp?: true
    hasBacklash?: true
    targetId?: true
    capacityEffectId?: true
    capacityId?: true
    capacityEffectZId?: true
    typeId?: true
    effectOutsideFightId?: true
    capacityCategoryId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type Capacity_infoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capacity_info to aggregate.
     */
    where?: capacity_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_infos to fetch.
     */
    orderBy?: capacity_infoOrderByWithRelationInput | capacity_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: capacity_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned capacity_infos
    **/
    _count?: true | Capacity_infoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Capacity_infoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Capacity_infoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Capacity_infoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Capacity_infoMaxAggregateInputType
  }

  export type GetCapacity_infoAggregateType<T extends Capacity_infoAggregateArgs> = {
        [P in keyof T & keyof AggregateCapacity_info]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapacity_info[P]>
      : GetScalarType<T[P], AggregateCapacity_info[P]>
  }




  export type capacity_infoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacity_infoWhereInput
    orderBy?: capacity_infoOrderByWithAggregationInput | capacity_infoOrderByWithAggregationInput[]
    by: Capacity_infoScalarFieldEnum[] | Capacity_infoScalarFieldEnum
    having?: capacity_infoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Capacity_infoCountAggregateInputType | true
    _avg?: Capacity_infoAvgAggregateInputType
    _sum?: Capacity_infoSumAggregateInputType
    _min?: Capacity_infoMinAggregateInputType
    _max?: Capacity_infoMaxAggregateInputType
  }

  export type Capacity_infoGroupByOutputType = {
    id: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityId: number
    capacityEffectZId: number
    typeId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt: Date
    updatedAt: Date | null
    status: string
    _count: Capacity_infoCountAggregateOutputType | null
    _avg: Capacity_infoAvgAggregateOutputType | null
    _sum: Capacity_infoSumAggregateOutputType | null
    _min: Capacity_infoMinAggregateOutputType | null
    _max: Capacity_infoMaxAggregateOutputType | null
  }

  type GetCapacity_infoGroupByPayload<T extends capacity_infoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Capacity_infoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Capacity_infoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Capacity_infoGroupByOutputType[P]>
            : GetScalarType<T[P], Capacity_infoGroupByOutputType[P]>
        }
      >
    >


  export type capacity_infoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    power?: boolean
    dynamaxPower?: boolean
    precision?: boolean
    pp?: boolean
    hasBacklash?: boolean
    targetId?: boolean
    capacityEffectId?: boolean
    capacityId?: boolean
    capacityEffectZId?: boolean
    typeId?: boolean
    effectOutsideFightId?: boolean
    capacityCategoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    capacityCategory?: boolean | capacity_categoryDefaultArgs<ExtArgs>
    capacityEffect?: boolean | capacity_effectDefaultArgs<ExtArgs>
    capacityEffectZ?: boolean | capacity_effectDefaultArgs<ExtArgs>
    capacity?: boolean | capacityDefaultArgs<ExtArgs>
    effectOutsideFight?: boolean | effect_outside_fightDefaultArgs<ExtArgs>
    target?: boolean | targetDefaultArgs<ExtArgs>
    type?: boolean | typeDefaultArgs<ExtArgs>
    capacityInfoInfluences?: boolean | capacity_info$capacityInfoInfluencesArgs<ExtArgs>
    capsuleGameCapacityInfos?: boolean | capacity_info$capsuleGameCapacityInfosArgs<ExtArgs>
    _count?: boolean | Capacity_infoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capacity_info"]>



  export type capacity_infoSelectScalar = {
    id?: boolean
    power?: boolean
    dynamaxPower?: boolean
    precision?: boolean
    pp?: boolean
    hasBacklash?: boolean
    targetId?: boolean
    capacityEffectId?: boolean
    capacityId?: boolean
    capacityEffectZId?: boolean
    typeId?: boolean
    effectOutsideFightId?: boolean
    capacityCategoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type capacity_infoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "power" | "dynamaxPower" | "precision" | "pp" | "hasBacklash" | "targetId" | "capacityEffectId" | "capacityId" | "capacityEffectZId" | "typeId" | "effectOutsideFightId" | "capacityCategoryId" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["capacity_info"]>
  export type capacity_infoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityCategory?: boolean | capacity_categoryDefaultArgs<ExtArgs>
    capacityEffect?: boolean | capacity_effectDefaultArgs<ExtArgs>
    capacityEffectZ?: boolean | capacity_effectDefaultArgs<ExtArgs>
    capacity?: boolean | capacityDefaultArgs<ExtArgs>
    effectOutsideFight?: boolean | effect_outside_fightDefaultArgs<ExtArgs>
    target?: boolean | targetDefaultArgs<ExtArgs>
    type?: boolean | typeDefaultArgs<ExtArgs>
    capacityInfoInfluences?: boolean | capacity_info$capacityInfoInfluencesArgs<ExtArgs>
    capsuleGameCapacityInfos?: boolean | capacity_info$capsuleGameCapacityInfosArgs<ExtArgs>
    _count?: boolean | Capacity_infoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $capacity_infoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "capacity_info"
    objects: {
      capacityCategory: Prisma.$capacity_categoryPayload<ExtArgs>
      capacityEffect: Prisma.$capacity_effectPayload<ExtArgs>
      capacityEffectZ: Prisma.$capacity_effectPayload<ExtArgs>
      capacity: Prisma.$capacityPayload<ExtArgs>
      effectOutsideFight: Prisma.$effect_outside_fightPayload<ExtArgs>
      target: Prisma.$targetPayload<ExtArgs>
      type: Prisma.$typePayload<ExtArgs>
      capacityInfoInfluences: Prisma.$capacity_info_influencePayload<ExtArgs>[]
      capsuleGameCapacityInfos: Prisma.$capsule_game_capacity_infoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      power: number
      dynamaxPower: number
      precision: number
      pp: number
      hasBacklash: boolean
      targetId: number
      capacityEffectId: number
      capacityId: number
      capacityEffectZId: number
      typeId: number
      effectOutsideFightId: number
      capacityCategoryId: number
      createdAt: Date
      updatedAt: Date | null
      status: string
    }, ExtArgs["result"]["capacity_info"]>
    composites: {}
  }

  type capacity_infoGetPayload<S extends boolean | null | undefined | capacity_infoDefaultArgs> = $Result.GetResult<Prisma.$capacity_infoPayload, S>

  type capacity_infoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<capacity_infoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Capacity_infoCountAggregateInputType | true
    }

  export interface capacity_infoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['capacity_info'], meta: { name: 'capacity_info' } }
    /**
     * Find zero or one Capacity_info that matches the filter.
     * @param {capacity_infoFindUniqueArgs} args - Arguments to find a Capacity_info
     * @example
     * // Get one Capacity_info
     * const capacity_info = await prisma.capacity_info.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends capacity_infoFindUniqueArgs>(args: SelectSubset<T, capacity_infoFindUniqueArgs<ExtArgs>>): Prisma__capacity_infoClient<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Capacity_info that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {capacity_infoFindUniqueOrThrowArgs} args - Arguments to find a Capacity_info
     * @example
     * // Get one Capacity_info
     * const capacity_info = await prisma.capacity_info.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends capacity_infoFindUniqueOrThrowArgs>(args: SelectSubset<T, capacity_infoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__capacity_infoClient<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capacity_info that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_infoFindFirstArgs} args - Arguments to find a Capacity_info
     * @example
     * // Get one Capacity_info
     * const capacity_info = await prisma.capacity_info.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends capacity_infoFindFirstArgs>(args?: SelectSubset<T, capacity_infoFindFirstArgs<ExtArgs>>): Prisma__capacity_infoClient<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capacity_info that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_infoFindFirstOrThrowArgs} args - Arguments to find a Capacity_info
     * @example
     * // Get one Capacity_info
     * const capacity_info = await prisma.capacity_info.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends capacity_infoFindFirstOrThrowArgs>(args?: SelectSubset<T, capacity_infoFindFirstOrThrowArgs<ExtArgs>>): Prisma__capacity_infoClient<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Capacity_infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_infoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Capacity_infos
     * const capacity_infos = await prisma.capacity_info.findMany()
     * 
     * // Get first 10 Capacity_infos
     * const capacity_infos = await prisma.capacity_info.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capacity_infoWithIdOnly = await prisma.capacity_info.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends capacity_infoFindManyArgs>(args?: SelectSubset<T, capacity_infoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Capacity_info.
     * @param {capacity_infoCreateArgs} args - Arguments to create a Capacity_info.
     * @example
     * // Create one Capacity_info
     * const Capacity_info = await prisma.capacity_info.create({
     *   data: {
     *     // ... data to create a Capacity_info
     *   }
     * })
     * 
     */
    create<T extends capacity_infoCreateArgs>(args: SelectSubset<T, capacity_infoCreateArgs<ExtArgs>>): Prisma__capacity_infoClient<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Capacity_infos.
     * @param {capacity_infoCreateManyArgs} args - Arguments to create many Capacity_infos.
     * @example
     * // Create many Capacity_infos
     * const capacity_info = await prisma.capacity_info.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends capacity_infoCreateManyArgs>(args?: SelectSubset<T, capacity_infoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Capacity_info.
     * @param {capacity_infoDeleteArgs} args - Arguments to delete one Capacity_info.
     * @example
     * // Delete one Capacity_info
     * const Capacity_info = await prisma.capacity_info.delete({
     *   where: {
     *     // ... filter to delete one Capacity_info
     *   }
     * })
     * 
     */
    delete<T extends capacity_infoDeleteArgs>(args: SelectSubset<T, capacity_infoDeleteArgs<ExtArgs>>): Prisma__capacity_infoClient<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Capacity_info.
     * @param {capacity_infoUpdateArgs} args - Arguments to update one Capacity_info.
     * @example
     * // Update one Capacity_info
     * const capacity_info = await prisma.capacity_info.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends capacity_infoUpdateArgs>(args: SelectSubset<T, capacity_infoUpdateArgs<ExtArgs>>): Prisma__capacity_infoClient<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Capacity_infos.
     * @param {capacity_infoDeleteManyArgs} args - Arguments to filter Capacity_infos to delete.
     * @example
     * // Delete a few Capacity_infos
     * const { count } = await prisma.capacity_info.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends capacity_infoDeleteManyArgs>(args?: SelectSubset<T, capacity_infoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capacity_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_infoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Capacity_infos
     * const capacity_info = await prisma.capacity_info.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends capacity_infoUpdateManyArgs>(args: SelectSubset<T, capacity_infoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Capacity_info.
     * @param {capacity_infoUpsertArgs} args - Arguments to update or create a Capacity_info.
     * @example
     * // Update or create a Capacity_info
     * const capacity_info = await prisma.capacity_info.upsert({
     *   create: {
     *     // ... data to create a Capacity_info
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Capacity_info we want to update
     *   }
     * })
     */
    upsert<T extends capacity_infoUpsertArgs>(args: SelectSubset<T, capacity_infoUpsertArgs<ExtArgs>>): Prisma__capacity_infoClient<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Capacity_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_infoCountArgs} args - Arguments to filter Capacity_infos to count.
     * @example
     * // Count the number of Capacity_infos
     * const count = await prisma.capacity_info.count({
     *   where: {
     *     // ... the filter for the Capacity_infos we want to count
     *   }
     * })
    **/
    count<T extends capacity_infoCountArgs>(
      args?: Subset<T, capacity_infoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Capacity_infoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Capacity_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Capacity_infoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Capacity_infoAggregateArgs>(args: Subset<T, Capacity_infoAggregateArgs>): Prisma.PrismaPromise<GetCapacity_infoAggregateType<T>>

    /**
     * Group by Capacity_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_infoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends capacity_infoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: capacity_infoGroupByArgs['orderBy'] }
        : { orderBy?: capacity_infoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, capacity_infoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapacity_infoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the capacity_info model
   */
  readonly fields: capacity_infoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for capacity_info.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__capacity_infoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capacityCategory<T extends capacity_categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, capacity_categoryDefaultArgs<ExtArgs>>): Prisma__capacity_categoryClient<$Result.GetResult<Prisma.$capacity_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    capacityEffect<T extends capacity_effectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, capacity_effectDefaultArgs<ExtArgs>>): Prisma__capacity_effectClient<$Result.GetResult<Prisma.$capacity_effectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    capacityEffectZ<T extends capacity_effectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, capacity_effectDefaultArgs<ExtArgs>>): Prisma__capacity_effectClient<$Result.GetResult<Prisma.$capacity_effectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    capacity<T extends capacityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, capacityDefaultArgs<ExtArgs>>): Prisma__capacityClient<$Result.GetResult<Prisma.$capacityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    effectOutsideFight<T extends effect_outside_fightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, effect_outside_fightDefaultArgs<ExtArgs>>): Prisma__effect_outside_fightClient<$Result.GetResult<Prisma.$effect_outside_fightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    target<T extends targetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, targetDefaultArgs<ExtArgs>>): Prisma__targetClient<$Result.GetResult<Prisma.$targetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    type<T extends typeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, typeDefaultArgs<ExtArgs>>): Prisma__typeClient<$Result.GetResult<Prisma.$typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    capacityInfoInfluences<T extends capacity_info$capacityInfoInfluencesArgs<ExtArgs> = {}>(args?: Subset<T, capacity_info$capacityInfoInfluencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacity_info_influencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    capsuleGameCapacityInfos<T extends capacity_info$capsuleGameCapacityInfosArgs<ExtArgs> = {}>(args?: Subset<T, capacity_info$capsuleGameCapacityInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capsule_game_capacity_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the capacity_info model
   */
  interface capacity_infoFieldRefs {
    readonly id: FieldRef<"capacity_info", 'Int'>
    readonly power: FieldRef<"capacity_info", 'Int'>
    readonly dynamaxPower: FieldRef<"capacity_info", 'Int'>
    readonly precision: FieldRef<"capacity_info", 'Int'>
    readonly pp: FieldRef<"capacity_info", 'Int'>
    readonly hasBacklash: FieldRef<"capacity_info", 'Boolean'>
    readonly targetId: FieldRef<"capacity_info", 'Int'>
    readonly capacityEffectId: FieldRef<"capacity_info", 'Int'>
    readonly capacityId: FieldRef<"capacity_info", 'Int'>
    readonly capacityEffectZId: FieldRef<"capacity_info", 'Int'>
    readonly typeId: FieldRef<"capacity_info", 'Int'>
    readonly effectOutsideFightId: FieldRef<"capacity_info", 'Int'>
    readonly capacityCategoryId: FieldRef<"capacity_info", 'Int'>
    readonly createdAt: FieldRef<"capacity_info", 'DateTime'>
    readonly updatedAt: FieldRef<"capacity_info", 'DateTime'>
    readonly status: FieldRef<"capacity_info", 'String'>
  }
    

  // Custom InputTypes
  /**
   * capacity_info findUnique
   */
  export type capacity_infoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    /**
     * Filter, which capacity_info to fetch.
     */
    where: capacity_infoWhereUniqueInput
  }

  /**
   * capacity_info findUniqueOrThrow
   */
  export type capacity_infoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    /**
     * Filter, which capacity_info to fetch.
     */
    where: capacity_infoWhereUniqueInput
  }

  /**
   * capacity_info findFirst
   */
  export type capacity_infoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    /**
     * Filter, which capacity_info to fetch.
     */
    where?: capacity_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_infos to fetch.
     */
    orderBy?: capacity_infoOrderByWithRelationInput | capacity_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capacity_infos.
     */
    cursor?: capacity_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capacity_infos.
     */
    distinct?: Capacity_infoScalarFieldEnum | Capacity_infoScalarFieldEnum[]
  }

  /**
   * capacity_info findFirstOrThrow
   */
  export type capacity_infoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    /**
     * Filter, which capacity_info to fetch.
     */
    where?: capacity_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_infos to fetch.
     */
    orderBy?: capacity_infoOrderByWithRelationInput | capacity_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capacity_infos.
     */
    cursor?: capacity_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capacity_infos.
     */
    distinct?: Capacity_infoScalarFieldEnum | Capacity_infoScalarFieldEnum[]
  }

  /**
   * capacity_info findMany
   */
  export type capacity_infoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    /**
     * Filter, which capacity_infos to fetch.
     */
    where?: capacity_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_infos to fetch.
     */
    orderBy?: capacity_infoOrderByWithRelationInput | capacity_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing capacity_infos.
     */
    cursor?: capacity_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_infos.
     */
    skip?: number
    distinct?: Capacity_infoScalarFieldEnum | Capacity_infoScalarFieldEnum[]
  }

  /**
   * capacity_info create
   */
  export type capacity_infoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    /**
     * The data needed to create a capacity_info.
     */
    data: XOR<capacity_infoCreateInput, capacity_infoUncheckedCreateInput>
  }

  /**
   * capacity_info createMany
   */
  export type capacity_infoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many capacity_infos.
     */
    data: capacity_infoCreateManyInput | capacity_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * capacity_info update
   */
  export type capacity_infoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    /**
     * The data needed to update a capacity_info.
     */
    data: XOR<capacity_infoUpdateInput, capacity_infoUncheckedUpdateInput>
    /**
     * Choose, which capacity_info to update.
     */
    where: capacity_infoWhereUniqueInput
  }

  /**
   * capacity_info updateMany
   */
  export type capacity_infoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update capacity_infos.
     */
    data: XOR<capacity_infoUpdateManyMutationInput, capacity_infoUncheckedUpdateManyInput>
    /**
     * Filter which capacity_infos to update
     */
    where?: capacity_infoWhereInput
    /**
     * Limit how many capacity_infos to update.
     */
    limit?: number
  }

  /**
   * capacity_info upsert
   */
  export type capacity_infoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    /**
     * The filter to search for the capacity_info to update in case it exists.
     */
    where: capacity_infoWhereUniqueInput
    /**
     * In case the capacity_info found by the `where` argument doesn't exist, create a new capacity_info with this data.
     */
    create: XOR<capacity_infoCreateInput, capacity_infoUncheckedCreateInput>
    /**
     * In case the capacity_info was found with the provided `where` argument, update it with this data.
     */
    update: XOR<capacity_infoUpdateInput, capacity_infoUncheckedUpdateInput>
  }

  /**
   * capacity_info delete
   */
  export type capacity_infoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
    /**
     * Filter which capacity_info to delete.
     */
    where: capacity_infoWhereUniqueInput
  }

  /**
   * capacity_info deleteMany
   */
  export type capacity_infoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capacity_infos to delete
     */
    where?: capacity_infoWhereInput
    /**
     * Limit how many capacity_infos to delete.
     */
    limit?: number
  }

  /**
   * capacity_info.capacityInfoInfluences
   */
  export type capacity_info$capacityInfoInfluencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info_influence
     */
    select?: capacity_info_influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info_influence
     */
    omit?: capacity_info_influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_info_influenceInclude<ExtArgs> | null
    where?: capacity_info_influenceWhereInput
    orderBy?: capacity_info_influenceOrderByWithRelationInput | capacity_info_influenceOrderByWithRelationInput[]
    cursor?: capacity_info_influenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Capacity_info_influenceScalarFieldEnum | Capacity_info_influenceScalarFieldEnum[]
  }

  /**
   * capacity_info.capsuleGameCapacityInfos
   */
  export type capacity_info$capsuleGameCapacityInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capsule_game_capacity_info
     */
    select?: capsule_game_capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capsule_game_capacity_info
     */
    omit?: capsule_game_capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capsule_game_capacity_infoInclude<ExtArgs> | null
    where?: capsule_game_capacity_infoWhereInput
    orderBy?: capsule_game_capacity_infoOrderByWithRelationInput | capsule_game_capacity_infoOrderByWithRelationInput[]
    cursor?: capsule_game_capacity_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Capsule_game_capacity_infoScalarFieldEnum | Capsule_game_capacity_infoScalarFieldEnum[]
  }

  /**
   * capacity_info without action
   */
  export type capacity_infoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info
     */
    select?: capacity_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info
     */
    omit?: capacity_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_infoInclude<ExtArgs> | null
  }


  /**
   * Model capacity_info_influence
   */

  export type AggregateCapacity_info_influence = {
    _count: Capacity_info_influenceCountAggregateOutputType | null
    _avg: Capacity_info_influenceAvgAggregateOutputType | null
    _sum: Capacity_info_influenceSumAggregateOutputType | null
    _min: Capacity_info_influenceMinAggregateOutputType | null
    _max: Capacity_info_influenceMaxAggregateOutputType | null
  }

  export type Capacity_info_influenceAvgAggregateOutputType = {
    capacityInfoId: number | null
    influenceId: number | null
  }

  export type Capacity_info_influenceSumAggregateOutputType = {
    capacityInfoId: number | null
    influenceId: number | null
  }

  export type Capacity_info_influenceMinAggregateOutputType = {
    capacityInfoId: number | null
    influenceId: number | null
  }

  export type Capacity_info_influenceMaxAggregateOutputType = {
    capacityInfoId: number | null
    influenceId: number | null
  }

  export type Capacity_info_influenceCountAggregateOutputType = {
    capacityInfoId: number
    influenceId: number
    _all: number
  }


  export type Capacity_info_influenceAvgAggregateInputType = {
    capacityInfoId?: true
    influenceId?: true
  }

  export type Capacity_info_influenceSumAggregateInputType = {
    capacityInfoId?: true
    influenceId?: true
  }

  export type Capacity_info_influenceMinAggregateInputType = {
    capacityInfoId?: true
    influenceId?: true
  }

  export type Capacity_info_influenceMaxAggregateInputType = {
    capacityInfoId?: true
    influenceId?: true
  }

  export type Capacity_info_influenceCountAggregateInputType = {
    capacityInfoId?: true
    influenceId?: true
    _all?: true
  }

  export type Capacity_info_influenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capacity_info_influence to aggregate.
     */
    where?: capacity_info_influenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_info_influences to fetch.
     */
    orderBy?: capacity_info_influenceOrderByWithRelationInput | capacity_info_influenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: capacity_info_influenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_info_influences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_info_influences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned capacity_info_influences
    **/
    _count?: true | Capacity_info_influenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Capacity_info_influenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Capacity_info_influenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Capacity_info_influenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Capacity_info_influenceMaxAggregateInputType
  }

  export type GetCapacity_info_influenceAggregateType<T extends Capacity_info_influenceAggregateArgs> = {
        [P in keyof T & keyof AggregateCapacity_info_influence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapacity_info_influence[P]>
      : GetScalarType<T[P], AggregateCapacity_info_influence[P]>
  }




  export type capacity_info_influenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacity_info_influenceWhereInput
    orderBy?: capacity_info_influenceOrderByWithAggregationInput | capacity_info_influenceOrderByWithAggregationInput[]
    by: Capacity_info_influenceScalarFieldEnum[] | Capacity_info_influenceScalarFieldEnum
    having?: capacity_info_influenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Capacity_info_influenceCountAggregateInputType | true
    _avg?: Capacity_info_influenceAvgAggregateInputType
    _sum?: Capacity_info_influenceSumAggregateInputType
    _min?: Capacity_info_influenceMinAggregateInputType
    _max?: Capacity_info_influenceMaxAggregateInputType
  }

  export type Capacity_info_influenceGroupByOutputType = {
    capacityInfoId: number
    influenceId: number
    _count: Capacity_info_influenceCountAggregateOutputType | null
    _avg: Capacity_info_influenceAvgAggregateOutputType | null
    _sum: Capacity_info_influenceSumAggregateOutputType | null
    _min: Capacity_info_influenceMinAggregateOutputType | null
    _max: Capacity_info_influenceMaxAggregateOutputType | null
  }

  type GetCapacity_info_influenceGroupByPayload<T extends capacity_info_influenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Capacity_info_influenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Capacity_info_influenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Capacity_info_influenceGroupByOutputType[P]>
            : GetScalarType<T[P], Capacity_info_influenceGroupByOutputType[P]>
        }
      >
    >


  export type capacity_info_influenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    capacityInfoId?: boolean
    influenceId?: boolean
    capacityInfo?: boolean | capacity_infoDefaultArgs<ExtArgs>
    influence?: boolean | influenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capacity_info_influence"]>



  export type capacity_info_influenceSelectScalar = {
    capacityInfoId?: boolean
    influenceId?: boolean
  }

  export type capacity_info_influenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"capacityInfoId" | "influenceId", ExtArgs["result"]["capacity_info_influence"]>
  export type capacity_info_influenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacityInfo?: boolean | capacity_infoDefaultArgs<ExtArgs>
    influence?: boolean | influenceDefaultArgs<ExtArgs>
  }

  export type $capacity_info_influencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "capacity_info_influence"
    objects: {
      capacityInfo: Prisma.$capacity_infoPayload<ExtArgs>
      influence: Prisma.$influencePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      capacityInfoId: number
      influenceId: number
    }, ExtArgs["result"]["capacity_info_influence"]>
    composites: {}
  }

  type capacity_info_influenceGetPayload<S extends boolean | null | undefined | capacity_info_influenceDefaultArgs> = $Result.GetResult<Prisma.$capacity_info_influencePayload, S>

  type capacity_info_influenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<capacity_info_influenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Capacity_info_influenceCountAggregateInputType | true
    }

  export interface capacity_info_influenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['capacity_info_influence'], meta: { name: 'capacity_info_influence' } }
    /**
     * Find zero or one Capacity_info_influence that matches the filter.
     * @param {capacity_info_influenceFindUniqueArgs} args - Arguments to find a Capacity_info_influence
     * @example
     * // Get one Capacity_info_influence
     * const capacity_info_influence = await prisma.capacity_info_influence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends capacity_info_influenceFindUniqueArgs>(args: SelectSubset<T, capacity_info_influenceFindUniqueArgs<ExtArgs>>): Prisma__capacity_info_influenceClient<$Result.GetResult<Prisma.$capacity_info_influencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Capacity_info_influence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {capacity_info_influenceFindUniqueOrThrowArgs} args - Arguments to find a Capacity_info_influence
     * @example
     * // Get one Capacity_info_influence
     * const capacity_info_influence = await prisma.capacity_info_influence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends capacity_info_influenceFindUniqueOrThrowArgs>(args: SelectSubset<T, capacity_info_influenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__capacity_info_influenceClient<$Result.GetResult<Prisma.$capacity_info_influencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capacity_info_influence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_info_influenceFindFirstArgs} args - Arguments to find a Capacity_info_influence
     * @example
     * // Get one Capacity_info_influence
     * const capacity_info_influence = await prisma.capacity_info_influence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends capacity_info_influenceFindFirstArgs>(args?: SelectSubset<T, capacity_info_influenceFindFirstArgs<ExtArgs>>): Prisma__capacity_info_influenceClient<$Result.GetResult<Prisma.$capacity_info_influencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capacity_info_influence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_info_influenceFindFirstOrThrowArgs} args - Arguments to find a Capacity_info_influence
     * @example
     * // Get one Capacity_info_influence
     * const capacity_info_influence = await prisma.capacity_info_influence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends capacity_info_influenceFindFirstOrThrowArgs>(args?: SelectSubset<T, capacity_info_influenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__capacity_info_influenceClient<$Result.GetResult<Prisma.$capacity_info_influencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Capacity_info_influences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_info_influenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Capacity_info_influences
     * const capacity_info_influences = await prisma.capacity_info_influence.findMany()
     * 
     * // Get first 10 Capacity_info_influences
     * const capacity_info_influences = await prisma.capacity_info_influence.findMany({ take: 10 })
     * 
     * // Only select the `capacityInfoId`
     * const capacity_info_influenceWithCapacityInfoIdOnly = await prisma.capacity_info_influence.findMany({ select: { capacityInfoId: true } })
     * 
     */
    findMany<T extends capacity_info_influenceFindManyArgs>(args?: SelectSubset<T, capacity_info_influenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacity_info_influencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Capacity_info_influence.
     * @param {capacity_info_influenceCreateArgs} args - Arguments to create a Capacity_info_influence.
     * @example
     * // Create one Capacity_info_influence
     * const Capacity_info_influence = await prisma.capacity_info_influence.create({
     *   data: {
     *     // ... data to create a Capacity_info_influence
     *   }
     * })
     * 
     */
    create<T extends capacity_info_influenceCreateArgs>(args: SelectSubset<T, capacity_info_influenceCreateArgs<ExtArgs>>): Prisma__capacity_info_influenceClient<$Result.GetResult<Prisma.$capacity_info_influencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Capacity_info_influences.
     * @param {capacity_info_influenceCreateManyArgs} args - Arguments to create many Capacity_info_influences.
     * @example
     * // Create many Capacity_info_influences
     * const capacity_info_influence = await prisma.capacity_info_influence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends capacity_info_influenceCreateManyArgs>(args?: SelectSubset<T, capacity_info_influenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Capacity_info_influence.
     * @param {capacity_info_influenceDeleteArgs} args - Arguments to delete one Capacity_info_influence.
     * @example
     * // Delete one Capacity_info_influence
     * const Capacity_info_influence = await prisma.capacity_info_influence.delete({
     *   where: {
     *     // ... filter to delete one Capacity_info_influence
     *   }
     * })
     * 
     */
    delete<T extends capacity_info_influenceDeleteArgs>(args: SelectSubset<T, capacity_info_influenceDeleteArgs<ExtArgs>>): Prisma__capacity_info_influenceClient<$Result.GetResult<Prisma.$capacity_info_influencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Capacity_info_influence.
     * @param {capacity_info_influenceUpdateArgs} args - Arguments to update one Capacity_info_influence.
     * @example
     * // Update one Capacity_info_influence
     * const capacity_info_influence = await prisma.capacity_info_influence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends capacity_info_influenceUpdateArgs>(args: SelectSubset<T, capacity_info_influenceUpdateArgs<ExtArgs>>): Prisma__capacity_info_influenceClient<$Result.GetResult<Prisma.$capacity_info_influencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Capacity_info_influences.
     * @param {capacity_info_influenceDeleteManyArgs} args - Arguments to filter Capacity_info_influences to delete.
     * @example
     * // Delete a few Capacity_info_influences
     * const { count } = await prisma.capacity_info_influence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends capacity_info_influenceDeleteManyArgs>(args?: SelectSubset<T, capacity_info_influenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capacity_info_influences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_info_influenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Capacity_info_influences
     * const capacity_info_influence = await prisma.capacity_info_influence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends capacity_info_influenceUpdateManyArgs>(args: SelectSubset<T, capacity_info_influenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Capacity_info_influence.
     * @param {capacity_info_influenceUpsertArgs} args - Arguments to update or create a Capacity_info_influence.
     * @example
     * // Update or create a Capacity_info_influence
     * const capacity_info_influence = await prisma.capacity_info_influence.upsert({
     *   create: {
     *     // ... data to create a Capacity_info_influence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Capacity_info_influence we want to update
     *   }
     * })
     */
    upsert<T extends capacity_info_influenceUpsertArgs>(args: SelectSubset<T, capacity_info_influenceUpsertArgs<ExtArgs>>): Prisma__capacity_info_influenceClient<$Result.GetResult<Prisma.$capacity_info_influencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Capacity_info_influences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_info_influenceCountArgs} args - Arguments to filter Capacity_info_influences to count.
     * @example
     * // Count the number of Capacity_info_influences
     * const count = await prisma.capacity_info_influence.count({
     *   where: {
     *     // ... the filter for the Capacity_info_influences we want to count
     *   }
     * })
    **/
    count<T extends capacity_info_influenceCountArgs>(
      args?: Subset<T, capacity_info_influenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Capacity_info_influenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Capacity_info_influence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Capacity_info_influenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Capacity_info_influenceAggregateArgs>(args: Subset<T, Capacity_info_influenceAggregateArgs>): Prisma.PrismaPromise<GetCapacity_info_influenceAggregateType<T>>

    /**
     * Group by Capacity_info_influence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacity_info_influenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends capacity_info_influenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: capacity_info_influenceGroupByArgs['orderBy'] }
        : { orderBy?: capacity_info_influenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, capacity_info_influenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapacity_info_influenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the capacity_info_influence model
   */
  readonly fields: capacity_info_influenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for capacity_info_influence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__capacity_info_influenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capacityInfo<T extends capacity_infoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, capacity_infoDefaultArgs<ExtArgs>>): Prisma__capacity_infoClient<$Result.GetResult<Prisma.$capacity_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    influence<T extends influenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, influenceDefaultArgs<ExtArgs>>): Prisma__influenceClient<$Result.GetResult<Prisma.$influencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the capacity_info_influence model
   */
  interface capacity_info_influenceFieldRefs {
    readonly capacityInfoId: FieldRef<"capacity_info_influence", 'Int'>
    readonly influenceId: FieldRef<"capacity_info_influence", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * capacity_info_influence findUnique
   */
  export type capacity_info_influenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info_influence
     */
    select?: capacity_info_influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info_influence
     */
    omit?: capacity_info_influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_info_influenceInclude<ExtArgs> | null
    /**
     * Filter, which capacity_info_influence to fetch.
     */
    where: capacity_info_influenceWhereUniqueInput
  }

  /**
   * capacity_info_influence findUniqueOrThrow
   */
  export type capacity_info_influenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info_influence
     */
    select?: capacity_info_influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info_influence
     */
    omit?: capacity_info_influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_info_influenceInclude<ExtArgs> | null
    /**
     * Filter, which capacity_info_influence to fetch.
     */
    where: capacity_info_influenceWhereUniqueInput
  }

  /**
   * capacity_info_influence findFirst
   */
  export type capacity_info_influenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info_influence
     */
    select?: capacity_info_influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info_influence
     */
    omit?: capacity_info_influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_info_influenceInclude<ExtArgs> | null
    /**
     * Filter, which capacity_info_influence to fetch.
     */
    where?: capacity_info_influenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_info_influences to fetch.
     */
    orderBy?: capacity_info_influenceOrderByWithRelationInput | capacity_info_influenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capacity_info_influences.
     */
    cursor?: capacity_info_influenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_info_influences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_info_influences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capacity_info_influences.
     */
    distinct?: Capacity_info_influenceScalarFieldEnum | Capacity_info_influenceScalarFieldEnum[]
  }

  /**
   * capacity_info_influence findFirstOrThrow
   */
  export type capacity_info_influenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info_influence
     */
    select?: capacity_info_influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info_influence
     */
    omit?: capacity_info_influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_info_influenceInclude<ExtArgs> | null
    /**
     * Filter, which capacity_info_influence to fetch.
     */
    where?: capacity_info_influenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_info_influences to fetch.
     */
    orderBy?: capacity_info_influenceOrderByWithRelationInput | capacity_info_influenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capacity_info_influences.
     */
    cursor?: capacity_info_influenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_info_influences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_info_influences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capacity_info_influences.
     */
    distinct?: Capacity_info_influenceScalarFieldEnum | Capacity_info_influenceScalarFieldEnum[]
  }

  /**
   * capacity_info_influence findMany
   */
  export type capacity_info_influenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info_influence
     */
    select?: capacity_info_influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info_influence
     */
    omit?: capacity_info_influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_info_influenceInclude<ExtArgs> | null
    /**
     * Filter, which capacity_info_influences to fetch.
     */
    where?: capacity_info_influenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacity_info_influences to fetch.
     */
    orderBy?: capacity_info_influenceOrderByWithRelationInput | capacity_info_influenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing capacity_info_influences.
     */
    cursor?: capacity_info_influenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacity_info_influences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacity_info_influences.
     */
    skip?: number
    distinct?: Capacity_info_influenceScalarFieldEnum | Capacity_info_influenceScalarFieldEnum[]
  }

  /**
   * capacity_info_influence create
   */
  export type capacity_info_influenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info_influence
     */
    select?: capacity_info_influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info_influence
     */
    omit?: capacity_info_influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_info_influenceInclude<ExtArgs> | null
    /**
     * The data needed to create a capacity_info_influence.
     */
    data: XOR<capacity_info_influenceCreateInput, capacity_info_influenceUncheckedCreateInput>
  }

  /**
   * capacity_info_influence createMany
   */
  export type capacity_info_influenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many capacity_info_influences.
     */
    data: capacity_info_influenceCreateManyInput | capacity_info_influenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * capacity_info_influence update
   */
  export type capacity_info_influenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info_influence
     */
    select?: capacity_info_influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info_influence
     */
    omit?: capacity_info_influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_info_influenceInclude<ExtArgs> | null
    /**
     * The data needed to update a capacity_info_influence.
     */
    data: XOR<capacity_info_influenceUpdateInput, capacity_info_influenceUncheckedUpdateInput>
    /**
     * Choose, which capacity_info_influence to update.
     */
    where: capacity_info_influenceWhereUniqueInput
  }

  /**
   * capacity_info_influence updateMany
   */
  export type capacity_info_influenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update capacity_info_influences.
     */
    data: XOR<capacity_info_influenceUpdateManyMutationInput, capacity_info_influenceUncheckedUpdateManyInput>
    /**
     * Filter which capacity_info_influences to update
     */
    where?: capacity_info_influenceWhereInput
    /**
     * Limit how many capacity_info_influences to update.
     */
    limit?: number
  }

  /**
   * capacity_info_influence upsert
   */
  export type capacity_info_influenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info_influence
     */
    select?: capacity_info_influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info_influence
     */
    omit?: capacity_info_influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_info_influenceInclude<ExtArgs> | null
    /**
     * The filter to search for the capacity_info_influence to update in case it exists.
     */
    where: capacity_info_influenceWhereUniqueInput
    /**
     * In case the capacity_info_influence found by the `where` argument doesn't exist, create a new capacity_info_influence with this data.
     */
    create: XOR<capacity_info_influenceCreateInput, capacity_info_influenceUncheckedCreateInput>
    /**
     * In case the capacity_info_influence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<capacity_info_influenceUpdateInput, capacity_info_influenceUncheckedUpdateInput>
  }

  /**
   * capacity_info_influence delete
   */
  export type capacity_info_influenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info_influence
     */
    select?: capacity_info_influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info_influence
     */
    omit?: capacity_info_influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_info_influenceInclude<ExtArgs> | null
    /**
     * Filter which capacity_info_influence to delete.
     */
    where: capacity_info_influenceWhereUniqueInput
  }

  /**
   * capacity_info_influence deleteMany
   */
  export type capacity_info_influenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capacity_info_influences to delete
     */
    where?: capacity_info_influenceWhereInput
    /**
     * Limit how many capacity_info_influences to delete.
     */
    limit?: number
  }

  /**
   * capacity_info_influence without action
   */
  export type capacity_info_influenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacity_info_influence
     */
    select?: capacity_info_influenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capacity_info_influence
     */
    omit?: capacity_info_influenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capacity_info_influenceInclude<ExtArgs> | null
  }


  /**
   * Model pokemon_game_location
   */

  export type AggregatePokemon_game_location = {
    _count: Pokemon_game_locationCountAggregateOutputType | null
    _avg: Pokemon_game_locationAvgAggregateOutputType | null
    _sum: Pokemon_game_locationSumAggregateOutputType | null
    _min: Pokemon_game_locationMinAggregateOutputType | null
    _max: Pokemon_game_locationMaxAggregateOutputType | null
  }

  export type Pokemon_game_locationAvgAggregateOutputType = {
    gameId: number | null
    rateId: number | null
    locationZoneId: number | null
    pokemonObtationId: number | null
    pokemonFormId: number | null
    id: number | null
  }

  export type Pokemon_game_locationSumAggregateOutputType = {
    gameId: number | null
    rateId: number | null
    locationZoneId: number | null
    pokemonObtationId: number | null
    pokemonFormId: number | null
    id: number | null
  }

  export type Pokemon_game_locationMinAggregateOutputType = {
    gameId: number | null
    rateId: number | null
    locationZoneId: number | null
    pokemonObtationId: number | null
    pokemonFormId: number | null
    id: number | null
  }

  export type Pokemon_game_locationMaxAggregateOutputType = {
    gameId: number | null
    rateId: number | null
    locationZoneId: number | null
    pokemonObtationId: number | null
    pokemonFormId: number | null
    id: number | null
  }

  export type Pokemon_game_locationCountAggregateOutputType = {
    gameId: number
    rateId: number
    locationZoneId: number
    pokemonObtationId: number
    pokemonFormId: number
    id: number
    _all: number
  }


  export type Pokemon_game_locationAvgAggregateInputType = {
    gameId?: true
    rateId?: true
    locationZoneId?: true
    pokemonObtationId?: true
    pokemonFormId?: true
    id?: true
  }

  export type Pokemon_game_locationSumAggregateInputType = {
    gameId?: true
    rateId?: true
    locationZoneId?: true
    pokemonObtationId?: true
    pokemonFormId?: true
    id?: true
  }

  export type Pokemon_game_locationMinAggregateInputType = {
    gameId?: true
    rateId?: true
    locationZoneId?: true
    pokemonObtationId?: true
    pokemonFormId?: true
    id?: true
  }

  export type Pokemon_game_locationMaxAggregateInputType = {
    gameId?: true
    rateId?: true
    locationZoneId?: true
    pokemonObtationId?: true
    pokemonFormId?: true
    id?: true
  }

  export type Pokemon_game_locationCountAggregateInputType = {
    gameId?: true
    rateId?: true
    locationZoneId?: true
    pokemonObtationId?: true
    pokemonFormId?: true
    id?: true
    _all?: true
  }

  export type Pokemon_game_locationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokemon_game_location to aggregate.
     */
    where?: pokemon_game_locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_game_locations to fetch.
     */
    orderBy?: pokemon_game_locationOrderByWithRelationInput | pokemon_game_locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pokemon_game_locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_game_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_game_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pokemon_game_locations
    **/
    _count?: true | Pokemon_game_locationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pokemon_game_locationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pokemon_game_locationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pokemon_game_locationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pokemon_game_locationMaxAggregateInputType
  }

  export type GetPokemon_game_locationAggregateType<T extends Pokemon_game_locationAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemon_game_location]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemon_game_location[P]>
      : GetScalarType<T[P], AggregatePokemon_game_location[P]>
  }




  export type pokemon_game_locationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pokemon_game_locationWhereInput
    orderBy?: pokemon_game_locationOrderByWithAggregationInput | pokemon_game_locationOrderByWithAggregationInput[]
    by: Pokemon_game_locationScalarFieldEnum[] | Pokemon_game_locationScalarFieldEnum
    having?: pokemon_game_locationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pokemon_game_locationCountAggregateInputType | true
    _avg?: Pokemon_game_locationAvgAggregateInputType
    _sum?: Pokemon_game_locationSumAggregateInputType
    _min?: Pokemon_game_locationMinAggregateInputType
    _max?: Pokemon_game_locationMaxAggregateInputType
  }

  export type Pokemon_game_locationGroupByOutputType = {
    gameId: number
    rateId: number
    locationZoneId: number
    pokemonObtationId: number
    pokemonFormId: number
    id: number
    _count: Pokemon_game_locationCountAggregateOutputType | null
    _avg: Pokemon_game_locationAvgAggregateOutputType | null
    _sum: Pokemon_game_locationSumAggregateOutputType | null
    _min: Pokemon_game_locationMinAggregateOutputType | null
    _max: Pokemon_game_locationMaxAggregateOutputType | null
  }

  type GetPokemon_game_locationGroupByPayload<T extends pokemon_game_locationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pokemon_game_locationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pokemon_game_locationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pokemon_game_locationGroupByOutputType[P]>
            : GetScalarType<T[P], Pokemon_game_locationGroupByOutputType[P]>
        }
      >
    >


  export type pokemon_game_locationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    gameId?: boolean
    rateId?: boolean
    locationZoneId?: boolean
    pokemonObtationId?: boolean
    pokemonFormId?: boolean
    id?: boolean
    game?: boolean | gameDefaultArgs<ExtArgs>
    locationZone?: boolean | location_zoneDefaultArgs<ExtArgs>
    pokemonForm?: boolean | pokemon_formDefaultArgs<ExtArgs>
    pokemonObtation?: boolean | pokemon_obtationDefaultArgs<ExtArgs>
    rate?: boolean | rateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemon_game_location"]>



  export type pokemon_game_locationSelectScalar = {
    gameId?: boolean
    rateId?: boolean
    locationZoneId?: boolean
    pokemonObtationId?: boolean
    pokemonFormId?: boolean
    id?: boolean
  }

  export type pokemon_game_locationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"gameId" | "rateId" | "locationZoneId" | "pokemonObtationId" | "pokemonFormId" | "id", ExtArgs["result"]["pokemon_game_location"]>
  export type pokemon_game_locationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | gameDefaultArgs<ExtArgs>
    locationZone?: boolean | location_zoneDefaultArgs<ExtArgs>
    pokemonForm?: boolean | pokemon_formDefaultArgs<ExtArgs>
    pokemonObtation?: boolean | pokemon_obtationDefaultArgs<ExtArgs>
    rate?: boolean | rateDefaultArgs<ExtArgs>
  }

  export type $pokemon_game_locationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pokemon_game_location"
    objects: {
      game: Prisma.$gamePayload<ExtArgs>
      locationZone: Prisma.$location_zonePayload<ExtArgs>
      pokemonForm: Prisma.$pokemon_formPayload<ExtArgs>
      pokemonObtation: Prisma.$pokemon_obtationPayload<ExtArgs>
      rate: Prisma.$ratePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      gameId: number
      rateId: number
      locationZoneId: number
      pokemonObtationId: number
      pokemonFormId: number
      id: number
    }, ExtArgs["result"]["pokemon_game_location"]>
    composites: {}
  }

  type pokemon_game_locationGetPayload<S extends boolean | null | undefined | pokemon_game_locationDefaultArgs> = $Result.GetResult<Prisma.$pokemon_game_locationPayload, S>

  type pokemon_game_locationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pokemon_game_locationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pokemon_game_locationCountAggregateInputType | true
    }

  export interface pokemon_game_locationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pokemon_game_location'], meta: { name: 'pokemon_game_location' } }
    /**
     * Find zero or one Pokemon_game_location that matches the filter.
     * @param {pokemon_game_locationFindUniqueArgs} args - Arguments to find a Pokemon_game_location
     * @example
     * // Get one Pokemon_game_location
     * const pokemon_game_location = await prisma.pokemon_game_location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pokemon_game_locationFindUniqueArgs>(args: SelectSubset<T, pokemon_game_locationFindUniqueArgs<ExtArgs>>): Prisma__pokemon_game_locationClient<$Result.GetResult<Prisma.$pokemon_game_locationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pokemon_game_location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pokemon_game_locationFindUniqueOrThrowArgs} args - Arguments to find a Pokemon_game_location
     * @example
     * // Get one Pokemon_game_location
     * const pokemon_game_location = await prisma.pokemon_game_location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pokemon_game_locationFindUniqueOrThrowArgs>(args: SelectSubset<T, pokemon_game_locationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pokemon_game_locationClient<$Result.GetResult<Prisma.$pokemon_game_locationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon_game_location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_game_locationFindFirstArgs} args - Arguments to find a Pokemon_game_location
     * @example
     * // Get one Pokemon_game_location
     * const pokemon_game_location = await prisma.pokemon_game_location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pokemon_game_locationFindFirstArgs>(args?: SelectSubset<T, pokemon_game_locationFindFirstArgs<ExtArgs>>): Prisma__pokemon_game_locationClient<$Result.GetResult<Prisma.$pokemon_game_locationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon_game_location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_game_locationFindFirstOrThrowArgs} args - Arguments to find a Pokemon_game_location
     * @example
     * // Get one Pokemon_game_location
     * const pokemon_game_location = await prisma.pokemon_game_location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pokemon_game_locationFindFirstOrThrowArgs>(args?: SelectSubset<T, pokemon_game_locationFindFirstOrThrowArgs<ExtArgs>>): Prisma__pokemon_game_locationClient<$Result.GetResult<Prisma.$pokemon_game_locationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pokemon_game_locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_game_locationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pokemon_game_locations
     * const pokemon_game_locations = await prisma.pokemon_game_location.findMany()
     * 
     * // Get first 10 Pokemon_game_locations
     * const pokemon_game_locations = await prisma.pokemon_game_location.findMany({ take: 10 })
     * 
     * // Only select the `gameId`
     * const pokemon_game_locationWithGameIdOnly = await prisma.pokemon_game_location.findMany({ select: { gameId: true } })
     * 
     */
    findMany<T extends pokemon_game_locationFindManyArgs>(args?: SelectSubset<T, pokemon_game_locationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pokemon_game_locationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pokemon_game_location.
     * @param {pokemon_game_locationCreateArgs} args - Arguments to create a Pokemon_game_location.
     * @example
     * // Create one Pokemon_game_location
     * const Pokemon_game_location = await prisma.pokemon_game_location.create({
     *   data: {
     *     // ... data to create a Pokemon_game_location
     *   }
     * })
     * 
     */
    create<T extends pokemon_game_locationCreateArgs>(args: SelectSubset<T, pokemon_game_locationCreateArgs<ExtArgs>>): Prisma__pokemon_game_locationClient<$Result.GetResult<Prisma.$pokemon_game_locationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pokemon_game_locations.
     * @param {pokemon_game_locationCreateManyArgs} args - Arguments to create many Pokemon_game_locations.
     * @example
     * // Create many Pokemon_game_locations
     * const pokemon_game_location = await prisma.pokemon_game_location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pokemon_game_locationCreateManyArgs>(args?: SelectSubset<T, pokemon_game_locationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pokemon_game_location.
     * @param {pokemon_game_locationDeleteArgs} args - Arguments to delete one Pokemon_game_location.
     * @example
     * // Delete one Pokemon_game_location
     * const Pokemon_game_location = await prisma.pokemon_game_location.delete({
     *   where: {
     *     // ... filter to delete one Pokemon_game_location
     *   }
     * })
     * 
     */
    delete<T extends pokemon_game_locationDeleteArgs>(args: SelectSubset<T, pokemon_game_locationDeleteArgs<ExtArgs>>): Prisma__pokemon_game_locationClient<$Result.GetResult<Prisma.$pokemon_game_locationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pokemon_game_location.
     * @param {pokemon_game_locationUpdateArgs} args - Arguments to update one Pokemon_game_location.
     * @example
     * // Update one Pokemon_game_location
     * const pokemon_game_location = await prisma.pokemon_game_location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pokemon_game_locationUpdateArgs>(args: SelectSubset<T, pokemon_game_locationUpdateArgs<ExtArgs>>): Prisma__pokemon_game_locationClient<$Result.GetResult<Prisma.$pokemon_game_locationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pokemon_game_locations.
     * @param {pokemon_game_locationDeleteManyArgs} args - Arguments to filter Pokemon_game_locations to delete.
     * @example
     * // Delete a few Pokemon_game_locations
     * const { count } = await prisma.pokemon_game_location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pokemon_game_locationDeleteManyArgs>(args?: SelectSubset<T, pokemon_game_locationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pokemon_game_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_game_locationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pokemon_game_locations
     * const pokemon_game_location = await prisma.pokemon_game_location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pokemon_game_locationUpdateManyArgs>(args: SelectSubset<T, pokemon_game_locationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pokemon_game_location.
     * @param {pokemon_game_locationUpsertArgs} args - Arguments to update or create a Pokemon_game_location.
     * @example
     * // Update or create a Pokemon_game_location
     * const pokemon_game_location = await prisma.pokemon_game_location.upsert({
     *   create: {
     *     // ... data to create a Pokemon_game_location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pokemon_game_location we want to update
     *   }
     * })
     */
    upsert<T extends pokemon_game_locationUpsertArgs>(args: SelectSubset<T, pokemon_game_locationUpsertArgs<ExtArgs>>): Prisma__pokemon_game_locationClient<$Result.GetResult<Prisma.$pokemon_game_locationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pokemon_game_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_game_locationCountArgs} args - Arguments to filter Pokemon_game_locations to count.
     * @example
     * // Count the number of Pokemon_game_locations
     * const count = await prisma.pokemon_game_location.count({
     *   where: {
     *     // ... the filter for the Pokemon_game_locations we want to count
     *   }
     * })
    **/
    count<T extends pokemon_game_locationCountArgs>(
      args?: Subset<T, pokemon_game_locationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pokemon_game_locationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pokemon_game_location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pokemon_game_locationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pokemon_game_locationAggregateArgs>(args: Subset<T, Pokemon_game_locationAggregateArgs>): Prisma.PrismaPromise<GetPokemon_game_locationAggregateType<T>>

    /**
     * Group by Pokemon_game_location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pokemon_game_locationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pokemon_game_locationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pokemon_game_locationGroupByArgs['orderBy'] }
        : { orderBy?: pokemon_game_locationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pokemon_game_locationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemon_game_locationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pokemon_game_location model
   */
  readonly fields: pokemon_game_locationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pokemon_game_location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pokemon_game_locationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends gameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, gameDefaultArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    locationZone<T extends location_zoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, location_zoneDefaultArgs<ExtArgs>>): Prisma__location_zoneClient<$Result.GetResult<Prisma.$location_zonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemonForm<T extends pokemon_formDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_formDefaultArgs<ExtArgs>>): Prisma__pokemon_formClient<$Result.GetResult<Prisma.$pokemon_formPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemonObtation<T extends pokemon_obtationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemon_obtationDefaultArgs<ExtArgs>>): Prisma__pokemon_obtationClient<$Result.GetResult<Prisma.$pokemon_obtationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rate<T extends rateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rateDefaultArgs<ExtArgs>>): Prisma__rateClient<$Result.GetResult<Prisma.$ratePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pokemon_game_location model
   */
  interface pokemon_game_locationFieldRefs {
    readonly gameId: FieldRef<"pokemon_game_location", 'Int'>
    readonly rateId: FieldRef<"pokemon_game_location", 'Int'>
    readonly locationZoneId: FieldRef<"pokemon_game_location", 'Int'>
    readonly pokemonObtationId: FieldRef<"pokemon_game_location", 'Int'>
    readonly pokemonFormId: FieldRef<"pokemon_game_location", 'Int'>
    readonly id: FieldRef<"pokemon_game_location", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * pokemon_game_location findUnique
   */
  export type pokemon_game_locationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_game_location to fetch.
     */
    where: pokemon_game_locationWhereUniqueInput
  }

  /**
   * pokemon_game_location findUniqueOrThrow
   */
  export type pokemon_game_locationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_game_location to fetch.
     */
    where: pokemon_game_locationWhereUniqueInput
  }

  /**
   * pokemon_game_location findFirst
   */
  export type pokemon_game_locationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_game_location to fetch.
     */
    where?: pokemon_game_locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_game_locations to fetch.
     */
    orderBy?: pokemon_game_locationOrderByWithRelationInput | pokemon_game_locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokemon_game_locations.
     */
    cursor?: pokemon_game_locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_game_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_game_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokemon_game_locations.
     */
    distinct?: Pokemon_game_locationScalarFieldEnum | Pokemon_game_locationScalarFieldEnum[]
  }

  /**
   * pokemon_game_location findFirstOrThrow
   */
  export type pokemon_game_locationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_game_location to fetch.
     */
    where?: pokemon_game_locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_game_locations to fetch.
     */
    orderBy?: pokemon_game_locationOrderByWithRelationInput | pokemon_game_locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pokemon_game_locations.
     */
    cursor?: pokemon_game_locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_game_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_game_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pokemon_game_locations.
     */
    distinct?: Pokemon_game_locationScalarFieldEnum | Pokemon_game_locationScalarFieldEnum[]
  }

  /**
   * pokemon_game_location findMany
   */
  export type pokemon_game_locationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
    /**
     * Filter, which pokemon_game_locations to fetch.
     */
    where?: pokemon_game_locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pokemon_game_locations to fetch.
     */
    orderBy?: pokemon_game_locationOrderByWithRelationInput | pokemon_game_locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pokemon_game_locations.
     */
    cursor?: pokemon_game_locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pokemon_game_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pokemon_game_locations.
     */
    skip?: number
    distinct?: Pokemon_game_locationScalarFieldEnum | Pokemon_game_locationScalarFieldEnum[]
  }

  /**
   * pokemon_game_location create
   */
  export type pokemon_game_locationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
    /**
     * The data needed to create a pokemon_game_location.
     */
    data: XOR<pokemon_game_locationCreateInput, pokemon_game_locationUncheckedCreateInput>
  }

  /**
   * pokemon_game_location createMany
   */
  export type pokemon_game_locationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pokemon_game_locations.
     */
    data: pokemon_game_locationCreateManyInput | pokemon_game_locationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pokemon_game_location update
   */
  export type pokemon_game_locationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
    /**
     * The data needed to update a pokemon_game_location.
     */
    data: XOR<pokemon_game_locationUpdateInput, pokemon_game_locationUncheckedUpdateInput>
    /**
     * Choose, which pokemon_game_location to update.
     */
    where: pokemon_game_locationWhereUniqueInput
  }

  /**
   * pokemon_game_location updateMany
   */
  export type pokemon_game_locationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pokemon_game_locations.
     */
    data: XOR<pokemon_game_locationUpdateManyMutationInput, pokemon_game_locationUncheckedUpdateManyInput>
    /**
     * Filter which pokemon_game_locations to update
     */
    where?: pokemon_game_locationWhereInput
    /**
     * Limit how many pokemon_game_locations to update.
     */
    limit?: number
  }

  /**
   * pokemon_game_location upsert
   */
  export type pokemon_game_locationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
    /**
     * The filter to search for the pokemon_game_location to update in case it exists.
     */
    where: pokemon_game_locationWhereUniqueInput
    /**
     * In case the pokemon_game_location found by the `where` argument doesn't exist, create a new pokemon_game_location with this data.
     */
    create: XOR<pokemon_game_locationCreateInput, pokemon_game_locationUncheckedCreateInput>
    /**
     * In case the pokemon_game_location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pokemon_game_locationUpdateInput, pokemon_game_locationUncheckedUpdateInput>
  }

  /**
   * pokemon_game_location delete
   */
  export type pokemon_game_locationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
    /**
     * Filter which pokemon_game_location to delete.
     */
    where: pokemon_game_locationWhereUniqueInput
  }

  /**
   * pokemon_game_location deleteMany
   */
  export type pokemon_game_locationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pokemon_game_locations to delete
     */
    where?: pokemon_game_locationWhereInput
    /**
     * Limit how many pokemon_game_locations to delete.
     */
    limit?: number
  }

  /**
   * pokemon_game_location without action
   */
  export type pokemon_game_locationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pokemon_game_location
     */
    select?: pokemon_game_locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pokemon_game_location
     */
    omit?: pokemon_game_locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pokemon_game_locationInclude<ExtArgs> | null
  }


  /**
   * Model skill_obtation
   */

  export type AggregateSkill_obtation = {
    _count: Skill_obtationCountAggregateOutputType | null
    _avg: Skill_obtationAvgAggregateOutputType | null
    _sum: Skill_obtationSumAggregateOutputType | null
    _min: Skill_obtationMinAggregateOutputType | null
    _max: Skill_obtationMaxAggregateOutputType | null
  }

  export type Skill_obtationAvgAggregateOutputType = {
    capacityId: number | null
    pokemonId: number | null
    groupGameId: number | null
    skillObtationTypeId: number | null
  }

  export type Skill_obtationSumAggregateOutputType = {
    capacityId: number | null
    pokemonId: number | null
    groupGameId: number | null
    skillObtationTypeId: number | null
  }

  export type Skill_obtationMinAggregateOutputType = {
    capacityId: number | null
    pokemonId: number | null
    groupGameId: number | null
    skillObtationTypeId: number | null
    detail: string | null
  }

  export type Skill_obtationMaxAggregateOutputType = {
    capacityId: number | null
    pokemonId: number | null
    groupGameId: number | null
    skillObtationTypeId: number | null
    detail: string | null
  }

  export type Skill_obtationCountAggregateOutputType = {
    capacityId: number
    pokemonId: number
    groupGameId: number
    skillObtationTypeId: number
    detail: number
    _all: number
  }


  export type Skill_obtationAvgAggregateInputType = {
    capacityId?: true
    pokemonId?: true
    groupGameId?: true
    skillObtationTypeId?: true
  }

  export type Skill_obtationSumAggregateInputType = {
    capacityId?: true
    pokemonId?: true
    groupGameId?: true
    skillObtationTypeId?: true
  }

  export type Skill_obtationMinAggregateInputType = {
    capacityId?: true
    pokemonId?: true
    groupGameId?: true
    skillObtationTypeId?: true
    detail?: true
  }

  export type Skill_obtationMaxAggregateInputType = {
    capacityId?: true
    pokemonId?: true
    groupGameId?: true
    skillObtationTypeId?: true
    detail?: true
  }

  export type Skill_obtationCountAggregateInputType = {
    capacityId?: true
    pokemonId?: true
    groupGameId?: true
    skillObtationTypeId?: true
    detail?: true
    _all?: true
  }

  export type Skill_obtationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skill_obtation to aggregate.
     */
    where?: skill_obtationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skill_obtations to fetch.
     */
    orderBy?: skill_obtationOrderByWithRelationInput | skill_obtationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skill_obtationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skill_obtations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skill_obtations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skill_obtations
    **/
    _count?: true | Skill_obtationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Skill_obtationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Skill_obtationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Skill_obtationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Skill_obtationMaxAggregateInputType
  }

  export type GetSkill_obtationAggregateType<T extends Skill_obtationAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill_obtation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill_obtation[P]>
      : GetScalarType<T[P], AggregateSkill_obtation[P]>
  }




  export type skill_obtationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skill_obtationWhereInput
    orderBy?: skill_obtationOrderByWithAggregationInput | skill_obtationOrderByWithAggregationInput[]
    by: Skill_obtationScalarFieldEnum[] | Skill_obtationScalarFieldEnum
    having?: skill_obtationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Skill_obtationCountAggregateInputType | true
    _avg?: Skill_obtationAvgAggregateInputType
    _sum?: Skill_obtationSumAggregateInputType
    _min?: Skill_obtationMinAggregateInputType
    _max?: Skill_obtationMaxAggregateInputType
  }

  export type Skill_obtationGroupByOutputType = {
    capacityId: number
    pokemonId: number
    groupGameId: number
    skillObtationTypeId: number
    detail: string
    _count: Skill_obtationCountAggregateOutputType | null
    _avg: Skill_obtationAvgAggregateOutputType | null
    _sum: Skill_obtationSumAggregateOutputType | null
    _min: Skill_obtationMinAggregateOutputType | null
    _max: Skill_obtationMaxAggregateOutputType | null
  }

  type GetSkill_obtationGroupByPayload<T extends skill_obtationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Skill_obtationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Skill_obtationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Skill_obtationGroupByOutputType[P]>
            : GetScalarType<T[P], Skill_obtationGroupByOutputType[P]>
        }
      >
    >


  export type skill_obtationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    capacityId?: boolean
    pokemonId?: boolean
    groupGameId?: boolean
    skillObtationTypeId?: boolean
    detail?: boolean
    capacity?: boolean | capacityDefaultArgs<ExtArgs>
    groupGame?: boolean | group_gameDefaultArgs<ExtArgs>
    pokemon?: boolean | pokemonDefaultArgs<ExtArgs>
    skillObtationType?: boolean | skill_obtation_typeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill_obtation"]>



  export type skill_obtationSelectScalar = {
    capacityId?: boolean
    pokemonId?: boolean
    groupGameId?: boolean
    skillObtationTypeId?: boolean
    detail?: boolean
  }

  export type skill_obtationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"capacityId" | "pokemonId" | "groupGameId" | "skillObtationTypeId" | "detail", ExtArgs["result"]["skill_obtation"]>
  export type skill_obtationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capacity?: boolean | capacityDefaultArgs<ExtArgs>
    groupGame?: boolean | group_gameDefaultArgs<ExtArgs>
    pokemon?: boolean | pokemonDefaultArgs<ExtArgs>
    skillObtationType?: boolean | skill_obtation_typeDefaultArgs<ExtArgs>
  }

  export type $skill_obtationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "skill_obtation"
    objects: {
      capacity: Prisma.$capacityPayload<ExtArgs>
      groupGame: Prisma.$group_gamePayload<ExtArgs>
      pokemon: Prisma.$pokemonPayload<ExtArgs>
      skillObtationType: Prisma.$skill_obtation_typePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      capacityId: number
      pokemonId: number
      groupGameId: number
      skillObtationTypeId: number
      detail: string
    }, ExtArgs["result"]["skill_obtation"]>
    composites: {}
  }

  type skill_obtationGetPayload<S extends boolean | null | undefined | skill_obtationDefaultArgs> = $Result.GetResult<Prisma.$skill_obtationPayload, S>

  type skill_obtationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<skill_obtationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Skill_obtationCountAggregateInputType | true
    }

  export interface skill_obtationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['skill_obtation'], meta: { name: 'skill_obtation' } }
    /**
     * Find zero or one Skill_obtation that matches the filter.
     * @param {skill_obtationFindUniqueArgs} args - Arguments to find a Skill_obtation
     * @example
     * // Get one Skill_obtation
     * const skill_obtation = await prisma.skill_obtation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends skill_obtationFindUniqueArgs>(args: SelectSubset<T, skill_obtationFindUniqueArgs<ExtArgs>>): Prisma__skill_obtationClient<$Result.GetResult<Prisma.$skill_obtationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skill_obtation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {skill_obtationFindUniqueOrThrowArgs} args - Arguments to find a Skill_obtation
     * @example
     * // Get one Skill_obtation
     * const skill_obtation = await prisma.skill_obtation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends skill_obtationFindUniqueOrThrowArgs>(args: SelectSubset<T, skill_obtationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__skill_obtationClient<$Result.GetResult<Prisma.$skill_obtationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill_obtation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skill_obtationFindFirstArgs} args - Arguments to find a Skill_obtation
     * @example
     * // Get one Skill_obtation
     * const skill_obtation = await prisma.skill_obtation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends skill_obtationFindFirstArgs>(args?: SelectSubset<T, skill_obtationFindFirstArgs<ExtArgs>>): Prisma__skill_obtationClient<$Result.GetResult<Prisma.$skill_obtationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill_obtation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skill_obtationFindFirstOrThrowArgs} args - Arguments to find a Skill_obtation
     * @example
     * // Get one Skill_obtation
     * const skill_obtation = await prisma.skill_obtation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends skill_obtationFindFirstOrThrowArgs>(args?: SelectSubset<T, skill_obtationFindFirstOrThrowArgs<ExtArgs>>): Prisma__skill_obtationClient<$Result.GetResult<Prisma.$skill_obtationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skill_obtations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skill_obtationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skill_obtations
     * const skill_obtations = await prisma.skill_obtation.findMany()
     * 
     * // Get first 10 Skill_obtations
     * const skill_obtations = await prisma.skill_obtation.findMany({ take: 10 })
     * 
     * // Only select the `capacityId`
     * const skill_obtationWithCapacityIdOnly = await prisma.skill_obtation.findMany({ select: { capacityId: true } })
     * 
     */
    findMany<T extends skill_obtationFindManyArgs>(args?: SelectSubset<T, skill_obtationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skill_obtationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skill_obtation.
     * @param {skill_obtationCreateArgs} args - Arguments to create a Skill_obtation.
     * @example
     * // Create one Skill_obtation
     * const Skill_obtation = await prisma.skill_obtation.create({
     *   data: {
     *     // ... data to create a Skill_obtation
     *   }
     * })
     * 
     */
    create<T extends skill_obtationCreateArgs>(args: SelectSubset<T, skill_obtationCreateArgs<ExtArgs>>): Prisma__skill_obtationClient<$Result.GetResult<Prisma.$skill_obtationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skill_obtations.
     * @param {skill_obtationCreateManyArgs} args - Arguments to create many Skill_obtations.
     * @example
     * // Create many Skill_obtations
     * const skill_obtation = await prisma.skill_obtation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends skill_obtationCreateManyArgs>(args?: SelectSubset<T, skill_obtationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Skill_obtation.
     * @param {skill_obtationDeleteArgs} args - Arguments to delete one Skill_obtation.
     * @example
     * // Delete one Skill_obtation
     * const Skill_obtation = await prisma.skill_obtation.delete({
     *   where: {
     *     // ... filter to delete one Skill_obtation
     *   }
     * })
     * 
     */
    delete<T extends skill_obtationDeleteArgs>(args: SelectSubset<T, skill_obtationDeleteArgs<ExtArgs>>): Prisma__skill_obtationClient<$Result.GetResult<Prisma.$skill_obtationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skill_obtation.
     * @param {skill_obtationUpdateArgs} args - Arguments to update one Skill_obtation.
     * @example
     * // Update one Skill_obtation
     * const skill_obtation = await prisma.skill_obtation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends skill_obtationUpdateArgs>(args: SelectSubset<T, skill_obtationUpdateArgs<ExtArgs>>): Prisma__skill_obtationClient<$Result.GetResult<Prisma.$skill_obtationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skill_obtations.
     * @param {skill_obtationDeleteManyArgs} args - Arguments to filter Skill_obtations to delete.
     * @example
     * // Delete a few Skill_obtations
     * const { count } = await prisma.skill_obtation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends skill_obtationDeleteManyArgs>(args?: SelectSubset<T, skill_obtationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skill_obtations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skill_obtationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skill_obtations
     * const skill_obtation = await prisma.skill_obtation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends skill_obtationUpdateManyArgs>(args: SelectSubset<T, skill_obtationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skill_obtation.
     * @param {skill_obtationUpsertArgs} args - Arguments to update or create a Skill_obtation.
     * @example
     * // Update or create a Skill_obtation
     * const skill_obtation = await prisma.skill_obtation.upsert({
     *   create: {
     *     // ... data to create a Skill_obtation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill_obtation we want to update
     *   }
     * })
     */
    upsert<T extends skill_obtationUpsertArgs>(args: SelectSubset<T, skill_obtationUpsertArgs<ExtArgs>>): Prisma__skill_obtationClient<$Result.GetResult<Prisma.$skill_obtationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skill_obtations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skill_obtationCountArgs} args - Arguments to filter Skill_obtations to count.
     * @example
     * // Count the number of Skill_obtations
     * const count = await prisma.skill_obtation.count({
     *   where: {
     *     // ... the filter for the Skill_obtations we want to count
     *   }
     * })
    **/
    count<T extends skill_obtationCountArgs>(
      args?: Subset<T, skill_obtationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Skill_obtationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill_obtation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Skill_obtationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Skill_obtationAggregateArgs>(args: Subset<T, Skill_obtationAggregateArgs>): Prisma.PrismaPromise<GetSkill_obtationAggregateType<T>>

    /**
     * Group by Skill_obtation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skill_obtationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends skill_obtationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: skill_obtationGroupByArgs['orderBy'] }
        : { orderBy?: skill_obtationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, skill_obtationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkill_obtationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the skill_obtation model
   */
  readonly fields: skill_obtationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for skill_obtation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__skill_obtationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capacity<T extends capacityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, capacityDefaultArgs<ExtArgs>>): Prisma__capacityClient<$Result.GetResult<Prisma.$capacityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    groupGame<T extends group_gameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, group_gameDefaultArgs<ExtArgs>>): Prisma__group_gameClient<$Result.GetResult<Prisma.$group_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemon<T extends pokemonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pokemonDefaultArgs<ExtArgs>>): Prisma__pokemonClient<$Result.GetResult<Prisma.$pokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skillObtationType<T extends skill_obtation_typeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, skill_obtation_typeDefaultArgs<ExtArgs>>): Prisma__skill_obtation_typeClient<$Result.GetResult<Prisma.$skill_obtation_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the skill_obtation model
   */
  interface skill_obtationFieldRefs {
    readonly capacityId: FieldRef<"skill_obtation", 'Int'>
    readonly pokemonId: FieldRef<"skill_obtation", 'Int'>
    readonly groupGameId: FieldRef<"skill_obtation", 'Int'>
    readonly skillObtationTypeId: FieldRef<"skill_obtation", 'Int'>
    readonly detail: FieldRef<"skill_obtation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * skill_obtation findUnique
   */
  export type skill_obtationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation
     */
    select?: skill_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation
     */
    omit?: skill_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtationInclude<ExtArgs> | null
    /**
     * Filter, which skill_obtation to fetch.
     */
    where: skill_obtationWhereUniqueInput
  }

  /**
   * skill_obtation findUniqueOrThrow
   */
  export type skill_obtationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation
     */
    select?: skill_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation
     */
    omit?: skill_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtationInclude<ExtArgs> | null
    /**
     * Filter, which skill_obtation to fetch.
     */
    where: skill_obtationWhereUniqueInput
  }

  /**
   * skill_obtation findFirst
   */
  export type skill_obtationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation
     */
    select?: skill_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation
     */
    omit?: skill_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtationInclude<ExtArgs> | null
    /**
     * Filter, which skill_obtation to fetch.
     */
    where?: skill_obtationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skill_obtations to fetch.
     */
    orderBy?: skill_obtationOrderByWithRelationInput | skill_obtationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skill_obtations.
     */
    cursor?: skill_obtationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skill_obtations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skill_obtations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skill_obtations.
     */
    distinct?: Skill_obtationScalarFieldEnum | Skill_obtationScalarFieldEnum[]
  }

  /**
   * skill_obtation findFirstOrThrow
   */
  export type skill_obtationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation
     */
    select?: skill_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation
     */
    omit?: skill_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtationInclude<ExtArgs> | null
    /**
     * Filter, which skill_obtation to fetch.
     */
    where?: skill_obtationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skill_obtations to fetch.
     */
    orderBy?: skill_obtationOrderByWithRelationInput | skill_obtationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skill_obtations.
     */
    cursor?: skill_obtationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skill_obtations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skill_obtations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skill_obtations.
     */
    distinct?: Skill_obtationScalarFieldEnum | Skill_obtationScalarFieldEnum[]
  }

  /**
   * skill_obtation findMany
   */
  export type skill_obtationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation
     */
    select?: skill_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation
     */
    omit?: skill_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtationInclude<ExtArgs> | null
    /**
     * Filter, which skill_obtations to fetch.
     */
    where?: skill_obtationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skill_obtations to fetch.
     */
    orderBy?: skill_obtationOrderByWithRelationInput | skill_obtationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skill_obtations.
     */
    cursor?: skill_obtationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skill_obtations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skill_obtations.
     */
    skip?: number
    distinct?: Skill_obtationScalarFieldEnum | Skill_obtationScalarFieldEnum[]
  }

  /**
   * skill_obtation create
   */
  export type skill_obtationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation
     */
    select?: skill_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation
     */
    omit?: skill_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtationInclude<ExtArgs> | null
    /**
     * The data needed to create a skill_obtation.
     */
    data: XOR<skill_obtationCreateInput, skill_obtationUncheckedCreateInput>
  }

  /**
   * skill_obtation createMany
   */
  export type skill_obtationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many skill_obtations.
     */
    data: skill_obtationCreateManyInput | skill_obtationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * skill_obtation update
   */
  export type skill_obtationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation
     */
    select?: skill_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation
     */
    omit?: skill_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtationInclude<ExtArgs> | null
    /**
     * The data needed to update a skill_obtation.
     */
    data: XOR<skill_obtationUpdateInput, skill_obtationUncheckedUpdateInput>
    /**
     * Choose, which skill_obtation to update.
     */
    where: skill_obtationWhereUniqueInput
  }

  /**
   * skill_obtation updateMany
   */
  export type skill_obtationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update skill_obtations.
     */
    data: XOR<skill_obtationUpdateManyMutationInput, skill_obtationUncheckedUpdateManyInput>
    /**
     * Filter which skill_obtations to update
     */
    where?: skill_obtationWhereInput
    /**
     * Limit how many skill_obtations to update.
     */
    limit?: number
  }

  /**
   * skill_obtation upsert
   */
  export type skill_obtationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation
     */
    select?: skill_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation
     */
    omit?: skill_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtationInclude<ExtArgs> | null
    /**
     * The filter to search for the skill_obtation to update in case it exists.
     */
    where: skill_obtationWhereUniqueInput
    /**
     * In case the skill_obtation found by the `where` argument doesn't exist, create a new skill_obtation with this data.
     */
    create: XOR<skill_obtationCreateInput, skill_obtationUncheckedCreateInput>
    /**
     * In case the skill_obtation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skill_obtationUpdateInput, skill_obtationUncheckedUpdateInput>
  }

  /**
   * skill_obtation delete
   */
  export type skill_obtationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation
     */
    select?: skill_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation
     */
    omit?: skill_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtationInclude<ExtArgs> | null
    /**
     * Filter which skill_obtation to delete.
     */
    where: skill_obtationWhereUniqueInput
  }

  /**
   * skill_obtation deleteMany
   */
  export type skill_obtationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skill_obtations to delete
     */
    where?: skill_obtationWhereInput
    /**
     * Limit how many skill_obtations to delete.
     */
    limit?: number
  }

  /**
   * skill_obtation without action
   */
  export type skill_obtationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill_obtation
     */
    select?: skill_obtationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill_obtation
     */
    omit?: skill_obtationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skill_obtationInclude<ExtArgs> | null
  }


  /**
   * Model refresh_token
   */

  export type AggregateRefresh_token = {
    _count: Refresh_tokenCountAggregateOutputType | null
    _avg: Refresh_tokenAvgAggregateOutputType | null
    _sum: Refresh_tokenSumAggregateOutputType | null
    _min: Refresh_tokenMinAggregateOutputType | null
    _max: Refresh_tokenMaxAggregateOutputType | null
  }

  export type Refresh_tokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type Refresh_tokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type Refresh_tokenMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
  }

  export type Refresh_tokenMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
  }

  export type Refresh_tokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    _all: number
  }


  export type Refresh_tokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type Refresh_tokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type Refresh_tokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
  }

  export type Refresh_tokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
  }

  export type Refresh_tokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    _all?: true
  }

  export type Refresh_tokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refresh_token to aggregate.
     */
    where?: refresh_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokenOrderByWithRelationInput | refresh_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: refresh_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned refresh_tokens
    **/
    _count?: true | Refresh_tokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Refresh_tokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Refresh_tokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Refresh_tokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Refresh_tokenMaxAggregateInputType
  }

  export type GetRefresh_tokenAggregateType<T extends Refresh_tokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefresh_token]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefresh_token[P]>
      : GetScalarType<T[P], AggregateRefresh_token[P]>
  }




  export type refresh_tokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refresh_tokenWhereInput
    orderBy?: refresh_tokenOrderByWithAggregationInput | refresh_tokenOrderByWithAggregationInput[]
    by: Refresh_tokenScalarFieldEnum[] | Refresh_tokenScalarFieldEnum
    having?: refresh_tokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Refresh_tokenCountAggregateInputType | true
    _avg?: Refresh_tokenAvgAggregateInputType
    _sum?: Refresh_tokenSumAggregateInputType
    _min?: Refresh_tokenMinAggregateInputType
    _max?: Refresh_tokenMaxAggregateInputType
  }

  export type Refresh_tokenGroupByOutputType = {
    id: number
    userId: number
    token: string
    expiresAt: Date
    _count: Refresh_tokenCountAggregateOutputType | null
    _avg: Refresh_tokenAvgAggregateOutputType | null
    _sum: Refresh_tokenSumAggregateOutputType | null
    _min: Refresh_tokenMinAggregateOutputType | null
    _max: Refresh_tokenMaxAggregateOutputType | null
  }

  type GetRefresh_tokenGroupByPayload<T extends refresh_tokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Refresh_tokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Refresh_tokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Refresh_tokenGroupByOutputType[P]>
            : GetScalarType<T[P], Refresh_tokenGroupByOutputType[P]>
        }
      >
    >


  export type refresh_tokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    users?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refresh_token"]>



  export type refresh_tokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
  }

  export type refresh_tokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt", ExtArgs["result"]["refresh_token"]>
  export type refresh_tokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $refresh_tokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "refresh_token"
    objects: {
      users: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      expiresAt: Date
    }, ExtArgs["result"]["refresh_token"]>
    composites: {}
  }

  type refresh_tokenGetPayload<S extends boolean | null | undefined | refresh_tokenDefaultArgs> = $Result.GetResult<Prisma.$refresh_tokenPayload, S>

  type refresh_tokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<refresh_tokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Refresh_tokenCountAggregateInputType | true
    }

  export interface refresh_tokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['refresh_token'], meta: { name: 'refresh_token' } }
    /**
     * Find zero or one Refresh_token that matches the filter.
     * @param {refresh_tokenFindUniqueArgs} args - Arguments to find a Refresh_token
     * @example
     * // Get one Refresh_token
     * const refresh_token = await prisma.refresh_token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends refresh_tokenFindUniqueArgs>(args: SelectSubset<T, refresh_tokenFindUniqueArgs<ExtArgs>>): Prisma__refresh_tokenClient<$Result.GetResult<Prisma.$refresh_tokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Refresh_token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {refresh_tokenFindUniqueOrThrowArgs} args - Arguments to find a Refresh_token
     * @example
     * // Get one Refresh_token
     * const refresh_token = await prisma.refresh_token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends refresh_tokenFindUniqueOrThrowArgs>(args: SelectSubset<T, refresh_tokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__refresh_tokenClient<$Result.GetResult<Prisma.$refresh_tokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refresh_token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokenFindFirstArgs} args - Arguments to find a Refresh_token
     * @example
     * // Get one Refresh_token
     * const refresh_token = await prisma.refresh_token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends refresh_tokenFindFirstArgs>(args?: SelectSubset<T, refresh_tokenFindFirstArgs<ExtArgs>>): Prisma__refresh_tokenClient<$Result.GetResult<Prisma.$refresh_tokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refresh_token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokenFindFirstOrThrowArgs} args - Arguments to find a Refresh_token
     * @example
     * // Get one Refresh_token
     * const refresh_token = await prisma.refresh_token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends refresh_tokenFindFirstOrThrowArgs>(args?: SelectSubset<T, refresh_tokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__refresh_tokenClient<$Result.GetResult<Prisma.$refresh_tokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Refresh_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refresh_tokens
     * const refresh_tokens = await prisma.refresh_token.findMany()
     * 
     * // Get first 10 Refresh_tokens
     * const refresh_tokens = await prisma.refresh_token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refresh_tokenWithIdOnly = await prisma.refresh_token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends refresh_tokenFindManyArgs>(args?: SelectSubset<T, refresh_tokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refresh_tokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Refresh_token.
     * @param {refresh_tokenCreateArgs} args - Arguments to create a Refresh_token.
     * @example
     * // Create one Refresh_token
     * const Refresh_token = await prisma.refresh_token.create({
     *   data: {
     *     // ... data to create a Refresh_token
     *   }
     * })
     * 
     */
    create<T extends refresh_tokenCreateArgs>(args: SelectSubset<T, refresh_tokenCreateArgs<ExtArgs>>): Prisma__refresh_tokenClient<$Result.GetResult<Prisma.$refresh_tokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Refresh_tokens.
     * @param {refresh_tokenCreateManyArgs} args - Arguments to create many Refresh_tokens.
     * @example
     * // Create many Refresh_tokens
     * const refresh_token = await prisma.refresh_token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends refresh_tokenCreateManyArgs>(args?: SelectSubset<T, refresh_tokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Refresh_token.
     * @param {refresh_tokenDeleteArgs} args - Arguments to delete one Refresh_token.
     * @example
     * // Delete one Refresh_token
     * const Refresh_token = await prisma.refresh_token.delete({
     *   where: {
     *     // ... filter to delete one Refresh_token
     *   }
     * })
     * 
     */
    delete<T extends refresh_tokenDeleteArgs>(args: SelectSubset<T, refresh_tokenDeleteArgs<ExtArgs>>): Prisma__refresh_tokenClient<$Result.GetResult<Prisma.$refresh_tokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Refresh_token.
     * @param {refresh_tokenUpdateArgs} args - Arguments to update one Refresh_token.
     * @example
     * // Update one Refresh_token
     * const refresh_token = await prisma.refresh_token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends refresh_tokenUpdateArgs>(args: SelectSubset<T, refresh_tokenUpdateArgs<ExtArgs>>): Prisma__refresh_tokenClient<$Result.GetResult<Prisma.$refresh_tokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Refresh_tokens.
     * @param {refresh_tokenDeleteManyArgs} args - Arguments to filter Refresh_tokens to delete.
     * @example
     * // Delete a few Refresh_tokens
     * const { count } = await prisma.refresh_token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends refresh_tokenDeleteManyArgs>(args?: SelectSubset<T, refresh_tokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refresh_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refresh_tokens
     * const refresh_token = await prisma.refresh_token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends refresh_tokenUpdateManyArgs>(args: SelectSubset<T, refresh_tokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Refresh_token.
     * @param {refresh_tokenUpsertArgs} args - Arguments to update or create a Refresh_token.
     * @example
     * // Update or create a Refresh_token
     * const refresh_token = await prisma.refresh_token.upsert({
     *   create: {
     *     // ... data to create a Refresh_token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refresh_token we want to update
     *   }
     * })
     */
    upsert<T extends refresh_tokenUpsertArgs>(args: SelectSubset<T, refresh_tokenUpsertArgs<ExtArgs>>): Prisma__refresh_tokenClient<$Result.GetResult<Prisma.$refresh_tokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Refresh_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokenCountArgs} args - Arguments to filter Refresh_tokens to count.
     * @example
     * // Count the number of Refresh_tokens
     * const count = await prisma.refresh_token.count({
     *   where: {
     *     // ... the filter for the Refresh_tokens we want to count
     *   }
     * })
    **/
    count<T extends refresh_tokenCountArgs>(
      args?: Subset<T, refresh_tokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Refresh_tokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refresh_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Refresh_tokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Refresh_tokenAggregateArgs>(args: Subset<T, Refresh_tokenAggregateArgs>): Prisma.PrismaPromise<GetRefresh_tokenAggregateType<T>>

    /**
     * Group by Refresh_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends refresh_tokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: refresh_tokenGroupByArgs['orderBy'] }
        : { orderBy?: refresh_tokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, refresh_tokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefresh_tokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the refresh_token model
   */
  readonly fields: refresh_tokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for refresh_token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__refresh_tokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the refresh_token model
   */
  interface refresh_tokenFieldRefs {
    readonly id: FieldRef<"refresh_token", 'Int'>
    readonly userId: FieldRef<"refresh_token", 'Int'>
    readonly token: FieldRef<"refresh_token", 'String'>
    readonly expiresAt: FieldRef<"refresh_token", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * refresh_token findUnique
   */
  export type refresh_tokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_token
     */
    select?: refresh_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_token
     */
    omit?: refresh_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokenInclude<ExtArgs> | null
    /**
     * Filter, which refresh_token to fetch.
     */
    where: refresh_tokenWhereUniqueInput
  }

  /**
   * refresh_token findUniqueOrThrow
   */
  export type refresh_tokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_token
     */
    select?: refresh_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_token
     */
    omit?: refresh_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokenInclude<ExtArgs> | null
    /**
     * Filter, which refresh_token to fetch.
     */
    where: refresh_tokenWhereUniqueInput
  }

  /**
   * refresh_token findFirst
   */
  export type refresh_tokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_token
     */
    select?: refresh_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_token
     */
    omit?: refresh_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokenInclude<ExtArgs> | null
    /**
     * Filter, which refresh_token to fetch.
     */
    where?: refresh_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokenOrderByWithRelationInput | refresh_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refresh_tokens.
     */
    cursor?: refresh_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refresh_tokens.
     */
    distinct?: Refresh_tokenScalarFieldEnum | Refresh_tokenScalarFieldEnum[]
  }

  /**
   * refresh_token findFirstOrThrow
   */
  export type refresh_tokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_token
     */
    select?: refresh_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_token
     */
    omit?: refresh_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokenInclude<ExtArgs> | null
    /**
     * Filter, which refresh_token to fetch.
     */
    where?: refresh_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokenOrderByWithRelationInput | refresh_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refresh_tokens.
     */
    cursor?: refresh_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refresh_tokens.
     */
    distinct?: Refresh_tokenScalarFieldEnum | Refresh_tokenScalarFieldEnum[]
  }

  /**
   * refresh_token findMany
   */
  export type refresh_tokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_token
     */
    select?: refresh_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_token
     */
    omit?: refresh_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokenInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where?: refresh_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokenOrderByWithRelationInput | refresh_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing refresh_tokens.
     */
    cursor?: refresh_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    distinct?: Refresh_tokenScalarFieldEnum | Refresh_tokenScalarFieldEnum[]
  }

  /**
   * refresh_token create
   */
  export type refresh_tokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_token
     */
    select?: refresh_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_token
     */
    omit?: refresh_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokenInclude<ExtArgs> | null
    /**
     * The data needed to create a refresh_token.
     */
    data: XOR<refresh_tokenCreateInput, refresh_tokenUncheckedCreateInput>
  }

  /**
   * refresh_token createMany
   */
  export type refresh_tokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many refresh_tokens.
     */
    data: refresh_tokenCreateManyInput | refresh_tokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * refresh_token update
   */
  export type refresh_tokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_token
     */
    select?: refresh_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_token
     */
    omit?: refresh_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokenInclude<ExtArgs> | null
    /**
     * The data needed to update a refresh_token.
     */
    data: XOR<refresh_tokenUpdateInput, refresh_tokenUncheckedUpdateInput>
    /**
     * Choose, which refresh_token to update.
     */
    where: refresh_tokenWhereUniqueInput
  }

  /**
   * refresh_token updateMany
   */
  export type refresh_tokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update refresh_tokens.
     */
    data: XOR<refresh_tokenUpdateManyMutationInput, refresh_tokenUncheckedUpdateManyInput>
    /**
     * Filter which refresh_tokens to update
     */
    where?: refresh_tokenWhereInput
    /**
     * Limit how many refresh_tokens to update.
     */
    limit?: number
  }

  /**
   * refresh_token upsert
   */
  export type refresh_tokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_token
     */
    select?: refresh_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_token
     */
    omit?: refresh_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokenInclude<ExtArgs> | null
    /**
     * The filter to search for the refresh_token to update in case it exists.
     */
    where: refresh_tokenWhereUniqueInput
    /**
     * In case the refresh_token found by the `where` argument doesn't exist, create a new refresh_token with this data.
     */
    create: XOR<refresh_tokenCreateInput, refresh_tokenUncheckedCreateInput>
    /**
     * In case the refresh_token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<refresh_tokenUpdateInput, refresh_tokenUncheckedUpdateInput>
  }

  /**
   * refresh_token delete
   */
  export type refresh_tokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_token
     */
    select?: refresh_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_token
     */
    omit?: refresh_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokenInclude<ExtArgs> | null
    /**
     * Filter which refresh_token to delete.
     */
    where: refresh_tokenWhereUniqueInput
  }

  /**
   * refresh_token deleteMany
   */
  export type refresh_tokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refresh_tokens to delete
     */
    where?: refresh_tokenWhereInput
    /**
     * Limit how many refresh_tokens to delete.
     */
    limit?: number
  }

  /**
   * refresh_token without action
   */
  export type refresh_tokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_token
     */
    select?: refresh_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_token
     */
    omit?: refresh_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokenInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const LangueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isoCode: 'isoCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type LangueScalarFieldEnum = (typeof LangueScalarFieldEnum)[keyof typeof LangueScalarFieldEnum]


  export const TranslationScalarFieldEnum: {
    langueId: 'langueId',
    referenceId: 'referenceId',
    referenceTable: 'referenceTable',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type TranslationScalarFieldEnum = (typeof TranslationScalarFieldEnum)[keyof typeof TranslationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    discordId: 'discordId',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    pseudonym: 'pseudonym',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const Shiny_hunting_methodScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Shiny_hunting_methodScalarFieldEnum = (typeof Shiny_hunting_methodScalarFieldEnum)[keyof typeof Shiny_hunting_methodScalarFieldEnum]


  export const PokeballScalarFieldEnum: {
    id: 'id',
    picture: 'picture',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type PokeballScalarFieldEnum = (typeof PokeballScalarFieldEnum)[keyof typeof PokeballScalarFieldEnum]


  export const GenerationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type GenerationScalarFieldEnum = (typeof GenerationScalarFieldEnum)[keyof typeof GenerationScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    generationId: 'generationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const Game_group_gameScalarFieldEnum: {
    gameId: 'gameId',
    groupGameId: 'groupGameId',
    landId: 'landId'
  };

  export type Game_group_gameScalarFieldEnum = (typeof Game_group_gameScalarFieldEnum)[keyof typeof Game_group_gameScalarFieldEnum]


  export const Group_gameScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Group_gameScalarFieldEnum = (typeof Group_gameScalarFieldEnum)[keyof typeof Group_gameScalarFieldEnum]


  export const Capsule_game_capacity_infoScalarFieldEnum: {
    capacityInfoId: 'capacityInfoId',
    capsuleId: 'capsuleId',
    groupeGameId: 'groupeGameId'
  };

  export type Capsule_game_capacity_infoScalarFieldEnum = (typeof Capsule_game_capacity_infoScalarFieldEnum)[keyof typeof Capsule_game_capacity_infoScalarFieldEnum]


  export const Pokemon_categoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Pokemon_categoryScalarFieldEnum = (typeof Pokemon_categoryScalarFieldEnum)[keyof typeof Pokemon_categoryScalarFieldEnum]


  export const PokemonScalarFieldEnum: {
    id: 'id',
    internationalNumber: 'internationalNumber',
    hatchingCycle: 'hatchingCycle',
    globalXp: 'globalXp',
    captureRate: 'captureRate',
    callHelpRate: 'callHelpRate',
    size: 'size',
    weight: 'weight',
    maleRate: 'maleRate',
    femelleRate: 'femelleRate',
    pokemonCategoryId: 'pokemonCategoryId',
    generationId: 'generationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type PokemonScalarFieldEnum = (typeof PokemonScalarFieldEnum)[keyof typeof PokemonScalarFieldEnum]


  export const GenderScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type GenderScalarFieldEnum = (typeof GenderScalarFieldEnum)[keyof typeof GenderScalarFieldEnum]


  export const FormScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type FormScalarFieldEnum = (typeof FormScalarFieldEnum)[keyof typeof FormScalarFieldEnum]


  export const Pokemon_form_genderScalarFieldEnum: {
    pokemonFormId: 'pokemonFormId',
    genderId: 'genderId'
  };

  export type Pokemon_form_genderScalarFieldEnum = (typeof Pokemon_form_genderScalarFieldEnum)[keyof typeof Pokemon_form_genderScalarFieldEnum]


  export const Pokemon_formScalarFieldEnum: {
    pokemonId: 'pokemonId',
    formId: 'formId',
    createdAt: 'createdAt',
    id: 'id',
    status: 'status',
    updatedAt: 'updatedAt'
  };

  export type Pokemon_formScalarFieldEnum = (typeof Pokemon_formScalarFieldEnum)[keyof typeof Pokemon_formScalarFieldEnum]


  export const Owned_pokemonScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    pokemonFormId: 'pokemonFormId',
    gameId: 'gameId',
    isShiny: 'isShiny',
    methodId: 'methodId',
    meetingNumber: 'meetingNumber',
    time: 'time',
    isFinish: 'isFinish',
    useCharmChroma: 'useCharmChroma',
    creationDate: 'creationDate',
    finishDate: 'finishDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Owned_pokemonScalarFieldEnum = (typeof Owned_pokemonScalarFieldEnum)[keyof typeof Owned_pokemonScalarFieldEnum]


  export const Owned_pokemon_detailScalarFieldEnum: {
    id: 'id',
    nickname: 'nickname',
    pokeballId: 'pokeballId',
    ownedPokemonId: 'ownedPokemonId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Owned_pokemon_detailScalarFieldEnum = (typeof Owned_pokemon_detailScalarFieldEnum)[keyof typeof Owned_pokemon_detailScalarFieldEnum]


  export const AbilityScalarFieldEnum: {
    id: 'id',
    appearanceGenerationId: 'appearanceGenerationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type AbilityScalarFieldEnum = (typeof AbilityScalarFieldEnum)[keyof typeof AbilityScalarFieldEnum]


  export const Ability_infoScalarFieldEnum: {
    id: 'id',
    generationId: 'generationId',
    abilityId: 'abilityId',
    effectOutsideFightId: 'effectOutsideFightId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Ability_infoScalarFieldEnum = (typeof Ability_infoScalarFieldEnum)[keyof typeof Ability_infoScalarFieldEnum]


  export const Pokemon_infoScalarFieldEnum: {
    id: 'id',
    xpGift: 'xpGift',
    generationId: 'generationId',
    pokemonId: 'pokemonId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Pokemon_infoScalarFieldEnum = (typeof Pokemon_infoScalarFieldEnum)[keyof typeof Pokemon_infoScalarFieldEnum]


  export const Ability_orderScalarFieldEnum: {
    pokemonInfoId: 'pokemonInfoId',
    abilityId: 'abilityId',
    order: 'order',
    isHidden: 'isHidden'
  };

  export type Ability_orderScalarFieldEnum = (typeof Ability_orderScalarFieldEnum)[keyof typeof Ability_orderScalarFieldEnum]


  export const Evolution_methodScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Evolution_methodScalarFieldEnum = (typeof Evolution_methodScalarFieldEnum)[keyof typeof Evolution_methodScalarFieldEnum]


  export const EvolutionScalarFieldEnum: {
    id: 'id',
    level: 'level',
    evolutionMethodId: 'evolutionMethodId',
    pokemonFormStartId: 'pokemonFormStartId',
    pokemonFormEndId: 'pokemonFormEndId',
    evolutionInfoId: 'evolutionInfoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type EvolutionScalarFieldEnum = (typeof EvolutionScalarFieldEnum)[keyof typeof EvolutionScalarFieldEnum]


  export const Evolution_infoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Evolution_infoScalarFieldEnum = (typeof Evolution_infoScalarFieldEnum)[keyof typeof Evolution_infoScalarFieldEnum]


  export const Egg_groupScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Egg_groupScalarFieldEnum = (typeof Egg_groupScalarFieldEnum)[keyof typeof Egg_groupScalarFieldEnum]


  export const Egg_group_orderScalarFieldEnum: {
    pokemonInfoId: 'pokemonInfoId',
    eggGroupId: 'eggGroupId',
    order: 'order'
  };

  export type Egg_group_orderScalarFieldEnum = (typeof Egg_group_orderScalarFieldEnum)[keyof typeof Egg_group_orderScalarFieldEnum]


  export const TypeScalarFieldEnum: {
    id: 'id',
    color: 'color',
    iconName: 'iconName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type TypeScalarFieldEnum = (typeof TypeScalarFieldEnum)[keyof typeof TypeScalarFieldEnum]


  export const Type_orderScalarFieldEnum: {
    typeId: 'typeId',
    pokemonInfoId: 'pokemonInfoId',
    order: 'order'
  };

  export type Type_orderScalarFieldEnum = (typeof Type_orderScalarFieldEnum)[keyof typeof Type_orderScalarFieldEnum]


  export const National_numberScalarFieldEnum: {
    groupGameId: 'groupGameId',
    pokemonId: 'pokemonId',
    number: 'number'
  };

  export type National_numberScalarFieldEnum = (typeof National_numberScalarFieldEnum)[keyof typeof National_numberScalarFieldEnum]


  export const LandScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type LandScalarFieldEnum = (typeof LandScalarFieldEnum)[keyof typeof LandScalarFieldEnum]


  export const CapacityScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type CapacityScalarFieldEnum = (typeof CapacityScalarFieldEnum)[keyof typeof CapacityScalarFieldEnum]


  export const Capacity_effectScalarFieldEnum: {
    id: 'id',
    zEffect: 'zEffect',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Capacity_effectScalarFieldEnum = (typeof Capacity_effectScalarFieldEnum)[keyof typeof Capacity_effectScalarFieldEnum]


  export const Capacity_categoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Capacity_categoryScalarFieldEnum = (typeof Capacity_categoryScalarFieldEnum)[keyof typeof Capacity_categoryScalarFieldEnum]


  export const CapsuleScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type CapsuleScalarFieldEnum = (typeof CapsuleScalarFieldEnum)[keyof typeof CapsuleScalarFieldEnum]


  export const DetailScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type DetailScalarFieldEnum = (typeof DetailScalarFieldEnum)[keyof typeof DetailScalarFieldEnum]


  export const Effect_outside_fightScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Effect_outside_fightScalarFieldEnum = (typeof Effect_outside_fightScalarFieldEnum)[keyof typeof Effect_outside_fightScalarFieldEnum]


  export const InfluenceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type InfluenceScalarFieldEnum = (typeof InfluenceScalarFieldEnum)[keyof typeof InfluenceScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const Location_zoneScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    zoneId: 'zoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Location_zoneScalarFieldEnum = (typeof Location_zoneScalarFieldEnum)[keyof typeof Location_zoneScalarFieldEnum]


  export const MeteoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type MeteoScalarFieldEnum = (typeof MeteoScalarFieldEnum)[keyof typeof MeteoScalarFieldEnum]


  export const Pokemon_obtationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Pokemon_obtationScalarFieldEnum = (typeof Pokemon_obtationScalarFieldEnum)[keyof typeof Pokemon_obtationScalarFieldEnum]


  export const RateScalarFieldEnum: {
    id: 'id',
    rate: 'rate',
    minLevel: 'minLevel',
    maxLevel: 'maxLevel',
    limit: 'limit',
    meteoId: 'meteoId',
    detailRateId: 'detailRateId',
    conditionRateId: 'conditionRateId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    isAlpha: 'isAlpha'
  };

  export type RateScalarFieldEnum = (typeof RateScalarFieldEnum)[keyof typeof RateScalarFieldEnum]


  export const Shiny_hunting_method_gameScalarFieldEnum: {
    shinyHuntingMethodId: 'shinyHuntingMethodId',
    groupGameId: 'groupGameId'
  };

  export type Shiny_hunting_method_gameScalarFieldEnum = (typeof Shiny_hunting_method_gameScalarFieldEnum)[keyof typeof Shiny_hunting_method_gameScalarFieldEnum]


  export const Shiny_hunting_method_rateScalarFieldEnum: {
    shinyHuntingMethodId: 'shinyHuntingMethodId',
    rateId: 'rateId'
  };

  export type Shiny_hunting_method_rateScalarFieldEnum = (typeof Shiny_hunting_method_rateScalarFieldEnum)[keyof typeof Shiny_hunting_method_rateScalarFieldEnum]


  export const Skill_obtation_typeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Skill_obtation_typeScalarFieldEnum = (typeof Skill_obtation_typeScalarFieldEnum)[keyof typeof Skill_obtation_typeScalarFieldEnum]


  export const StatisticScalarFieldEnum: {
    id: 'id',
    pv: 'pv',
    attack: 'attack',
    defense: 'defense',
    specialAttack: 'specialAttack',
    specialDefense: 'specialDefense',
    special: 'special',
    speed: 'speed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type StatisticScalarFieldEnum = (typeof StatisticScalarFieldEnum)[keyof typeof StatisticScalarFieldEnum]


  export const Statistic_group_gameScalarFieldEnum: {
    groupGameId: 'groupGameId',
    pokemonId: 'pokemonId',
    statisticId: 'statisticId'
  };

  export type Statistic_group_gameScalarFieldEnum = (typeof Statistic_group_gameScalarFieldEnum)[keyof typeof Statistic_group_gameScalarFieldEnum]


  export const TargetScalarFieldEnum: {
    id: 'id',
    isMultiple: 'isMultiple',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type TargetScalarFieldEnum = (typeof TargetScalarFieldEnum)[keyof typeof TargetScalarFieldEnum]


  export const Capacity_infoScalarFieldEnum: {
    id: 'id',
    power: 'power',
    dynamaxPower: 'dynamaxPower',
    precision: 'precision',
    pp: 'pp',
    hasBacklash: 'hasBacklash',
    targetId: 'targetId',
    capacityEffectId: 'capacityEffectId',
    capacityId: 'capacityId',
    capacityEffectZId: 'capacityEffectZId',
    typeId: 'typeId',
    effectOutsideFightId: 'effectOutsideFightId',
    capacityCategoryId: 'capacityCategoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type Capacity_infoScalarFieldEnum = (typeof Capacity_infoScalarFieldEnum)[keyof typeof Capacity_infoScalarFieldEnum]


  export const Capacity_info_influenceScalarFieldEnum: {
    capacityInfoId: 'capacityInfoId',
    influenceId: 'influenceId'
  };

  export type Capacity_info_influenceScalarFieldEnum = (typeof Capacity_info_influenceScalarFieldEnum)[keyof typeof Capacity_info_influenceScalarFieldEnum]


  export const Pokemon_game_locationScalarFieldEnum: {
    gameId: 'gameId',
    rateId: 'rateId',
    locationZoneId: 'locationZoneId',
    pokemonObtationId: 'pokemonObtationId',
    pokemonFormId: 'pokemonFormId',
    id: 'id'
  };

  export type Pokemon_game_locationScalarFieldEnum = (typeof Pokemon_game_locationScalarFieldEnum)[keyof typeof Pokemon_game_locationScalarFieldEnum]


  export const Skill_obtationScalarFieldEnum: {
    capacityId: 'capacityId',
    pokemonId: 'pokemonId',
    groupGameId: 'groupGameId',
    skillObtationTypeId: 'skillObtationTypeId',
    detail: 'detail'
  };

  export type Skill_obtationScalarFieldEnum = (typeof Skill_obtationScalarFieldEnum)[keyof typeof Skill_obtationScalarFieldEnum]


  export const Refresh_tokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt'
  };

  export type Refresh_tokenScalarFieldEnum = (typeof Refresh_tokenScalarFieldEnum)[keyof typeof Refresh_tokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const langueOrderByRelevanceFieldEnum: {
    name: 'name',
    isoCode: 'isoCode',
    status: 'status'
  };

  export type langueOrderByRelevanceFieldEnum = (typeof langueOrderByRelevanceFieldEnum)[keyof typeof langueOrderByRelevanceFieldEnum]


  export const translationOrderByRelevanceFieldEnum: {
    name: 'name',
    status: 'status'
  };

  export type translationOrderByRelevanceFieldEnum = (typeof translationOrderByRelevanceFieldEnum)[keyof typeof translationOrderByRelevanceFieldEnum]


  export const userOrderByRelevanceFieldEnum: {
    email: 'email',
    password: 'password',
    status: 'status',
    pseudonym: 'pseudonym'
  };

  export type userOrderByRelevanceFieldEnum = (typeof userOrderByRelevanceFieldEnum)[keyof typeof userOrderByRelevanceFieldEnum]


  export const shiny_hunting_methodOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type shiny_hunting_methodOrderByRelevanceFieldEnum = (typeof shiny_hunting_methodOrderByRelevanceFieldEnum)[keyof typeof shiny_hunting_methodOrderByRelevanceFieldEnum]


  export const pokeballOrderByRelevanceFieldEnum: {
    picture: 'picture',
    status: 'status'
  };

  export type pokeballOrderByRelevanceFieldEnum = (typeof pokeballOrderByRelevanceFieldEnum)[keyof typeof pokeballOrderByRelevanceFieldEnum]


  export const generationOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type generationOrderByRelevanceFieldEnum = (typeof generationOrderByRelevanceFieldEnum)[keyof typeof generationOrderByRelevanceFieldEnum]


  export const gameOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type gameOrderByRelevanceFieldEnum = (typeof gameOrderByRelevanceFieldEnum)[keyof typeof gameOrderByRelevanceFieldEnum]


  export const group_gameOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type group_gameOrderByRelevanceFieldEnum = (typeof group_gameOrderByRelevanceFieldEnum)[keyof typeof group_gameOrderByRelevanceFieldEnum]


  export const pokemon_categoryOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type pokemon_categoryOrderByRelevanceFieldEnum = (typeof pokemon_categoryOrderByRelevanceFieldEnum)[keyof typeof pokemon_categoryOrderByRelevanceFieldEnum]


  export const pokemonOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type pokemonOrderByRelevanceFieldEnum = (typeof pokemonOrderByRelevanceFieldEnum)[keyof typeof pokemonOrderByRelevanceFieldEnum]


  export const genderOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type genderOrderByRelevanceFieldEnum = (typeof genderOrderByRelevanceFieldEnum)[keyof typeof genderOrderByRelevanceFieldEnum]


  export const formOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type formOrderByRelevanceFieldEnum = (typeof formOrderByRelevanceFieldEnum)[keyof typeof formOrderByRelevanceFieldEnum]


  export const pokemon_formOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type pokemon_formOrderByRelevanceFieldEnum = (typeof pokemon_formOrderByRelevanceFieldEnum)[keyof typeof pokemon_formOrderByRelevanceFieldEnum]


  export const owned_pokemonOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type owned_pokemonOrderByRelevanceFieldEnum = (typeof owned_pokemonOrderByRelevanceFieldEnum)[keyof typeof owned_pokemonOrderByRelevanceFieldEnum]


  export const owned_pokemon_detailOrderByRelevanceFieldEnum: {
    nickname: 'nickname',
    status: 'status'
  };

  export type owned_pokemon_detailOrderByRelevanceFieldEnum = (typeof owned_pokemon_detailOrderByRelevanceFieldEnum)[keyof typeof owned_pokemon_detailOrderByRelevanceFieldEnum]


  export const abilityOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type abilityOrderByRelevanceFieldEnum = (typeof abilityOrderByRelevanceFieldEnum)[keyof typeof abilityOrderByRelevanceFieldEnum]


  export const ability_infoOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type ability_infoOrderByRelevanceFieldEnum = (typeof ability_infoOrderByRelevanceFieldEnum)[keyof typeof ability_infoOrderByRelevanceFieldEnum]


  export const pokemon_infoOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type pokemon_infoOrderByRelevanceFieldEnum = (typeof pokemon_infoOrderByRelevanceFieldEnum)[keyof typeof pokemon_infoOrderByRelevanceFieldEnum]


  export const evolution_methodOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type evolution_methodOrderByRelevanceFieldEnum = (typeof evolution_methodOrderByRelevanceFieldEnum)[keyof typeof evolution_methodOrderByRelevanceFieldEnum]


  export const evolutionOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type evolutionOrderByRelevanceFieldEnum = (typeof evolutionOrderByRelevanceFieldEnum)[keyof typeof evolutionOrderByRelevanceFieldEnum]


  export const evolution_infoOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type evolution_infoOrderByRelevanceFieldEnum = (typeof evolution_infoOrderByRelevanceFieldEnum)[keyof typeof evolution_infoOrderByRelevanceFieldEnum]


  export const egg_groupOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type egg_groupOrderByRelevanceFieldEnum = (typeof egg_groupOrderByRelevanceFieldEnum)[keyof typeof egg_groupOrderByRelevanceFieldEnum]


  export const typeOrderByRelevanceFieldEnum: {
    color: 'color',
    iconName: 'iconName',
    status: 'status'
  };

  export type typeOrderByRelevanceFieldEnum = (typeof typeOrderByRelevanceFieldEnum)[keyof typeof typeOrderByRelevanceFieldEnum]


  export const landOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type landOrderByRelevanceFieldEnum = (typeof landOrderByRelevanceFieldEnum)[keyof typeof landOrderByRelevanceFieldEnum]


  export const capacityOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type capacityOrderByRelevanceFieldEnum = (typeof capacityOrderByRelevanceFieldEnum)[keyof typeof capacityOrderByRelevanceFieldEnum]


  export const capacity_effectOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type capacity_effectOrderByRelevanceFieldEnum = (typeof capacity_effectOrderByRelevanceFieldEnum)[keyof typeof capacity_effectOrderByRelevanceFieldEnum]


  export const capacity_categoryOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type capacity_categoryOrderByRelevanceFieldEnum = (typeof capacity_categoryOrderByRelevanceFieldEnum)[keyof typeof capacity_categoryOrderByRelevanceFieldEnum]


  export const capsuleOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type capsuleOrderByRelevanceFieldEnum = (typeof capsuleOrderByRelevanceFieldEnum)[keyof typeof capsuleOrderByRelevanceFieldEnum]


  export const detailOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type detailOrderByRelevanceFieldEnum = (typeof detailOrderByRelevanceFieldEnum)[keyof typeof detailOrderByRelevanceFieldEnum]


  export const effect_outside_fightOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type effect_outside_fightOrderByRelevanceFieldEnum = (typeof effect_outside_fightOrderByRelevanceFieldEnum)[keyof typeof effect_outside_fightOrderByRelevanceFieldEnum]


  export const influenceOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type influenceOrderByRelevanceFieldEnum = (typeof influenceOrderByRelevanceFieldEnum)[keyof typeof influenceOrderByRelevanceFieldEnum]


  export const locationOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type locationOrderByRelevanceFieldEnum = (typeof locationOrderByRelevanceFieldEnum)[keyof typeof locationOrderByRelevanceFieldEnum]


  export const zoneOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type zoneOrderByRelevanceFieldEnum = (typeof zoneOrderByRelevanceFieldEnum)[keyof typeof zoneOrderByRelevanceFieldEnum]


  export const location_zoneOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type location_zoneOrderByRelevanceFieldEnum = (typeof location_zoneOrderByRelevanceFieldEnum)[keyof typeof location_zoneOrderByRelevanceFieldEnum]


  export const meteoOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type meteoOrderByRelevanceFieldEnum = (typeof meteoOrderByRelevanceFieldEnum)[keyof typeof meteoOrderByRelevanceFieldEnum]


  export const pokemon_obtationOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type pokemon_obtationOrderByRelevanceFieldEnum = (typeof pokemon_obtationOrderByRelevanceFieldEnum)[keyof typeof pokemon_obtationOrderByRelevanceFieldEnum]


  export const rateOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type rateOrderByRelevanceFieldEnum = (typeof rateOrderByRelevanceFieldEnum)[keyof typeof rateOrderByRelevanceFieldEnum]


  export const skill_obtation_typeOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type skill_obtation_typeOrderByRelevanceFieldEnum = (typeof skill_obtation_typeOrderByRelevanceFieldEnum)[keyof typeof skill_obtation_typeOrderByRelevanceFieldEnum]


  export const statisticOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type statisticOrderByRelevanceFieldEnum = (typeof statisticOrderByRelevanceFieldEnum)[keyof typeof statisticOrderByRelevanceFieldEnum]


  export const targetOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type targetOrderByRelevanceFieldEnum = (typeof targetOrderByRelevanceFieldEnum)[keyof typeof targetOrderByRelevanceFieldEnum]


  export const capacity_infoOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type capacity_infoOrderByRelevanceFieldEnum = (typeof capacity_infoOrderByRelevanceFieldEnum)[keyof typeof capacity_infoOrderByRelevanceFieldEnum]


  export const skill_obtationOrderByRelevanceFieldEnum: {
    detail: 'detail'
  };

  export type skill_obtationOrderByRelevanceFieldEnum = (typeof skill_obtationOrderByRelevanceFieldEnum)[keyof typeof skill_obtationOrderByRelevanceFieldEnum]


  export const refresh_tokenOrderByRelevanceFieldEnum: {
    token: 'token'
  };

  export type refresh_tokenOrderByRelevanceFieldEnum = (typeof refresh_tokenOrderByRelevanceFieldEnum)[keyof typeof refresh_tokenOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'reference_table'
   */
  export type Enumreference_tableFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'reference_table'>
    


  /**
   * Reference to a field of type 'role'
   */
  export type EnumroleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'role'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type langueWhereInput = {
    AND?: langueWhereInput | langueWhereInput[]
    OR?: langueWhereInput[]
    NOT?: langueWhereInput | langueWhereInput[]
    id?: IntFilter<"langue"> | number
    name?: StringFilter<"langue"> | string
    isoCode?: StringFilter<"langue"> | string
    createdAt?: DateTimeFilter<"langue"> | Date | string
    updatedAt?: DateTimeNullableFilter<"langue"> | Date | string | null
    status?: StringFilter<"langue"> | string
    translations?: TranslationListRelationFilter
  }

  export type langueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isoCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    translations?: translationOrderByRelationAggregateInput
    _relevance?: langueOrderByRelevanceInput
  }

  export type langueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    isoCode?: string
    AND?: langueWhereInput | langueWhereInput[]
    OR?: langueWhereInput[]
    NOT?: langueWhereInput | langueWhereInput[]
    createdAt?: DateTimeFilter<"langue"> | Date | string
    updatedAt?: DateTimeNullableFilter<"langue"> | Date | string | null
    status?: StringFilter<"langue"> | string
    translations?: TranslationListRelationFilter
  }, "id" | "name" | "isoCode">

  export type langueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isoCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: langueCountOrderByAggregateInput
    _avg?: langueAvgOrderByAggregateInput
    _max?: langueMaxOrderByAggregateInput
    _min?: langueMinOrderByAggregateInput
    _sum?: langueSumOrderByAggregateInput
  }

  export type langueScalarWhereWithAggregatesInput = {
    AND?: langueScalarWhereWithAggregatesInput | langueScalarWhereWithAggregatesInput[]
    OR?: langueScalarWhereWithAggregatesInput[]
    NOT?: langueScalarWhereWithAggregatesInput | langueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"langue"> | number
    name?: StringWithAggregatesFilter<"langue"> | string
    isoCode?: StringWithAggregatesFilter<"langue"> | string
    createdAt?: DateTimeWithAggregatesFilter<"langue"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"langue"> | Date | string | null
    status?: StringWithAggregatesFilter<"langue"> | string
  }

  export type translationWhereInput = {
    AND?: translationWhereInput | translationWhereInput[]
    OR?: translationWhereInput[]
    NOT?: translationWhereInput | translationWhereInput[]
    langueId?: IntFilter<"translation"> | number
    referenceId?: BigIntFilter<"translation"> | bigint | number
    referenceTable?: Enumreference_tableFilter<"translation"> | $Enums.reference_table
    name?: StringFilter<"translation"> | string
    createdAt?: DateTimeFilter<"translation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"translation"> | Date | string | null
    status?: StringFilter<"translation"> | string
    langue?: XOR<LangueScalarRelationFilter, langueWhereInput>
  }

  export type translationOrderByWithRelationInput = {
    langueId?: SortOrder
    referenceId?: SortOrder
    referenceTable?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    langue?: langueOrderByWithRelationInput
    _relevance?: translationOrderByRelevanceInput
  }

  export type translationWhereUniqueInput = Prisma.AtLeast<{
    referenceTable_referenceId_langueId?: translationReferenceTableReferenceIdLangueIdCompoundUniqueInput
    AND?: translationWhereInput | translationWhereInput[]
    OR?: translationWhereInput[]
    NOT?: translationWhereInput | translationWhereInput[]
    langueId?: IntFilter<"translation"> | number
    referenceId?: BigIntFilter<"translation"> | bigint | number
    referenceTable?: Enumreference_tableFilter<"translation"> | $Enums.reference_table
    name?: StringFilter<"translation"> | string
    createdAt?: DateTimeFilter<"translation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"translation"> | Date | string | null
    status?: StringFilter<"translation"> | string
    langue?: XOR<LangueScalarRelationFilter, langueWhereInput>
  }, "referenceTable_referenceId_langueId">

  export type translationOrderByWithAggregationInput = {
    langueId?: SortOrder
    referenceId?: SortOrder
    referenceTable?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: translationCountOrderByAggregateInput
    _avg?: translationAvgOrderByAggregateInput
    _max?: translationMaxOrderByAggregateInput
    _min?: translationMinOrderByAggregateInput
    _sum?: translationSumOrderByAggregateInput
  }

  export type translationScalarWhereWithAggregatesInput = {
    AND?: translationScalarWhereWithAggregatesInput | translationScalarWhereWithAggregatesInput[]
    OR?: translationScalarWhereWithAggregatesInput[]
    NOT?: translationScalarWhereWithAggregatesInput | translationScalarWhereWithAggregatesInput[]
    langueId?: IntWithAggregatesFilter<"translation"> | number
    referenceId?: BigIntWithAggregatesFilter<"translation"> | bigint | number
    referenceTable?: Enumreference_tableWithAggregatesFilter<"translation"> | $Enums.reference_table
    name?: StringWithAggregatesFilter<"translation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"translation"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"translation"> | Date | string | null
    status?: StringWithAggregatesFilter<"translation"> | string
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    discordId?: BigIntNullableFilter<"user"> | bigint | number | null
    email?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeNullableFilter<"user"> | Date | string | null
    status?: StringFilter<"user"> | string
    pseudonym?: StringFilter<"user"> | string
    role?: EnumroleFilter<"user"> | $Enums.role
    ownedPokemons?: Owned_pokemonListRelationFilter
    refreshTokens?: Refresh_tokenListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    discordId?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    pseudonym?: SortOrder
    role?: SortOrder
    ownedPokemons?: owned_pokemonOrderByRelationAggregateInput
    refreshTokens?: refresh_tokenOrderByRelationAggregateInput
    _relevance?: userOrderByRelevanceInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    pseudonym?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    discordId?: BigIntNullableFilter<"user"> | bigint | number | null
    password?: StringFilter<"user"> | string
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeNullableFilter<"user"> | Date | string | null
    status?: StringFilter<"user"> | string
    role?: EnumroleFilter<"user"> | $Enums.role
    ownedPokemons?: Owned_pokemonListRelationFilter
    refreshTokens?: Refresh_tokenListRelationFilter
  }, "id" | "email" | "pseudonym">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    discordId?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    pseudonym?: SortOrder
    role?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    discordId?: BigIntNullableWithAggregatesFilter<"user"> | bigint | number | null
    email?: StringWithAggregatesFilter<"user"> | string
    password?: StringWithAggregatesFilter<"user"> | string
    createdAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    status?: StringWithAggregatesFilter<"user"> | string
    pseudonym?: StringWithAggregatesFilter<"user"> | string
    role?: EnumroleWithAggregatesFilter<"user"> | $Enums.role
  }

  export type shiny_hunting_methodWhereInput = {
    AND?: shiny_hunting_methodWhereInput | shiny_hunting_methodWhereInput[]
    OR?: shiny_hunting_methodWhereInput[]
    NOT?: shiny_hunting_methodWhereInput | shiny_hunting_methodWhereInput[]
    id?: IntFilter<"shiny_hunting_method"> | number
    createdAt?: DateTimeFilter<"shiny_hunting_method"> | Date | string
    updatedAt?: DateTimeNullableFilter<"shiny_hunting_method"> | Date | string | null
    status?: StringFilter<"shiny_hunting_method"> | string
    ownedPokemons?: Owned_pokemonListRelationFilter
    shinyHuntingMethodGames?: Shiny_hunting_method_gameListRelationFilter
    shinyHuntingMethodRates?: Shiny_hunting_method_rateListRelationFilter
  }

  export type shiny_hunting_methodOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    ownedPokemons?: owned_pokemonOrderByRelationAggregateInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameOrderByRelationAggregateInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateOrderByRelationAggregateInput
    _relevance?: shiny_hunting_methodOrderByRelevanceInput
  }

  export type shiny_hunting_methodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: shiny_hunting_methodWhereInput | shiny_hunting_methodWhereInput[]
    OR?: shiny_hunting_methodWhereInput[]
    NOT?: shiny_hunting_methodWhereInput | shiny_hunting_methodWhereInput[]
    createdAt?: DateTimeFilter<"shiny_hunting_method"> | Date | string
    updatedAt?: DateTimeNullableFilter<"shiny_hunting_method"> | Date | string | null
    status?: StringFilter<"shiny_hunting_method"> | string
    ownedPokemons?: Owned_pokemonListRelationFilter
    shinyHuntingMethodGames?: Shiny_hunting_method_gameListRelationFilter
    shinyHuntingMethodRates?: Shiny_hunting_method_rateListRelationFilter
  }, "id">

  export type shiny_hunting_methodOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: shiny_hunting_methodCountOrderByAggregateInput
    _avg?: shiny_hunting_methodAvgOrderByAggregateInput
    _max?: shiny_hunting_methodMaxOrderByAggregateInput
    _min?: shiny_hunting_methodMinOrderByAggregateInput
    _sum?: shiny_hunting_methodSumOrderByAggregateInput
  }

  export type shiny_hunting_methodScalarWhereWithAggregatesInput = {
    AND?: shiny_hunting_methodScalarWhereWithAggregatesInput | shiny_hunting_methodScalarWhereWithAggregatesInput[]
    OR?: shiny_hunting_methodScalarWhereWithAggregatesInput[]
    NOT?: shiny_hunting_methodScalarWhereWithAggregatesInput | shiny_hunting_methodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"shiny_hunting_method"> | number
    createdAt?: DateTimeWithAggregatesFilter<"shiny_hunting_method"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"shiny_hunting_method"> | Date | string | null
    status?: StringWithAggregatesFilter<"shiny_hunting_method"> | string
  }

  export type pokeballWhereInput = {
    AND?: pokeballWhereInput | pokeballWhereInput[]
    OR?: pokeballWhereInput[]
    NOT?: pokeballWhereInput | pokeballWhereInput[]
    id?: IntFilter<"pokeball"> | number
    picture?: StringFilter<"pokeball"> | string
    createdAt?: DateTimeFilter<"pokeball"> | Date | string
    updatedAt?: DateTimeNullableFilter<"pokeball"> | Date | string | null
    status?: StringFilter<"pokeball"> | string
    ownedPokemonDetails?: Owned_pokemon_detailListRelationFilter
  }

  export type pokeballOrderByWithRelationInput = {
    id?: SortOrder
    picture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    ownedPokemonDetails?: owned_pokemon_detailOrderByRelationAggregateInput
    _relevance?: pokeballOrderByRelevanceInput
  }

  export type pokeballWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pokeballWhereInput | pokeballWhereInput[]
    OR?: pokeballWhereInput[]
    NOT?: pokeballWhereInput | pokeballWhereInput[]
    picture?: StringFilter<"pokeball"> | string
    createdAt?: DateTimeFilter<"pokeball"> | Date | string
    updatedAt?: DateTimeNullableFilter<"pokeball"> | Date | string | null
    status?: StringFilter<"pokeball"> | string
    ownedPokemonDetails?: Owned_pokemon_detailListRelationFilter
  }, "id">

  export type pokeballOrderByWithAggregationInput = {
    id?: SortOrder
    picture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: pokeballCountOrderByAggregateInput
    _avg?: pokeballAvgOrderByAggregateInput
    _max?: pokeballMaxOrderByAggregateInput
    _min?: pokeballMinOrderByAggregateInput
    _sum?: pokeballSumOrderByAggregateInput
  }

  export type pokeballScalarWhereWithAggregatesInput = {
    AND?: pokeballScalarWhereWithAggregatesInput | pokeballScalarWhereWithAggregatesInput[]
    OR?: pokeballScalarWhereWithAggregatesInput[]
    NOT?: pokeballScalarWhereWithAggregatesInput | pokeballScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pokeball"> | number
    picture?: StringWithAggregatesFilter<"pokeball"> | string
    createdAt?: DateTimeWithAggregatesFilter<"pokeball"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"pokeball"> | Date | string | null
    status?: StringWithAggregatesFilter<"pokeball"> | string
  }

  export type generationWhereInput = {
    AND?: generationWhereInput | generationWhereInput[]
    OR?: generationWhereInput[]
    NOT?: generationWhereInput | generationWhereInput[]
    id?: IntFilter<"generation"> | number
    createdAt?: DateTimeFilter<"generation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"generation"> | Date | string | null
    status?: StringFilter<"generation"> | string
    abilities?: AbilityListRelationFilter
    abilityInfos?: Ability_infoListRelationFilter
    games?: GameListRelationFilter
    pokemons?: PokemonListRelationFilter
    pokemonInfos?: Pokemon_infoListRelationFilter
  }

  export type generationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    abilities?: abilityOrderByRelationAggregateInput
    abilityInfos?: ability_infoOrderByRelationAggregateInput
    games?: gameOrderByRelationAggregateInput
    pokemons?: pokemonOrderByRelationAggregateInput
    pokemonInfos?: pokemon_infoOrderByRelationAggregateInput
    _relevance?: generationOrderByRelevanceInput
  }

  export type generationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: generationWhereInput | generationWhereInput[]
    OR?: generationWhereInput[]
    NOT?: generationWhereInput | generationWhereInput[]
    createdAt?: DateTimeFilter<"generation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"generation"> | Date | string | null
    status?: StringFilter<"generation"> | string
    abilities?: AbilityListRelationFilter
    abilityInfos?: Ability_infoListRelationFilter
    games?: GameListRelationFilter
    pokemons?: PokemonListRelationFilter
    pokemonInfos?: Pokemon_infoListRelationFilter
  }, "id">

  export type generationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: generationCountOrderByAggregateInput
    _avg?: generationAvgOrderByAggregateInput
    _max?: generationMaxOrderByAggregateInput
    _min?: generationMinOrderByAggregateInput
    _sum?: generationSumOrderByAggregateInput
  }

  export type generationScalarWhereWithAggregatesInput = {
    AND?: generationScalarWhereWithAggregatesInput | generationScalarWhereWithAggregatesInput[]
    OR?: generationScalarWhereWithAggregatesInput[]
    NOT?: generationScalarWhereWithAggregatesInput | generationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"generation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"generation"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"generation"> | Date | string | null
    status?: StringWithAggregatesFilter<"generation"> | string
  }

  export type gameWhereInput = {
    AND?: gameWhereInput | gameWhereInput[]
    OR?: gameWhereInput[]
    NOT?: gameWhereInput | gameWhereInput[]
    id?: IntFilter<"game"> | number
    generationId?: IntFilter<"game"> | number
    createdAt?: DateTimeFilter<"game"> | Date | string
    updatedAt?: DateTimeNullableFilter<"game"> | Date | string | null
    status?: StringFilter<"game"> | string
    generation?: XOR<GenerationScalarRelationFilter, generationWhereInput>
    gameGroupGames?: Game_group_gameListRelationFilter
    ownedPokemons?: Owned_pokemonListRelationFilter
    pokemonRatingGames?: Pokemon_game_locationListRelationFilter
  }

  export type gameOrderByWithRelationInput = {
    id?: SortOrder
    generationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    generation?: generationOrderByWithRelationInput
    gameGroupGames?: game_group_gameOrderByRelationAggregateInput
    ownedPokemons?: owned_pokemonOrderByRelationAggregateInput
    pokemonRatingGames?: pokemon_game_locationOrderByRelationAggregateInput
    _relevance?: gameOrderByRelevanceInput
  }

  export type gameWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: gameWhereInput | gameWhereInput[]
    OR?: gameWhereInput[]
    NOT?: gameWhereInput | gameWhereInput[]
    generationId?: IntFilter<"game"> | number
    createdAt?: DateTimeFilter<"game"> | Date | string
    updatedAt?: DateTimeNullableFilter<"game"> | Date | string | null
    status?: StringFilter<"game"> | string
    generation?: XOR<GenerationScalarRelationFilter, generationWhereInput>
    gameGroupGames?: Game_group_gameListRelationFilter
    ownedPokemons?: Owned_pokemonListRelationFilter
    pokemonRatingGames?: Pokemon_game_locationListRelationFilter
  }, "id">

  export type gameOrderByWithAggregationInput = {
    id?: SortOrder
    generationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: gameCountOrderByAggregateInput
    _avg?: gameAvgOrderByAggregateInput
    _max?: gameMaxOrderByAggregateInput
    _min?: gameMinOrderByAggregateInput
    _sum?: gameSumOrderByAggregateInput
  }

  export type gameScalarWhereWithAggregatesInput = {
    AND?: gameScalarWhereWithAggregatesInput | gameScalarWhereWithAggregatesInput[]
    OR?: gameScalarWhereWithAggregatesInput[]
    NOT?: gameScalarWhereWithAggregatesInput | gameScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"game"> | number
    generationId?: IntWithAggregatesFilter<"game"> | number
    createdAt?: DateTimeWithAggregatesFilter<"game"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"game"> | Date | string | null
    status?: StringWithAggregatesFilter<"game"> | string
  }

  export type game_group_gameWhereInput = {
    AND?: game_group_gameWhereInput | game_group_gameWhereInput[]
    OR?: game_group_gameWhereInput[]
    NOT?: game_group_gameWhereInput | game_group_gameWhereInput[]
    gameId?: IntFilter<"game_group_game"> | number
    groupGameId?: IntFilter<"game_group_game"> | number
    landId?: IntFilter<"game_group_game"> | number
    game?: XOR<GameScalarRelationFilter, gameWhereInput>
    groupGame?: XOR<Group_gameScalarRelationFilter, group_gameWhereInput>
    land?: XOR<LandScalarRelationFilter, landWhereInput>
  }

  export type game_group_gameOrderByWithRelationInput = {
    gameId?: SortOrder
    groupGameId?: SortOrder
    landId?: SortOrder
    game?: gameOrderByWithRelationInput
    groupGame?: group_gameOrderByWithRelationInput
    land?: landOrderByWithRelationInput
  }

  export type game_group_gameWhereUniqueInput = Prisma.AtLeast<{
    gameId_groupGameId_landId?: game_group_gameGameIdGroupGameIdLandIdCompoundUniqueInput
    AND?: game_group_gameWhereInput | game_group_gameWhereInput[]
    OR?: game_group_gameWhereInput[]
    NOT?: game_group_gameWhereInput | game_group_gameWhereInput[]
    gameId?: IntFilter<"game_group_game"> | number
    groupGameId?: IntFilter<"game_group_game"> | number
    landId?: IntFilter<"game_group_game"> | number
    game?: XOR<GameScalarRelationFilter, gameWhereInput>
    groupGame?: XOR<Group_gameScalarRelationFilter, group_gameWhereInput>
    land?: XOR<LandScalarRelationFilter, landWhereInput>
  }, "gameId_groupGameId_landId">

  export type game_group_gameOrderByWithAggregationInput = {
    gameId?: SortOrder
    groupGameId?: SortOrder
    landId?: SortOrder
    _count?: game_group_gameCountOrderByAggregateInput
    _avg?: game_group_gameAvgOrderByAggregateInput
    _max?: game_group_gameMaxOrderByAggregateInput
    _min?: game_group_gameMinOrderByAggregateInput
    _sum?: game_group_gameSumOrderByAggregateInput
  }

  export type game_group_gameScalarWhereWithAggregatesInput = {
    AND?: game_group_gameScalarWhereWithAggregatesInput | game_group_gameScalarWhereWithAggregatesInput[]
    OR?: game_group_gameScalarWhereWithAggregatesInput[]
    NOT?: game_group_gameScalarWhereWithAggregatesInput | game_group_gameScalarWhereWithAggregatesInput[]
    gameId?: IntWithAggregatesFilter<"game_group_game"> | number
    groupGameId?: IntWithAggregatesFilter<"game_group_game"> | number
    landId?: IntWithAggregatesFilter<"game_group_game"> | number
  }

  export type group_gameWhereInput = {
    AND?: group_gameWhereInput | group_gameWhereInput[]
    OR?: group_gameWhereInput[]
    NOT?: group_gameWhereInput | group_gameWhereInput[]
    id?: IntFilter<"group_game"> | number
    createdAt?: DateTimeFilter<"group_game"> | Date | string
    updatedAt?: DateTimeNullableFilter<"group_game"> | Date | string | null
    status?: StringFilter<"group_game"> | string
    capsuleGameCapacityIinfos?: Capsule_game_capacity_infoListRelationFilter
    gameGroupGames?: Game_group_gameListRelationFilter
    nationnalNumbers?: National_numberListRelationFilter
    shinyHuntingMethodGames?: Shiny_hunting_method_gameListRelationFilter
    skillObtations?: Skill_obtationListRelationFilter
    statisticGroupGames?: Statistic_group_gameListRelationFilter
  }

  export type group_gameOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoOrderByRelationAggregateInput
    gameGroupGames?: game_group_gameOrderByRelationAggregateInput
    nationnalNumbers?: national_numberOrderByRelationAggregateInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameOrderByRelationAggregateInput
    skillObtations?: skill_obtationOrderByRelationAggregateInput
    statisticGroupGames?: statistic_group_gameOrderByRelationAggregateInput
    _relevance?: group_gameOrderByRelevanceInput
  }

  export type group_gameWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: group_gameWhereInput | group_gameWhereInput[]
    OR?: group_gameWhereInput[]
    NOT?: group_gameWhereInput | group_gameWhereInput[]
    createdAt?: DateTimeFilter<"group_game"> | Date | string
    updatedAt?: DateTimeNullableFilter<"group_game"> | Date | string | null
    status?: StringFilter<"group_game"> | string
    capsuleGameCapacityIinfos?: Capsule_game_capacity_infoListRelationFilter
    gameGroupGames?: Game_group_gameListRelationFilter
    nationnalNumbers?: National_numberListRelationFilter
    shinyHuntingMethodGames?: Shiny_hunting_method_gameListRelationFilter
    skillObtations?: Skill_obtationListRelationFilter
    statisticGroupGames?: Statistic_group_gameListRelationFilter
  }, "id">

  export type group_gameOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: group_gameCountOrderByAggregateInput
    _avg?: group_gameAvgOrderByAggregateInput
    _max?: group_gameMaxOrderByAggregateInput
    _min?: group_gameMinOrderByAggregateInput
    _sum?: group_gameSumOrderByAggregateInput
  }

  export type group_gameScalarWhereWithAggregatesInput = {
    AND?: group_gameScalarWhereWithAggregatesInput | group_gameScalarWhereWithAggregatesInput[]
    OR?: group_gameScalarWhereWithAggregatesInput[]
    NOT?: group_gameScalarWhereWithAggregatesInput | group_gameScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"group_game"> | number
    createdAt?: DateTimeWithAggregatesFilter<"group_game"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"group_game"> | Date | string | null
    status?: StringWithAggregatesFilter<"group_game"> | string
  }

  export type capsule_game_capacity_infoWhereInput = {
    AND?: capsule_game_capacity_infoWhereInput | capsule_game_capacity_infoWhereInput[]
    OR?: capsule_game_capacity_infoWhereInput[]
    NOT?: capsule_game_capacity_infoWhereInput | capsule_game_capacity_infoWhereInput[]
    capacityInfoId?: IntFilter<"capsule_game_capacity_info"> | number
    capsuleId?: IntFilter<"capsule_game_capacity_info"> | number
    groupeGameId?: IntFilter<"capsule_game_capacity_info"> | number
    capacityInfo?: XOR<Capacity_infoScalarRelationFilter, capacity_infoWhereInput>
    capsule?: XOR<CapsuleScalarRelationFilter, capsuleWhereInput>
    groupGame?: XOR<Group_gameScalarRelationFilter, group_gameWhereInput>
  }

  export type capsule_game_capacity_infoOrderByWithRelationInput = {
    capacityInfoId?: SortOrder
    capsuleId?: SortOrder
    groupeGameId?: SortOrder
    capacityInfo?: capacity_infoOrderByWithRelationInput
    capsule?: capsuleOrderByWithRelationInput
    groupGame?: group_gameOrderByWithRelationInput
  }

  export type capsule_game_capacity_infoWhereUniqueInput = Prisma.AtLeast<{
    capacityInfoId_groupeGameId?: capsule_game_capacity_infoCapacityInfoIdGroupeGameIdCompoundUniqueInput
    AND?: capsule_game_capacity_infoWhereInput | capsule_game_capacity_infoWhereInput[]
    OR?: capsule_game_capacity_infoWhereInput[]
    NOT?: capsule_game_capacity_infoWhereInput | capsule_game_capacity_infoWhereInput[]
    capacityInfoId?: IntFilter<"capsule_game_capacity_info"> | number
    capsuleId?: IntFilter<"capsule_game_capacity_info"> | number
    groupeGameId?: IntFilter<"capsule_game_capacity_info"> | number
    capacityInfo?: XOR<Capacity_infoScalarRelationFilter, capacity_infoWhereInput>
    capsule?: XOR<CapsuleScalarRelationFilter, capsuleWhereInput>
    groupGame?: XOR<Group_gameScalarRelationFilter, group_gameWhereInput>
  }, "capacityInfoId_groupeGameId">

  export type capsule_game_capacity_infoOrderByWithAggregationInput = {
    capacityInfoId?: SortOrder
    capsuleId?: SortOrder
    groupeGameId?: SortOrder
    _count?: capsule_game_capacity_infoCountOrderByAggregateInput
    _avg?: capsule_game_capacity_infoAvgOrderByAggregateInput
    _max?: capsule_game_capacity_infoMaxOrderByAggregateInput
    _min?: capsule_game_capacity_infoMinOrderByAggregateInput
    _sum?: capsule_game_capacity_infoSumOrderByAggregateInput
  }

  export type capsule_game_capacity_infoScalarWhereWithAggregatesInput = {
    AND?: capsule_game_capacity_infoScalarWhereWithAggregatesInput | capsule_game_capacity_infoScalarWhereWithAggregatesInput[]
    OR?: capsule_game_capacity_infoScalarWhereWithAggregatesInput[]
    NOT?: capsule_game_capacity_infoScalarWhereWithAggregatesInput | capsule_game_capacity_infoScalarWhereWithAggregatesInput[]
    capacityInfoId?: IntWithAggregatesFilter<"capsule_game_capacity_info"> | number
    capsuleId?: IntWithAggregatesFilter<"capsule_game_capacity_info"> | number
    groupeGameId?: IntWithAggregatesFilter<"capsule_game_capacity_info"> | number
  }

  export type pokemon_categoryWhereInput = {
    AND?: pokemon_categoryWhereInput | pokemon_categoryWhereInput[]
    OR?: pokemon_categoryWhereInput[]
    NOT?: pokemon_categoryWhereInput | pokemon_categoryWhereInput[]
    id?: IntFilter<"pokemon_category"> | number
    createdAt?: DateTimeFilter<"pokemon_category"> | Date | string
    updatedAt?: DateTimeNullableFilter<"pokemon_category"> | Date | string | null
    status?: StringFilter<"pokemon_category"> | string
    pokemons?: PokemonListRelationFilter
  }

  export type pokemon_categoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    pokemons?: pokemonOrderByRelationAggregateInput
    _relevance?: pokemon_categoryOrderByRelevanceInput
  }

  export type pokemon_categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pokemon_categoryWhereInput | pokemon_categoryWhereInput[]
    OR?: pokemon_categoryWhereInput[]
    NOT?: pokemon_categoryWhereInput | pokemon_categoryWhereInput[]
    createdAt?: DateTimeFilter<"pokemon_category"> | Date | string
    updatedAt?: DateTimeNullableFilter<"pokemon_category"> | Date | string | null
    status?: StringFilter<"pokemon_category"> | string
    pokemons?: PokemonListRelationFilter
  }, "id">

  export type pokemon_categoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: pokemon_categoryCountOrderByAggregateInput
    _avg?: pokemon_categoryAvgOrderByAggregateInput
    _max?: pokemon_categoryMaxOrderByAggregateInput
    _min?: pokemon_categoryMinOrderByAggregateInput
    _sum?: pokemon_categorySumOrderByAggregateInput
  }

  export type pokemon_categoryScalarWhereWithAggregatesInput = {
    AND?: pokemon_categoryScalarWhereWithAggregatesInput | pokemon_categoryScalarWhereWithAggregatesInput[]
    OR?: pokemon_categoryScalarWhereWithAggregatesInput[]
    NOT?: pokemon_categoryScalarWhereWithAggregatesInput | pokemon_categoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pokemon_category"> | number
    createdAt?: DateTimeWithAggregatesFilter<"pokemon_category"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"pokemon_category"> | Date | string | null
    status?: StringWithAggregatesFilter<"pokemon_category"> | string
  }

  export type pokemonWhereInput = {
    AND?: pokemonWhereInput | pokemonWhereInput[]
    OR?: pokemonWhereInput[]
    NOT?: pokemonWhereInput | pokemonWhereInput[]
    id?: IntFilter<"pokemon"> | number
    internationalNumber?: IntFilter<"pokemon"> | number
    hatchingCycle?: IntFilter<"pokemon"> | number
    globalXp?: IntFilter<"pokemon"> | number
    captureRate?: IntFilter<"pokemon"> | number
    callHelpRate?: IntFilter<"pokemon"> | number
    size?: DecimalFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    weight?: DecimalFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    pokemonCategoryId?: IntFilter<"pokemon"> | number
    generationId?: IntFilter<"pokemon"> | number
    createdAt?: DateTimeFilter<"pokemon"> | Date | string
    updatedAt?: DateTimeNullableFilter<"pokemon"> | Date | string | null
    status?: StringFilter<"pokemon"> | string
    nationalNumbers?: National_numberListRelationFilter
    pokemon_category?: XOR<Pokemon_categoryScalarRelationFilter, pokemon_categoryWhereInput>
    generation?: XOR<GenerationScalarRelationFilter, generationWhereInput>
    pokemonForms?: Pokemon_formListRelationFilter
    pokemonInfos?: Pokemon_infoListRelationFilter
    skillObtations?: Skill_obtationListRelationFilter
    statisticGroupGames?: Statistic_group_gameListRelationFilter
  }

  export type pokemonOrderByWithRelationInput = {
    id?: SortOrder
    internationalNumber?: SortOrder
    hatchingCycle?: SortOrder
    globalXp?: SortOrder
    captureRate?: SortOrder
    callHelpRate?: SortOrder
    size?: SortOrder
    weight?: SortOrder
    maleRate?: SortOrder
    femelleRate?: SortOrder
    pokemonCategoryId?: SortOrder
    generationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    nationalNumbers?: national_numberOrderByRelationAggregateInput
    pokemon_category?: pokemon_categoryOrderByWithRelationInput
    generation?: generationOrderByWithRelationInput
    pokemonForms?: pokemon_formOrderByRelationAggregateInput
    pokemonInfos?: pokemon_infoOrderByRelationAggregateInput
    skillObtations?: skill_obtationOrderByRelationAggregateInput
    statisticGroupGames?: statistic_group_gameOrderByRelationAggregateInput
    _relevance?: pokemonOrderByRelevanceInput
  }

  export type pokemonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pokemonWhereInput | pokemonWhereInput[]
    OR?: pokemonWhereInput[]
    NOT?: pokemonWhereInput | pokemonWhereInput[]
    internationalNumber?: IntFilter<"pokemon"> | number
    hatchingCycle?: IntFilter<"pokemon"> | number
    globalXp?: IntFilter<"pokemon"> | number
    captureRate?: IntFilter<"pokemon"> | number
    callHelpRate?: IntFilter<"pokemon"> | number
    size?: DecimalFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    weight?: DecimalFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    pokemonCategoryId?: IntFilter<"pokemon"> | number
    generationId?: IntFilter<"pokemon"> | number
    createdAt?: DateTimeFilter<"pokemon"> | Date | string
    updatedAt?: DateTimeNullableFilter<"pokemon"> | Date | string | null
    status?: StringFilter<"pokemon"> | string
    nationalNumbers?: National_numberListRelationFilter
    pokemon_category?: XOR<Pokemon_categoryScalarRelationFilter, pokemon_categoryWhereInput>
    generation?: XOR<GenerationScalarRelationFilter, generationWhereInput>
    pokemonForms?: Pokemon_formListRelationFilter
    pokemonInfos?: Pokemon_infoListRelationFilter
    skillObtations?: Skill_obtationListRelationFilter
    statisticGroupGames?: Statistic_group_gameListRelationFilter
  }, "id">

  export type pokemonOrderByWithAggregationInput = {
    id?: SortOrder
    internationalNumber?: SortOrder
    hatchingCycle?: SortOrder
    globalXp?: SortOrder
    captureRate?: SortOrder
    callHelpRate?: SortOrder
    size?: SortOrder
    weight?: SortOrder
    maleRate?: SortOrder
    femelleRate?: SortOrder
    pokemonCategoryId?: SortOrder
    generationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: pokemonCountOrderByAggregateInput
    _avg?: pokemonAvgOrderByAggregateInput
    _max?: pokemonMaxOrderByAggregateInput
    _min?: pokemonMinOrderByAggregateInput
    _sum?: pokemonSumOrderByAggregateInput
  }

  export type pokemonScalarWhereWithAggregatesInput = {
    AND?: pokemonScalarWhereWithAggregatesInput | pokemonScalarWhereWithAggregatesInput[]
    OR?: pokemonScalarWhereWithAggregatesInput[]
    NOT?: pokemonScalarWhereWithAggregatesInput | pokemonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pokemon"> | number
    internationalNumber?: IntWithAggregatesFilter<"pokemon"> | number
    hatchingCycle?: IntWithAggregatesFilter<"pokemon"> | number
    globalXp?: IntWithAggregatesFilter<"pokemon"> | number
    captureRate?: IntWithAggregatesFilter<"pokemon"> | number
    callHelpRate?: IntWithAggregatesFilter<"pokemon"> | number
    size?: DecimalWithAggregatesFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    weight?: DecimalWithAggregatesFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalWithAggregatesFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalWithAggregatesFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    pokemonCategoryId?: IntWithAggregatesFilter<"pokemon"> | number
    generationId?: IntWithAggregatesFilter<"pokemon"> | number
    createdAt?: DateTimeWithAggregatesFilter<"pokemon"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"pokemon"> | Date | string | null
    status?: StringWithAggregatesFilter<"pokemon"> | string
  }

  export type genderWhereInput = {
    AND?: genderWhereInput | genderWhereInput[]
    OR?: genderWhereInput[]
    NOT?: genderWhereInput | genderWhereInput[]
    id?: IntFilter<"gender"> | number
    createdAt?: DateTimeFilter<"gender"> | Date | string
    updatedAt?: DateTimeNullableFilter<"gender"> | Date | string | null
    status?: StringFilter<"gender"> | string
    pokemonFormGenders?: Pokemon_form_genderListRelationFilter
  }

  export type genderOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    pokemonFormGenders?: pokemon_form_genderOrderByRelationAggregateInput
    _relevance?: genderOrderByRelevanceInput
  }

  export type genderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: genderWhereInput | genderWhereInput[]
    OR?: genderWhereInput[]
    NOT?: genderWhereInput | genderWhereInput[]
    createdAt?: DateTimeFilter<"gender"> | Date | string
    updatedAt?: DateTimeNullableFilter<"gender"> | Date | string | null
    status?: StringFilter<"gender"> | string
    pokemonFormGenders?: Pokemon_form_genderListRelationFilter
  }, "id">

  export type genderOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: genderCountOrderByAggregateInput
    _avg?: genderAvgOrderByAggregateInput
    _max?: genderMaxOrderByAggregateInput
    _min?: genderMinOrderByAggregateInput
    _sum?: genderSumOrderByAggregateInput
  }

  export type genderScalarWhereWithAggregatesInput = {
    AND?: genderScalarWhereWithAggregatesInput | genderScalarWhereWithAggregatesInput[]
    OR?: genderScalarWhereWithAggregatesInput[]
    NOT?: genderScalarWhereWithAggregatesInput | genderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"gender"> | number
    createdAt?: DateTimeWithAggregatesFilter<"gender"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"gender"> | Date | string | null
    status?: StringWithAggregatesFilter<"gender"> | string
  }

  export type formWhereInput = {
    AND?: formWhereInput | formWhereInput[]
    OR?: formWhereInput[]
    NOT?: formWhereInput | formWhereInput[]
    id?: IntFilter<"form"> | number
    createdAt?: DateTimeFilter<"form"> | Date | string
    updatedAt?: DateTimeNullableFilter<"form"> | Date | string | null
    status?: StringFilter<"form"> | string
    pokemonForms?: Pokemon_formListRelationFilter
  }

  export type formOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    pokemonForms?: pokemon_formOrderByRelationAggregateInput
    _relevance?: formOrderByRelevanceInput
  }

  export type formWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: formWhereInput | formWhereInput[]
    OR?: formWhereInput[]
    NOT?: formWhereInput | formWhereInput[]
    createdAt?: DateTimeFilter<"form"> | Date | string
    updatedAt?: DateTimeNullableFilter<"form"> | Date | string | null
    status?: StringFilter<"form"> | string
    pokemonForms?: Pokemon_formListRelationFilter
  }, "id">

  export type formOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: formCountOrderByAggregateInput
    _avg?: formAvgOrderByAggregateInput
    _max?: formMaxOrderByAggregateInput
    _min?: formMinOrderByAggregateInput
    _sum?: formSumOrderByAggregateInput
  }

  export type formScalarWhereWithAggregatesInput = {
    AND?: formScalarWhereWithAggregatesInput | formScalarWhereWithAggregatesInput[]
    OR?: formScalarWhereWithAggregatesInput[]
    NOT?: formScalarWhereWithAggregatesInput | formScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"form"> | number
    createdAt?: DateTimeWithAggregatesFilter<"form"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"form"> | Date | string | null
    status?: StringWithAggregatesFilter<"form"> | string
  }

  export type pokemon_form_genderWhereInput = {
    AND?: pokemon_form_genderWhereInput | pokemon_form_genderWhereInput[]
    OR?: pokemon_form_genderWhereInput[]
    NOT?: pokemon_form_genderWhereInput | pokemon_form_genderWhereInput[]
    pokemonFormId?: IntFilter<"pokemon_form_gender"> | number
    genderId?: IntFilter<"pokemon_form_gender"> | number
    gender?: XOR<GenderScalarRelationFilter, genderWhereInput>
    pokemon_form?: XOR<Pokemon_formScalarRelationFilter, pokemon_formWhereInput>
  }

  export type pokemon_form_genderOrderByWithRelationInput = {
    pokemonFormId?: SortOrder
    genderId?: SortOrder
    gender?: genderOrderByWithRelationInput
    pokemon_form?: pokemon_formOrderByWithRelationInput
  }

  export type pokemon_form_genderWhereUniqueInput = Prisma.AtLeast<{
    genderId_pokemonFormId?: pokemon_form_genderGenderIdPokemonFormIdCompoundUniqueInput
    AND?: pokemon_form_genderWhereInput | pokemon_form_genderWhereInput[]
    OR?: pokemon_form_genderWhereInput[]
    NOT?: pokemon_form_genderWhereInput | pokemon_form_genderWhereInput[]
    pokemonFormId?: IntFilter<"pokemon_form_gender"> | number
    genderId?: IntFilter<"pokemon_form_gender"> | number
    gender?: XOR<GenderScalarRelationFilter, genderWhereInput>
    pokemon_form?: XOR<Pokemon_formScalarRelationFilter, pokemon_formWhereInput>
  }, "genderId_pokemonFormId">

  export type pokemon_form_genderOrderByWithAggregationInput = {
    pokemonFormId?: SortOrder
    genderId?: SortOrder
    _count?: pokemon_form_genderCountOrderByAggregateInput
    _avg?: pokemon_form_genderAvgOrderByAggregateInput
    _max?: pokemon_form_genderMaxOrderByAggregateInput
    _min?: pokemon_form_genderMinOrderByAggregateInput
    _sum?: pokemon_form_genderSumOrderByAggregateInput
  }

  export type pokemon_form_genderScalarWhereWithAggregatesInput = {
    AND?: pokemon_form_genderScalarWhereWithAggregatesInput | pokemon_form_genderScalarWhereWithAggregatesInput[]
    OR?: pokemon_form_genderScalarWhereWithAggregatesInput[]
    NOT?: pokemon_form_genderScalarWhereWithAggregatesInput | pokemon_form_genderScalarWhereWithAggregatesInput[]
    pokemonFormId?: IntWithAggregatesFilter<"pokemon_form_gender"> | number
    genderId?: IntWithAggregatesFilter<"pokemon_form_gender"> | number
  }

  export type pokemon_formWhereInput = {
    AND?: pokemon_formWhereInput | pokemon_formWhereInput[]
    OR?: pokemon_formWhereInput[]
    NOT?: pokemon_formWhereInput | pokemon_formWhereInput[]
    pokemonId?: IntFilter<"pokemon_form"> | number
    formId?: IntFilter<"pokemon_form"> | number
    createdAt?: DateTimeFilter<"pokemon_form"> | Date | string
    id?: IntFilter<"pokemon_form"> | number
    status?: StringFilter<"pokemon_form"> | string
    updatedAt?: DateTimeNullableFilter<"pokemon_form"> | Date | string | null
    evolutionEnds?: EvolutionListRelationFilter
    evolutionStarts?: EvolutionListRelationFilter
    ownedPokemons?: Owned_pokemonListRelationFilter
    form?: XOR<FormScalarRelationFilter, formWhereInput>
    pokemon?: XOR<PokemonScalarRelationFilter, pokemonWhereInput>
    pokemonFormGenders?: Pokemon_form_genderListRelationFilter
    pokemonRatingGames?: Pokemon_game_locationListRelationFilter
  }

  export type pokemon_formOrderByWithRelationInput = {
    pokemonId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    id?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    evolutionEnds?: evolutionOrderByRelationAggregateInput
    evolutionStarts?: evolutionOrderByRelationAggregateInput
    ownedPokemons?: owned_pokemonOrderByRelationAggregateInput
    form?: formOrderByWithRelationInput
    pokemon?: pokemonOrderByWithRelationInput
    pokemonFormGenders?: pokemon_form_genderOrderByRelationAggregateInput
    pokemonRatingGames?: pokemon_game_locationOrderByRelationAggregateInput
    _relevance?: pokemon_formOrderByRelevanceInput
  }

  export type pokemon_formWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pokemonId_formId?: pokemon_formPokemonIdFormIdCompoundUniqueInput
    AND?: pokemon_formWhereInput | pokemon_formWhereInput[]
    OR?: pokemon_formWhereInput[]
    NOT?: pokemon_formWhereInput | pokemon_formWhereInput[]
    pokemonId?: IntFilter<"pokemon_form"> | number
    formId?: IntFilter<"pokemon_form"> | number
    createdAt?: DateTimeFilter<"pokemon_form"> | Date | string
    status?: StringFilter<"pokemon_form"> | string
    updatedAt?: DateTimeNullableFilter<"pokemon_form"> | Date | string | null
    evolutionEnds?: EvolutionListRelationFilter
    evolutionStarts?: EvolutionListRelationFilter
    ownedPokemons?: Owned_pokemonListRelationFilter
    form?: XOR<FormScalarRelationFilter, formWhereInput>
    pokemon?: XOR<PokemonScalarRelationFilter, pokemonWhereInput>
    pokemonFormGenders?: Pokemon_form_genderListRelationFilter
    pokemonRatingGames?: Pokemon_game_locationListRelationFilter
  }, "id" | "pokemonId_formId">

  export type pokemon_formOrderByWithAggregationInput = {
    pokemonId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    id?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: pokemon_formCountOrderByAggregateInput
    _avg?: pokemon_formAvgOrderByAggregateInput
    _max?: pokemon_formMaxOrderByAggregateInput
    _min?: pokemon_formMinOrderByAggregateInput
    _sum?: pokemon_formSumOrderByAggregateInput
  }

  export type pokemon_formScalarWhereWithAggregatesInput = {
    AND?: pokemon_formScalarWhereWithAggregatesInput | pokemon_formScalarWhereWithAggregatesInput[]
    OR?: pokemon_formScalarWhereWithAggregatesInput[]
    NOT?: pokemon_formScalarWhereWithAggregatesInput | pokemon_formScalarWhereWithAggregatesInput[]
    pokemonId?: IntWithAggregatesFilter<"pokemon_form"> | number
    formId?: IntWithAggregatesFilter<"pokemon_form"> | number
    createdAt?: DateTimeWithAggregatesFilter<"pokemon_form"> | Date | string
    id?: IntWithAggregatesFilter<"pokemon_form"> | number
    status?: StringWithAggregatesFilter<"pokemon_form"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"pokemon_form"> | Date | string | null
  }

  export type owned_pokemonWhereInput = {
    AND?: owned_pokemonWhereInput | owned_pokemonWhereInput[]
    OR?: owned_pokemonWhereInput[]
    NOT?: owned_pokemonWhereInput | owned_pokemonWhereInput[]
    id?: BigIntFilter<"owned_pokemon"> | bigint | number
    userId?: IntFilter<"owned_pokemon"> | number
    pokemonFormId?: IntFilter<"owned_pokemon"> | number
    gameId?: IntFilter<"owned_pokemon"> | number
    isShiny?: BoolFilter<"owned_pokemon"> | boolean
    methodId?: IntFilter<"owned_pokemon"> | number
    meetingNumber?: IntNullableFilter<"owned_pokemon"> | number | null
    time?: DateTimeNullableFilter<"owned_pokemon"> | Date | string | null
    isFinish?: BoolFilter<"owned_pokemon"> | boolean
    useCharmChroma?: BoolFilter<"owned_pokemon"> | boolean
    creationDate?: DateTimeFilter<"owned_pokemon"> | Date | string
    finishDate?: DateTimeNullableFilter<"owned_pokemon"> | Date | string | null
    createdAt?: DateTimeFilter<"owned_pokemon"> | Date | string
    updatedAt?: DateTimeNullableFilter<"owned_pokemon"> | Date | string | null
    status?: StringFilter<"owned_pokemon"> | string
    game?: XOR<GameScalarRelationFilter, gameWhereInput>
    shinyHuntingMethod?: XOR<Shiny_hunting_methodScalarRelationFilter, shiny_hunting_methodWhereInput>
    pokemonForms?: XOR<Pokemon_formScalarRelationFilter, pokemon_formWhereInput>
    users?: XOR<UserScalarRelationFilter, userWhereInput>
    ownedPokemonDetails?: Owned_pokemon_detailListRelationFilter
  }

  export type owned_pokemonOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    pokemonFormId?: SortOrder
    gameId?: SortOrder
    isShiny?: SortOrder
    methodId?: SortOrder
    meetingNumber?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    isFinish?: SortOrder
    useCharmChroma?: SortOrder
    creationDate?: SortOrder
    finishDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    game?: gameOrderByWithRelationInput
    shinyHuntingMethod?: shiny_hunting_methodOrderByWithRelationInput
    pokemonForms?: pokemon_formOrderByWithRelationInput
    users?: userOrderByWithRelationInput
    ownedPokemonDetails?: owned_pokemon_detailOrderByRelationAggregateInput
    _relevance?: owned_pokemonOrderByRelevanceInput
  }

  export type owned_pokemonWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: owned_pokemonWhereInput | owned_pokemonWhereInput[]
    OR?: owned_pokemonWhereInput[]
    NOT?: owned_pokemonWhereInput | owned_pokemonWhereInput[]
    userId?: IntFilter<"owned_pokemon"> | number
    pokemonFormId?: IntFilter<"owned_pokemon"> | number
    gameId?: IntFilter<"owned_pokemon"> | number
    isShiny?: BoolFilter<"owned_pokemon"> | boolean
    methodId?: IntFilter<"owned_pokemon"> | number
    meetingNumber?: IntNullableFilter<"owned_pokemon"> | number | null
    time?: DateTimeNullableFilter<"owned_pokemon"> | Date | string | null
    isFinish?: BoolFilter<"owned_pokemon"> | boolean
    useCharmChroma?: BoolFilter<"owned_pokemon"> | boolean
    creationDate?: DateTimeFilter<"owned_pokemon"> | Date | string
    finishDate?: DateTimeNullableFilter<"owned_pokemon"> | Date | string | null
    createdAt?: DateTimeFilter<"owned_pokemon"> | Date | string
    updatedAt?: DateTimeNullableFilter<"owned_pokemon"> | Date | string | null
    status?: StringFilter<"owned_pokemon"> | string
    game?: XOR<GameScalarRelationFilter, gameWhereInput>
    shinyHuntingMethod?: XOR<Shiny_hunting_methodScalarRelationFilter, shiny_hunting_methodWhereInput>
    pokemonForms?: XOR<Pokemon_formScalarRelationFilter, pokemon_formWhereInput>
    users?: XOR<UserScalarRelationFilter, userWhereInput>
    ownedPokemonDetails?: Owned_pokemon_detailListRelationFilter
  }, "id">

  export type owned_pokemonOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    pokemonFormId?: SortOrder
    gameId?: SortOrder
    isShiny?: SortOrder
    methodId?: SortOrder
    meetingNumber?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    isFinish?: SortOrder
    useCharmChroma?: SortOrder
    creationDate?: SortOrder
    finishDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: owned_pokemonCountOrderByAggregateInput
    _avg?: owned_pokemonAvgOrderByAggregateInput
    _max?: owned_pokemonMaxOrderByAggregateInput
    _min?: owned_pokemonMinOrderByAggregateInput
    _sum?: owned_pokemonSumOrderByAggregateInput
  }

  export type owned_pokemonScalarWhereWithAggregatesInput = {
    AND?: owned_pokemonScalarWhereWithAggregatesInput | owned_pokemonScalarWhereWithAggregatesInput[]
    OR?: owned_pokemonScalarWhereWithAggregatesInput[]
    NOT?: owned_pokemonScalarWhereWithAggregatesInput | owned_pokemonScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"owned_pokemon"> | bigint | number
    userId?: IntWithAggregatesFilter<"owned_pokemon"> | number
    pokemonFormId?: IntWithAggregatesFilter<"owned_pokemon"> | number
    gameId?: IntWithAggregatesFilter<"owned_pokemon"> | number
    isShiny?: BoolWithAggregatesFilter<"owned_pokemon"> | boolean
    methodId?: IntWithAggregatesFilter<"owned_pokemon"> | number
    meetingNumber?: IntNullableWithAggregatesFilter<"owned_pokemon"> | number | null
    time?: DateTimeNullableWithAggregatesFilter<"owned_pokemon"> | Date | string | null
    isFinish?: BoolWithAggregatesFilter<"owned_pokemon"> | boolean
    useCharmChroma?: BoolWithAggregatesFilter<"owned_pokemon"> | boolean
    creationDate?: DateTimeWithAggregatesFilter<"owned_pokemon"> | Date | string
    finishDate?: DateTimeNullableWithAggregatesFilter<"owned_pokemon"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"owned_pokemon"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"owned_pokemon"> | Date | string | null
    status?: StringWithAggregatesFilter<"owned_pokemon"> | string
  }

  export type owned_pokemon_detailWhereInput = {
    AND?: owned_pokemon_detailWhereInput | owned_pokemon_detailWhereInput[]
    OR?: owned_pokemon_detailWhereInput[]
    NOT?: owned_pokemon_detailWhereInput | owned_pokemon_detailWhereInput[]
    id?: BigIntFilter<"owned_pokemon_detail"> | bigint | number
    nickname?: StringFilter<"owned_pokemon_detail"> | string
    pokeballId?: IntFilter<"owned_pokemon_detail"> | number
    ownedPokemonId?: BigIntFilter<"owned_pokemon_detail"> | bigint | number
    createdAt?: DateTimeFilter<"owned_pokemon_detail"> | Date | string
    updatedAt?: DateTimeNullableFilter<"owned_pokemon_detail"> | Date | string | null
    status?: StringFilter<"owned_pokemon_detail"> | string
    ownedPokemon?: XOR<Owned_pokemonScalarRelationFilter, owned_pokemonWhereInput>
    pokeball?: XOR<PokeballScalarRelationFilter, pokeballWhereInput>
  }

  export type owned_pokemon_detailOrderByWithRelationInput = {
    id?: SortOrder
    nickname?: SortOrder
    pokeballId?: SortOrder
    ownedPokemonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    ownedPokemon?: owned_pokemonOrderByWithRelationInput
    pokeball?: pokeballOrderByWithRelationInput
    _relevance?: owned_pokemon_detailOrderByRelevanceInput
  }

  export type owned_pokemon_detailWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: owned_pokemon_detailWhereInput | owned_pokemon_detailWhereInput[]
    OR?: owned_pokemon_detailWhereInput[]
    NOT?: owned_pokemon_detailWhereInput | owned_pokemon_detailWhereInput[]
    nickname?: StringFilter<"owned_pokemon_detail"> | string
    pokeballId?: IntFilter<"owned_pokemon_detail"> | number
    ownedPokemonId?: BigIntFilter<"owned_pokemon_detail"> | bigint | number
    createdAt?: DateTimeFilter<"owned_pokemon_detail"> | Date | string
    updatedAt?: DateTimeNullableFilter<"owned_pokemon_detail"> | Date | string | null
    status?: StringFilter<"owned_pokemon_detail"> | string
    ownedPokemon?: XOR<Owned_pokemonScalarRelationFilter, owned_pokemonWhereInput>
    pokeball?: XOR<PokeballScalarRelationFilter, pokeballWhereInput>
  }, "id">

  export type owned_pokemon_detailOrderByWithAggregationInput = {
    id?: SortOrder
    nickname?: SortOrder
    pokeballId?: SortOrder
    ownedPokemonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: owned_pokemon_detailCountOrderByAggregateInput
    _avg?: owned_pokemon_detailAvgOrderByAggregateInput
    _max?: owned_pokemon_detailMaxOrderByAggregateInput
    _min?: owned_pokemon_detailMinOrderByAggregateInput
    _sum?: owned_pokemon_detailSumOrderByAggregateInput
  }

  export type owned_pokemon_detailScalarWhereWithAggregatesInput = {
    AND?: owned_pokemon_detailScalarWhereWithAggregatesInput | owned_pokemon_detailScalarWhereWithAggregatesInput[]
    OR?: owned_pokemon_detailScalarWhereWithAggregatesInput[]
    NOT?: owned_pokemon_detailScalarWhereWithAggregatesInput | owned_pokemon_detailScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"owned_pokemon_detail"> | bigint | number
    nickname?: StringWithAggregatesFilter<"owned_pokemon_detail"> | string
    pokeballId?: IntWithAggregatesFilter<"owned_pokemon_detail"> | number
    ownedPokemonId?: BigIntWithAggregatesFilter<"owned_pokemon_detail"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"owned_pokemon_detail"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"owned_pokemon_detail"> | Date | string | null
    status?: StringWithAggregatesFilter<"owned_pokemon_detail"> | string
  }

  export type abilityWhereInput = {
    AND?: abilityWhereInput | abilityWhereInput[]
    OR?: abilityWhereInput[]
    NOT?: abilityWhereInput | abilityWhereInput[]
    id?: IntFilter<"ability"> | number
    appearanceGenerationId?: IntFilter<"ability"> | number
    createdAt?: DateTimeFilter<"ability"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ability"> | Date | string | null
    status?: StringFilter<"ability"> | string
    generation?: XOR<GenerationScalarRelationFilter, generationWhereInput>
    abilityInfos?: Ability_infoListRelationFilter
    abilityOrders?: Ability_orderListRelationFilter
  }

  export type abilityOrderByWithRelationInput = {
    id?: SortOrder
    appearanceGenerationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    generation?: generationOrderByWithRelationInput
    abilityInfos?: ability_infoOrderByRelationAggregateInput
    abilityOrders?: ability_orderOrderByRelationAggregateInput
    _relevance?: abilityOrderByRelevanceInput
  }

  export type abilityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: abilityWhereInput | abilityWhereInput[]
    OR?: abilityWhereInput[]
    NOT?: abilityWhereInput | abilityWhereInput[]
    appearanceGenerationId?: IntFilter<"ability"> | number
    createdAt?: DateTimeFilter<"ability"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ability"> | Date | string | null
    status?: StringFilter<"ability"> | string
    generation?: XOR<GenerationScalarRelationFilter, generationWhereInput>
    abilityInfos?: Ability_infoListRelationFilter
    abilityOrders?: Ability_orderListRelationFilter
  }, "id">

  export type abilityOrderByWithAggregationInput = {
    id?: SortOrder
    appearanceGenerationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: abilityCountOrderByAggregateInput
    _avg?: abilityAvgOrderByAggregateInput
    _max?: abilityMaxOrderByAggregateInput
    _min?: abilityMinOrderByAggregateInput
    _sum?: abilitySumOrderByAggregateInput
  }

  export type abilityScalarWhereWithAggregatesInput = {
    AND?: abilityScalarWhereWithAggregatesInput | abilityScalarWhereWithAggregatesInput[]
    OR?: abilityScalarWhereWithAggregatesInput[]
    NOT?: abilityScalarWhereWithAggregatesInput | abilityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ability"> | number
    appearanceGenerationId?: IntWithAggregatesFilter<"ability"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ability"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ability"> | Date | string | null
    status?: StringWithAggregatesFilter<"ability"> | string
  }

  export type ability_infoWhereInput = {
    AND?: ability_infoWhereInput | ability_infoWhereInput[]
    OR?: ability_infoWhereInput[]
    NOT?: ability_infoWhereInput | ability_infoWhereInput[]
    id?: IntFilter<"ability_info"> | number
    generationId?: IntFilter<"ability_info"> | number
    abilityId?: IntFilter<"ability_info"> | number
    effectOutsideFightId?: IntFilter<"ability_info"> | number
    createdAt?: DateTimeFilter<"ability_info"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ability_info"> | Date | string | null
    status?: StringFilter<"ability_info"> | string
    abilities?: XOR<AbilityScalarRelationFilter, abilityWhereInput>
    effectWithoutFight?: XOR<Effect_outside_fightScalarRelationFilter, effect_outside_fightWhereInput>
    generation?: XOR<GenerationScalarRelationFilter, generationWhereInput>
  }

  export type ability_infoOrderByWithRelationInput = {
    id?: SortOrder
    generationId?: SortOrder
    abilityId?: SortOrder
    effectOutsideFightId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    abilities?: abilityOrderByWithRelationInput
    effectWithoutFight?: effect_outside_fightOrderByWithRelationInput
    generation?: generationOrderByWithRelationInput
    _relevance?: ability_infoOrderByRelevanceInput
  }

  export type ability_infoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ability_infoWhereInput | ability_infoWhereInput[]
    OR?: ability_infoWhereInput[]
    NOT?: ability_infoWhereInput | ability_infoWhereInput[]
    generationId?: IntFilter<"ability_info"> | number
    abilityId?: IntFilter<"ability_info"> | number
    effectOutsideFightId?: IntFilter<"ability_info"> | number
    createdAt?: DateTimeFilter<"ability_info"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ability_info"> | Date | string | null
    status?: StringFilter<"ability_info"> | string
    abilities?: XOR<AbilityScalarRelationFilter, abilityWhereInput>
    effectWithoutFight?: XOR<Effect_outside_fightScalarRelationFilter, effect_outside_fightWhereInput>
    generation?: XOR<GenerationScalarRelationFilter, generationWhereInput>
  }, "id">

  export type ability_infoOrderByWithAggregationInput = {
    id?: SortOrder
    generationId?: SortOrder
    abilityId?: SortOrder
    effectOutsideFightId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: ability_infoCountOrderByAggregateInput
    _avg?: ability_infoAvgOrderByAggregateInput
    _max?: ability_infoMaxOrderByAggregateInput
    _min?: ability_infoMinOrderByAggregateInput
    _sum?: ability_infoSumOrderByAggregateInput
  }

  export type ability_infoScalarWhereWithAggregatesInput = {
    AND?: ability_infoScalarWhereWithAggregatesInput | ability_infoScalarWhereWithAggregatesInput[]
    OR?: ability_infoScalarWhereWithAggregatesInput[]
    NOT?: ability_infoScalarWhereWithAggregatesInput | ability_infoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ability_info"> | number
    generationId?: IntWithAggregatesFilter<"ability_info"> | number
    abilityId?: IntWithAggregatesFilter<"ability_info"> | number
    effectOutsideFightId?: IntWithAggregatesFilter<"ability_info"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ability_info"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ability_info"> | Date | string | null
    status?: StringWithAggregatesFilter<"ability_info"> | string
  }

  export type pokemon_infoWhereInput = {
    AND?: pokemon_infoWhereInput | pokemon_infoWhereInput[]
    OR?: pokemon_infoWhereInput[]
    NOT?: pokemon_infoWhereInput | pokemon_infoWhereInput[]
    id?: IntFilter<"pokemon_info"> | number
    xpGift?: IntFilter<"pokemon_info"> | number
    generationId?: IntFilter<"pokemon_info"> | number
    pokemonId?: IntFilter<"pokemon_info"> | number
    createdAt?: DateTimeFilter<"pokemon_info"> | Date | string
    updatedAt?: DateTimeNullableFilter<"pokemon_info"> | Date | string | null
    status?: StringFilter<"pokemon_info"> | string
    abilityOrders?: Ability_orderListRelationFilter
    eggGroupOrders?: Egg_group_orderListRelationFilter
    generation?: XOR<GenerationScalarRelationFilter, generationWhereInput>
    pokemon?: XOR<PokemonScalarRelationFilter, pokemonWhereInput>
    typeOrders?: Type_orderListRelationFilter
  }

  export type pokemon_infoOrderByWithRelationInput = {
    id?: SortOrder
    xpGift?: SortOrder
    generationId?: SortOrder
    pokemonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    abilityOrders?: ability_orderOrderByRelationAggregateInput
    eggGroupOrders?: egg_group_orderOrderByRelationAggregateInput
    generation?: generationOrderByWithRelationInput
    pokemon?: pokemonOrderByWithRelationInput
    typeOrders?: type_orderOrderByRelationAggregateInput
    _relevance?: pokemon_infoOrderByRelevanceInput
  }

  export type pokemon_infoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pokemon_infoWhereInput | pokemon_infoWhereInput[]
    OR?: pokemon_infoWhereInput[]
    NOT?: pokemon_infoWhereInput | pokemon_infoWhereInput[]
    xpGift?: IntFilter<"pokemon_info"> | number
    generationId?: IntFilter<"pokemon_info"> | number
    pokemonId?: IntFilter<"pokemon_info"> | number
    createdAt?: DateTimeFilter<"pokemon_info"> | Date | string
    updatedAt?: DateTimeNullableFilter<"pokemon_info"> | Date | string | null
    status?: StringFilter<"pokemon_info"> | string
    abilityOrders?: Ability_orderListRelationFilter
    eggGroupOrders?: Egg_group_orderListRelationFilter
    generation?: XOR<GenerationScalarRelationFilter, generationWhereInput>
    pokemon?: XOR<PokemonScalarRelationFilter, pokemonWhereInput>
    typeOrders?: Type_orderListRelationFilter
  }, "id">

  export type pokemon_infoOrderByWithAggregationInput = {
    id?: SortOrder
    xpGift?: SortOrder
    generationId?: SortOrder
    pokemonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: pokemon_infoCountOrderByAggregateInput
    _avg?: pokemon_infoAvgOrderByAggregateInput
    _max?: pokemon_infoMaxOrderByAggregateInput
    _min?: pokemon_infoMinOrderByAggregateInput
    _sum?: pokemon_infoSumOrderByAggregateInput
  }

  export type pokemon_infoScalarWhereWithAggregatesInput = {
    AND?: pokemon_infoScalarWhereWithAggregatesInput | pokemon_infoScalarWhereWithAggregatesInput[]
    OR?: pokemon_infoScalarWhereWithAggregatesInput[]
    NOT?: pokemon_infoScalarWhereWithAggregatesInput | pokemon_infoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pokemon_info"> | number
    xpGift?: IntWithAggregatesFilter<"pokemon_info"> | number
    generationId?: IntWithAggregatesFilter<"pokemon_info"> | number
    pokemonId?: IntWithAggregatesFilter<"pokemon_info"> | number
    createdAt?: DateTimeWithAggregatesFilter<"pokemon_info"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"pokemon_info"> | Date | string | null
    status?: StringWithAggregatesFilter<"pokemon_info"> | string
  }

  export type ability_orderWhereInput = {
    AND?: ability_orderWhereInput | ability_orderWhereInput[]
    OR?: ability_orderWhereInput[]
    NOT?: ability_orderWhereInput | ability_orderWhereInput[]
    pokemonInfoId?: IntFilter<"ability_order"> | number
    abilityId?: IntFilter<"ability_order"> | number
    order?: IntFilter<"ability_order"> | number
    isHidden?: BoolFilter<"ability_order"> | boolean
    ability?: XOR<AbilityScalarRelationFilter, abilityWhereInput>
    pokemonInfo?: XOR<Pokemon_infoScalarRelationFilter, pokemon_infoWhereInput>
  }

  export type ability_orderOrderByWithRelationInput = {
    pokemonInfoId?: SortOrder
    abilityId?: SortOrder
    order?: SortOrder
    isHidden?: SortOrder
    ability?: abilityOrderByWithRelationInput
    pokemonInfo?: pokemon_infoOrderByWithRelationInput
  }

  export type ability_orderWhereUniqueInput = Prisma.AtLeast<{
    abilityId_pokemonInfoId?: ability_orderAbilityIdPokemonInfoIdCompoundUniqueInput
    AND?: ability_orderWhereInput | ability_orderWhereInput[]
    OR?: ability_orderWhereInput[]
    NOT?: ability_orderWhereInput | ability_orderWhereInput[]
    pokemonInfoId?: IntFilter<"ability_order"> | number
    abilityId?: IntFilter<"ability_order"> | number
    order?: IntFilter<"ability_order"> | number
    isHidden?: BoolFilter<"ability_order"> | boolean
    ability?: XOR<AbilityScalarRelationFilter, abilityWhereInput>
    pokemonInfo?: XOR<Pokemon_infoScalarRelationFilter, pokemon_infoWhereInput>
  }, "abilityId_pokemonInfoId">

  export type ability_orderOrderByWithAggregationInput = {
    pokemonInfoId?: SortOrder
    abilityId?: SortOrder
    order?: SortOrder
    isHidden?: SortOrder
    _count?: ability_orderCountOrderByAggregateInput
    _avg?: ability_orderAvgOrderByAggregateInput
    _max?: ability_orderMaxOrderByAggregateInput
    _min?: ability_orderMinOrderByAggregateInput
    _sum?: ability_orderSumOrderByAggregateInput
  }

  export type ability_orderScalarWhereWithAggregatesInput = {
    AND?: ability_orderScalarWhereWithAggregatesInput | ability_orderScalarWhereWithAggregatesInput[]
    OR?: ability_orderScalarWhereWithAggregatesInput[]
    NOT?: ability_orderScalarWhereWithAggregatesInput | ability_orderScalarWhereWithAggregatesInput[]
    pokemonInfoId?: IntWithAggregatesFilter<"ability_order"> | number
    abilityId?: IntWithAggregatesFilter<"ability_order"> | number
    order?: IntWithAggregatesFilter<"ability_order"> | number
    isHidden?: BoolWithAggregatesFilter<"ability_order"> | boolean
  }

  export type evolution_methodWhereInput = {
    AND?: evolution_methodWhereInput | evolution_methodWhereInput[]
    OR?: evolution_methodWhereInput[]
    NOT?: evolution_methodWhereInput | evolution_methodWhereInput[]
    id?: IntFilter<"evolution_method"> | number
    createdAt?: DateTimeFilter<"evolution_method"> | Date | string
    updatedAt?: DateTimeNullableFilter<"evolution_method"> | Date | string | null
    status?: StringFilter<"evolution_method"> | string
    evolutions?: EvolutionListRelationFilter
  }

  export type evolution_methodOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    evolutions?: evolutionOrderByRelationAggregateInput
    _relevance?: evolution_methodOrderByRelevanceInput
  }

  export type evolution_methodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: evolution_methodWhereInput | evolution_methodWhereInput[]
    OR?: evolution_methodWhereInput[]
    NOT?: evolution_methodWhereInput | evolution_methodWhereInput[]
    createdAt?: DateTimeFilter<"evolution_method"> | Date | string
    updatedAt?: DateTimeNullableFilter<"evolution_method"> | Date | string | null
    status?: StringFilter<"evolution_method"> | string
    evolutions?: EvolutionListRelationFilter
  }, "id">

  export type evolution_methodOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: evolution_methodCountOrderByAggregateInput
    _avg?: evolution_methodAvgOrderByAggregateInput
    _max?: evolution_methodMaxOrderByAggregateInput
    _min?: evolution_methodMinOrderByAggregateInput
    _sum?: evolution_methodSumOrderByAggregateInput
  }

  export type evolution_methodScalarWhereWithAggregatesInput = {
    AND?: evolution_methodScalarWhereWithAggregatesInput | evolution_methodScalarWhereWithAggregatesInput[]
    OR?: evolution_methodScalarWhereWithAggregatesInput[]
    NOT?: evolution_methodScalarWhereWithAggregatesInput | evolution_methodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"evolution_method"> | number
    createdAt?: DateTimeWithAggregatesFilter<"evolution_method"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"evolution_method"> | Date | string | null
    status?: StringWithAggregatesFilter<"evolution_method"> | string
  }

  export type evolutionWhereInput = {
    AND?: evolutionWhereInput | evolutionWhereInput[]
    OR?: evolutionWhereInput[]
    NOT?: evolutionWhereInput | evolutionWhereInput[]
    id?: IntFilter<"evolution"> | number
    level?: IntNullableFilter<"evolution"> | number | null
    evolutionMethodId?: IntFilter<"evolution"> | number
    pokemonFormStartId?: IntFilter<"evolution"> | number
    pokemonFormEndId?: IntFilter<"evolution"> | number
    evolutionInfoId?: IntFilter<"evolution"> | number
    createdAt?: DateTimeFilter<"evolution"> | Date | string
    updatedAt?: DateTimeNullableFilter<"evolution"> | Date | string | null
    status?: StringFilter<"evolution"> | string
    evolutionInfo?: XOR<Evolution_infoScalarRelationFilter, evolution_infoWhereInput>
    evolutionMethod?: XOR<Evolution_methodScalarRelationFilter, evolution_methodWhereInput>
    pokemonEnd?: XOR<Pokemon_formScalarRelationFilter, pokemon_formWhereInput>
    pokemonStart?: XOR<Pokemon_formScalarRelationFilter, pokemon_formWhereInput>
  }

  export type evolutionOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrderInput | SortOrder
    evolutionMethodId?: SortOrder
    pokemonFormStartId?: SortOrder
    pokemonFormEndId?: SortOrder
    evolutionInfoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    evolutionInfo?: evolution_infoOrderByWithRelationInput
    evolutionMethod?: evolution_methodOrderByWithRelationInput
    pokemonEnd?: pokemon_formOrderByWithRelationInput
    pokemonStart?: pokemon_formOrderByWithRelationInput
    _relevance?: evolutionOrderByRelevanceInput
  }

  export type evolutionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: evolutionWhereInput | evolutionWhereInput[]
    OR?: evolutionWhereInput[]
    NOT?: evolutionWhereInput | evolutionWhereInput[]
    level?: IntNullableFilter<"evolution"> | number | null
    evolutionMethodId?: IntFilter<"evolution"> | number
    pokemonFormStartId?: IntFilter<"evolution"> | number
    pokemonFormEndId?: IntFilter<"evolution"> | number
    evolutionInfoId?: IntFilter<"evolution"> | number
    createdAt?: DateTimeFilter<"evolution"> | Date | string
    updatedAt?: DateTimeNullableFilter<"evolution"> | Date | string | null
    status?: StringFilter<"evolution"> | string
    evolutionInfo?: XOR<Evolution_infoScalarRelationFilter, evolution_infoWhereInput>
    evolutionMethod?: XOR<Evolution_methodScalarRelationFilter, evolution_methodWhereInput>
    pokemonEnd?: XOR<Pokemon_formScalarRelationFilter, pokemon_formWhereInput>
    pokemonStart?: XOR<Pokemon_formScalarRelationFilter, pokemon_formWhereInput>
  }, "id">

  export type evolutionOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrderInput | SortOrder
    evolutionMethodId?: SortOrder
    pokemonFormStartId?: SortOrder
    pokemonFormEndId?: SortOrder
    evolutionInfoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: evolutionCountOrderByAggregateInput
    _avg?: evolutionAvgOrderByAggregateInput
    _max?: evolutionMaxOrderByAggregateInput
    _min?: evolutionMinOrderByAggregateInput
    _sum?: evolutionSumOrderByAggregateInput
  }

  export type evolutionScalarWhereWithAggregatesInput = {
    AND?: evolutionScalarWhereWithAggregatesInput | evolutionScalarWhereWithAggregatesInput[]
    OR?: evolutionScalarWhereWithAggregatesInput[]
    NOT?: evolutionScalarWhereWithAggregatesInput | evolutionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"evolution"> | number
    level?: IntNullableWithAggregatesFilter<"evolution"> | number | null
    evolutionMethodId?: IntWithAggregatesFilter<"evolution"> | number
    pokemonFormStartId?: IntWithAggregatesFilter<"evolution"> | number
    pokemonFormEndId?: IntWithAggregatesFilter<"evolution"> | number
    evolutionInfoId?: IntWithAggregatesFilter<"evolution"> | number
    createdAt?: DateTimeWithAggregatesFilter<"evolution"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"evolution"> | Date | string | null
    status?: StringWithAggregatesFilter<"evolution"> | string
  }

  export type evolution_infoWhereInput = {
    AND?: evolution_infoWhereInput | evolution_infoWhereInput[]
    OR?: evolution_infoWhereInput[]
    NOT?: evolution_infoWhereInput | evolution_infoWhereInput[]
    id?: IntFilter<"evolution_info"> | number
    createdAt?: DateTimeFilter<"evolution_info"> | Date | string
    updatedAt?: DateTimeNullableFilter<"evolution_info"> | Date | string | null
    status?: StringFilter<"evolution_info"> | string
    evolutions?: EvolutionListRelationFilter
  }

  export type evolution_infoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    evolutions?: evolutionOrderByRelationAggregateInput
    _relevance?: evolution_infoOrderByRelevanceInput
  }

  export type evolution_infoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: evolution_infoWhereInput | evolution_infoWhereInput[]
    OR?: evolution_infoWhereInput[]
    NOT?: evolution_infoWhereInput | evolution_infoWhereInput[]
    createdAt?: DateTimeFilter<"evolution_info"> | Date | string
    updatedAt?: DateTimeNullableFilter<"evolution_info"> | Date | string | null
    status?: StringFilter<"evolution_info"> | string
    evolutions?: EvolutionListRelationFilter
  }, "id">

  export type evolution_infoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: evolution_infoCountOrderByAggregateInput
    _avg?: evolution_infoAvgOrderByAggregateInput
    _max?: evolution_infoMaxOrderByAggregateInput
    _min?: evolution_infoMinOrderByAggregateInput
    _sum?: evolution_infoSumOrderByAggregateInput
  }

  export type evolution_infoScalarWhereWithAggregatesInput = {
    AND?: evolution_infoScalarWhereWithAggregatesInput | evolution_infoScalarWhereWithAggregatesInput[]
    OR?: evolution_infoScalarWhereWithAggregatesInput[]
    NOT?: evolution_infoScalarWhereWithAggregatesInput | evolution_infoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"evolution_info"> | number
    createdAt?: DateTimeWithAggregatesFilter<"evolution_info"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"evolution_info"> | Date | string | null
    status?: StringWithAggregatesFilter<"evolution_info"> | string
  }

  export type egg_groupWhereInput = {
    AND?: egg_groupWhereInput | egg_groupWhereInput[]
    OR?: egg_groupWhereInput[]
    NOT?: egg_groupWhereInput | egg_groupWhereInput[]
    id?: IntFilter<"egg_group"> | number
    createdAt?: DateTimeFilter<"egg_group"> | Date | string
    updatedAt?: DateTimeNullableFilter<"egg_group"> | Date | string | null
    status?: StringFilter<"egg_group"> | string
    eggGroupOrders?: Egg_group_orderListRelationFilter
  }

  export type egg_groupOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    eggGroupOrders?: egg_group_orderOrderByRelationAggregateInput
    _relevance?: egg_groupOrderByRelevanceInput
  }

  export type egg_groupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: egg_groupWhereInput | egg_groupWhereInput[]
    OR?: egg_groupWhereInput[]
    NOT?: egg_groupWhereInput | egg_groupWhereInput[]
    createdAt?: DateTimeFilter<"egg_group"> | Date | string
    updatedAt?: DateTimeNullableFilter<"egg_group"> | Date | string | null
    status?: StringFilter<"egg_group"> | string
    eggGroupOrders?: Egg_group_orderListRelationFilter
  }, "id">

  export type egg_groupOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: egg_groupCountOrderByAggregateInput
    _avg?: egg_groupAvgOrderByAggregateInput
    _max?: egg_groupMaxOrderByAggregateInput
    _min?: egg_groupMinOrderByAggregateInput
    _sum?: egg_groupSumOrderByAggregateInput
  }

  export type egg_groupScalarWhereWithAggregatesInput = {
    AND?: egg_groupScalarWhereWithAggregatesInput | egg_groupScalarWhereWithAggregatesInput[]
    OR?: egg_groupScalarWhereWithAggregatesInput[]
    NOT?: egg_groupScalarWhereWithAggregatesInput | egg_groupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"egg_group"> | number
    createdAt?: DateTimeWithAggregatesFilter<"egg_group"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"egg_group"> | Date | string | null
    status?: StringWithAggregatesFilter<"egg_group"> | string
  }

  export type egg_group_orderWhereInput = {
    AND?: egg_group_orderWhereInput | egg_group_orderWhereInput[]
    OR?: egg_group_orderWhereInput[]
    NOT?: egg_group_orderWhereInput | egg_group_orderWhereInput[]
    pokemonInfoId?: IntFilter<"egg_group_order"> | number
    eggGroupId?: IntFilter<"egg_group_order"> | number
    order?: IntFilter<"egg_group_order"> | number
    eggGroup?: XOR<Egg_groupScalarRelationFilter, egg_groupWhereInput>
    pokemonInfo?: XOR<Pokemon_infoScalarRelationFilter, pokemon_infoWhereInput>
  }

  export type egg_group_orderOrderByWithRelationInput = {
    pokemonInfoId?: SortOrder
    eggGroupId?: SortOrder
    order?: SortOrder
    eggGroup?: egg_groupOrderByWithRelationInput
    pokemonInfo?: pokemon_infoOrderByWithRelationInput
  }

  export type egg_group_orderWhereUniqueInput = Prisma.AtLeast<{
    eggGroupId_pokemonInfoId?: egg_group_orderEggGroupIdPokemonInfoIdCompoundUniqueInput
    AND?: egg_group_orderWhereInput | egg_group_orderWhereInput[]
    OR?: egg_group_orderWhereInput[]
    NOT?: egg_group_orderWhereInput | egg_group_orderWhereInput[]
    pokemonInfoId?: IntFilter<"egg_group_order"> | number
    eggGroupId?: IntFilter<"egg_group_order"> | number
    order?: IntFilter<"egg_group_order"> | number
    eggGroup?: XOR<Egg_groupScalarRelationFilter, egg_groupWhereInput>
    pokemonInfo?: XOR<Pokemon_infoScalarRelationFilter, pokemon_infoWhereInput>
  }, "eggGroupId_pokemonInfoId">

  export type egg_group_orderOrderByWithAggregationInput = {
    pokemonInfoId?: SortOrder
    eggGroupId?: SortOrder
    order?: SortOrder
    _count?: egg_group_orderCountOrderByAggregateInput
    _avg?: egg_group_orderAvgOrderByAggregateInput
    _max?: egg_group_orderMaxOrderByAggregateInput
    _min?: egg_group_orderMinOrderByAggregateInput
    _sum?: egg_group_orderSumOrderByAggregateInput
  }

  export type egg_group_orderScalarWhereWithAggregatesInput = {
    AND?: egg_group_orderScalarWhereWithAggregatesInput | egg_group_orderScalarWhereWithAggregatesInput[]
    OR?: egg_group_orderScalarWhereWithAggregatesInput[]
    NOT?: egg_group_orderScalarWhereWithAggregatesInput | egg_group_orderScalarWhereWithAggregatesInput[]
    pokemonInfoId?: IntWithAggregatesFilter<"egg_group_order"> | number
    eggGroupId?: IntWithAggregatesFilter<"egg_group_order"> | number
    order?: IntWithAggregatesFilter<"egg_group_order"> | number
  }

  export type typeWhereInput = {
    AND?: typeWhereInput | typeWhereInput[]
    OR?: typeWhereInput[]
    NOT?: typeWhereInput | typeWhereInput[]
    id?: IntFilter<"type"> | number
    color?: StringFilter<"type"> | string
    iconName?: StringFilter<"type"> | string
    createdAt?: DateTimeFilter<"type"> | Date | string
    updatedAt?: DateTimeNullableFilter<"type"> | Date | string | null
    status?: StringFilter<"type"> | string
    capacityInfos?: Capacity_infoListRelationFilter
    typeOrders?: Type_orderListRelationFilter
  }

  export type typeOrderByWithRelationInput = {
    id?: SortOrder
    color?: SortOrder
    iconName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    capacityInfos?: capacity_infoOrderByRelationAggregateInput
    typeOrders?: type_orderOrderByRelationAggregateInput
    _relevance?: typeOrderByRelevanceInput
  }

  export type typeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: typeWhereInput | typeWhereInput[]
    OR?: typeWhereInput[]
    NOT?: typeWhereInput | typeWhereInput[]
    color?: StringFilter<"type"> | string
    iconName?: StringFilter<"type"> | string
    createdAt?: DateTimeFilter<"type"> | Date | string
    updatedAt?: DateTimeNullableFilter<"type"> | Date | string | null
    status?: StringFilter<"type"> | string
    capacityInfos?: Capacity_infoListRelationFilter
    typeOrders?: Type_orderListRelationFilter
  }, "id">

  export type typeOrderByWithAggregationInput = {
    id?: SortOrder
    color?: SortOrder
    iconName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: typeCountOrderByAggregateInput
    _avg?: typeAvgOrderByAggregateInput
    _max?: typeMaxOrderByAggregateInput
    _min?: typeMinOrderByAggregateInput
    _sum?: typeSumOrderByAggregateInput
  }

  export type typeScalarWhereWithAggregatesInput = {
    AND?: typeScalarWhereWithAggregatesInput | typeScalarWhereWithAggregatesInput[]
    OR?: typeScalarWhereWithAggregatesInput[]
    NOT?: typeScalarWhereWithAggregatesInput | typeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"type"> | number
    color?: StringWithAggregatesFilter<"type"> | string
    iconName?: StringWithAggregatesFilter<"type"> | string
    createdAt?: DateTimeWithAggregatesFilter<"type"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"type"> | Date | string | null
    status?: StringWithAggregatesFilter<"type"> | string
  }

  export type type_orderWhereInput = {
    AND?: type_orderWhereInput | type_orderWhereInput[]
    OR?: type_orderWhereInput[]
    NOT?: type_orderWhereInput | type_orderWhereInput[]
    typeId?: IntFilter<"type_order"> | number
    pokemonInfoId?: IntFilter<"type_order"> | number
    order?: IntFilter<"type_order"> | number
    pokemonInfo?: XOR<Pokemon_infoScalarRelationFilter, pokemon_infoWhereInput>
    type?: XOR<TypeScalarRelationFilter, typeWhereInput>
  }

  export type type_orderOrderByWithRelationInput = {
    typeId?: SortOrder
    pokemonInfoId?: SortOrder
    order?: SortOrder
    pokemonInfo?: pokemon_infoOrderByWithRelationInput
    type?: typeOrderByWithRelationInput
  }

  export type type_orderWhereUniqueInput = Prisma.AtLeast<{
    typeId_pokemonInfoId?: type_orderTypeIdPokemonInfoIdCompoundUniqueInput
    AND?: type_orderWhereInput | type_orderWhereInput[]
    OR?: type_orderWhereInput[]
    NOT?: type_orderWhereInput | type_orderWhereInput[]
    typeId?: IntFilter<"type_order"> | number
    pokemonInfoId?: IntFilter<"type_order"> | number
    order?: IntFilter<"type_order"> | number
    pokemonInfo?: XOR<Pokemon_infoScalarRelationFilter, pokemon_infoWhereInput>
    type?: XOR<TypeScalarRelationFilter, typeWhereInput>
  }, "typeId_pokemonInfoId">

  export type type_orderOrderByWithAggregationInput = {
    typeId?: SortOrder
    pokemonInfoId?: SortOrder
    order?: SortOrder
    _count?: type_orderCountOrderByAggregateInput
    _avg?: type_orderAvgOrderByAggregateInput
    _max?: type_orderMaxOrderByAggregateInput
    _min?: type_orderMinOrderByAggregateInput
    _sum?: type_orderSumOrderByAggregateInput
  }

  export type type_orderScalarWhereWithAggregatesInput = {
    AND?: type_orderScalarWhereWithAggregatesInput | type_orderScalarWhereWithAggregatesInput[]
    OR?: type_orderScalarWhereWithAggregatesInput[]
    NOT?: type_orderScalarWhereWithAggregatesInput | type_orderScalarWhereWithAggregatesInput[]
    typeId?: IntWithAggregatesFilter<"type_order"> | number
    pokemonInfoId?: IntWithAggregatesFilter<"type_order"> | number
    order?: IntWithAggregatesFilter<"type_order"> | number
  }

  export type national_numberWhereInput = {
    AND?: national_numberWhereInput | national_numberWhereInput[]
    OR?: national_numberWhereInput[]
    NOT?: national_numberWhereInput | national_numberWhereInput[]
    groupGameId?: IntFilter<"national_number"> | number
    pokemonId?: IntFilter<"national_number"> | number
    number?: IntFilter<"national_number"> | number
    groupGame?: XOR<Group_gameScalarRelationFilter, group_gameWhereInput>
    pokemon?: XOR<PokemonScalarRelationFilter, pokemonWhereInput>
  }

  export type national_numberOrderByWithRelationInput = {
    groupGameId?: SortOrder
    pokemonId?: SortOrder
    number?: SortOrder
    groupGame?: group_gameOrderByWithRelationInput
    pokemon?: pokemonOrderByWithRelationInput
  }

  export type national_numberWhereUniqueInput = Prisma.AtLeast<{
    pokemonId_groupGameId?: national_numberPokemonIdGroupGameIdCompoundUniqueInput
    AND?: national_numberWhereInput | national_numberWhereInput[]
    OR?: national_numberWhereInput[]
    NOT?: national_numberWhereInput | national_numberWhereInput[]
    groupGameId?: IntFilter<"national_number"> | number
    pokemonId?: IntFilter<"national_number"> | number
    number?: IntFilter<"national_number"> | number
    groupGame?: XOR<Group_gameScalarRelationFilter, group_gameWhereInput>
    pokemon?: XOR<PokemonScalarRelationFilter, pokemonWhereInput>
  }, "pokemonId_groupGameId">

  export type national_numberOrderByWithAggregationInput = {
    groupGameId?: SortOrder
    pokemonId?: SortOrder
    number?: SortOrder
    _count?: national_numberCountOrderByAggregateInput
    _avg?: national_numberAvgOrderByAggregateInput
    _max?: national_numberMaxOrderByAggregateInput
    _min?: national_numberMinOrderByAggregateInput
    _sum?: national_numberSumOrderByAggregateInput
  }

  export type national_numberScalarWhereWithAggregatesInput = {
    AND?: national_numberScalarWhereWithAggregatesInput | national_numberScalarWhereWithAggregatesInput[]
    OR?: national_numberScalarWhereWithAggregatesInput[]
    NOT?: national_numberScalarWhereWithAggregatesInput | national_numberScalarWhereWithAggregatesInput[]
    groupGameId?: IntWithAggregatesFilter<"national_number"> | number
    pokemonId?: IntWithAggregatesFilter<"national_number"> | number
    number?: IntWithAggregatesFilter<"national_number"> | number
  }

  export type landWhereInput = {
    AND?: landWhereInput | landWhereInput[]
    OR?: landWhereInput[]
    NOT?: landWhereInput | landWhereInput[]
    id?: IntFilter<"land"> | number
    createdAt?: DateTimeFilter<"land"> | Date | string
    updatedAt?: DateTimeNullableFilter<"land"> | Date | string | null
    status?: StringFilter<"land"> | string
    game_group_game?: Game_group_gameListRelationFilter
  }

  export type landOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    game_group_game?: game_group_gameOrderByRelationAggregateInput
    _relevance?: landOrderByRelevanceInput
  }

  export type landWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: landWhereInput | landWhereInput[]
    OR?: landWhereInput[]
    NOT?: landWhereInput | landWhereInput[]
    createdAt?: DateTimeFilter<"land"> | Date | string
    updatedAt?: DateTimeNullableFilter<"land"> | Date | string | null
    status?: StringFilter<"land"> | string
    game_group_game?: Game_group_gameListRelationFilter
  }, "id">

  export type landOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: landCountOrderByAggregateInput
    _avg?: landAvgOrderByAggregateInput
    _max?: landMaxOrderByAggregateInput
    _min?: landMinOrderByAggregateInput
    _sum?: landSumOrderByAggregateInput
  }

  export type landScalarWhereWithAggregatesInput = {
    AND?: landScalarWhereWithAggregatesInput | landScalarWhereWithAggregatesInput[]
    OR?: landScalarWhereWithAggregatesInput[]
    NOT?: landScalarWhereWithAggregatesInput | landScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"land"> | number
    createdAt?: DateTimeWithAggregatesFilter<"land"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"land"> | Date | string | null
    status?: StringWithAggregatesFilter<"land"> | string
  }

  export type capacityWhereInput = {
    AND?: capacityWhereInput | capacityWhereInput[]
    OR?: capacityWhereInput[]
    NOT?: capacityWhereInput | capacityWhereInput[]
    id?: IntFilter<"capacity"> | number
    createdAt?: DateTimeFilter<"capacity"> | Date | string
    updatedAt?: DateTimeNullableFilter<"capacity"> | Date | string | null
    status?: StringFilter<"capacity"> | string
    capacityInfos?: Capacity_infoListRelationFilter
    skillObtations?: Skill_obtationListRelationFilter
  }

  export type capacityOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    capacityInfos?: capacity_infoOrderByRelationAggregateInput
    skillObtations?: skill_obtationOrderByRelationAggregateInput
    _relevance?: capacityOrderByRelevanceInput
  }

  export type capacityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: capacityWhereInput | capacityWhereInput[]
    OR?: capacityWhereInput[]
    NOT?: capacityWhereInput | capacityWhereInput[]
    createdAt?: DateTimeFilter<"capacity"> | Date | string
    updatedAt?: DateTimeNullableFilter<"capacity"> | Date | string | null
    status?: StringFilter<"capacity"> | string
    capacityInfos?: Capacity_infoListRelationFilter
    skillObtations?: Skill_obtationListRelationFilter
  }, "id">

  export type capacityOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: capacityCountOrderByAggregateInput
    _avg?: capacityAvgOrderByAggregateInput
    _max?: capacityMaxOrderByAggregateInput
    _min?: capacityMinOrderByAggregateInput
    _sum?: capacitySumOrderByAggregateInput
  }

  export type capacityScalarWhereWithAggregatesInput = {
    AND?: capacityScalarWhereWithAggregatesInput | capacityScalarWhereWithAggregatesInput[]
    OR?: capacityScalarWhereWithAggregatesInput[]
    NOT?: capacityScalarWhereWithAggregatesInput | capacityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"capacity"> | number
    createdAt?: DateTimeWithAggregatesFilter<"capacity"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"capacity"> | Date | string | null
    status?: StringWithAggregatesFilter<"capacity"> | string
  }

  export type capacity_effectWhereInput = {
    AND?: capacity_effectWhereInput | capacity_effectWhereInput[]
    OR?: capacity_effectWhereInput[]
    NOT?: capacity_effectWhereInput | capacity_effectWhereInput[]
    id?: IntFilter<"capacity_effect"> | number
    zEffect?: BoolFilter<"capacity_effect"> | boolean
    createdAt?: DateTimeFilter<"capacity_effect"> | Date | string
    updatedAt?: DateTimeNullableFilter<"capacity_effect"> | Date | string | null
    status?: StringFilter<"capacity_effect"> | string
    capacityInfos?: Capacity_infoListRelationFilter
    capacityZInfos?: Capacity_infoListRelationFilter
  }

  export type capacity_effectOrderByWithRelationInput = {
    id?: SortOrder
    zEffect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    capacityInfos?: capacity_infoOrderByRelationAggregateInput
    capacityZInfos?: capacity_infoOrderByRelationAggregateInput
    _relevance?: capacity_effectOrderByRelevanceInput
  }

  export type capacity_effectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: capacity_effectWhereInput | capacity_effectWhereInput[]
    OR?: capacity_effectWhereInput[]
    NOT?: capacity_effectWhereInput | capacity_effectWhereInput[]
    zEffect?: BoolFilter<"capacity_effect"> | boolean
    createdAt?: DateTimeFilter<"capacity_effect"> | Date | string
    updatedAt?: DateTimeNullableFilter<"capacity_effect"> | Date | string | null
    status?: StringFilter<"capacity_effect"> | string
    capacityInfos?: Capacity_infoListRelationFilter
    capacityZInfos?: Capacity_infoListRelationFilter
  }, "id">

  export type capacity_effectOrderByWithAggregationInput = {
    id?: SortOrder
    zEffect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: capacity_effectCountOrderByAggregateInput
    _avg?: capacity_effectAvgOrderByAggregateInput
    _max?: capacity_effectMaxOrderByAggregateInput
    _min?: capacity_effectMinOrderByAggregateInput
    _sum?: capacity_effectSumOrderByAggregateInput
  }

  export type capacity_effectScalarWhereWithAggregatesInput = {
    AND?: capacity_effectScalarWhereWithAggregatesInput | capacity_effectScalarWhereWithAggregatesInput[]
    OR?: capacity_effectScalarWhereWithAggregatesInput[]
    NOT?: capacity_effectScalarWhereWithAggregatesInput | capacity_effectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"capacity_effect"> | number
    zEffect?: BoolWithAggregatesFilter<"capacity_effect"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"capacity_effect"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"capacity_effect"> | Date | string | null
    status?: StringWithAggregatesFilter<"capacity_effect"> | string
  }

  export type capacity_categoryWhereInput = {
    AND?: capacity_categoryWhereInput | capacity_categoryWhereInput[]
    OR?: capacity_categoryWhereInput[]
    NOT?: capacity_categoryWhereInput | capacity_categoryWhereInput[]
    id?: IntFilter<"capacity_category"> | number
    createdAt?: DateTimeFilter<"capacity_category"> | Date | string
    updatedAt?: DateTimeNullableFilter<"capacity_category"> | Date | string | null
    status?: StringFilter<"capacity_category"> | string
    capacityInfos?: Capacity_infoListRelationFilter
  }

  export type capacity_categoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    capacityInfos?: capacity_infoOrderByRelationAggregateInput
    _relevance?: capacity_categoryOrderByRelevanceInput
  }

  export type capacity_categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: capacity_categoryWhereInput | capacity_categoryWhereInput[]
    OR?: capacity_categoryWhereInput[]
    NOT?: capacity_categoryWhereInput | capacity_categoryWhereInput[]
    createdAt?: DateTimeFilter<"capacity_category"> | Date | string
    updatedAt?: DateTimeNullableFilter<"capacity_category"> | Date | string | null
    status?: StringFilter<"capacity_category"> | string
    capacityInfos?: Capacity_infoListRelationFilter
  }, "id">

  export type capacity_categoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: capacity_categoryCountOrderByAggregateInput
    _avg?: capacity_categoryAvgOrderByAggregateInput
    _max?: capacity_categoryMaxOrderByAggregateInput
    _min?: capacity_categoryMinOrderByAggregateInput
    _sum?: capacity_categorySumOrderByAggregateInput
  }

  export type capacity_categoryScalarWhereWithAggregatesInput = {
    AND?: capacity_categoryScalarWhereWithAggregatesInput | capacity_categoryScalarWhereWithAggregatesInput[]
    OR?: capacity_categoryScalarWhereWithAggregatesInput[]
    NOT?: capacity_categoryScalarWhereWithAggregatesInput | capacity_categoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"capacity_category"> | number
    createdAt?: DateTimeWithAggregatesFilter<"capacity_category"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"capacity_category"> | Date | string | null
    status?: StringWithAggregatesFilter<"capacity_category"> | string
  }

  export type capsuleWhereInput = {
    AND?: capsuleWhereInput | capsuleWhereInput[]
    OR?: capsuleWhereInput[]
    NOT?: capsuleWhereInput | capsuleWhereInput[]
    id?: IntFilter<"capsule"> | number
    createdAt?: DateTimeFilter<"capsule"> | Date | string
    updatedAt?: DateTimeNullableFilter<"capsule"> | Date | string | null
    status?: StringFilter<"capsule"> | string
    capsule_game_capacity_info?: Capsule_game_capacity_infoListRelationFilter
  }

  export type capsuleOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    capsule_game_capacity_info?: capsule_game_capacity_infoOrderByRelationAggregateInput
    _relevance?: capsuleOrderByRelevanceInput
  }

  export type capsuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: capsuleWhereInput | capsuleWhereInput[]
    OR?: capsuleWhereInput[]
    NOT?: capsuleWhereInput | capsuleWhereInput[]
    createdAt?: DateTimeFilter<"capsule"> | Date | string
    updatedAt?: DateTimeNullableFilter<"capsule"> | Date | string | null
    status?: StringFilter<"capsule"> | string
    capsule_game_capacity_info?: Capsule_game_capacity_infoListRelationFilter
  }, "id">

  export type capsuleOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: capsuleCountOrderByAggregateInput
    _avg?: capsuleAvgOrderByAggregateInput
    _max?: capsuleMaxOrderByAggregateInput
    _min?: capsuleMinOrderByAggregateInput
    _sum?: capsuleSumOrderByAggregateInput
  }

  export type capsuleScalarWhereWithAggregatesInput = {
    AND?: capsuleScalarWhereWithAggregatesInput | capsuleScalarWhereWithAggregatesInput[]
    OR?: capsuleScalarWhereWithAggregatesInput[]
    NOT?: capsuleScalarWhereWithAggregatesInput | capsuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"capsule"> | number
    createdAt?: DateTimeWithAggregatesFilter<"capsule"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"capsule"> | Date | string | null
    status?: StringWithAggregatesFilter<"capsule"> | string
  }

  export type detailWhereInput = {
    AND?: detailWhereInput | detailWhereInput[]
    OR?: detailWhereInput[]
    NOT?: detailWhereInput | detailWhereInput[]
    id?: IntFilter<"detail"> | number
    createdAt?: DateTimeFilter<"detail"> | Date | string
    updatedAt?: DateTimeNullableFilter<"detail"> | Date | string | null
    status?: StringFilter<"detail"> | string
    conditionRates?: RateListRelationFilter
    detailRates?: RateListRelationFilter
  }

  export type detailOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    conditionRates?: rateOrderByRelationAggregateInput
    detailRates?: rateOrderByRelationAggregateInput
    _relevance?: detailOrderByRelevanceInput
  }

  export type detailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: detailWhereInput | detailWhereInput[]
    OR?: detailWhereInput[]
    NOT?: detailWhereInput | detailWhereInput[]
    createdAt?: DateTimeFilter<"detail"> | Date | string
    updatedAt?: DateTimeNullableFilter<"detail"> | Date | string | null
    status?: StringFilter<"detail"> | string
    conditionRates?: RateListRelationFilter
    detailRates?: RateListRelationFilter
  }, "id">

  export type detailOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: detailCountOrderByAggregateInput
    _avg?: detailAvgOrderByAggregateInput
    _max?: detailMaxOrderByAggregateInput
    _min?: detailMinOrderByAggregateInput
    _sum?: detailSumOrderByAggregateInput
  }

  export type detailScalarWhereWithAggregatesInput = {
    AND?: detailScalarWhereWithAggregatesInput | detailScalarWhereWithAggregatesInput[]
    OR?: detailScalarWhereWithAggregatesInput[]
    NOT?: detailScalarWhereWithAggregatesInput | detailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"detail"> | number
    createdAt?: DateTimeWithAggregatesFilter<"detail"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"detail"> | Date | string | null
    status?: StringWithAggregatesFilter<"detail"> | string
  }

  export type effect_outside_fightWhereInput = {
    AND?: effect_outside_fightWhereInput | effect_outside_fightWhereInput[]
    OR?: effect_outside_fightWhereInput[]
    NOT?: effect_outside_fightWhereInput | effect_outside_fightWhereInput[]
    id?: IntFilter<"effect_outside_fight"> | number
    createdAt?: DateTimeFilter<"effect_outside_fight"> | Date | string
    updatedAt?: DateTimeNullableFilter<"effect_outside_fight"> | Date | string | null
    status?: StringFilter<"effect_outside_fight"> | string
    abilityInfos?: Ability_infoListRelationFilter
    capacityInfos?: Capacity_infoListRelationFilter
  }

  export type effect_outside_fightOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    abilityInfos?: ability_infoOrderByRelationAggregateInput
    capacityInfos?: capacity_infoOrderByRelationAggregateInput
    _relevance?: effect_outside_fightOrderByRelevanceInput
  }

  export type effect_outside_fightWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: effect_outside_fightWhereInput | effect_outside_fightWhereInput[]
    OR?: effect_outside_fightWhereInput[]
    NOT?: effect_outside_fightWhereInput | effect_outside_fightWhereInput[]
    createdAt?: DateTimeFilter<"effect_outside_fight"> | Date | string
    updatedAt?: DateTimeNullableFilter<"effect_outside_fight"> | Date | string | null
    status?: StringFilter<"effect_outside_fight"> | string
    abilityInfos?: Ability_infoListRelationFilter
    capacityInfos?: Capacity_infoListRelationFilter
  }, "id">

  export type effect_outside_fightOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: effect_outside_fightCountOrderByAggregateInput
    _avg?: effect_outside_fightAvgOrderByAggregateInput
    _max?: effect_outside_fightMaxOrderByAggregateInput
    _min?: effect_outside_fightMinOrderByAggregateInput
    _sum?: effect_outside_fightSumOrderByAggregateInput
  }

  export type effect_outside_fightScalarWhereWithAggregatesInput = {
    AND?: effect_outside_fightScalarWhereWithAggregatesInput | effect_outside_fightScalarWhereWithAggregatesInput[]
    OR?: effect_outside_fightScalarWhereWithAggregatesInput[]
    NOT?: effect_outside_fightScalarWhereWithAggregatesInput | effect_outside_fightScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"effect_outside_fight"> | number
    createdAt?: DateTimeWithAggregatesFilter<"effect_outside_fight"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"effect_outside_fight"> | Date | string | null
    status?: StringWithAggregatesFilter<"effect_outside_fight"> | string
  }

  export type influenceWhereInput = {
    AND?: influenceWhereInput | influenceWhereInput[]
    OR?: influenceWhereInput[]
    NOT?: influenceWhereInput | influenceWhereInput[]
    id?: IntFilter<"influence"> | number
    createdAt?: DateTimeFilter<"influence"> | Date | string
    updatedAt?: DateTimeNullableFilter<"influence"> | Date | string | null
    status?: StringFilter<"influence"> | string
    capacityInfoInfluences?: Capacity_info_influenceListRelationFilter
  }

  export type influenceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    capacityInfoInfluences?: capacity_info_influenceOrderByRelationAggregateInput
    _relevance?: influenceOrderByRelevanceInput
  }

  export type influenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: influenceWhereInput | influenceWhereInput[]
    OR?: influenceWhereInput[]
    NOT?: influenceWhereInput | influenceWhereInput[]
    createdAt?: DateTimeFilter<"influence"> | Date | string
    updatedAt?: DateTimeNullableFilter<"influence"> | Date | string | null
    status?: StringFilter<"influence"> | string
    capacityInfoInfluences?: Capacity_info_influenceListRelationFilter
  }, "id">

  export type influenceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: influenceCountOrderByAggregateInput
    _avg?: influenceAvgOrderByAggregateInput
    _max?: influenceMaxOrderByAggregateInput
    _min?: influenceMinOrderByAggregateInput
    _sum?: influenceSumOrderByAggregateInput
  }

  export type influenceScalarWhereWithAggregatesInput = {
    AND?: influenceScalarWhereWithAggregatesInput | influenceScalarWhereWithAggregatesInput[]
    OR?: influenceScalarWhereWithAggregatesInput[]
    NOT?: influenceScalarWhereWithAggregatesInput | influenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"influence"> | number
    createdAt?: DateTimeWithAggregatesFilter<"influence"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"influence"> | Date | string | null
    status?: StringWithAggregatesFilter<"influence"> | string
  }

  export type locationWhereInput = {
    AND?: locationWhereInput | locationWhereInput[]
    OR?: locationWhereInput[]
    NOT?: locationWhereInput | locationWhereInput[]
    id?: IntFilter<"location"> | number
    createdAt?: DateTimeFilter<"location"> | Date | string
    updatedAt?: DateTimeNullableFilter<"location"> | Date | string | null
    status?: StringFilter<"location"> | string
    locationZones?: Location_zoneListRelationFilter
  }

  export type locationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    locationZones?: location_zoneOrderByRelationAggregateInput
    _relevance?: locationOrderByRelevanceInput
  }

  export type locationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: locationWhereInput | locationWhereInput[]
    OR?: locationWhereInput[]
    NOT?: locationWhereInput | locationWhereInput[]
    createdAt?: DateTimeFilter<"location"> | Date | string
    updatedAt?: DateTimeNullableFilter<"location"> | Date | string | null
    status?: StringFilter<"location"> | string
    locationZones?: Location_zoneListRelationFilter
  }, "id">

  export type locationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: locationCountOrderByAggregateInput
    _avg?: locationAvgOrderByAggregateInput
    _max?: locationMaxOrderByAggregateInput
    _min?: locationMinOrderByAggregateInput
    _sum?: locationSumOrderByAggregateInput
  }

  export type locationScalarWhereWithAggregatesInput = {
    AND?: locationScalarWhereWithAggregatesInput | locationScalarWhereWithAggregatesInput[]
    OR?: locationScalarWhereWithAggregatesInput[]
    NOT?: locationScalarWhereWithAggregatesInput | locationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"location"> | number
    createdAt?: DateTimeWithAggregatesFilter<"location"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"location"> | Date | string | null
    status?: StringWithAggregatesFilter<"location"> | string
  }

  export type zoneWhereInput = {
    AND?: zoneWhereInput | zoneWhereInput[]
    OR?: zoneWhereInput[]
    NOT?: zoneWhereInput | zoneWhereInput[]
    id?: IntFilter<"zone"> | number
    createdAt?: DateTimeFilter<"zone"> | Date | string
    updatedAt?: DateTimeNullableFilter<"zone"> | Date | string | null
    status?: StringFilter<"zone"> | string
    locationZones?: Location_zoneListRelationFilter
  }

  export type zoneOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    locationZones?: location_zoneOrderByRelationAggregateInput
    _relevance?: zoneOrderByRelevanceInput
  }

  export type zoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: zoneWhereInput | zoneWhereInput[]
    OR?: zoneWhereInput[]
    NOT?: zoneWhereInput | zoneWhereInput[]
    createdAt?: DateTimeFilter<"zone"> | Date | string
    updatedAt?: DateTimeNullableFilter<"zone"> | Date | string | null
    status?: StringFilter<"zone"> | string
    locationZones?: Location_zoneListRelationFilter
  }, "id">

  export type zoneOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: zoneCountOrderByAggregateInput
    _avg?: zoneAvgOrderByAggregateInput
    _max?: zoneMaxOrderByAggregateInput
    _min?: zoneMinOrderByAggregateInput
    _sum?: zoneSumOrderByAggregateInput
  }

  export type zoneScalarWhereWithAggregatesInput = {
    AND?: zoneScalarWhereWithAggregatesInput | zoneScalarWhereWithAggregatesInput[]
    OR?: zoneScalarWhereWithAggregatesInput[]
    NOT?: zoneScalarWhereWithAggregatesInput | zoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"zone"> | number
    createdAt?: DateTimeWithAggregatesFilter<"zone"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"zone"> | Date | string | null
    status?: StringWithAggregatesFilter<"zone"> | string
  }

  export type location_zoneWhereInput = {
    AND?: location_zoneWhereInput | location_zoneWhereInput[]
    OR?: location_zoneWhereInput[]
    NOT?: location_zoneWhereInput | location_zoneWhereInput[]
    id?: IntFilter<"location_zone"> | number
    locationId?: IntFilter<"location_zone"> | number
    zoneId?: IntFilter<"location_zone"> | number
    createdAt?: DateTimeFilter<"location_zone"> | Date | string
    updatedAt?: DateTimeNullableFilter<"location_zone"> | Date | string | null
    status?: StringFilter<"location_zone"> | string
    location?: XOR<LocationScalarRelationFilter, locationWhereInput>
    zone?: XOR<ZoneScalarRelationFilter, zoneWhereInput>
    pokemonRatingGames?: Pokemon_game_locationListRelationFilter
  }

  export type location_zoneOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    location?: locationOrderByWithRelationInput
    zone?: zoneOrderByWithRelationInput
    pokemonRatingGames?: pokemon_game_locationOrderByRelationAggregateInput
    _relevance?: location_zoneOrderByRelevanceInput
  }

  export type location_zoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    locationId_zoneId?: location_zoneLocationIdZoneIdCompoundUniqueInput
    AND?: location_zoneWhereInput | location_zoneWhereInput[]
    OR?: location_zoneWhereInput[]
    NOT?: location_zoneWhereInput | location_zoneWhereInput[]
    locationId?: IntFilter<"location_zone"> | number
    zoneId?: IntFilter<"location_zone"> | number
    createdAt?: DateTimeFilter<"location_zone"> | Date | string
    updatedAt?: DateTimeNullableFilter<"location_zone"> | Date | string | null
    status?: StringFilter<"location_zone"> | string
    location?: XOR<LocationScalarRelationFilter, locationWhereInput>
    zone?: XOR<ZoneScalarRelationFilter, zoneWhereInput>
    pokemonRatingGames?: Pokemon_game_locationListRelationFilter
  }, "id" | "locationId_zoneId">

  export type location_zoneOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: location_zoneCountOrderByAggregateInput
    _avg?: location_zoneAvgOrderByAggregateInput
    _max?: location_zoneMaxOrderByAggregateInput
    _min?: location_zoneMinOrderByAggregateInput
    _sum?: location_zoneSumOrderByAggregateInput
  }

  export type location_zoneScalarWhereWithAggregatesInput = {
    AND?: location_zoneScalarWhereWithAggregatesInput | location_zoneScalarWhereWithAggregatesInput[]
    OR?: location_zoneScalarWhereWithAggregatesInput[]
    NOT?: location_zoneScalarWhereWithAggregatesInput | location_zoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"location_zone"> | number
    locationId?: IntWithAggregatesFilter<"location_zone"> | number
    zoneId?: IntWithAggregatesFilter<"location_zone"> | number
    createdAt?: DateTimeWithAggregatesFilter<"location_zone"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"location_zone"> | Date | string | null
    status?: StringWithAggregatesFilter<"location_zone"> | string
  }

  export type meteoWhereInput = {
    AND?: meteoWhereInput | meteoWhereInput[]
    OR?: meteoWhereInput[]
    NOT?: meteoWhereInput | meteoWhereInput[]
    id?: IntFilter<"meteo"> | number
    createdAt?: DateTimeFilter<"meteo"> | Date | string
    updatedAt?: DateTimeNullableFilter<"meteo"> | Date | string | null
    status?: StringFilter<"meteo"> | string
    rates?: RateListRelationFilter
  }

  export type meteoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    rates?: rateOrderByRelationAggregateInput
    _relevance?: meteoOrderByRelevanceInput
  }

  export type meteoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: meteoWhereInput | meteoWhereInput[]
    OR?: meteoWhereInput[]
    NOT?: meteoWhereInput | meteoWhereInput[]
    createdAt?: DateTimeFilter<"meteo"> | Date | string
    updatedAt?: DateTimeNullableFilter<"meteo"> | Date | string | null
    status?: StringFilter<"meteo"> | string
    rates?: RateListRelationFilter
  }, "id">

  export type meteoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: meteoCountOrderByAggregateInput
    _avg?: meteoAvgOrderByAggregateInput
    _max?: meteoMaxOrderByAggregateInput
    _min?: meteoMinOrderByAggregateInput
    _sum?: meteoSumOrderByAggregateInput
  }

  export type meteoScalarWhereWithAggregatesInput = {
    AND?: meteoScalarWhereWithAggregatesInput | meteoScalarWhereWithAggregatesInput[]
    OR?: meteoScalarWhereWithAggregatesInput[]
    NOT?: meteoScalarWhereWithAggregatesInput | meteoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"meteo"> | number
    createdAt?: DateTimeWithAggregatesFilter<"meteo"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"meteo"> | Date | string | null
    status?: StringWithAggregatesFilter<"meteo"> | string
  }

  export type pokemon_obtationWhereInput = {
    AND?: pokemon_obtationWhereInput | pokemon_obtationWhereInput[]
    OR?: pokemon_obtationWhereInput[]
    NOT?: pokemon_obtationWhereInput | pokemon_obtationWhereInput[]
    id?: IntFilter<"pokemon_obtation"> | number
    createdAt?: DateTimeFilter<"pokemon_obtation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"pokemon_obtation"> | Date | string | null
    status?: StringFilter<"pokemon_obtation"> | string
    pokemonRatingGames?: Pokemon_game_locationListRelationFilter
  }

  export type pokemon_obtationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    pokemonRatingGames?: pokemon_game_locationOrderByRelationAggregateInput
    _relevance?: pokemon_obtationOrderByRelevanceInput
  }

  export type pokemon_obtationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pokemon_obtationWhereInput | pokemon_obtationWhereInput[]
    OR?: pokemon_obtationWhereInput[]
    NOT?: pokemon_obtationWhereInput | pokemon_obtationWhereInput[]
    createdAt?: DateTimeFilter<"pokemon_obtation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"pokemon_obtation"> | Date | string | null
    status?: StringFilter<"pokemon_obtation"> | string
    pokemonRatingGames?: Pokemon_game_locationListRelationFilter
  }, "id">

  export type pokemon_obtationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: pokemon_obtationCountOrderByAggregateInput
    _avg?: pokemon_obtationAvgOrderByAggregateInput
    _max?: pokemon_obtationMaxOrderByAggregateInput
    _min?: pokemon_obtationMinOrderByAggregateInput
    _sum?: pokemon_obtationSumOrderByAggregateInput
  }

  export type pokemon_obtationScalarWhereWithAggregatesInput = {
    AND?: pokemon_obtationScalarWhereWithAggregatesInput | pokemon_obtationScalarWhereWithAggregatesInput[]
    OR?: pokemon_obtationScalarWhereWithAggregatesInput[]
    NOT?: pokemon_obtationScalarWhereWithAggregatesInput | pokemon_obtationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pokemon_obtation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"pokemon_obtation"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"pokemon_obtation"> | Date | string | null
    status?: StringWithAggregatesFilter<"pokemon_obtation"> | string
  }

  export type rateWhereInput = {
    AND?: rateWhereInput | rateWhereInput[]
    OR?: rateWhereInput[]
    NOT?: rateWhereInput | rateWhereInput[]
    id?: IntFilter<"rate"> | number
    rate?: DecimalFilter<"rate"> | Decimal | DecimalJsLike | number | string
    minLevel?: IntFilter<"rate"> | number
    maxLevel?: IntFilter<"rate"> | number
    limit?: IntNullableFilter<"rate"> | number | null
    meteoId?: IntFilter<"rate"> | number
    detailRateId?: IntFilter<"rate"> | number
    conditionRateId?: IntFilter<"rate"> | number
    createdAt?: DateTimeFilter<"rate"> | Date | string
    updatedAt?: DateTimeNullableFilter<"rate"> | Date | string | null
    status?: StringFilter<"rate"> | string
    isAlpha?: BoolFilter<"rate"> | boolean
    pokemonRatingGames?: Pokemon_game_locationListRelationFilter
    conditionRate?: XOR<DetailScalarRelationFilter, detailWhereInput>
    detailRate?: XOR<DetailScalarRelationFilter, detailWhereInput>
    meteo?: XOR<MeteoScalarRelationFilter, meteoWhereInput>
    shinyHuntingMethodRates?: Shiny_hunting_method_rateListRelationFilter
  }

  export type rateOrderByWithRelationInput = {
    id?: SortOrder
    rate?: SortOrder
    minLevel?: SortOrder
    maxLevel?: SortOrder
    limit?: SortOrderInput | SortOrder
    meteoId?: SortOrder
    detailRateId?: SortOrder
    conditionRateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    isAlpha?: SortOrder
    pokemonRatingGames?: pokemon_game_locationOrderByRelationAggregateInput
    conditionRate?: detailOrderByWithRelationInput
    detailRate?: detailOrderByWithRelationInput
    meteo?: meteoOrderByWithRelationInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateOrderByRelationAggregateInput
    _relevance?: rateOrderByRelevanceInput
  }

  export type rateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: rateWhereInput | rateWhereInput[]
    OR?: rateWhereInput[]
    NOT?: rateWhereInput | rateWhereInput[]
    rate?: DecimalFilter<"rate"> | Decimal | DecimalJsLike | number | string
    minLevel?: IntFilter<"rate"> | number
    maxLevel?: IntFilter<"rate"> | number
    limit?: IntNullableFilter<"rate"> | number | null
    meteoId?: IntFilter<"rate"> | number
    detailRateId?: IntFilter<"rate"> | number
    conditionRateId?: IntFilter<"rate"> | number
    createdAt?: DateTimeFilter<"rate"> | Date | string
    updatedAt?: DateTimeNullableFilter<"rate"> | Date | string | null
    status?: StringFilter<"rate"> | string
    isAlpha?: BoolFilter<"rate"> | boolean
    pokemonRatingGames?: Pokemon_game_locationListRelationFilter
    conditionRate?: XOR<DetailScalarRelationFilter, detailWhereInput>
    detailRate?: XOR<DetailScalarRelationFilter, detailWhereInput>
    meteo?: XOR<MeteoScalarRelationFilter, meteoWhereInput>
    shinyHuntingMethodRates?: Shiny_hunting_method_rateListRelationFilter
  }, "id">

  export type rateOrderByWithAggregationInput = {
    id?: SortOrder
    rate?: SortOrder
    minLevel?: SortOrder
    maxLevel?: SortOrder
    limit?: SortOrderInput | SortOrder
    meteoId?: SortOrder
    detailRateId?: SortOrder
    conditionRateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    isAlpha?: SortOrder
    _count?: rateCountOrderByAggregateInput
    _avg?: rateAvgOrderByAggregateInput
    _max?: rateMaxOrderByAggregateInput
    _min?: rateMinOrderByAggregateInput
    _sum?: rateSumOrderByAggregateInput
  }

  export type rateScalarWhereWithAggregatesInput = {
    AND?: rateScalarWhereWithAggregatesInput | rateScalarWhereWithAggregatesInput[]
    OR?: rateScalarWhereWithAggregatesInput[]
    NOT?: rateScalarWhereWithAggregatesInput | rateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"rate"> | number
    rate?: DecimalWithAggregatesFilter<"rate"> | Decimal | DecimalJsLike | number | string
    minLevel?: IntWithAggregatesFilter<"rate"> | number
    maxLevel?: IntWithAggregatesFilter<"rate"> | number
    limit?: IntNullableWithAggregatesFilter<"rate"> | number | null
    meteoId?: IntWithAggregatesFilter<"rate"> | number
    detailRateId?: IntWithAggregatesFilter<"rate"> | number
    conditionRateId?: IntWithAggregatesFilter<"rate"> | number
    createdAt?: DateTimeWithAggregatesFilter<"rate"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"rate"> | Date | string | null
    status?: StringWithAggregatesFilter<"rate"> | string
    isAlpha?: BoolWithAggregatesFilter<"rate"> | boolean
  }

  export type shiny_hunting_method_gameWhereInput = {
    AND?: shiny_hunting_method_gameWhereInput | shiny_hunting_method_gameWhereInput[]
    OR?: shiny_hunting_method_gameWhereInput[]
    NOT?: shiny_hunting_method_gameWhereInput | shiny_hunting_method_gameWhereInput[]
    shinyHuntingMethodId?: IntFilter<"shiny_hunting_method_game"> | number
    groupGameId?: IntFilter<"shiny_hunting_method_game"> | number
    groupGame?: XOR<Group_gameScalarRelationFilter, group_gameWhereInput>
    shinyHuntingMethod?: XOR<Shiny_hunting_methodScalarRelationFilter, shiny_hunting_methodWhereInput>
  }

  export type shiny_hunting_method_gameOrderByWithRelationInput = {
    shinyHuntingMethodId?: SortOrder
    groupGameId?: SortOrder
    groupGame?: group_gameOrderByWithRelationInput
    shinyHuntingMethod?: shiny_hunting_methodOrderByWithRelationInput
  }

  export type shiny_hunting_method_gameWhereUniqueInput = Prisma.AtLeast<{
    groupGameId_shinyHuntingMethodId?: shiny_hunting_method_gameGroupGameIdShinyHuntingMethodIdCompoundUniqueInput
    AND?: shiny_hunting_method_gameWhereInput | shiny_hunting_method_gameWhereInput[]
    OR?: shiny_hunting_method_gameWhereInput[]
    NOT?: shiny_hunting_method_gameWhereInput | shiny_hunting_method_gameWhereInput[]
    shinyHuntingMethodId?: IntFilter<"shiny_hunting_method_game"> | number
    groupGameId?: IntFilter<"shiny_hunting_method_game"> | number
    groupGame?: XOR<Group_gameScalarRelationFilter, group_gameWhereInput>
    shinyHuntingMethod?: XOR<Shiny_hunting_methodScalarRelationFilter, shiny_hunting_methodWhereInput>
  }, "groupGameId_shinyHuntingMethodId">

  export type shiny_hunting_method_gameOrderByWithAggregationInput = {
    shinyHuntingMethodId?: SortOrder
    groupGameId?: SortOrder
    _count?: shiny_hunting_method_gameCountOrderByAggregateInput
    _avg?: shiny_hunting_method_gameAvgOrderByAggregateInput
    _max?: shiny_hunting_method_gameMaxOrderByAggregateInput
    _min?: shiny_hunting_method_gameMinOrderByAggregateInput
    _sum?: shiny_hunting_method_gameSumOrderByAggregateInput
  }

  export type shiny_hunting_method_gameScalarWhereWithAggregatesInput = {
    AND?: shiny_hunting_method_gameScalarWhereWithAggregatesInput | shiny_hunting_method_gameScalarWhereWithAggregatesInput[]
    OR?: shiny_hunting_method_gameScalarWhereWithAggregatesInput[]
    NOT?: shiny_hunting_method_gameScalarWhereWithAggregatesInput | shiny_hunting_method_gameScalarWhereWithAggregatesInput[]
    shinyHuntingMethodId?: IntWithAggregatesFilter<"shiny_hunting_method_game"> | number
    groupGameId?: IntWithAggregatesFilter<"shiny_hunting_method_game"> | number
  }

  export type shiny_hunting_method_rateWhereInput = {
    AND?: shiny_hunting_method_rateWhereInput | shiny_hunting_method_rateWhereInput[]
    OR?: shiny_hunting_method_rateWhereInput[]
    NOT?: shiny_hunting_method_rateWhereInput | shiny_hunting_method_rateWhereInput[]
    shinyHuntingMethodId?: IntFilter<"shiny_hunting_method_rate"> | number
    rateId?: IntFilter<"shiny_hunting_method_rate"> | number
    rate?: XOR<RateScalarRelationFilter, rateWhereInput>
    shinyHuntingMethod?: XOR<Shiny_hunting_methodScalarRelationFilter, shiny_hunting_methodWhereInput>
  }

  export type shiny_hunting_method_rateOrderByWithRelationInput = {
    shinyHuntingMethodId?: SortOrder
    rateId?: SortOrder
    rate?: rateOrderByWithRelationInput
    shinyHuntingMethod?: shiny_hunting_methodOrderByWithRelationInput
  }

  export type shiny_hunting_method_rateWhereUniqueInput = Prisma.AtLeast<{
    shinyHuntingMethodId_rateId?: shiny_hunting_method_rateShinyHuntingMethodIdRateIdCompoundUniqueInput
    AND?: shiny_hunting_method_rateWhereInput | shiny_hunting_method_rateWhereInput[]
    OR?: shiny_hunting_method_rateWhereInput[]
    NOT?: shiny_hunting_method_rateWhereInput | shiny_hunting_method_rateWhereInput[]
    shinyHuntingMethodId?: IntFilter<"shiny_hunting_method_rate"> | number
    rateId?: IntFilter<"shiny_hunting_method_rate"> | number
    rate?: XOR<RateScalarRelationFilter, rateWhereInput>
    shinyHuntingMethod?: XOR<Shiny_hunting_methodScalarRelationFilter, shiny_hunting_methodWhereInput>
  }, "shinyHuntingMethodId_rateId">

  export type shiny_hunting_method_rateOrderByWithAggregationInput = {
    shinyHuntingMethodId?: SortOrder
    rateId?: SortOrder
    _count?: shiny_hunting_method_rateCountOrderByAggregateInput
    _avg?: shiny_hunting_method_rateAvgOrderByAggregateInput
    _max?: shiny_hunting_method_rateMaxOrderByAggregateInput
    _min?: shiny_hunting_method_rateMinOrderByAggregateInput
    _sum?: shiny_hunting_method_rateSumOrderByAggregateInput
  }

  export type shiny_hunting_method_rateScalarWhereWithAggregatesInput = {
    AND?: shiny_hunting_method_rateScalarWhereWithAggregatesInput | shiny_hunting_method_rateScalarWhereWithAggregatesInput[]
    OR?: shiny_hunting_method_rateScalarWhereWithAggregatesInput[]
    NOT?: shiny_hunting_method_rateScalarWhereWithAggregatesInput | shiny_hunting_method_rateScalarWhereWithAggregatesInput[]
    shinyHuntingMethodId?: IntWithAggregatesFilter<"shiny_hunting_method_rate"> | number
    rateId?: IntWithAggregatesFilter<"shiny_hunting_method_rate"> | number
  }

  export type skill_obtation_typeWhereInput = {
    AND?: skill_obtation_typeWhereInput | skill_obtation_typeWhereInput[]
    OR?: skill_obtation_typeWhereInput[]
    NOT?: skill_obtation_typeWhereInput | skill_obtation_typeWhereInput[]
    id?: IntFilter<"skill_obtation_type"> | number
    createdAt?: DateTimeFilter<"skill_obtation_type"> | Date | string
    updatedAt?: DateTimeNullableFilter<"skill_obtation_type"> | Date | string | null
    status?: StringFilter<"skill_obtation_type"> | string
    skillObtations?: Skill_obtationListRelationFilter
  }

  export type skill_obtation_typeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    skillObtations?: skill_obtationOrderByRelationAggregateInput
    _relevance?: skill_obtation_typeOrderByRelevanceInput
  }

  export type skill_obtation_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: skill_obtation_typeWhereInput | skill_obtation_typeWhereInput[]
    OR?: skill_obtation_typeWhereInput[]
    NOT?: skill_obtation_typeWhereInput | skill_obtation_typeWhereInput[]
    createdAt?: DateTimeFilter<"skill_obtation_type"> | Date | string
    updatedAt?: DateTimeNullableFilter<"skill_obtation_type"> | Date | string | null
    status?: StringFilter<"skill_obtation_type"> | string
    skillObtations?: Skill_obtationListRelationFilter
  }, "id">

  export type skill_obtation_typeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: skill_obtation_typeCountOrderByAggregateInput
    _avg?: skill_obtation_typeAvgOrderByAggregateInput
    _max?: skill_obtation_typeMaxOrderByAggregateInput
    _min?: skill_obtation_typeMinOrderByAggregateInput
    _sum?: skill_obtation_typeSumOrderByAggregateInput
  }

  export type skill_obtation_typeScalarWhereWithAggregatesInput = {
    AND?: skill_obtation_typeScalarWhereWithAggregatesInput | skill_obtation_typeScalarWhereWithAggregatesInput[]
    OR?: skill_obtation_typeScalarWhereWithAggregatesInput[]
    NOT?: skill_obtation_typeScalarWhereWithAggregatesInput | skill_obtation_typeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"skill_obtation_type"> | number
    createdAt?: DateTimeWithAggregatesFilter<"skill_obtation_type"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"skill_obtation_type"> | Date | string | null
    status?: StringWithAggregatesFilter<"skill_obtation_type"> | string
  }

  export type statisticWhereInput = {
    AND?: statisticWhereInput | statisticWhereInput[]
    OR?: statisticWhereInput[]
    NOT?: statisticWhereInput | statisticWhereInput[]
    id?: IntFilter<"statistic"> | number
    pv?: IntFilter<"statistic"> | number
    attack?: IntFilter<"statistic"> | number
    defense?: IntFilter<"statistic"> | number
    specialAttack?: IntNullableFilter<"statistic"> | number | null
    specialDefense?: IntNullableFilter<"statistic"> | number | null
    special?: IntNullableFilter<"statistic"> | number | null
    speed?: IntFilter<"statistic"> | number
    createdAt?: DateTimeFilter<"statistic"> | Date | string
    updatedAt?: DateTimeNullableFilter<"statistic"> | Date | string | null
    status?: StringFilter<"statistic"> | string
    statisticGroupGames?: Statistic_group_gameListRelationFilter
  }

  export type statisticOrderByWithRelationInput = {
    id?: SortOrder
    pv?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    specialAttack?: SortOrderInput | SortOrder
    specialDefense?: SortOrderInput | SortOrder
    special?: SortOrderInput | SortOrder
    speed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    statisticGroupGames?: statistic_group_gameOrderByRelationAggregateInput
    _relevance?: statisticOrderByRelevanceInput
  }

  export type statisticWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: statisticWhereInput | statisticWhereInput[]
    OR?: statisticWhereInput[]
    NOT?: statisticWhereInput | statisticWhereInput[]
    pv?: IntFilter<"statistic"> | number
    attack?: IntFilter<"statistic"> | number
    defense?: IntFilter<"statistic"> | number
    specialAttack?: IntNullableFilter<"statistic"> | number | null
    specialDefense?: IntNullableFilter<"statistic"> | number | null
    special?: IntNullableFilter<"statistic"> | number | null
    speed?: IntFilter<"statistic"> | number
    createdAt?: DateTimeFilter<"statistic"> | Date | string
    updatedAt?: DateTimeNullableFilter<"statistic"> | Date | string | null
    status?: StringFilter<"statistic"> | string
    statisticGroupGames?: Statistic_group_gameListRelationFilter
  }, "id">

  export type statisticOrderByWithAggregationInput = {
    id?: SortOrder
    pv?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    specialAttack?: SortOrderInput | SortOrder
    specialDefense?: SortOrderInput | SortOrder
    special?: SortOrderInput | SortOrder
    speed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: statisticCountOrderByAggregateInput
    _avg?: statisticAvgOrderByAggregateInput
    _max?: statisticMaxOrderByAggregateInput
    _min?: statisticMinOrderByAggregateInput
    _sum?: statisticSumOrderByAggregateInput
  }

  export type statisticScalarWhereWithAggregatesInput = {
    AND?: statisticScalarWhereWithAggregatesInput | statisticScalarWhereWithAggregatesInput[]
    OR?: statisticScalarWhereWithAggregatesInput[]
    NOT?: statisticScalarWhereWithAggregatesInput | statisticScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"statistic"> | number
    pv?: IntWithAggregatesFilter<"statistic"> | number
    attack?: IntWithAggregatesFilter<"statistic"> | number
    defense?: IntWithAggregatesFilter<"statistic"> | number
    specialAttack?: IntNullableWithAggregatesFilter<"statistic"> | number | null
    specialDefense?: IntNullableWithAggregatesFilter<"statistic"> | number | null
    special?: IntNullableWithAggregatesFilter<"statistic"> | number | null
    speed?: IntWithAggregatesFilter<"statistic"> | number
    createdAt?: DateTimeWithAggregatesFilter<"statistic"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"statistic"> | Date | string | null
    status?: StringWithAggregatesFilter<"statistic"> | string
  }

  export type statistic_group_gameWhereInput = {
    AND?: statistic_group_gameWhereInput | statistic_group_gameWhereInput[]
    OR?: statistic_group_gameWhereInput[]
    NOT?: statistic_group_gameWhereInput | statistic_group_gameWhereInput[]
    groupGameId?: IntFilter<"statistic_group_game"> | number
    pokemonId?: IntFilter<"statistic_group_game"> | number
    statisticId?: IntFilter<"statistic_group_game"> | number
    groupGame?: XOR<Group_gameScalarRelationFilter, group_gameWhereInput>
    pokemon?: XOR<PokemonScalarRelationFilter, pokemonWhereInput>
    statistic?: XOR<StatisticScalarRelationFilter, statisticWhereInput>
  }

  export type statistic_group_gameOrderByWithRelationInput = {
    groupGameId?: SortOrder
    pokemonId?: SortOrder
    statisticId?: SortOrder
    groupGame?: group_gameOrderByWithRelationInput
    pokemon?: pokemonOrderByWithRelationInput
    statistic?: statisticOrderByWithRelationInput
  }

  export type statistic_group_gameWhereUniqueInput = Prisma.AtLeast<{
    pokemonId_groupGameId?: statistic_group_gamePokemonIdGroupGameIdCompoundUniqueInput
    AND?: statistic_group_gameWhereInput | statistic_group_gameWhereInput[]
    OR?: statistic_group_gameWhereInput[]
    NOT?: statistic_group_gameWhereInput | statistic_group_gameWhereInput[]
    groupGameId?: IntFilter<"statistic_group_game"> | number
    pokemonId?: IntFilter<"statistic_group_game"> | number
    statisticId?: IntFilter<"statistic_group_game"> | number
    groupGame?: XOR<Group_gameScalarRelationFilter, group_gameWhereInput>
    pokemon?: XOR<PokemonScalarRelationFilter, pokemonWhereInput>
    statistic?: XOR<StatisticScalarRelationFilter, statisticWhereInput>
  }, "pokemonId_groupGameId">

  export type statistic_group_gameOrderByWithAggregationInput = {
    groupGameId?: SortOrder
    pokemonId?: SortOrder
    statisticId?: SortOrder
    _count?: statistic_group_gameCountOrderByAggregateInput
    _avg?: statistic_group_gameAvgOrderByAggregateInput
    _max?: statistic_group_gameMaxOrderByAggregateInput
    _min?: statistic_group_gameMinOrderByAggregateInput
    _sum?: statistic_group_gameSumOrderByAggregateInput
  }

  export type statistic_group_gameScalarWhereWithAggregatesInput = {
    AND?: statistic_group_gameScalarWhereWithAggregatesInput | statistic_group_gameScalarWhereWithAggregatesInput[]
    OR?: statistic_group_gameScalarWhereWithAggregatesInput[]
    NOT?: statistic_group_gameScalarWhereWithAggregatesInput | statistic_group_gameScalarWhereWithAggregatesInput[]
    groupGameId?: IntWithAggregatesFilter<"statistic_group_game"> | number
    pokemonId?: IntWithAggregatesFilter<"statistic_group_game"> | number
    statisticId?: IntWithAggregatesFilter<"statistic_group_game"> | number
  }

  export type targetWhereInput = {
    AND?: targetWhereInput | targetWhereInput[]
    OR?: targetWhereInput[]
    NOT?: targetWhereInput | targetWhereInput[]
    id?: IntFilter<"target"> | number
    isMultiple?: BoolFilter<"target"> | boolean
    createdAt?: DateTimeFilter<"target"> | Date | string
    updatedAt?: DateTimeNullableFilter<"target"> | Date | string | null
    status?: StringFilter<"target"> | string
    capacityInfos?: Capacity_infoListRelationFilter
  }

  export type targetOrderByWithRelationInput = {
    id?: SortOrder
    isMultiple?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    capacityInfos?: capacity_infoOrderByRelationAggregateInput
    _relevance?: targetOrderByRelevanceInput
  }

  export type targetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: targetWhereInput | targetWhereInput[]
    OR?: targetWhereInput[]
    NOT?: targetWhereInput | targetWhereInput[]
    isMultiple?: BoolFilter<"target"> | boolean
    createdAt?: DateTimeFilter<"target"> | Date | string
    updatedAt?: DateTimeNullableFilter<"target"> | Date | string | null
    status?: StringFilter<"target"> | string
    capacityInfos?: Capacity_infoListRelationFilter
  }, "id">

  export type targetOrderByWithAggregationInput = {
    id?: SortOrder
    isMultiple?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: targetCountOrderByAggregateInput
    _avg?: targetAvgOrderByAggregateInput
    _max?: targetMaxOrderByAggregateInput
    _min?: targetMinOrderByAggregateInput
    _sum?: targetSumOrderByAggregateInput
  }

  export type targetScalarWhereWithAggregatesInput = {
    AND?: targetScalarWhereWithAggregatesInput | targetScalarWhereWithAggregatesInput[]
    OR?: targetScalarWhereWithAggregatesInput[]
    NOT?: targetScalarWhereWithAggregatesInput | targetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"target"> | number
    isMultiple?: BoolWithAggregatesFilter<"target"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"target"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"target"> | Date | string | null
    status?: StringWithAggregatesFilter<"target"> | string
  }

  export type capacity_infoWhereInput = {
    AND?: capacity_infoWhereInput | capacity_infoWhereInput[]
    OR?: capacity_infoWhereInput[]
    NOT?: capacity_infoWhereInput | capacity_infoWhereInput[]
    id?: IntFilter<"capacity_info"> | number
    power?: IntFilter<"capacity_info"> | number
    dynamaxPower?: IntFilter<"capacity_info"> | number
    precision?: IntFilter<"capacity_info"> | number
    pp?: IntFilter<"capacity_info"> | number
    hasBacklash?: BoolFilter<"capacity_info"> | boolean
    targetId?: IntFilter<"capacity_info"> | number
    capacityEffectId?: IntFilter<"capacity_info"> | number
    capacityId?: IntFilter<"capacity_info"> | number
    capacityEffectZId?: IntFilter<"capacity_info"> | number
    typeId?: IntFilter<"capacity_info"> | number
    effectOutsideFightId?: IntFilter<"capacity_info"> | number
    capacityCategoryId?: IntFilter<"capacity_info"> | number
    createdAt?: DateTimeFilter<"capacity_info"> | Date | string
    updatedAt?: DateTimeNullableFilter<"capacity_info"> | Date | string | null
    status?: StringFilter<"capacity_info"> | string
    capacityCategory?: XOR<Capacity_categoryScalarRelationFilter, capacity_categoryWhereInput>
    capacityEffect?: XOR<Capacity_effectScalarRelationFilter, capacity_effectWhereInput>
    capacityEffectZ?: XOR<Capacity_effectScalarRelationFilter, capacity_effectWhereInput>
    capacity?: XOR<CapacityScalarRelationFilter, capacityWhereInput>
    effectOutsideFight?: XOR<Effect_outside_fightScalarRelationFilter, effect_outside_fightWhereInput>
    target?: XOR<TargetScalarRelationFilter, targetWhereInput>
    type?: XOR<TypeScalarRelationFilter, typeWhereInput>
    capacityInfoInfluences?: Capacity_info_influenceListRelationFilter
    capsuleGameCapacityInfos?: Capsule_game_capacity_infoListRelationFilter
  }

  export type capacity_infoOrderByWithRelationInput = {
    id?: SortOrder
    power?: SortOrder
    dynamaxPower?: SortOrder
    precision?: SortOrder
    pp?: SortOrder
    hasBacklash?: SortOrder
    targetId?: SortOrder
    capacityEffectId?: SortOrder
    capacityId?: SortOrder
    capacityEffectZId?: SortOrder
    typeId?: SortOrder
    effectOutsideFightId?: SortOrder
    capacityCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    capacityCategory?: capacity_categoryOrderByWithRelationInput
    capacityEffect?: capacity_effectOrderByWithRelationInput
    capacityEffectZ?: capacity_effectOrderByWithRelationInput
    capacity?: capacityOrderByWithRelationInput
    effectOutsideFight?: effect_outside_fightOrderByWithRelationInput
    target?: targetOrderByWithRelationInput
    type?: typeOrderByWithRelationInput
    capacityInfoInfluences?: capacity_info_influenceOrderByRelationAggregateInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoOrderByRelationAggregateInput
    _relevance?: capacity_infoOrderByRelevanceInput
  }

  export type capacity_infoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: capacity_infoWhereInput | capacity_infoWhereInput[]
    OR?: capacity_infoWhereInput[]
    NOT?: capacity_infoWhereInput | capacity_infoWhereInput[]
    power?: IntFilter<"capacity_info"> | number
    dynamaxPower?: IntFilter<"capacity_info"> | number
    precision?: IntFilter<"capacity_info"> | number
    pp?: IntFilter<"capacity_info"> | number
    hasBacklash?: BoolFilter<"capacity_info"> | boolean
    targetId?: IntFilter<"capacity_info"> | number
    capacityEffectId?: IntFilter<"capacity_info"> | number
    capacityId?: IntFilter<"capacity_info"> | number
    capacityEffectZId?: IntFilter<"capacity_info"> | number
    typeId?: IntFilter<"capacity_info"> | number
    effectOutsideFightId?: IntFilter<"capacity_info"> | number
    capacityCategoryId?: IntFilter<"capacity_info"> | number
    createdAt?: DateTimeFilter<"capacity_info"> | Date | string
    updatedAt?: DateTimeNullableFilter<"capacity_info"> | Date | string | null
    status?: StringFilter<"capacity_info"> | string
    capacityCategory?: XOR<Capacity_categoryScalarRelationFilter, capacity_categoryWhereInput>
    capacityEffect?: XOR<Capacity_effectScalarRelationFilter, capacity_effectWhereInput>
    capacityEffectZ?: XOR<Capacity_effectScalarRelationFilter, capacity_effectWhereInput>
    capacity?: XOR<CapacityScalarRelationFilter, capacityWhereInput>
    effectOutsideFight?: XOR<Effect_outside_fightScalarRelationFilter, effect_outside_fightWhereInput>
    target?: XOR<TargetScalarRelationFilter, targetWhereInput>
    type?: XOR<TypeScalarRelationFilter, typeWhereInput>
    capacityInfoInfluences?: Capacity_info_influenceListRelationFilter
    capsuleGameCapacityInfos?: Capsule_game_capacity_infoListRelationFilter
  }, "id">

  export type capacity_infoOrderByWithAggregationInput = {
    id?: SortOrder
    power?: SortOrder
    dynamaxPower?: SortOrder
    precision?: SortOrder
    pp?: SortOrder
    hasBacklash?: SortOrder
    targetId?: SortOrder
    capacityEffectId?: SortOrder
    capacityId?: SortOrder
    capacityEffectZId?: SortOrder
    typeId?: SortOrder
    effectOutsideFightId?: SortOrder
    capacityCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: capacity_infoCountOrderByAggregateInput
    _avg?: capacity_infoAvgOrderByAggregateInput
    _max?: capacity_infoMaxOrderByAggregateInput
    _min?: capacity_infoMinOrderByAggregateInput
    _sum?: capacity_infoSumOrderByAggregateInput
  }

  export type capacity_infoScalarWhereWithAggregatesInput = {
    AND?: capacity_infoScalarWhereWithAggregatesInput | capacity_infoScalarWhereWithAggregatesInput[]
    OR?: capacity_infoScalarWhereWithAggregatesInput[]
    NOT?: capacity_infoScalarWhereWithAggregatesInput | capacity_infoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"capacity_info"> | number
    power?: IntWithAggregatesFilter<"capacity_info"> | number
    dynamaxPower?: IntWithAggregatesFilter<"capacity_info"> | number
    precision?: IntWithAggregatesFilter<"capacity_info"> | number
    pp?: IntWithAggregatesFilter<"capacity_info"> | number
    hasBacklash?: BoolWithAggregatesFilter<"capacity_info"> | boolean
    targetId?: IntWithAggregatesFilter<"capacity_info"> | number
    capacityEffectId?: IntWithAggregatesFilter<"capacity_info"> | number
    capacityId?: IntWithAggregatesFilter<"capacity_info"> | number
    capacityEffectZId?: IntWithAggregatesFilter<"capacity_info"> | number
    typeId?: IntWithAggregatesFilter<"capacity_info"> | number
    effectOutsideFightId?: IntWithAggregatesFilter<"capacity_info"> | number
    capacityCategoryId?: IntWithAggregatesFilter<"capacity_info"> | number
    createdAt?: DateTimeWithAggregatesFilter<"capacity_info"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"capacity_info"> | Date | string | null
    status?: StringWithAggregatesFilter<"capacity_info"> | string
  }

  export type capacity_info_influenceWhereInput = {
    AND?: capacity_info_influenceWhereInput | capacity_info_influenceWhereInput[]
    OR?: capacity_info_influenceWhereInput[]
    NOT?: capacity_info_influenceWhereInput | capacity_info_influenceWhereInput[]
    capacityInfoId?: IntFilter<"capacity_info_influence"> | number
    influenceId?: IntFilter<"capacity_info_influence"> | number
    capacityInfo?: XOR<Capacity_infoScalarRelationFilter, capacity_infoWhereInput>
    influence?: XOR<InfluenceScalarRelationFilter, influenceWhereInput>
  }

  export type capacity_info_influenceOrderByWithRelationInput = {
    capacityInfoId?: SortOrder
    influenceId?: SortOrder
    capacityInfo?: capacity_infoOrderByWithRelationInput
    influence?: influenceOrderByWithRelationInput
  }

  export type capacity_info_influenceWhereUniqueInput = Prisma.AtLeast<{
    capacityInfoId_influenceId?: capacity_info_influenceCapacityInfoIdInfluenceIdCompoundUniqueInput
    AND?: capacity_info_influenceWhereInput | capacity_info_influenceWhereInput[]
    OR?: capacity_info_influenceWhereInput[]
    NOT?: capacity_info_influenceWhereInput | capacity_info_influenceWhereInput[]
    capacityInfoId?: IntFilter<"capacity_info_influence"> | number
    influenceId?: IntFilter<"capacity_info_influence"> | number
    capacityInfo?: XOR<Capacity_infoScalarRelationFilter, capacity_infoWhereInput>
    influence?: XOR<InfluenceScalarRelationFilter, influenceWhereInput>
  }, "capacityInfoId_influenceId">

  export type capacity_info_influenceOrderByWithAggregationInput = {
    capacityInfoId?: SortOrder
    influenceId?: SortOrder
    _count?: capacity_info_influenceCountOrderByAggregateInput
    _avg?: capacity_info_influenceAvgOrderByAggregateInput
    _max?: capacity_info_influenceMaxOrderByAggregateInput
    _min?: capacity_info_influenceMinOrderByAggregateInput
    _sum?: capacity_info_influenceSumOrderByAggregateInput
  }

  export type capacity_info_influenceScalarWhereWithAggregatesInput = {
    AND?: capacity_info_influenceScalarWhereWithAggregatesInput | capacity_info_influenceScalarWhereWithAggregatesInput[]
    OR?: capacity_info_influenceScalarWhereWithAggregatesInput[]
    NOT?: capacity_info_influenceScalarWhereWithAggregatesInput | capacity_info_influenceScalarWhereWithAggregatesInput[]
    capacityInfoId?: IntWithAggregatesFilter<"capacity_info_influence"> | number
    influenceId?: IntWithAggregatesFilter<"capacity_info_influence"> | number
  }

  export type pokemon_game_locationWhereInput = {
    AND?: pokemon_game_locationWhereInput | pokemon_game_locationWhereInput[]
    OR?: pokemon_game_locationWhereInput[]
    NOT?: pokemon_game_locationWhereInput | pokemon_game_locationWhereInput[]
    gameId?: IntFilter<"pokemon_game_location"> | number
    rateId?: IntFilter<"pokemon_game_location"> | number
    locationZoneId?: IntFilter<"pokemon_game_location"> | number
    pokemonObtationId?: IntFilter<"pokemon_game_location"> | number
    pokemonFormId?: IntFilter<"pokemon_game_location"> | number
    id?: IntFilter<"pokemon_game_location"> | number
    game?: XOR<GameScalarRelationFilter, gameWhereInput>
    locationZone?: XOR<Location_zoneScalarRelationFilter, location_zoneWhereInput>
    pokemonForm?: XOR<Pokemon_formScalarRelationFilter, pokemon_formWhereInput>
    pokemonObtation?: XOR<Pokemon_obtationScalarRelationFilter, pokemon_obtationWhereInput>
    rate?: XOR<RateScalarRelationFilter, rateWhereInput>
  }

  export type pokemon_game_locationOrderByWithRelationInput = {
    gameId?: SortOrder
    rateId?: SortOrder
    locationZoneId?: SortOrder
    pokemonObtationId?: SortOrder
    pokemonFormId?: SortOrder
    id?: SortOrder
    game?: gameOrderByWithRelationInput
    locationZone?: location_zoneOrderByWithRelationInput
    pokemonForm?: pokemon_formOrderByWithRelationInput
    pokemonObtation?: pokemon_obtationOrderByWithRelationInput
    rate?: rateOrderByWithRelationInput
  }

  export type pokemon_game_locationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    gameId_rateId_locationZoneId_pokemonFormId_pokemonObtationId?: pokemon_game_locationGameIdRateIdLocationZoneIdPokemonFormIdPokemonObtationIdCompoundUniqueInput
    AND?: pokemon_game_locationWhereInput | pokemon_game_locationWhereInput[]
    OR?: pokemon_game_locationWhereInput[]
    NOT?: pokemon_game_locationWhereInput | pokemon_game_locationWhereInput[]
    gameId?: IntFilter<"pokemon_game_location"> | number
    rateId?: IntFilter<"pokemon_game_location"> | number
    locationZoneId?: IntFilter<"pokemon_game_location"> | number
    pokemonObtationId?: IntFilter<"pokemon_game_location"> | number
    pokemonFormId?: IntFilter<"pokemon_game_location"> | number
    game?: XOR<GameScalarRelationFilter, gameWhereInput>
    locationZone?: XOR<Location_zoneScalarRelationFilter, location_zoneWhereInput>
    pokemonForm?: XOR<Pokemon_formScalarRelationFilter, pokemon_formWhereInput>
    pokemonObtation?: XOR<Pokemon_obtationScalarRelationFilter, pokemon_obtationWhereInput>
    rate?: XOR<RateScalarRelationFilter, rateWhereInput>
  }, "id" | "gameId_rateId_locationZoneId_pokemonFormId_pokemonObtationId">

  export type pokemon_game_locationOrderByWithAggregationInput = {
    gameId?: SortOrder
    rateId?: SortOrder
    locationZoneId?: SortOrder
    pokemonObtationId?: SortOrder
    pokemonFormId?: SortOrder
    id?: SortOrder
    _count?: pokemon_game_locationCountOrderByAggregateInput
    _avg?: pokemon_game_locationAvgOrderByAggregateInput
    _max?: pokemon_game_locationMaxOrderByAggregateInput
    _min?: pokemon_game_locationMinOrderByAggregateInput
    _sum?: pokemon_game_locationSumOrderByAggregateInput
  }

  export type pokemon_game_locationScalarWhereWithAggregatesInput = {
    AND?: pokemon_game_locationScalarWhereWithAggregatesInput | pokemon_game_locationScalarWhereWithAggregatesInput[]
    OR?: pokemon_game_locationScalarWhereWithAggregatesInput[]
    NOT?: pokemon_game_locationScalarWhereWithAggregatesInput | pokemon_game_locationScalarWhereWithAggregatesInput[]
    gameId?: IntWithAggregatesFilter<"pokemon_game_location"> | number
    rateId?: IntWithAggregatesFilter<"pokemon_game_location"> | number
    locationZoneId?: IntWithAggregatesFilter<"pokemon_game_location"> | number
    pokemonObtationId?: IntWithAggregatesFilter<"pokemon_game_location"> | number
    pokemonFormId?: IntWithAggregatesFilter<"pokemon_game_location"> | number
    id?: IntWithAggregatesFilter<"pokemon_game_location"> | number
  }

  export type skill_obtationWhereInput = {
    AND?: skill_obtationWhereInput | skill_obtationWhereInput[]
    OR?: skill_obtationWhereInput[]
    NOT?: skill_obtationWhereInput | skill_obtationWhereInput[]
    capacityId?: IntFilter<"skill_obtation"> | number
    pokemonId?: IntFilter<"skill_obtation"> | number
    groupGameId?: IntFilter<"skill_obtation"> | number
    skillObtationTypeId?: IntFilter<"skill_obtation"> | number
    detail?: StringFilter<"skill_obtation"> | string
    capacity?: XOR<CapacityScalarRelationFilter, capacityWhereInput>
    groupGame?: XOR<Group_gameScalarRelationFilter, group_gameWhereInput>
    pokemon?: XOR<PokemonScalarRelationFilter, pokemonWhereInput>
    skillObtationType?: XOR<Skill_obtation_typeScalarRelationFilter, skill_obtation_typeWhereInput>
  }

  export type skill_obtationOrderByWithRelationInput = {
    capacityId?: SortOrder
    pokemonId?: SortOrder
    groupGameId?: SortOrder
    skillObtationTypeId?: SortOrder
    detail?: SortOrder
    capacity?: capacityOrderByWithRelationInput
    groupGame?: group_gameOrderByWithRelationInput
    pokemon?: pokemonOrderByWithRelationInput
    skillObtationType?: skill_obtation_typeOrderByWithRelationInput
    _relevance?: skill_obtationOrderByRelevanceInput
  }

  export type skill_obtationWhereUniqueInput = Prisma.AtLeast<{
    pokemonId_groupGameId_capacityId_skillObtationTypeId_detail?: skill_obtationPokemonIdGroupGameIdCapacityIdSkillObtationTypeIdDetailCompoundUniqueInput
    AND?: skill_obtationWhereInput | skill_obtationWhereInput[]
    OR?: skill_obtationWhereInput[]
    NOT?: skill_obtationWhereInput | skill_obtationWhereInput[]
    capacityId?: IntFilter<"skill_obtation"> | number
    pokemonId?: IntFilter<"skill_obtation"> | number
    groupGameId?: IntFilter<"skill_obtation"> | number
    skillObtationTypeId?: IntFilter<"skill_obtation"> | number
    detail?: StringFilter<"skill_obtation"> | string
    capacity?: XOR<CapacityScalarRelationFilter, capacityWhereInput>
    groupGame?: XOR<Group_gameScalarRelationFilter, group_gameWhereInput>
    pokemon?: XOR<PokemonScalarRelationFilter, pokemonWhereInput>
    skillObtationType?: XOR<Skill_obtation_typeScalarRelationFilter, skill_obtation_typeWhereInput>
  }, "pokemonId_groupGameId_capacityId_skillObtationTypeId_detail">

  export type skill_obtationOrderByWithAggregationInput = {
    capacityId?: SortOrder
    pokemonId?: SortOrder
    groupGameId?: SortOrder
    skillObtationTypeId?: SortOrder
    detail?: SortOrder
    _count?: skill_obtationCountOrderByAggregateInput
    _avg?: skill_obtationAvgOrderByAggregateInput
    _max?: skill_obtationMaxOrderByAggregateInput
    _min?: skill_obtationMinOrderByAggregateInput
    _sum?: skill_obtationSumOrderByAggregateInput
  }

  export type skill_obtationScalarWhereWithAggregatesInput = {
    AND?: skill_obtationScalarWhereWithAggregatesInput | skill_obtationScalarWhereWithAggregatesInput[]
    OR?: skill_obtationScalarWhereWithAggregatesInput[]
    NOT?: skill_obtationScalarWhereWithAggregatesInput | skill_obtationScalarWhereWithAggregatesInput[]
    capacityId?: IntWithAggregatesFilter<"skill_obtation"> | number
    pokemonId?: IntWithAggregatesFilter<"skill_obtation"> | number
    groupGameId?: IntWithAggregatesFilter<"skill_obtation"> | number
    skillObtationTypeId?: IntWithAggregatesFilter<"skill_obtation"> | number
    detail?: StringWithAggregatesFilter<"skill_obtation"> | string
  }

  export type refresh_tokenWhereInput = {
    AND?: refresh_tokenWhereInput | refresh_tokenWhereInput[]
    OR?: refresh_tokenWhereInput[]
    NOT?: refresh_tokenWhereInput | refresh_tokenWhereInput[]
    id?: IntFilter<"refresh_token"> | number
    userId?: IntFilter<"refresh_token"> | number
    token?: StringFilter<"refresh_token"> | string
    expiresAt?: DateTimeFilter<"refresh_token"> | Date | string
    users?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type refresh_tokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    users?: userOrderByWithRelationInput
    _relevance?: refresh_tokenOrderByRelevanceInput
  }

  export type refresh_tokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: refresh_tokenWhereInput | refresh_tokenWhereInput[]
    OR?: refresh_tokenWhereInput[]
    NOT?: refresh_tokenWhereInput | refresh_tokenWhereInput[]
    userId?: IntFilter<"refresh_token"> | number
    expiresAt?: DateTimeFilter<"refresh_token"> | Date | string
    users?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "token">

  export type refresh_tokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    _count?: refresh_tokenCountOrderByAggregateInput
    _avg?: refresh_tokenAvgOrderByAggregateInput
    _max?: refresh_tokenMaxOrderByAggregateInput
    _min?: refresh_tokenMinOrderByAggregateInput
    _sum?: refresh_tokenSumOrderByAggregateInput
  }

  export type refresh_tokenScalarWhereWithAggregatesInput = {
    AND?: refresh_tokenScalarWhereWithAggregatesInput | refresh_tokenScalarWhereWithAggregatesInput[]
    OR?: refresh_tokenScalarWhereWithAggregatesInput[]
    NOT?: refresh_tokenScalarWhereWithAggregatesInput | refresh_tokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"refresh_token"> | number
    userId?: IntWithAggregatesFilter<"refresh_token"> | number
    token?: StringWithAggregatesFilter<"refresh_token"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"refresh_token"> | Date | string
  }

  export type langueCreateInput = {
    name: string
    isoCode: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    translations?: translationCreateNestedManyWithoutLangueInput
  }

  export type langueUncheckedCreateInput = {
    id?: number
    name: string
    isoCode: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    translations?: translationUncheckedCreateNestedManyWithoutLangueInput
  }

  export type langueUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isoCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    translations?: translationUpdateManyWithoutLangueNestedInput
  }

  export type langueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isoCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    translations?: translationUncheckedUpdateManyWithoutLangueNestedInput
  }

  export type langueCreateManyInput = {
    id?: number
    name: string
    isoCode: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type langueUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isoCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type langueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isoCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type translationCreateInput = {
    referenceId: bigint | number
    referenceTable: $Enums.reference_table
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    langue: langueCreateNestedOneWithoutTranslationsInput
  }

  export type translationUncheckedCreateInput = {
    langueId: number
    referenceId: bigint | number
    referenceTable: $Enums.reference_table
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type translationUpdateInput = {
    referenceId?: BigIntFieldUpdateOperationsInput | bigint | number
    referenceTable?: Enumreference_tableFieldUpdateOperationsInput | $Enums.reference_table
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    langue?: langueUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type translationUncheckedUpdateInput = {
    langueId?: IntFieldUpdateOperationsInput | number
    referenceId?: BigIntFieldUpdateOperationsInput | bigint | number
    referenceTable?: Enumreference_tableFieldUpdateOperationsInput | $Enums.reference_table
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type translationCreateManyInput = {
    langueId: number
    referenceId: bigint | number
    referenceTable: $Enums.reference_table
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type translationUpdateManyMutationInput = {
    referenceId?: BigIntFieldUpdateOperationsInput | bigint | number
    referenceTable?: Enumreference_tableFieldUpdateOperationsInput | $Enums.reference_table
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type translationUncheckedUpdateManyInput = {
    langueId?: IntFieldUpdateOperationsInput | number
    referenceId?: BigIntFieldUpdateOperationsInput | bigint | number
    referenceTable?: Enumreference_tableFieldUpdateOperationsInput | $Enums.reference_table
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateInput = {
    discordId?: bigint | number | null
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pseudonym: string
    role?: $Enums.role
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutUsersInput
    refreshTokens?: refresh_tokenCreateNestedManyWithoutUsersInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    discordId?: bigint | number | null
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pseudonym: string
    role?: $Enums.role
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutUsersInput
    refreshTokens?: refresh_tokenUncheckedCreateNestedManyWithoutUsersInput
  }

  export type userUpdateInput = {
    discordId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pseudonym?: StringFieldUpdateOperationsInput | string
    role?: EnumroleFieldUpdateOperationsInput | $Enums.role
    ownedPokemons?: owned_pokemonUpdateManyWithoutUsersNestedInput
    refreshTokens?: refresh_tokenUpdateManyWithoutUsersNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    discordId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pseudonym?: StringFieldUpdateOperationsInput | string
    role?: EnumroleFieldUpdateOperationsInput | $Enums.role
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutUsersNestedInput
    refreshTokens?: refresh_tokenUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    discordId?: bigint | number | null
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pseudonym: string
    role?: $Enums.role
  }

  export type userUpdateManyMutationInput = {
    discordId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pseudonym?: StringFieldUpdateOperationsInput | string
    role?: EnumroleFieldUpdateOperationsInput | $Enums.role
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    discordId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pseudonym?: StringFieldUpdateOperationsInput | string
    role?: EnumroleFieldUpdateOperationsInput | $Enums.role
  }

  export type shiny_hunting_methodCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutShinyHuntingMethodInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameCreateNestedManyWithoutShinyHuntingMethodInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateCreateNestedManyWithoutShinyHuntingMethodInput
  }

  export type shiny_hunting_methodUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutShinyHuntingMethodInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedCreateNestedManyWithoutShinyHuntingMethodInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedCreateNestedManyWithoutShinyHuntingMethodInput
  }

  export type shiny_hunting_methodUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemons?: owned_pokemonUpdateManyWithoutShinyHuntingMethodNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUpdateManyWithoutShinyHuntingMethodNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUpdateManyWithoutShinyHuntingMethodNestedInput
  }

  export type shiny_hunting_methodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutShinyHuntingMethodNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedUpdateManyWithoutShinyHuntingMethodNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedUpdateManyWithoutShinyHuntingMethodNestedInput
  }

  export type shiny_hunting_methodCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type shiny_hunting_methodUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type shiny_hunting_methodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokeballCreateInput = {
    picture: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemonDetails?: owned_pokemon_detailCreateNestedManyWithoutPokeballInput
  }

  export type pokeballUncheckedCreateInput = {
    id?: number
    picture: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemonDetails?: owned_pokemon_detailUncheckedCreateNestedManyWithoutPokeballInput
  }

  export type pokeballUpdateInput = {
    picture?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemonDetails?: owned_pokemon_detailUpdateManyWithoutPokeballNestedInput
  }

  export type pokeballUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    picture?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemonDetails?: owned_pokemon_detailUncheckedUpdateManyWithoutPokeballNestedInput
  }

  export type pokeballCreateManyInput = {
    id?: number
    picture: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokeballUpdateManyMutationInput = {
    picture?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokeballUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    picture?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type generationCreateInput = {
    id: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilities?: abilityCreateNestedManyWithoutGenerationInput
    abilityInfos?: ability_infoCreateNestedManyWithoutGenerationInput
    games?: gameCreateNestedManyWithoutGenerationInput
    pokemons?: pokemonCreateNestedManyWithoutGenerationInput
    pokemonInfos?: pokemon_infoCreateNestedManyWithoutGenerationInput
  }

  export type generationUncheckedCreateInput = {
    id: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilities?: abilityUncheckedCreateNestedManyWithoutGenerationInput
    abilityInfos?: ability_infoUncheckedCreateNestedManyWithoutGenerationInput
    games?: gameUncheckedCreateNestedManyWithoutGenerationInput
    pokemons?: pokemonUncheckedCreateNestedManyWithoutGenerationInput
    pokemonInfos?: pokemon_infoUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type generationUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilities?: abilityUpdateManyWithoutGenerationNestedInput
    abilityInfos?: ability_infoUpdateManyWithoutGenerationNestedInput
    games?: gameUpdateManyWithoutGenerationNestedInput
    pokemons?: pokemonUpdateManyWithoutGenerationNestedInput
    pokemonInfos?: pokemon_infoUpdateManyWithoutGenerationNestedInput
  }

  export type generationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilities?: abilityUncheckedUpdateManyWithoutGenerationNestedInput
    abilityInfos?: ability_infoUncheckedUpdateManyWithoutGenerationNestedInput
    games?: gameUncheckedUpdateManyWithoutGenerationNestedInput
    pokemons?: pokemonUncheckedUpdateManyWithoutGenerationNestedInput
    pokemonInfos?: pokemon_infoUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type generationCreateManyInput = {
    id: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type generationUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type generationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type gameCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    generation: generationCreateNestedOneWithoutGamesInput
    gameGroupGames?: game_group_gameCreateNestedManyWithoutGameInput
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutGameInput
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutGameInput
  }

  export type gameUncheckedCreateInput = {
    id?: number
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    gameGroupGames?: game_group_gameUncheckedCreateNestedManyWithoutGameInput
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutGameInput
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutGameInput
  }

  export type gameUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    generation?: generationUpdateOneRequiredWithoutGamesNestedInput
    gameGroupGames?: game_group_gameUpdateManyWithoutGameNestedInput
    ownedPokemons?: owned_pokemonUpdateManyWithoutGameNestedInput
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutGameNestedInput
  }

  export type gameUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameGroupGames?: game_group_gameUncheckedUpdateManyWithoutGameNestedInput
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutGameNestedInput
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutGameNestedInput
  }

  export type gameCreateManyInput = {
    id?: number
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type gameUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type gameUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type game_group_gameCreateInput = {
    game: gameCreateNestedOneWithoutGameGroupGamesInput
    groupGame: group_gameCreateNestedOneWithoutGameGroupGamesInput
    land: landCreateNestedOneWithoutGame_group_gameInput
  }

  export type game_group_gameUncheckedCreateInput = {
    gameId: number
    groupGameId: number
    landId: number
  }

  export type game_group_gameUpdateInput = {
    game?: gameUpdateOneRequiredWithoutGameGroupGamesNestedInput
    groupGame?: group_gameUpdateOneRequiredWithoutGameGroupGamesNestedInput
    land?: landUpdateOneRequiredWithoutGame_group_gameNestedInput
  }

  export type game_group_gameUncheckedUpdateInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    groupGameId?: IntFieldUpdateOperationsInput | number
    landId?: IntFieldUpdateOperationsInput | number
  }

  export type game_group_gameCreateManyInput = {
    gameId: number
    groupGameId: number
    landId: number
  }

  export type game_group_gameUpdateManyMutationInput = {

  }

  export type game_group_gameUncheckedUpdateManyInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    groupGameId?: IntFieldUpdateOperationsInput | number
    landId?: IntFieldUpdateOperationsInput | number
  }

  export type group_gameCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoCreateNestedManyWithoutGroupGameInput
    gameGroupGames?: game_group_gameCreateNestedManyWithoutGroupGameInput
    nationnalNumbers?: national_numberCreateNestedManyWithoutGroupGameInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameCreateNestedManyWithoutGroupGameInput
    skillObtations?: skill_obtationCreateNestedManyWithoutGroupGameInput
    statisticGroupGames?: statistic_group_gameCreateNestedManyWithoutGroupGameInput
  }

  export type group_gameUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutGroupGameInput
    gameGroupGames?: game_group_gameUncheckedCreateNestedManyWithoutGroupGameInput
    nationnalNumbers?: national_numberUncheckedCreateNestedManyWithoutGroupGameInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedCreateNestedManyWithoutGroupGameInput
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutGroupGameInput
    statisticGroupGames?: statistic_group_gameUncheckedCreateNestedManyWithoutGroupGameInput
  }

  export type group_gameUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUpdateManyWithoutGroupGameNestedInput
    gameGroupGames?: game_group_gameUpdateManyWithoutGroupGameNestedInput
    nationnalNumbers?: national_numberUpdateManyWithoutGroupGameNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUpdateManyWithoutGroupGameNestedInput
    skillObtations?: skill_obtationUpdateManyWithoutGroupGameNestedInput
    statisticGroupGames?: statistic_group_gameUpdateManyWithoutGroupGameNestedInput
  }

  export type group_gameUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutGroupGameNestedInput
    gameGroupGames?: game_group_gameUncheckedUpdateManyWithoutGroupGameNestedInput
    nationnalNumbers?: national_numberUncheckedUpdateManyWithoutGroupGameNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedUpdateManyWithoutGroupGameNestedInput
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutGroupGameNestedInput
    statisticGroupGames?: statistic_group_gameUncheckedUpdateManyWithoutGroupGameNestedInput
  }

  export type group_gameCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type group_gameUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type group_gameUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capsule_game_capacity_infoCreateInput = {
    capacityInfo: capacity_infoCreateNestedOneWithoutCapsuleGameCapacityInfosInput
    capsule: capsuleCreateNestedOneWithoutCapsule_game_capacity_infoInput
    groupGame: group_gameCreateNestedOneWithoutCapsuleGameCapacityIinfosInput
  }

  export type capsule_game_capacity_infoUncheckedCreateInput = {
    capacityInfoId: number
    capsuleId: number
    groupeGameId: number
  }

  export type capsule_game_capacity_infoUpdateInput = {
    capacityInfo?: capacity_infoUpdateOneRequiredWithoutCapsuleGameCapacityInfosNestedInput
    capsule?: capsuleUpdateOneRequiredWithoutCapsule_game_capacity_infoNestedInput
    groupGame?: group_gameUpdateOneRequiredWithoutCapsuleGameCapacityIinfosNestedInput
  }

  export type capsule_game_capacity_infoUncheckedUpdateInput = {
    capacityInfoId?: IntFieldUpdateOperationsInput | number
    capsuleId?: IntFieldUpdateOperationsInput | number
    groupeGameId?: IntFieldUpdateOperationsInput | number
  }

  export type capsule_game_capacity_infoCreateManyInput = {
    capacityInfoId: number
    capsuleId: number
    groupeGameId: number
  }

  export type capsule_game_capacity_infoUpdateManyMutationInput = {

  }

  export type capsule_game_capacity_infoUncheckedUpdateManyInput = {
    capacityInfoId?: IntFieldUpdateOperationsInput | number
    capsuleId?: IntFieldUpdateOperationsInput | number
    groupeGameId?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_categoryCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pokemons?: pokemonCreateNestedManyWithoutPokemon_categoryInput
  }

  export type pokemon_categoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pokemons?: pokemonUncheckedCreateNestedManyWithoutPokemon_categoryInput
  }

  export type pokemon_categoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pokemons?: pokemonUpdateManyWithoutPokemon_categoryNestedInput
  }

  export type pokemon_categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pokemons?: pokemonUncheckedUpdateManyWithoutPokemon_categoryNestedInput
  }

  export type pokemon_categoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokemon_categoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemonCreateInput = {
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    nationalNumbers?: national_numberCreateNestedManyWithoutPokemonInput
    pokemon_category: pokemon_categoryCreateNestedOneWithoutPokemonsInput
    generation: generationCreateNestedOneWithoutPokemonsInput
    pokemonForms?: pokemon_formCreateNestedManyWithoutPokemonInput
    pokemonInfos?: pokemon_infoCreateNestedManyWithoutPokemonInput
    skillObtations?: skill_obtationCreateNestedManyWithoutPokemonInput
    statisticGroupGames?: statistic_group_gameCreateNestedManyWithoutPokemonInput
  }

  export type pokemonUncheckedCreateInput = {
    id?: number
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    pokemonCategoryId: number
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    nationalNumbers?: national_numberUncheckedCreateNestedManyWithoutPokemonInput
    pokemonForms?: pokemon_formUncheckedCreateNestedManyWithoutPokemonInput
    pokemonInfos?: pokemon_infoUncheckedCreateNestedManyWithoutPokemonInput
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutPokemonInput
    statisticGroupGames?: statistic_group_gameUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type pokemonUpdateInput = {
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    nationalNumbers?: national_numberUpdateManyWithoutPokemonNestedInput
    pokemon_category?: pokemon_categoryUpdateOneRequiredWithoutPokemonsNestedInput
    generation?: generationUpdateOneRequiredWithoutPokemonsNestedInput
    pokemonForms?: pokemon_formUpdateManyWithoutPokemonNestedInput
    pokemonInfos?: pokemon_infoUpdateManyWithoutPokemonNestedInput
    skillObtations?: skill_obtationUpdateManyWithoutPokemonNestedInput
    statisticGroupGames?: statistic_group_gameUpdateManyWithoutPokemonNestedInput
  }

  export type pokemonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pokemonCategoryId?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    nationalNumbers?: national_numberUncheckedUpdateManyWithoutPokemonNestedInput
    pokemonForms?: pokemon_formUncheckedUpdateManyWithoutPokemonNestedInput
    pokemonInfos?: pokemon_infoUncheckedUpdateManyWithoutPokemonNestedInput
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutPokemonNestedInput
    statisticGroupGames?: statistic_group_gameUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type pokemonCreateManyInput = {
    id?: number
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    pokemonCategoryId: number
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokemonUpdateManyMutationInput = {
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pokemonCategoryId?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type genderCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pokemonFormGenders?: pokemon_form_genderCreateNestedManyWithoutGenderInput
  }

  export type genderUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pokemonFormGenders?: pokemon_form_genderUncheckedCreateNestedManyWithoutGenderInput
  }

  export type genderUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pokemonFormGenders?: pokemon_form_genderUpdateManyWithoutGenderNestedInput
  }

  export type genderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pokemonFormGenders?: pokemon_form_genderUncheckedUpdateManyWithoutGenderNestedInput
  }

  export type genderCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type genderUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type genderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type formCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pokemonForms?: pokemon_formCreateNestedManyWithoutFormInput
  }

  export type formUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pokemonForms?: pokemon_formUncheckedCreateNestedManyWithoutFormInput
  }

  export type formUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pokemonForms?: pokemon_formUpdateManyWithoutFormNestedInput
  }

  export type formUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pokemonForms?: pokemon_formUncheckedUpdateManyWithoutFormNestedInput
  }

  export type formCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type formUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type formUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_form_genderCreateInput = {
    gender: genderCreateNestedOneWithoutPokemonFormGendersInput
    pokemon_form: pokemon_formCreateNestedOneWithoutPokemonFormGendersInput
  }

  export type pokemon_form_genderUncheckedCreateInput = {
    pokemonFormId: number
    genderId: number
  }

  export type pokemon_form_genderUpdateInput = {
    gender?: genderUpdateOneRequiredWithoutPokemonFormGendersNestedInput
    pokemon_form?: pokemon_formUpdateOneRequiredWithoutPokemonFormGendersNestedInput
  }

  export type pokemon_form_genderUncheckedUpdateInput = {
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    genderId?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_form_genderCreateManyInput = {
    pokemonFormId: number
    genderId: number
  }

  export type pokemon_form_genderUpdateManyMutationInput = {

  }

  export type pokemon_form_genderUncheckedUpdateManyInput = {
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    genderId?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_formCreateInput = {
    createdAt?: Date | string
    status?: string
    updatedAt?: Date | string | null
    evolutionEnds?: evolutionCreateNestedManyWithoutPokemonEndInput
    evolutionStarts?: evolutionCreateNestedManyWithoutPokemonStartInput
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutPokemonFormsInput
    form: formCreateNestedOneWithoutPokemonFormsInput
    pokemon: pokemonCreateNestedOneWithoutPokemonFormsInput
    pokemonFormGenders?: pokemon_form_genderCreateNestedManyWithoutPokemon_formInput
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutPokemonFormInput
  }

  export type pokemon_formUncheckedCreateInput = {
    pokemonId: number
    formId: number
    createdAt?: Date | string
    id?: number
    status?: string
    updatedAt?: Date | string | null
    evolutionEnds?: evolutionUncheckedCreateNestedManyWithoutPokemonEndInput
    evolutionStarts?: evolutionUncheckedCreateNestedManyWithoutPokemonStartInput
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutPokemonFormsInput
    pokemonFormGenders?: pokemon_form_genderUncheckedCreateNestedManyWithoutPokemon_formInput
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutPokemonFormInput
  }

  export type pokemon_formUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionEnds?: evolutionUpdateManyWithoutPokemonEndNestedInput
    evolutionStarts?: evolutionUpdateManyWithoutPokemonStartNestedInput
    ownedPokemons?: owned_pokemonUpdateManyWithoutPokemonFormsNestedInput
    form?: formUpdateOneRequiredWithoutPokemonFormsNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutPokemonFormsNestedInput
    pokemonFormGenders?: pokemon_form_genderUpdateManyWithoutPokemon_formNestedInput
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutPokemonFormNestedInput
  }

  export type pokemon_formUncheckedUpdateInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionEnds?: evolutionUncheckedUpdateManyWithoutPokemonEndNestedInput
    evolutionStarts?: evolutionUncheckedUpdateManyWithoutPokemonStartNestedInput
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutPokemonFormsNestedInput
    pokemonFormGenders?: pokemon_form_genderUncheckedUpdateManyWithoutPokemon_formNestedInput
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutPokemonFormNestedInput
  }

  export type pokemon_formCreateManyInput = {
    pokemonId: number
    formId: number
    createdAt?: Date | string
    id?: number
    status?: string
    updatedAt?: Date | string | null
  }

  export type pokemon_formUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pokemon_formUncheckedUpdateManyInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type owned_pokemonCreateInput = {
    id?: bigint | number
    isShiny: boolean
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    game: gameCreateNestedOneWithoutOwnedPokemonsInput
    shinyHuntingMethod: shiny_hunting_methodCreateNestedOneWithoutOwnedPokemonsInput
    pokemonForms: pokemon_formCreateNestedOneWithoutOwnedPokemonsInput
    users: userCreateNestedOneWithoutOwnedPokemonsInput
    ownedPokemonDetails?: owned_pokemon_detailCreateNestedManyWithoutOwnedPokemonInput
  }

  export type owned_pokemonUncheckedCreateInput = {
    id?: bigint | number
    userId: number
    pokemonFormId: number
    gameId: number
    isShiny: boolean
    methodId: number
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemonDetails?: owned_pokemon_detailUncheckedCreateNestedManyWithoutOwnedPokemonInput
  }

  export type owned_pokemonUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    game?: gameUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    shinyHuntingMethod?: shiny_hunting_methodUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    pokemonForms?: pokemon_formUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    users?: userUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    ownedPokemonDetails?: owned_pokemon_detailUpdateManyWithoutOwnedPokemonNestedInput
  }

  export type owned_pokemonUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    methodId?: IntFieldUpdateOperationsInput | number
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemonDetails?: owned_pokemon_detailUncheckedUpdateManyWithoutOwnedPokemonNestedInput
  }

  export type owned_pokemonCreateManyInput = {
    id?: bigint | number
    userId: number
    pokemonFormId: number
    gameId: number
    isShiny: boolean
    methodId: number
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type owned_pokemonUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type owned_pokemonUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    methodId?: IntFieldUpdateOperationsInput | number
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type owned_pokemon_detailCreateInput = {
    id?: bigint | number
    nickname: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemon: owned_pokemonCreateNestedOneWithoutOwnedPokemonDetailsInput
    pokeball: pokeballCreateNestedOneWithoutOwnedPokemonDetailsInput
  }

  export type owned_pokemon_detailUncheckedCreateInput = {
    id?: bigint | number
    nickname: string
    pokeballId: number
    ownedPokemonId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type owned_pokemon_detailUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nickname?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemon?: owned_pokemonUpdateOneRequiredWithoutOwnedPokemonDetailsNestedInput
    pokeball?: pokeballUpdateOneRequiredWithoutOwnedPokemonDetailsNestedInput
  }

  export type owned_pokemon_detailUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nickname?: StringFieldUpdateOperationsInput | string
    pokeballId?: IntFieldUpdateOperationsInput | number
    ownedPokemonId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type owned_pokemon_detailCreateManyInput = {
    id?: bigint | number
    nickname: string
    pokeballId: number
    ownedPokemonId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type owned_pokemon_detailUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nickname?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type owned_pokemon_detailUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nickname?: StringFieldUpdateOperationsInput | string
    pokeballId?: IntFieldUpdateOperationsInput | number
    ownedPokemonId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type abilityCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    generation: generationCreateNestedOneWithoutAbilitiesInput
    abilityInfos?: ability_infoCreateNestedManyWithoutAbilitiesInput
    abilityOrders?: ability_orderCreateNestedManyWithoutAbilityInput
  }

  export type abilityUncheckedCreateInput = {
    id?: number
    appearanceGenerationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityInfos?: ability_infoUncheckedCreateNestedManyWithoutAbilitiesInput
    abilityOrders?: ability_orderUncheckedCreateNestedManyWithoutAbilityInput
  }

  export type abilityUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    generation?: generationUpdateOneRequiredWithoutAbilitiesNestedInput
    abilityInfos?: ability_infoUpdateManyWithoutAbilitiesNestedInput
    abilityOrders?: ability_orderUpdateManyWithoutAbilityNestedInput
  }

  export type abilityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    appearanceGenerationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityInfos?: ability_infoUncheckedUpdateManyWithoutAbilitiesNestedInput
    abilityOrders?: ability_orderUncheckedUpdateManyWithoutAbilityNestedInput
  }

  export type abilityCreateManyInput = {
    id?: number
    appearanceGenerationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type abilityUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type abilityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    appearanceGenerationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ability_infoCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilities: abilityCreateNestedOneWithoutAbilityInfosInput
    effectWithoutFight: effect_outside_fightCreateNestedOneWithoutAbilityInfosInput
    generation: generationCreateNestedOneWithoutAbilityInfosInput
  }

  export type ability_infoUncheckedCreateInput = {
    id?: number
    generationId: number
    abilityId: number
    effectOutsideFightId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type ability_infoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilities?: abilityUpdateOneRequiredWithoutAbilityInfosNestedInput
    effectWithoutFight?: effect_outside_fightUpdateOneRequiredWithoutAbilityInfosNestedInput
    generation?: generationUpdateOneRequiredWithoutAbilityInfosNestedInput
  }

  export type ability_infoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    abilityId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ability_infoCreateManyInput = {
    id?: number
    generationId: number
    abilityId: number
    effectOutsideFightId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type ability_infoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ability_infoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    abilityId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_infoCreateInput = {
    xpGift: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityOrders?: ability_orderCreateNestedManyWithoutPokemonInfoInput
    eggGroupOrders?: egg_group_orderCreateNestedManyWithoutPokemonInfoInput
    generation: generationCreateNestedOneWithoutPokemonInfosInput
    pokemon: pokemonCreateNestedOneWithoutPokemonInfosInput
    typeOrders?: type_orderCreateNestedManyWithoutPokemonInfoInput
  }

  export type pokemon_infoUncheckedCreateInput = {
    id?: number
    xpGift: number
    generationId: number
    pokemonId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityOrders?: ability_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
    eggGroupOrders?: egg_group_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
    typeOrders?: type_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
  }

  export type pokemon_infoUpdateInput = {
    xpGift?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityOrders?: ability_orderUpdateManyWithoutPokemonInfoNestedInput
    eggGroupOrders?: egg_group_orderUpdateManyWithoutPokemonInfoNestedInput
    generation?: generationUpdateOneRequiredWithoutPokemonInfosNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutPokemonInfosNestedInput
    typeOrders?: type_orderUpdateManyWithoutPokemonInfoNestedInput
  }

  export type pokemon_infoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    xpGift?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityOrders?: ability_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
    eggGroupOrders?: egg_group_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
    typeOrders?: type_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
  }

  export type pokemon_infoCreateManyInput = {
    id?: number
    xpGift: number
    generationId: number
    pokemonId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokemon_infoUpdateManyMutationInput = {
    xpGift?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_infoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    xpGift?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ability_orderCreateInput = {
    order: number
    isHidden: boolean
    ability: abilityCreateNestedOneWithoutAbilityOrdersInput
    pokemonInfo: pokemon_infoCreateNestedOneWithoutAbilityOrdersInput
  }

  export type ability_orderUncheckedCreateInput = {
    pokemonInfoId: number
    abilityId: number
    order: number
    isHidden: boolean
  }

  export type ability_orderUpdateInput = {
    order?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    ability?: abilityUpdateOneRequiredWithoutAbilityOrdersNestedInput
    pokemonInfo?: pokemon_infoUpdateOneRequiredWithoutAbilityOrdersNestedInput
  }

  export type ability_orderUncheckedUpdateInput = {
    pokemonInfoId?: IntFieldUpdateOperationsInput | number
    abilityId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ability_orderCreateManyInput = {
    pokemonInfoId: number
    abilityId: number
    order: number
    isHidden: boolean
  }

  export type ability_orderUpdateManyMutationInput = {
    order?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ability_orderUncheckedUpdateManyInput = {
    pokemonInfoId?: IntFieldUpdateOperationsInput | number
    abilityId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type evolution_methodCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    evolutions?: evolutionCreateNestedManyWithoutEvolutionMethodInput
  }

  export type evolution_methodUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    evolutions?: evolutionUncheckedCreateNestedManyWithoutEvolutionMethodInput
  }

  export type evolution_methodUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    evolutions?: evolutionUpdateManyWithoutEvolutionMethodNestedInput
  }

  export type evolution_methodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    evolutions?: evolutionUncheckedUpdateManyWithoutEvolutionMethodNestedInput
  }

  export type evolution_methodCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolution_methodUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolution_methodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolutionCreateInput = {
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    evolutionInfo: evolution_infoCreateNestedOneWithoutEvolutionsInput
    evolutionMethod: evolution_methodCreateNestedOneWithoutEvolutionsInput
    pokemonEnd: pokemon_formCreateNestedOneWithoutEvolutionEndsInput
    pokemonStart: pokemon_formCreateNestedOneWithoutEvolutionStartsInput
  }

  export type evolutionUncheckedCreateInput = {
    id?: number
    level?: number | null
    evolutionMethodId: number
    pokemonFormStartId: number
    pokemonFormEndId: number
    evolutionInfoId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolutionUpdateInput = {
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    evolutionInfo?: evolution_infoUpdateOneRequiredWithoutEvolutionsNestedInput
    evolutionMethod?: evolution_methodUpdateOneRequiredWithoutEvolutionsNestedInput
    pokemonEnd?: pokemon_formUpdateOneRequiredWithoutEvolutionEndsNestedInput
    pokemonStart?: pokemon_formUpdateOneRequiredWithoutEvolutionStartsNestedInput
  }

  export type evolutionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableIntFieldUpdateOperationsInput | number | null
    evolutionMethodId?: IntFieldUpdateOperationsInput | number
    pokemonFormStartId?: IntFieldUpdateOperationsInput | number
    pokemonFormEndId?: IntFieldUpdateOperationsInput | number
    evolutionInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolutionCreateManyInput = {
    id?: number
    level?: number | null
    evolutionMethodId: number
    pokemonFormStartId: number
    pokemonFormEndId: number
    evolutionInfoId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolutionUpdateManyMutationInput = {
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolutionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableIntFieldUpdateOperationsInput | number | null
    evolutionMethodId?: IntFieldUpdateOperationsInput | number
    pokemonFormStartId?: IntFieldUpdateOperationsInput | number
    pokemonFormEndId?: IntFieldUpdateOperationsInput | number
    evolutionInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolution_infoCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    evolutions?: evolutionCreateNestedManyWithoutEvolutionInfoInput
  }

  export type evolution_infoUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    evolutions?: evolutionUncheckedCreateNestedManyWithoutEvolutionInfoInput
  }

  export type evolution_infoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    evolutions?: evolutionUpdateManyWithoutEvolutionInfoNestedInput
  }

  export type evolution_infoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    evolutions?: evolutionUncheckedUpdateManyWithoutEvolutionInfoNestedInput
  }

  export type evolution_infoCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolution_infoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolution_infoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type egg_groupCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    eggGroupOrders?: egg_group_orderCreateNestedManyWithoutEggGroupInput
  }

  export type egg_groupUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    eggGroupOrders?: egg_group_orderUncheckedCreateNestedManyWithoutEggGroupInput
  }

  export type egg_groupUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    eggGroupOrders?: egg_group_orderUpdateManyWithoutEggGroupNestedInput
  }

  export type egg_groupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    eggGroupOrders?: egg_group_orderUncheckedUpdateManyWithoutEggGroupNestedInput
  }

  export type egg_groupCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type egg_groupUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type egg_groupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type egg_group_orderCreateInput = {
    order: number
    eggGroup: egg_groupCreateNestedOneWithoutEggGroupOrdersInput
    pokemonInfo: pokemon_infoCreateNestedOneWithoutEggGroupOrdersInput
  }

  export type egg_group_orderUncheckedCreateInput = {
    pokemonInfoId: number
    eggGroupId: number
    order: number
  }

  export type egg_group_orderUpdateInput = {
    order?: IntFieldUpdateOperationsInput | number
    eggGroup?: egg_groupUpdateOneRequiredWithoutEggGroupOrdersNestedInput
    pokemonInfo?: pokemon_infoUpdateOneRequiredWithoutEggGroupOrdersNestedInput
  }

  export type egg_group_orderUncheckedUpdateInput = {
    pokemonInfoId?: IntFieldUpdateOperationsInput | number
    eggGroupId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type egg_group_orderCreateManyInput = {
    pokemonInfoId: number
    eggGroupId: number
    order: number
  }

  export type egg_group_orderUpdateManyMutationInput = {
    order?: IntFieldUpdateOperationsInput | number
  }

  export type egg_group_orderUncheckedUpdateManyInput = {
    pokemonInfoId?: IntFieldUpdateOperationsInput | number
    eggGroupId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type typeCreateInput = {
    color: string
    iconName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoCreateNestedManyWithoutTypeInput
    typeOrders?: type_orderCreateNestedManyWithoutTypeInput
  }

  export type typeUncheckedCreateInput = {
    id?: number
    color: string
    iconName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoUncheckedCreateNestedManyWithoutTypeInput
    typeOrders?: type_orderUncheckedCreateNestedManyWithoutTypeInput
  }

  export type typeUpdateInput = {
    color?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUpdateManyWithoutTypeNestedInput
    typeOrders?: type_orderUpdateManyWithoutTypeNestedInput
  }

  export type typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUncheckedUpdateManyWithoutTypeNestedInput
    typeOrders?: type_orderUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type typeCreateManyInput = {
    id?: number
    color: string
    iconName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type typeUpdateManyMutationInput = {
    color?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type type_orderCreateInput = {
    order: number
    pokemonInfo: pokemon_infoCreateNestedOneWithoutTypeOrdersInput
    type: typeCreateNestedOneWithoutTypeOrdersInput
  }

  export type type_orderUncheckedCreateInput = {
    typeId: number
    pokemonInfoId: number
    order: number
  }

  export type type_orderUpdateInput = {
    order?: IntFieldUpdateOperationsInput | number
    pokemonInfo?: pokemon_infoUpdateOneRequiredWithoutTypeOrdersNestedInput
    type?: typeUpdateOneRequiredWithoutTypeOrdersNestedInput
  }

  export type type_orderUncheckedUpdateInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    pokemonInfoId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type type_orderCreateManyInput = {
    typeId: number
    pokemonInfoId: number
    order: number
  }

  export type type_orderUpdateManyMutationInput = {
    order?: IntFieldUpdateOperationsInput | number
  }

  export type type_orderUncheckedUpdateManyInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    pokemonInfoId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type national_numberCreateInput = {
    number: number
    groupGame: group_gameCreateNestedOneWithoutNationnalNumbersInput
    pokemon: pokemonCreateNestedOneWithoutNationalNumbersInput
  }

  export type national_numberUncheckedCreateInput = {
    groupGameId: number
    pokemonId: number
    number: number
  }

  export type national_numberUpdateInput = {
    number?: IntFieldUpdateOperationsInput | number
    groupGame?: group_gameUpdateOneRequiredWithoutNationnalNumbersNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutNationalNumbersNestedInput
  }

  export type national_numberUncheckedUpdateInput = {
    groupGameId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
  }

  export type national_numberCreateManyInput = {
    groupGameId: number
    pokemonId: number
    number: number
  }

  export type national_numberUpdateManyMutationInput = {
    number?: IntFieldUpdateOperationsInput | number
  }

  export type national_numberUncheckedUpdateManyInput = {
    groupGameId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
  }

  export type landCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    game_group_game?: game_group_gameCreateNestedManyWithoutLandInput
  }

  export type landUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    game_group_game?: game_group_gameUncheckedCreateNestedManyWithoutLandInput
  }

  export type landUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    game_group_game?: game_group_gameUpdateManyWithoutLandNestedInput
  }

  export type landUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    game_group_game?: game_group_gameUncheckedUpdateManyWithoutLandNestedInput
  }

  export type landCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type landUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type landUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacityCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoCreateNestedManyWithoutCapacityInput
    skillObtations?: skill_obtationCreateNestedManyWithoutCapacityInput
  }

  export type capacityUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoUncheckedCreateNestedManyWithoutCapacityInput
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutCapacityInput
  }

  export type capacityUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUpdateManyWithoutCapacityNestedInput
    skillObtations?: skill_obtationUpdateManyWithoutCapacityNestedInput
  }

  export type capacityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUncheckedUpdateManyWithoutCapacityNestedInput
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutCapacityNestedInput
  }

  export type capacityCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type capacityUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_effectCreateInput = {
    zEffect: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoCreateNestedManyWithoutCapacityEffectInput
    capacityZInfos?: capacity_infoCreateNestedManyWithoutCapacityEffectZInput
  }

  export type capacity_effectUncheckedCreateInput = {
    id?: number
    zEffect: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoUncheckedCreateNestedManyWithoutCapacityEffectInput
    capacityZInfos?: capacity_infoUncheckedCreateNestedManyWithoutCapacityEffectZInput
  }

  export type capacity_effectUpdateInput = {
    zEffect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUpdateManyWithoutCapacityEffectNestedInput
    capacityZInfos?: capacity_infoUpdateManyWithoutCapacityEffectZNestedInput
  }

  export type capacity_effectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    zEffect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUncheckedUpdateManyWithoutCapacityEffectNestedInput
    capacityZInfos?: capacity_infoUncheckedUpdateManyWithoutCapacityEffectZNestedInput
  }

  export type capacity_effectCreateManyInput = {
    id?: number
    zEffect: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type capacity_effectUpdateManyMutationInput = {
    zEffect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_effectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    zEffect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_categoryCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoCreateNestedManyWithoutCapacityCategoryInput
  }

  export type capacity_categoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoUncheckedCreateNestedManyWithoutCapacityCategoryInput
  }

  export type capacity_categoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUpdateManyWithoutCapacityCategoryNestedInput
  }

  export type capacity_categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUncheckedUpdateManyWithoutCapacityCategoryNestedInput
  }

  export type capacity_categoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type capacity_categoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capsuleCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsule_game_capacity_info?: capsule_game_capacity_infoCreateNestedManyWithoutCapsuleInput
  }

  export type capsuleUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsule_game_capacity_info?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutCapsuleInput
  }

  export type capsuleUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsule_game_capacity_info?: capsule_game_capacity_infoUpdateManyWithoutCapsuleNestedInput
  }

  export type capsuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsule_game_capacity_info?: capsule_game_capacity_infoUncheckedUpdateManyWithoutCapsuleNestedInput
  }

  export type capsuleCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type capsuleUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capsuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type detailCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    conditionRates?: rateCreateNestedManyWithoutConditionRateInput
    detailRates?: rateCreateNestedManyWithoutDetailRateInput
  }

  export type detailUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    conditionRates?: rateUncheckedCreateNestedManyWithoutConditionRateInput
    detailRates?: rateUncheckedCreateNestedManyWithoutDetailRateInput
  }

  export type detailUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    conditionRates?: rateUpdateManyWithoutConditionRateNestedInput
    detailRates?: rateUpdateManyWithoutDetailRateNestedInput
  }

  export type detailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    conditionRates?: rateUncheckedUpdateManyWithoutConditionRateNestedInput
    detailRates?: rateUncheckedUpdateManyWithoutDetailRateNestedInput
  }

  export type detailCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type detailUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type detailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type effect_outside_fightCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityInfos?: ability_infoCreateNestedManyWithoutEffectWithoutFightInput
    capacityInfos?: capacity_infoCreateNestedManyWithoutEffectOutsideFightInput
  }

  export type effect_outside_fightUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityInfos?: ability_infoUncheckedCreateNestedManyWithoutEffectWithoutFightInput
    capacityInfos?: capacity_infoUncheckedCreateNestedManyWithoutEffectOutsideFightInput
  }

  export type effect_outside_fightUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityInfos?: ability_infoUpdateManyWithoutEffectWithoutFightNestedInput
    capacityInfos?: capacity_infoUpdateManyWithoutEffectOutsideFightNestedInput
  }

  export type effect_outside_fightUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityInfos?: ability_infoUncheckedUpdateManyWithoutEffectWithoutFightNestedInput
    capacityInfos?: capacity_infoUncheckedUpdateManyWithoutEffectOutsideFightNestedInput
  }

  export type effect_outside_fightCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type effect_outside_fightUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type effect_outside_fightUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type influenceCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfoInfluences?: capacity_info_influenceCreateNestedManyWithoutInfluenceInput
  }

  export type influenceUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfoInfluences?: capacity_info_influenceUncheckedCreateNestedManyWithoutInfluenceInput
  }

  export type influenceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfoInfluences?: capacity_info_influenceUpdateManyWithoutInfluenceNestedInput
  }

  export type influenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfoInfluences?: capacity_info_influenceUncheckedUpdateManyWithoutInfluenceNestedInput
  }

  export type influenceCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type influenceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type influenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type locationCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    locationZones?: location_zoneCreateNestedManyWithoutLocationInput
  }

  export type locationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    locationZones?: location_zoneUncheckedCreateNestedManyWithoutLocationInput
  }

  export type locationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationZones?: location_zoneUpdateManyWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationZones?: location_zoneUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type locationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type locationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type locationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type zoneCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    locationZones?: location_zoneCreateNestedManyWithoutZoneInput
  }

  export type zoneUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    locationZones?: location_zoneUncheckedCreateNestedManyWithoutZoneInput
  }

  export type zoneUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationZones?: location_zoneUpdateManyWithoutZoneNestedInput
  }

  export type zoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationZones?: location_zoneUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type zoneCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type zoneUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type zoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type location_zoneCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    location: locationCreateNestedOneWithoutLocationZonesInput
    zone: zoneCreateNestedOneWithoutLocationZonesInput
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutLocationZoneInput
  }

  export type location_zoneUncheckedCreateInput = {
    id?: number
    locationId: number
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutLocationZoneInput
  }

  export type location_zoneUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: locationUpdateOneRequiredWithoutLocationZonesNestedInput
    zone?: zoneUpdateOneRequiredWithoutLocationZonesNestedInput
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutLocationZoneNestedInput
  }

  export type location_zoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutLocationZoneNestedInput
  }

  export type location_zoneCreateManyInput = {
    id?: number
    locationId: number
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type location_zoneUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type location_zoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type meteoCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    rates?: rateCreateNestedManyWithoutMeteoInput
  }

  export type meteoUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    rates?: rateUncheckedCreateNestedManyWithoutMeteoInput
  }

  export type meteoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rates?: rateUpdateManyWithoutMeteoNestedInput
  }

  export type meteoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rates?: rateUncheckedUpdateManyWithoutMeteoNestedInput
  }

  export type meteoCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type meteoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type meteoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_obtationCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutPokemonObtationInput
  }

  export type pokemon_obtationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutPokemonObtationInput
  }

  export type pokemon_obtationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutPokemonObtationNestedInput
  }

  export type pokemon_obtationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutPokemonObtationNestedInput
  }

  export type pokemon_obtationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokemon_obtationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_obtationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type rateCreateInput = {
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutRateInput
    conditionRate: detailCreateNestedOneWithoutConditionRatesInput
    detailRate: detailCreateNestedOneWithoutDetailRatesInput
    meteo: meteoCreateNestedOneWithoutRatesInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateCreateNestedManyWithoutRateInput
  }

  export type rateUncheckedCreateInput = {
    id?: number
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    meteoId: number
    detailRateId: number
    conditionRateId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutRateInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedCreateNestedManyWithoutRateInput
  }

  export type rateUpdateInput = {
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutRateNestedInput
    conditionRate?: detailUpdateOneRequiredWithoutConditionRatesNestedInput
    detailRate?: detailUpdateOneRequiredWithoutDetailRatesNestedInput
    meteo?: meteoUpdateOneRequiredWithoutRatesNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUpdateManyWithoutRateNestedInput
  }

  export type rateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    meteoId?: IntFieldUpdateOperationsInput | number
    detailRateId?: IntFieldUpdateOperationsInput | number
    conditionRateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutRateNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedUpdateManyWithoutRateNestedInput
  }

  export type rateCreateManyInput = {
    id?: number
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    meteoId: number
    detailRateId: number
    conditionRateId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
  }

  export type rateUpdateManyMutationInput = {
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
  }

  export type rateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    meteoId?: IntFieldUpdateOperationsInput | number
    detailRateId?: IntFieldUpdateOperationsInput | number
    conditionRateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
  }

  export type shiny_hunting_method_gameCreateInput = {
    groupGame: group_gameCreateNestedOneWithoutShinyHuntingMethodGamesInput
    shinyHuntingMethod: shiny_hunting_methodCreateNestedOneWithoutShinyHuntingMethodGamesInput
  }

  export type shiny_hunting_method_gameUncheckedCreateInput = {
    shinyHuntingMethodId: number
    groupGameId: number
  }

  export type shiny_hunting_method_gameUpdateInput = {
    groupGame?: group_gameUpdateOneRequiredWithoutShinyHuntingMethodGamesNestedInput
    shinyHuntingMethod?: shiny_hunting_methodUpdateOneRequiredWithoutShinyHuntingMethodGamesNestedInput
  }

  export type shiny_hunting_method_gameUncheckedUpdateInput = {
    shinyHuntingMethodId?: IntFieldUpdateOperationsInput | number
    groupGameId?: IntFieldUpdateOperationsInput | number
  }

  export type shiny_hunting_method_gameCreateManyInput = {
    shinyHuntingMethodId: number
    groupGameId: number
  }

  export type shiny_hunting_method_gameUpdateManyMutationInput = {

  }

  export type shiny_hunting_method_gameUncheckedUpdateManyInput = {
    shinyHuntingMethodId?: IntFieldUpdateOperationsInput | number
    groupGameId?: IntFieldUpdateOperationsInput | number
  }

  export type shiny_hunting_method_rateCreateInput = {
    rate: rateCreateNestedOneWithoutShinyHuntingMethodRatesInput
    shinyHuntingMethod: shiny_hunting_methodCreateNestedOneWithoutShinyHuntingMethodRatesInput
  }

  export type shiny_hunting_method_rateUncheckedCreateInput = {
    shinyHuntingMethodId: number
    rateId: number
  }

  export type shiny_hunting_method_rateUpdateInput = {
    rate?: rateUpdateOneRequiredWithoutShinyHuntingMethodRatesNestedInput
    shinyHuntingMethod?: shiny_hunting_methodUpdateOneRequiredWithoutShinyHuntingMethodRatesNestedInput
  }

  export type shiny_hunting_method_rateUncheckedUpdateInput = {
    shinyHuntingMethodId?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
  }

  export type shiny_hunting_method_rateCreateManyInput = {
    shinyHuntingMethodId: number
    rateId: number
  }

  export type shiny_hunting_method_rateUpdateManyMutationInput = {

  }

  export type shiny_hunting_method_rateUncheckedUpdateManyInput = {
    shinyHuntingMethodId?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
  }

  export type skill_obtation_typeCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    skillObtations?: skill_obtationCreateNestedManyWithoutSkillObtationTypeInput
  }

  export type skill_obtation_typeUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutSkillObtationTypeInput
  }

  export type skill_obtation_typeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    skillObtations?: skill_obtationUpdateManyWithoutSkillObtationTypeNestedInput
  }

  export type skill_obtation_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutSkillObtationTypeNestedInput
  }

  export type skill_obtation_typeCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type skill_obtation_typeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type skill_obtation_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type statisticCreateInput = {
    pv: number
    attack: number
    defense: number
    specialAttack?: number | null
    specialDefense?: number | null
    special?: number | null
    speed: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    statisticGroupGames?: statistic_group_gameCreateNestedManyWithoutStatisticInput
  }

  export type statisticUncheckedCreateInput = {
    id?: number
    pv: number
    attack: number
    defense: number
    specialAttack?: number | null
    specialDefense?: number | null
    special?: number | null
    speed: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    statisticGroupGames?: statistic_group_gameUncheckedCreateNestedManyWithoutStatisticInput
  }

  export type statisticUpdateInput = {
    pv?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    specialAttack?: NullableIntFieldUpdateOperationsInput | number | null
    specialDefense?: NullableIntFieldUpdateOperationsInput | number | null
    special?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    statisticGroupGames?: statistic_group_gameUpdateManyWithoutStatisticNestedInput
  }

  export type statisticUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pv?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    specialAttack?: NullableIntFieldUpdateOperationsInput | number | null
    specialDefense?: NullableIntFieldUpdateOperationsInput | number | null
    special?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    statisticGroupGames?: statistic_group_gameUncheckedUpdateManyWithoutStatisticNestedInput
  }

  export type statisticCreateManyInput = {
    id?: number
    pv: number
    attack: number
    defense: number
    specialAttack?: number | null
    specialDefense?: number | null
    special?: number | null
    speed: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type statisticUpdateManyMutationInput = {
    pv?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    specialAttack?: NullableIntFieldUpdateOperationsInput | number | null
    specialDefense?: NullableIntFieldUpdateOperationsInput | number | null
    special?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type statisticUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pv?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    specialAttack?: NullableIntFieldUpdateOperationsInput | number | null
    specialDefense?: NullableIntFieldUpdateOperationsInput | number | null
    special?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type statistic_group_gameCreateInput = {
    groupGame: group_gameCreateNestedOneWithoutStatisticGroupGamesInput
    pokemon: pokemonCreateNestedOneWithoutStatisticGroupGamesInput
    statistic: statisticCreateNestedOneWithoutStatisticGroupGamesInput
  }

  export type statistic_group_gameUncheckedCreateInput = {
    groupGameId: number
    pokemonId: number
    statisticId: number
  }

  export type statistic_group_gameUpdateInput = {
    groupGame?: group_gameUpdateOneRequiredWithoutStatisticGroupGamesNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutStatisticGroupGamesNestedInput
    statistic?: statisticUpdateOneRequiredWithoutStatisticGroupGamesNestedInput
  }

  export type statistic_group_gameUncheckedUpdateInput = {
    groupGameId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    statisticId?: IntFieldUpdateOperationsInput | number
  }

  export type statistic_group_gameCreateManyInput = {
    groupGameId: number
    pokemonId: number
    statisticId: number
  }

  export type statistic_group_gameUpdateManyMutationInput = {

  }

  export type statistic_group_gameUncheckedUpdateManyInput = {
    groupGameId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    statisticId?: IntFieldUpdateOperationsInput | number
  }

  export type targetCreateInput = {
    isMultiple: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoCreateNestedManyWithoutTargetInput
  }

  export type targetUncheckedCreateInput = {
    id?: number
    isMultiple: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoUncheckedCreateNestedManyWithoutTargetInput
  }

  export type targetUpdateInput = {
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUpdateManyWithoutTargetNestedInput
  }

  export type targetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type targetCreateManyInput = {
    id?: number
    isMultiple: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type targetUpdateManyMutationInput = {
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type targetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_infoCreateInput = {
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityCategory: capacity_categoryCreateNestedOneWithoutCapacityInfosInput
    capacityEffect: capacity_effectCreateNestedOneWithoutCapacityInfosInput
    capacityEffectZ: capacity_effectCreateNestedOneWithoutCapacityZInfosInput
    capacity: capacityCreateNestedOneWithoutCapacityInfosInput
    effectOutsideFight: effect_outside_fightCreateNestedOneWithoutCapacityInfosInput
    target: targetCreateNestedOneWithoutCapacityInfosInput
    type: typeCreateNestedOneWithoutCapacityInfosInput
    capacityInfoInfluences?: capacity_info_influenceCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoUncheckedCreateInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityId: number
    capacityEffectZId: number
    typeId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfoInfluences?: capacity_info_influenceUncheckedCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoUpdateInput = {
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityCategory?: capacity_categoryUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffect?: capacity_effectUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffectZ?: capacity_effectUpdateOneRequiredWithoutCapacityZInfosNestedInput
    capacity?: capacityUpdateOneRequiredWithoutCapacityInfosNestedInput
    effectOutsideFight?: effect_outside_fightUpdateOneRequiredWithoutCapacityInfosNestedInput
    target?: targetUpdateOneRequiredWithoutCapacityInfosNestedInput
    type?: typeUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityInfoInfluences?: capacity_info_influenceUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfoInfluences?: capacity_info_influenceUncheckedUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoCreateManyInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityId: number
    capacityEffectZId: number
    typeId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type capacity_infoUpdateManyMutationInput = {
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_infoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_info_influenceCreateInput = {
    capacityInfo: capacity_infoCreateNestedOneWithoutCapacityInfoInfluencesInput
    influence: influenceCreateNestedOneWithoutCapacityInfoInfluencesInput
  }

  export type capacity_info_influenceUncheckedCreateInput = {
    capacityInfoId: number
    influenceId: number
  }

  export type capacity_info_influenceUpdateInput = {
    capacityInfo?: capacity_infoUpdateOneRequiredWithoutCapacityInfoInfluencesNestedInput
    influence?: influenceUpdateOneRequiredWithoutCapacityInfoInfluencesNestedInput
  }

  export type capacity_info_influenceUncheckedUpdateInput = {
    capacityInfoId?: IntFieldUpdateOperationsInput | number
    influenceId?: IntFieldUpdateOperationsInput | number
  }

  export type capacity_info_influenceCreateManyInput = {
    capacityInfoId: number
    influenceId: number
  }

  export type capacity_info_influenceUpdateManyMutationInput = {

  }

  export type capacity_info_influenceUncheckedUpdateManyInput = {
    capacityInfoId?: IntFieldUpdateOperationsInput | number
    influenceId?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_game_locationCreateInput = {
    game: gameCreateNestedOneWithoutPokemonRatingGamesInput
    locationZone: location_zoneCreateNestedOneWithoutPokemonRatingGamesInput
    pokemonForm: pokemon_formCreateNestedOneWithoutPokemonRatingGamesInput
    pokemonObtation: pokemon_obtationCreateNestedOneWithoutPokemonRatingGamesInput
    rate: rateCreateNestedOneWithoutPokemonRatingGamesInput
  }

  export type pokemon_game_locationUncheckedCreateInput = {
    gameId: number
    rateId: number
    locationZoneId: number
    pokemonObtationId: number
    pokemonFormId: number
    id?: number
  }

  export type pokemon_game_locationUpdateInput = {
    game?: gameUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    locationZone?: location_zoneUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    pokemonForm?: pokemon_formUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    pokemonObtation?: pokemon_obtationUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    rate?: rateUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
  }

  export type pokemon_game_locationUncheckedUpdateInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    locationZoneId?: IntFieldUpdateOperationsInput | number
    pokemonObtationId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_game_locationCreateManyInput = {
    gameId: number
    rateId: number
    locationZoneId: number
    pokemonObtationId: number
    pokemonFormId: number
    id?: number
  }

  export type pokemon_game_locationUpdateManyMutationInput = {

  }

  export type pokemon_game_locationUncheckedUpdateManyInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    locationZoneId?: IntFieldUpdateOperationsInput | number
    pokemonObtationId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type skill_obtationCreateInput = {
    detail: string
    capacity: capacityCreateNestedOneWithoutSkillObtationsInput
    groupGame: group_gameCreateNestedOneWithoutSkillObtationsInput
    pokemon: pokemonCreateNestedOneWithoutSkillObtationsInput
    skillObtationType: skill_obtation_typeCreateNestedOneWithoutSkillObtationsInput
  }

  export type skill_obtationUncheckedCreateInput = {
    capacityId: number
    pokemonId: number
    groupGameId: number
    skillObtationTypeId: number
    detail: string
  }

  export type skill_obtationUpdateInput = {
    detail?: StringFieldUpdateOperationsInput | string
    capacity?: capacityUpdateOneRequiredWithoutSkillObtationsNestedInput
    groupGame?: group_gameUpdateOneRequiredWithoutSkillObtationsNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutSkillObtationsNestedInput
    skillObtationType?: skill_obtation_typeUpdateOneRequiredWithoutSkillObtationsNestedInput
  }

  export type skill_obtationUncheckedUpdateInput = {
    capacityId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    groupGameId?: IntFieldUpdateOperationsInput | number
    skillObtationTypeId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type skill_obtationCreateManyInput = {
    capacityId: number
    pokemonId: number
    groupGameId: number
    skillObtationTypeId: number
    detail: string
  }

  export type skill_obtationUpdateManyMutationInput = {
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type skill_obtationUncheckedUpdateManyInput = {
    capacityId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    groupGameId?: IntFieldUpdateOperationsInput | number
    skillObtationTypeId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type refresh_tokenCreateInput = {
    token: string
    expiresAt: Date | string
    users: userCreateNestedOneWithoutRefreshTokensInput
  }

  export type refresh_tokenUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
  }

  export type refresh_tokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: userUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type refresh_tokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refresh_tokenCreateManyInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
  }

  export type refresh_tokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refresh_tokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TranslationListRelationFilter = {
    every?: translationWhereInput
    some?: translationWhereInput
    none?: translationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type translationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type langueOrderByRelevanceInput = {
    fields: langueOrderByRelevanceFieldEnum | langueOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type langueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isoCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type langueAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type langueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isoCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type langueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isoCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type langueSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type Enumreference_tableFilter<$PrismaModel = never> = {
    equals?: $Enums.reference_table | Enumreference_tableFieldRefInput<$PrismaModel>
    in?: $Enums.reference_table[]
    notIn?: $Enums.reference_table[]
    not?: NestedEnumreference_tableFilter<$PrismaModel> | $Enums.reference_table
  }

  export type LangueScalarRelationFilter = {
    is?: langueWhereInput
    isNot?: langueWhereInput
  }

  export type translationOrderByRelevanceInput = {
    fields: translationOrderByRelevanceFieldEnum | translationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type translationReferenceTableReferenceIdLangueIdCompoundUniqueInput = {
    referenceTable: $Enums.reference_table
    referenceId: bigint | number
    langueId: number
  }

  export type translationCountOrderByAggregateInput = {
    langueId?: SortOrder
    referenceId?: SortOrder
    referenceTable?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type translationAvgOrderByAggregateInput = {
    langueId?: SortOrder
    referenceId?: SortOrder
  }

  export type translationMaxOrderByAggregateInput = {
    langueId?: SortOrder
    referenceId?: SortOrder
    referenceTable?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type translationMinOrderByAggregateInput = {
    langueId?: SortOrder
    referenceId?: SortOrder
    referenceTable?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type translationSumOrderByAggregateInput = {
    langueId?: SortOrder
    referenceId?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type Enumreference_tableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.reference_table | Enumreference_tableFieldRefInput<$PrismaModel>
    in?: $Enums.reference_table[]
    notIn?: $Enums.reference_table[]
    not?: NestedEnumreference_tableWithAggregatesFilter<$PrismaModel> | $Enums.reference_table
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreference_tableFilter<$PrismaModel>
    _max?: NestedEnumreference_tableFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type EnumroleFilter<$PrismaModel = never> = {
    equals?: $Enums.role | EnumroleFieldRefInput<$PrismaModel>
    in?: $Enums.role[]
    notIn?: $Enums.role[]
    not?: NestedEnumroleFilter<$PrismaModel> | $Enums.role
  }

  export type Owned_pokemonListRelationFilter = {
    every?: owned_pokemonWhereInput
    some?: owned_pokemonWhereInput
    none?: owned_pokemonWhereInput
  }

  export type Refresh_tokenListRelationFilter = {
    every?: refresh_tokenWhereInput
    some?: refresh_tokenWhereInput
    none?: refresh_tokenWhereInput
  }

  export type owned_pokemonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type refresh_tokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userOrderByRelevanceInput = {
    fields: userOrderByRelevanceFieldEnum | userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    pseudonym?: SortOrder
    role?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    pseudonym?: SortOrder
    role?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    pseudonym?: SortOrder
    role?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type EnumroleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.role | EnumroleFieldRefInput<$PrismaModel>
    in?: $Enums.role[]
    notIn?: $Enums.role[]
    not?: NestedEnumroleWithAggregatesFilter<$PrismaModel> | $Enums.role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroleFilter<$PrismaModel>
    _max?: NestedEnumroleFilter<$PrismaModel>
  }

  export type Shiny_hunting_method_gameListRelationFilter = {
    every?: shiny_hunting_method_gameWhereInput
    some?: shiny_hunting_method_gameWhereInput
    none?: shiny_hunting_method_gameWhereInput
  }

  export type Shiny_hunting_method_rateListRelationFilter = {
    every?: shiny_hunting_method_rateWhereInput
    some?: shiny_hunting_method_rateWhereInput
    none?: shiny_hunting_method_rateWhereInput
  }

  export type shiny_hunting_method_gameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type shiny_hunting_method_rateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type shiny_hunting_methodOrderByRelevanceInput = {
    fields: shiny_hunting_methodOrderByRelevanceFieldEnum | shiny_hunting_methodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type shiny_hunting_methodCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type shiny_hunting_methodAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type shiny_hunting_methodMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type shiny_hunting_methodMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type shiny_hunting_methodSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Owned_pokemon_detailListRelationFilter = {
    every?: owned_pokemon_detailWhereInput
    some?: owned_pokemon_detailWhereInput
    none?: owned_pokemon_detailWhereInput
  }

  export type owned_pokemon_detailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pokeballOrderByRelevanceInput = {
    fields: pokeballOrderByRelevanceFieldEnum | pokeballOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type pokeballCountOrderByAggregateInput = {
    id?: SortOrder
    picture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokeballAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pokeballMaxOrderByAggregateInput = {
    id?: SortOrder
    picture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokeballMinOrderByAggregateInput = {
    id?: SortOrder
    picture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokeballSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AbilityListRelationFilter = {
    every?: abilityWhereInput
    some?: abilityWhereInput
    none?: abilityWhereInput
  }

  export type Ability_infoListRelationFilter = {
    every?: ability_infoWhereInput
    some?: ability_infoWhereInput
    none?: ability_infoWhereInput
  }

  export type GameListRelationFilter = {
    every?: gameWhereInput
    some?: gameWhereInput
    none?: gameWhereInput
  }

  export type PokemonListRelationFilter = {
    every?: pokemonWhereInput
    some?: pokemonWhereInput
    none?: pokemonWhereInput
  }

  export type Pokemon_infoListRelationFilter = {
    every?: pokemon_infoWhereInput
    some?: pokemon_infoWhereInput
    none?: pokemon_infoWhereInput
  }

  export type abilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ability_infoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pokemonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pokemon_infoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type generationOrderByRelevanceInput = {
    fields: generationOrderByRelevanceFieldEnum | generationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type generationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type generationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type generationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type generationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type generationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GenerationScalarRelationFilter = {
    is?: generationWhereInput
    isNot?: generationWhereInput
  }

  export type Game_group_gameListRelationFilter = {
    every?: game_group_gameWhereInput
    some?: game_group_gameWhereInput
    none?: game_group_gameWhereInput
  }

  export type Pokemon_game_locationListRelationFilter = {
    every?: pokemon_game_locationWhereInput
    some?: pokemon_game_locationWhereInput
    none?: pokemon_game_locationWhereInput
  }

  export type game_group_gameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pokemon_game_locationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gameOrderByRelevanceInput = {
    fields: gameOrderByRelevanceFieldEnum | gameOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type gameCountOrderByAggregateInput = {
    id?: SortOrder
    generationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type gameAvgOrderByAggregateInput = {
    id?: SortOrder
    generationId?: SortOrder
  }

  export type gameMaxOrderByAggregateInput = {
    id?: SortOrder
    generationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type gameMinOrderByAggregateInput = {
    id?: SortOrder
    generationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type gameSumOrderByAggregateInput = {
    id?: SortOrder
    generationId?: SortOrder
  }

  export type GameScalarRelationFilter = {
    is?: gameWhereInput
    isNot?: gameWhereInput
  }

  export type Group_gameScalarRelationFilter = {
    is?: group_gameWhereInput
    isNot?: group_gameWhereInput
  }

  export type LandScalarRelationFilter = {
    is?: landWhereInput
    isNot?: landWhereInput
  }

  export type game_group_gameGameIdGroupGameIdLandIdCompoundUniqueInput = {
    gameId: number
    groupGameId: number
    landId: number
  }

  export type game_group_gameCountOrderByAggregateInput = {
    gameId?: SortOrder
    groupGameId?: SortOrder
    landId?: SortOrder
  }

  export type game_group_gameAvgOrderByAggregateInput = {
    gameId?: SortOrder
    groupGameId?: SortOrder
    landId?: SortOrder
  }

  export type game_group_gameMaxOrderByAggregateInput = {
    gameId?: SortOrder
    groupGameId?: SortOrder
    landId?: SortOrder
  }

  export type game_group_gameMinOrderByAggregateInput = {
    gameId?: SortOrder
    groupGameId?: SortOrder
    landId?: SortOrder
  }

  export type game_group_gameSumOrderByAggregateInput = {
    gameId?: SortOrder
    groupGameId?: SortOrder
    landId?: SortOrder
  }

  export type Capsule_game_capacity_infoListRelationFilter = {
    every?: capsule_game_capacity_infoWhereInput
    some?: capsule_game_capacity_infoWhereInput
    none?: capsule_game_capacity_infoWhereInput
  }

  export type National_numberListRelationFilter = {
    every?: national_numberWhereInput
    some?: national_numberWhereInput
    none?: national_numberWhereInput
  }

  export type Skill_obtationListRelationFilter = {
    every?: skill_obtationWhereInput
    some?: skill_obtationWhereInput
    none?: skill_obtationWhereInput
  }

  export type Statistic_group_gameListRelationFilter = {
    every?: statistic_group_gameWhereInput
    some?: statistic_group_gameWhereInput
    none?: statistic_group_gameWhereInput
  }

  export type capsule_game_capacity_infoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type national_numberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type skill_obtationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type statistic_group_gameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type group_gameOrderByRelevanceInput = {
    fields: group_gameOrderByRelevanceFieldEnum | group_gameOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type group_gameCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type group_gameAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type group_gameMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type group_gameMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type group_gameSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Capacity_infoScalarRelationFilter = {
    is?: capacity_infoWhereInput
    isNot?: capacity_infoWhereInput
  }

  export type CapsuleScalarRelationFilter = {
    is?: capsuleWhereInput
    isNot?: capsuleWhereInput
  }

  export type capsule_game_capacity_infoCapacityInfoIdGroupeGameIdCompoundUniqueInput = {
    capacityInfoId: number
    groupeGameId: number
  }

  export type capsule_game_capacity_infoCountOrderByAggregateInput = {
    capacityInfoId?: SortOrder
    capsuleId?: SortOrder
    groupeGameId?: SortOrder
  }

  export type capsule_game_capacity_infoAvgOrderByAggregateInput = {
    capacityInfoId?: SortOrder
    capsuleId?: SortOrder
    groupeGameId?: SortOrder
  }

  export type capsule_game_capacity_infoMaxOrderByAggregateInput = {
    capacityInfoId?: SortOrder
    capsuleId?: SortOrder
    groupeGameId?: SortOrder
  }

  export type capsule_game_capacity_infoMinOrderByAggregateInput = {
    capacityInfoId?: SortOrder
    capsuleId?: SortOrder
    groupeGameId?: SortOrder
  }

  export type capsule_game_capacity_infoSumOrderByAggregateInput = {
    capacityInfoId?: SortOrder
    capsuleId?: SortOrder
    groupeGameId?: SortOrder
  }

  export type pokemon_categoryOrderByRelevanceInput = {
    fields: pokemon_categoryOrderByRelevanceFieldEnum | pokemon_categoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type pokemon_categoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokemon_categoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pokemon_categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokemon_categoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokemon_categorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Pokemon_categoryScalarRelationFilter = {
    is?: pokemon_categoryWhereInput
    isNot?: pokemon_categoryWhereInput
  }

  export type Pokemon_formListRelationFilter = {
    every?: pokemon_formWhereInput
    some?: pokemon_formWhereInput
    none?: pokemon_formWhereInput
  }

  export type pokemon_formOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pokemonOrderByRelevanceInput = {
    fields: pokemonOrderByRelevanceFieldEnum | pokemonOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type pokemonCountOrderByAggregateInput = {
    id?: SortOrder
    internationalNumber?: SortOrder
    hatchingCycle?: SortOrder
    globalXp?: SortOrder
    captureRate?: SortOrder
    callHelpRate?: SortOrder
    size?: SortOrder
    weight?: SortOrder
    maleRate?: SortOrder
    femelleRate?: SortOrder
    pokemonCategoryId?: SortOrder
    generationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokemonAvgOrderByAggregateInput = {
    id?: SortOrder
    internationalNumber?: SortOrder
    hatchingCycle?: SortOrder
    globalXp?: SortOrder
    captureRate?: SortOrder
    callHelpRate?: SortOrder
    size?: SortOrder
    weight?: SortOrder
    maleRate?: SortOrder
    femelleRate?: SortOrder
    pokemonCategoryId?: SortOrder
    generationId?: SortOrder
  }

  export type pokemonMaxOrderByAggregateInput = {
    id?: SortOrder
    internationalNumber?: SortOrder
    hatchingCycle?: SortOrder
    globalXp?: SortOrder
    captureRate?: SortOrder
    callHelpRate?: SortOrder
    size?: SortOrder
    weight?: SortOrder
    maleRate?: SortOrder
    femelleRate?: SortOrder
    pokemonCategoryId?: SortOrder
    generationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokemonMinOrderByAggregateInput = {
    id?: SortOrder
    internationalNumber?: SortOrder
    hatchingCycle?: SortOrder
    globalXp?: SortOrder
    captureRate?: SortOrder
    callHelpRate?: SortOrder
    size?: SortOrder
    weight?: SortOrder
    maleRate?: SortOrder
    femelleRate?: SortOrder
    pokemonCategoryId?: SortOrder
    generationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokemonSumOrderByAggregateInput = {
    id?: SortOrder
    internationalNumber?: SortOrder
    hatchingCycle?: SortOrder
    globalXp?: SortOrder
    captureRate?: SortOrder
    callHelpRate?: SortOrder
    size?: SortOrder
    weight?: SortOrder
    maleRate?: SortOrder
    femelleRate?: SortOrder
    pokemonCategoryId?: SortOrder
    generationId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Pokemon_form_genderListRelationFilter = {
    every?: pokemon_form_genderWhereInput
    some?: pokemon_form_genderWhereInput
    none?: pokemon_form_genderWhereInput
  }

  export type pokemon_form_genderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type genderOrderByRelevanceInput = {
    fields: genderOrderByRelevanceFieldEnum | genderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type genderCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type genderAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type genderMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type genderMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type genderSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type formOrderByRelevanceInput = {
    fields: formOrderByRelevanceFieldEnum | formOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type formCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type formAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type formMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type formMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type formSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GenderScalarRelationFilter = {
    is?: genderWhereInput
    isNot?: genderWhereInput
  }

  export type Pokemon_formScalarRelationFilter = {
    is?: pokemon_formWhereInput
    isNot?: pokemon_formWhereInput
  }

  export type pokemon_form_genderGenderIdPokemonFormIdCompoundUniqueInput = {
    genderId: number
    pokemonFormId: number
  }

  export type pokemon_form_genderCountOrderByAggregateInput = {
    pokemonFormId?: SortOrder
    genderId?: SortOrder
  }

  export type pokemon_form_genderAvgOrderByAggregateInput = {
    pokemonFormId?: SortOrder
    genderId?: SortOrder
  }

  export type pokemon_form_genderMaxOrderByAggregateInput = {
    pokemonFormId?: SortOrder
    genderId?: SortOrder
  }

  export type pokemon_form_genderMinOrderByAggregateInput = {
    pokemonFormId?: SortOrder
    genderId?: SortOrder
  }

  export type pokemon_form_genderSumOrderByAggregateInput = {
    pokemonFormId?: SortOrder
    genderId?: SortOrder
  }

  export type EvolutionListRelationFilter = {
    every?: evolutionWhereInput
    some?: evolutionWhereInput
    none?: evolutionWhereInput
  }

  export type FormScalarRelationFilter = {
    is?: formWhereInput
    isNot?: formWhereInput
  }

  export type PokemonScalarRelationFilter = {
    is?: pokemonWhereInput
    isNot?: pokemonWhereInput
  }

  export type evolutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pokemon_formOrderByRelevanceInput = {
    fields: pokemon_formOrderByRelevanceFieldEnum | pokemon_formOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type pokemon_formPokemonIdFormIdCompoundUniqueInput = {
    pokemonId: number
    formId: number
  }

  export type pokemon_formCountOrderByAggregateInput = {
    pokemonId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    id?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
  }

  export type pokemon_formAvgOrderByAggregateInput = {
    pokemonId?: SortOrder
    formId?: SortOrder
    id?: SortOrder
  }

  export type pokemon_formMaxOrderByAggregateInput = {
    pokemonId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    id?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
  }

  export type pokemon_formMinOrderByAggregateInput = {
    pokemonId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    id?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
  }

  export type pokemon_formSumOrderByAggregateInput = {
    pokemonId?: SortOrder
    formId?: SortOrder
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Shiny_hunting_methodScalarRelationFilter = {
    is?: shiny_hunting_methodWhereInput
    isNot?: shiny_hunting_methodWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type owned_pokemonOrderByRelevanceInput = {
    fields: owned_pokemonOrderByRelevanceFieldEnum | owned_pokemonOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type owned_pokemonCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pokemonFormId?: SortOrder
    gameId?: SortOrder
    isShiny?: SortOrder
    methodId?: SortOrder
    meetingNumber?: SortOrder
    time?: SortOrder
    isFinish?: SortOrder
    useCharmChroma?: SortOrder
    creationDate?: SortOrder
    finishDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type owned_pokemonAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pokemonFormId?: SortOrder
    gameId?: SortOrder
    methodId?: SortOrder
    meetingNumber?: SortOrder
  }

  export type owned_pokemonMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pokemonFormId?: SortOrder
    gameId?: SortOrder
    isShiny?: SortOrder
    methodId?: SortOrder
    meetingNumber?: SortOrder
    time?: SortOrder
    isFinish?: SortOrder
    useCharmChroma?: SortOrder
    creationDate?: SortOrder
    finishDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type owned_pokemonMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pokemonFormId?: SortOrder
    gameId?: SortOrder
    isShiny?: SortOrder
    methodId?: SortOrder
    meetingNumber?: SortOrder
    time?: SortOrder
    isFinish?: SortOrder
    useCharmChroma?: SortOrder
    creationDate?: SortOrder
    finishDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type owned_pokemonSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pokemonFormId?: SortOrder
    gameId?: SortOrder
    methodId?: SortOrder
    meetingNumber?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Owned_pokemonScalarRelationFilter = {
    is?: owned_pokemonWhereInput
    isNot?: owned_pokemonWhereInput
  }

  export type PokeballScalarRelationFilter = {
    is?: pokeballWhereInput
    isNot?: pokeballWhereInput
  }

  export type owned_pokemon_detailOrderByRelevanceInput = {
    fields: owned_pokemon_detailOrderByRelevanceFieldEnum | owned_pokemon_detailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type owned_pokemon_detailCountOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    pokeballId?: SortOrder
    ownedPokemonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type owned_pokemon_detailAvgOrderByAggregateInput = {
    id?: SortOrder
    pokeballId?: SortOrder
    ownedPokemonId?: SortOrder
  }

  export type owned_pokemon_detailMaxOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    pokeballId?: SortOrder
    ownedPokemonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type owned_pokemon_detailMinOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    pokeballId?: SortOrder
    ownedPokemonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type owned_pokemon_detailSumOrderByAggregateInput = {
    id?: SortOrder
    pokeballId?: SortOrder
    ownedPokemonId?: SortOrder
  }

  export type Ability_orderListRelationFilter = {
    every?: ability_orderWhereInput
    some?: ability_orderWhereInput
    none?: ability_orderWhereInput
  }

  export type ability_orderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type abilityOrderByRelevanceInput = {
    fields: abilityOrderByRelevanceFieldEnum | abilityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type abilityCountOrderByAggregateInput = {
    id?: SortOrder
    appearanceGenerationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type abilityAvgOrderByAggregateInput = {
    id?: SortOrder
    appearanceGenerationId?: SortOrder
  }

  export type abilityMaxOrderByAggregateInput = {
    id?: SortOrder
    appearanceGenerationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type abilityMinOrderByAggregateInput = {
    id?: SortOrder
    appearanceGenerationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type abilitySumOrderByAggregateInput = {
    id?: SortOrder
    appearanceGenerationId?: SortOrder
  }

  export type AbilityScalarRelationFilter = {
    is?: abilityWhereInput
    isNot?: abilityWhereInput
  }

  export type Effect_outside_fightScalarRelationFilter = {
    is?: effect_outside_fightWhereInput
    isNot?: effect_outside_fightWhereInput
  }

  export type ability_infoOrderByRelevanceInput = {
    fields: ability_infoOrderByRelevanceFieldEnum | ability_infoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ability_infoCountOrderByAggregateInput = {
    id?: SortOrder
    generationId?: SortOrder
    abilityId?: SortOrder
    effectOutsideFightId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ability_infoAvgOrderByAggregateInput = {
    id?: SortOrder
    generationId?: SortOrder
    abilityId?: SortOrder
    effectOutsideFightId?: SortOrder
  }

  export type ability_infoMaxOrderByAggregateInput = {
    id?: SortOrder
    generationId?: SortOrder
    abilityId?: SortOrder
    effectOutsideFightId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ability_infoMinOrderByAggregateInput = {
    id?: SortOrder
    generationId?: SortOrder
    abilityId?: SortOrder
    effectOutsideFightId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ability_infoSumOrderByAggregateInput = {
    id?: SortOrder
    generationId?: SortOrder
    abilityId?: SortOrder
    effectOutsideFightId?: SortOrder
  }

  export type Egg_group_orderListRelationFilter = {
    every?: egg_group_orderWhereInput
    some?: egg_group_orderWhereInput
    none?: egg_group_orderWhereInput
  }

  export type Type_orderListRelationFilter = {
    every?: type_orderWhereInput
    some?: type_orderWhereInput
    none?: type_orderWhereInput
  }

  export type egg_group_orderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type type_orderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pokemon_infoOrderByRelevanceInput = {
    fields: pokemon_infoOrderByRelevanceFieldEnum | pokemon_infoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type pokemon_infoCountOrderByAggregateInput = {
    id?: SortOrder
    xpGift?: SortOrder
    generationId?: SortOrder
    pokemonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokemon_infoAvgOrderByAggregateInput = {
    id?: SortOrder
    xpGift?: SortOrder
    generationId?: SortOrder
    pokemonId?: SortOrder
  }

  export type pokemon_infoMaxOrderByAggregateInput = {
    id?: SortOrder
    xpGift?: SortOrder
    generationId?: SortOrder
    pokemonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokemon_infoMinOrderByAggregateInput = {
    id?: SortOrder
    xpGift?: SortOrder
    generationId?: SortOrder
    pokemonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokemon_infoSumOrderByAggregateInput = {
    id?: SortOrder
    xpGift?: SortOrder
    generationId?: SortOrder
    pokemonId?: SortOrder
  }

  export type Pokemon_infoScalarRelationFilter = {
    is?: pokemon_infoWhereInput
    isNot?: pokemon_infoWhereInput
  }

  export type ability_orderAbilityIdPokemonInfoIdCompoundUniqueInput = {
    abilityId: number
    pokemonInfoId: number
  }

  export type ability_orderCountOrderByAggregateInput = {
    pokemonInfoId?: SortOrder
    abilityId?: SortOrder
    order?: SortOrder
    isHidden?: SortOrder
  }

  export type ability_orderAvgOrderByAggregateInput = {
    pokemonInfoId?: SortOrder
    abilityId?: SortOrder
    order?: SortOrder
  }

  export type ability_orderMaxOrderByAggregateInput = {
    pokemonInfoId?: SortOrder
    abilityId?: SortOrder
    order?: SortOrder
    isHidden?: SortOrder
  }

  export type ability_orderMinOrderByAggregateInput = {
    pokemonInfoId?: SortOrder
    abilityId?: SortOrder
    order?: SortOrder
    isHidden?: SortOrder
  }

  export type ability_orderSumOrderByAggregateInput = {
    pokemonInfoId?: SortOrder
    abilityId?: SortOrder
    order?: SortOrder
  }

  export type evolution_methodOrderByRelevanceInput = {
    fields: evolution_methodOrderByRelevanceFieldEnum | evolution_methodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type evolution_methodCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type evolution_methodAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type evolution_methodMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type evolution_methodMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type evolution_methodSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Evolution_infoScalarRelationFilter = {
    is?: evolution_infoWhereInput
    isNot?: evolution_infoWhereInput
  }

  export type Evolution_methodScalarRelationFilter = {
    is?: evolution_methodWhereInput
    isNot?: evolution_methodWhereInput
  }

  export type evolutionOrderByRelevanceInput = {
    fields: evolutionOrderByRelevanceFieldEnum | evolutionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type evolutionCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    evolutionMethodId?: SortOrder
    pokemonFormStartId?: SortOrder
    pokemonFormEndId?: SortOrder
    evolutionInfoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type evolutionAvgOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    evolutionMethodId?: SortOrder
    pokemonFormStartId?: SortOrder
    pokemonFormEndId?: SortOrder
    evolutionInfoId?: SortOrder
  }

  export type evolutionMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    evolutionMethodId?: SortOrder
    pokemonFormStartId?: SortOrder
    pokemonFormEndId?: SortOrder
    evolutionInfoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type evolutionMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    evolutionMethodId?: SortOrder
    pokemonFormStartId?: SortOrder
    pokemonFormEndId?: SortOrder
    evolutionInfoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type evolutionSumOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    evolutionMethodId?: SortOrder
    pokemonFormStartId?: SortOrder
    pokemonFormEndId?: SortOrder
    evolutionInfoId?: SortOrder
  }

  export type evolution_infoOrderByRelevanceInput = {
    fields: evolution_infoOrderByRelevanceFieldEnum | evolution_infoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type evolution_infoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type evolution_infoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type evolution_infoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type evolution_infoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type evolution_infoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type egg_groupOrderByRelevanceInput = {
    fields: egg_groupOrderByRelevanceFieldEnum | egg_groupOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type egg_groupCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type egg_groupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type egg_groupMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type egg_groupMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type egg_groupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Egg_groupScalarRelationFilter = {
    is?: egg_groupWhereInput
    isNot?: egg_groupWhereInput
  }

  export type egg_group_orderEggGroupIdPokemonInfoIdCompoundUniqueInput = {
    eggGroupId: number
    pokemonInfoId: number
  }

  export type egg_group_orderCountOrderByAggregateInput = {
    pokemonInfoId?: SortOrder
    eggGroupId?: SortOrder
    order?: SortOrder
  }

  export type egg_group_orderAvgOrderByAggregateInput = {
    pokemonInfoId?: SortOrder
    eggGroupId?: SortOrder
    order?: SortOrder
  }

  export type egg_group_orderMaxOrderByAggregateInput = {
    pokemonInfoId?: SortOrder
    eggGroupId?: SortOrder
    order?: SortOrder
  }

  export type egg_group_orderMinOrderByAggregateInput = {
    pokemonInfoId?: SortOrder
    eggGroupId?: SortOrder
    order?: SortOrder
  }

  export type egg_group_orderSumOrderByAggregateInput = {
    pokemonInfoId?: SortOrder
    eggGroupId?: SortOrder
    order?: SortOrder
  }

  export type Capacity_infoListRelationFilter = {
    every?: capacity_infoWhereInput
    some?: capacity_infoWhereInput
    none?: capacity_infoWhereInput
  }

  export type capacity_infoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type typeOrderByRelevanceInput = {
    fields: typeOrderByRelevanceFieldEnum | typeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type typeCountOrderByAggregateInput = {
    id?: SortOrder
    color?: SortOrder
    iconName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type typeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type typeMaxOrderByAggregateInput = {
    id?: SortOrder
    color?: SortOrder
    iconName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type typeMinOrderByAggregateInput = {
    id?: SortOrder
    color?: SortOrder
    iconName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type typeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TypeScalarRelationFilter = {
    is?: typeWhereInput
    isNot?: typeWhereInput
  }

  export type type_orderTypeIdPokemonInfoIdCompoundUniqueInput = {
    typeId: number
    pokemonInfoId: number
  }

  export type type_orderCountOrderByAggregateInput = {
    typeId?: SortOrder
    pokemonInfoId?: SortOrder
    order?: SortOrder
  }

  export type type_orderAvgOrderByAggregateInput = {
    typeId?: SortOrder
    pokemonInfoId?: SortOrder
    order?: SortOrder
  }

  export type type_orderMaxOrderByAggregateInput = {
    typeId?: SortOrder
    pokemonInfoId?: SortOrder
    order?: SortOrder
  }

  export type type_orderMinOrderByAggregateInput = {
    typeId?: SortOrder
    pokemonInfoId?: SortOrder
    order?: SortOrder
  }

  export type type_orderSumOrderByAggregateInput = {
    typeId?: SortOrder
    pokemonInfoId?: SortOrder
    order?: SortOrder
  }

  export type national_numberPokemonIdGroupGameIdCompoundUniqueInput = {
    pokemonId: number
    groupGameId: number
  }

  export type national_numberCountOrderByAggregateInput = {
    groupGameId?: SortOrder
    pokemonId?: SortOrder
    number?: SortOrder
  }

  export type national_numberAvgOrderByAggregateInput = {
    groupGameId?: SortOrder
    pokemonId?: SortOrder
    number?: SortOrder
  }

  export type national_numberMaxOrderByAggregateInput = {
    groupGameId?: SortOrder
    pokemonId?: SortOrder
    number?: SortOrder
  }

  export type national_numberMinOrderByAggregateInput = {
    groupGameId?: SortOrder
    pokemonId?: SortOrder
    number?: SortOrder
  }

  export type national_numberSumOrderByAggregateInput = {
    groupGameId?: SortOrder
    pokemonId?: SortOrder
    number?: SortOrder
  }

  export type landOrderByRelevanceInput = {
    fields: landOrderByRelevanceFieldEnum | landOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type landCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type landAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type landMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type landMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type landSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type capacityOrderByRelevanceInput = {
    fields: capacityOrderByRelevanceFieldEnum | capacityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type capacityCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capacityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type capacityMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capacityMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capacitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type capacity_effectOrderByRelevanceInput = {
    fields: capacity_effectOrderByRelevanceFieldEnum | capacity_effectOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type capacity_effectCountOrderByAggregateInput = {
    id?: SortOrder
    zEffect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capacity_effectAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type capacity_effectMaxOrderByAggregateInput = {
    id?: SortOrder
    zEffect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capacity_effectMinOrderByAggregateInput = {
    id?: SortOrder
    zEffect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capacity_effectSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type capacity_categoryOrderByRelevanceInput = {
    fields: capacity_categoryOrderByRelevanceFieldEnum | capacity_categoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type capacity_categoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capacity_categoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type capacity_categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capacity_categoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capacity_categorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type capsuleOrderByRelevanceInput = {
    fields: capsuleOrderByRelevanceFieldEnum | capsuleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type capsuleCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capsuleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type capsuleMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capsuleMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capsuleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RateListRelationFilter = {
    every?: rateWhereInput
    some?: rateWhereInput
    none?: rateWhereInput
  }

  export type rateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type detailOrderByRelevanceInput = {
    fields: detailOrderByRelevanceFieldEnum | detailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type detailCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type detailAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type detailMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type detailMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type detailSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type effect_outside_fightOrderByRelevanceInput = {
    fields: effect_outside_fightOrderByRelevanceFieldEnum | effect_outside_fightOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type effect_outside_fightCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type effect_outside_fightAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type effect_outside_fightMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type effect_outside_fightMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type effect_outside_fightSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Capacity_info_influenceListRelationFilter = {
    every?: capacity_info_influenceWhereInput
    some?: capacity_info_influenceWhereInput
    none?: capacity_info_influenceWhereInput
  }

  export type capacity_info_influenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type influenceOrderByRelevanceInput = {
    fields: influenceOrderByRelevanceFieldEnum | influenceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type influenceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type influenceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type influenceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type influenceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type influenceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Location_zoneListRelationFilter = {
    every?: location_zoneWhereInput
    some?: location_zoneWhereInput
    none?: location_zoneWhereInput
  }

  export type location_zoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type locationOrderByRelevanceInput = {
    fields: locationOrderByRelevanceFieldEnum | locationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type locationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type locationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type locationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type locationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type locationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type zoneOrderByRelevanceInput = {
    fields: zoneOrderByRelevanceFieldEnum | zoneOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type zoneCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type zoneAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type zoneMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type zoneMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type zoneSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LocationScalarRelationFilter = {
    is?: locationWhereInput
    isNot?: locationWhereInput
  }

  export type ZoneScalarRelationFilter = {
    is?: zoneWhereInput
    isNot?: zoneWhereInput
  }

  export type location_zoneOrderByRelevanceInput = {
    fields: location_zoneOrderByRelevanceFieldEnum | location_zoneOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type location_zoneLocationIdZoneIdCompoundUniqueInput = {
    locationId: number
    zoneId: number
  }

  export type location_zoneCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type location_zoneAvgOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    zoneId?: SortOrder
  }

  export type location_zoneMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type location_zoneMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type location_zoneSumOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    zoneId?: SortOrder
  }

  export type meteoOrderByRelevanceInput = {
    fields: meteoOrderByRelevanceFieldEnum | meteoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type meteoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type meteoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type meteoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type meteoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type meteoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pokemon_obtationOrderByRelevanceInput = {
    fields: pokemon_obtationOrderByRelevanceFieldEnum | pokemon_obtationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type pokemon_obtationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokemon_obtationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pokemon_obtationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokemon_obtationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type pokemon_obtationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DetailScalarRelationFilter = {
    is?: detailWhereInput
    isNot?: detailWhereInput
  }

  export type MeteoScalarRelationFilter = {
    is?: meteoWhereInput
    isNot?: meteoWhereInput
  }

  export type rateOrderByRelevanceInput = {
    fields: rateOrderByRelevanceFieldEnum | rateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type rateCountOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    minLevel?: SortOrder
    maxLevel?: SortOrder
    limit?: SortOrder
    meteoId?: SortOrder
    detailRateId?: SortOrder
    conditionRateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    isAlpha?: SortOrder
  }

  export type rateAvgOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    minLevel?: SortOrder
    maxLevel?: SortOrder
    limit?: SortOrder
    meteoId?: SortOrder
    detailRateId?: SortOrder
    conditionRateId?: SortOrder
  }

  export type rateMaxOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    minLevel?: SortOrder
    maxLevel?: SortOrder
    limit?: SortOrder
    meteoId?: SortOrder
    detailRateId?: SortOrder
    conditionRateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    isAlpha?: SortOrder
  }

  export type rateMinOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    minLevel?: SortOrder
    maxLevel?: SortOrder
    limit?: SortOrder
    meteoId?: SortOrder
    detailRateId?: SortOrder
    conditionRateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    isAlpha?: SortOrder
  }

  export type rateSumOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    minLevel?: SortOrder
    maxLevel?: SortOrder
    limit?: SortOrder
    meteoId?: SortOrder
    detailRateId?: SortOrder
    conditionRateId?: SortOrder
  }

  export type shiny_hunting_method_gameGroupGameIdShinyHuntingMethodIdCompoundUniqueInput = {
    groupGameId: number
    shinyHuntingMethodId: number
  }

  export type shiny_hunting_method_gameCountOrderByAggregateInput = {
    shinyHuntingMethodId?: SortOrder
    groupGameId?: SortOrder
  }

  export type shiny_hunting_method_gameAvgOrderByAggregateInput = {
    shinyHuntingMethodId?: SortOrder
    groupGameId?: SortOrder
  }

  export type shiny_hunting_method_gameMaxOrderByAggregateInput = {
    shinyHuntingMethodId?: SortOrder
    groupGameId?: SortOrder
  }

  export type shiny_hunting_method_gameMinOrderByAggregateInput = {
    shinyHuntingMethodId?: SortOrder
    groupGameId?: SortOrder
  }

  export type shiny_hunting_method_gameSumOrderByAggregateInput = {
    shinyHuntingMethodId?: SortOrder
    groupGameId?: SortOrder
  }

  export type RateScalarRelationFilter = {
    is?: rateWhereInput
    isNot?: rateWhereInput
  }

  export type shiny_hunting_method_rateShinyHuntingMethodIdRateIdCompoundUniqueInput = {
    shinyHuntingMethodId: number
    rateId: number
  }

  export type shiny_hunting_method_rateCountOrderByAggregateInput = {
    shinyHuntingMethodId?: SortOrder
    rateId?: SortOrder
  }

  export type shiny_hunting_method_rateAvgOrderByAggregateInput = {
    shinyHuntingMethodId?: SortOrder
    rateId?: SortOrder
  }

  export type shiny_hunting_method_rateMaxOrderByAggregateInput = {
    shinyHuntingMethodId?: SortOrder
    rateId?: SortOrder
  }

  export type shiny_hunting_method_rateMinOrderByAggregateInput = {
    shinyHuntingMethodId?: SortOrder
    rateId?: SortOrder
  }

  export type shiny_hunting_method_rateSumOrderByAggregateInput = {
    shinyHuntingMethodId?: SortOrder
    rateId?: SortOrder
  }

  export type skill_obtation_typeOrderByRelevanceInput = {
    fields: skill_obtation_typeOrderByRelevanceFieldEnum | skill_obtation_typeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type skill_obtation_typeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type skill_obtation_typeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type skill_obtation_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type skill_obtation_typeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type skill_obtation_typeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type statisticOrderByRelevanceInput = {
    fields: statisticOrderByRelevanceFieldEnum | statisticOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type statisticCountOrderByAggregateInput = {
    id?: SortOrder
    pv?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    specialAttack?: SortOrder
    specialDefense?: SortOrder
    special?: SortOrder
    speed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type statisticAvgOrderByAggregateInput = {
    id?: SortOrder
    pv?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    specialAttack?: SortOrder
    specialDefense?: SortOrder
    special?: SortOrder
    speed?: SortOrder
  }

  export type statisticMaxOrderByAggregateInput = {
    id?: SortOrder
    pv?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    specialAttack?: SortOrder
    specialDefense?: SortOrder
    special?: SortOrder
    speed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type statisticMinOrderByAggregateInput = {
    id?: SortOrder
    pv?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    specialAttack?: SortOrder
    specialDefense?: SortOrder
    special?: SortOrder
    speed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type statisticSumOrderByAggregateInput = {
    id?: SortOrder
    pv?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    specialAttack?: SortOrder
    specialDefense?: SortOrder
    special?: SortOrder
    speed?: SortOrder
  }

  export type StatisticScalarRelationFilter = {
    is?: statisticWhereInput
    isNot?: statisticWhereInput
  }

  export type statistic_group_gamePokemonIdGroupGameIdCompoundUniqueInput = {
    pokemonId: number
    groupGameId: number
  }

  export type statistic_group_gameCountOrderByAggregateInput = {
    groupGameId?: SortOrder
    pokemonId?: SortOrder
    statisticId?: SortOrder
  }

  export type statistic_group_gameAvgOrderByAggregateInput = {
    groupGameId?: SortOrder
    pokemonId?: SortOrder
    statisticId?: SortOrder
  }

  export type statistic_group_gameMaxOrderByAggregateInput = {
    groupGameId?: SortOrder
    pokemonId?: SortOrder
    statisticId?: SortOrder
  }

  export type statistic_group_gameMinOrderByAggregateInput = {
    groupGameId?: SortOrder
    pokemonId?: SortOrder
    statisticId?: SortOrder
  }

  export type statistic_group_gameSumOrderByAggregateInput = {
    groupGameId?: SortOrder
    pokemonId?: SortOrder
    statisticId?: SortOrder
  }

  export type targetOrderByRelevanceInput = {
    fields: targetOrderByRelevanceFieldEnum | targetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type targetCountOrderByAggregateInput = {
    id?: SortOrder
    isMultiple?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type targetAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type targetMaxOrderByAggregateInput = {
    id?: SortOrder
    isMultiple?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type targetMinOrderByAggregateInput = {
    id?: SortOrder
    isMultiple?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type targetSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Capacity_categoryScalarRelationFilter = {
    is?: capacity_categoryWhereInput
    isNot?: capacity_categoryWhereInput
  }

  export type Capacity_effectScalarRelationFilter = {
    is?: capacity_effectWhereInput
    isNot?: capacity_effectWhereInput
  }

  export type CapacityScalarRelationFilter = {
    is?: capacityWhereInput
    isNot?: capacityWhereInput
  }

  export type TargetScalarRelationFilter = {
    is?: targetWhereInput
    isNot?: targetWhereInput
  }

  export type capacity_infoOrderByRelevanceInput = {
    fields: capacity_infoOrderByRelevanceFieldEnum | capacity_infoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type capacity_infoCountOrderByAggregateInput = {
    id?: SortOrder
    power?: SortOrder
    dynamaxPower?: SortOrder
    precision?: SortOrder
    pp?: SortOrder
    hasBacklash?: SortOrder
    targetId?: SortOrder
    capacityEffectId?: SortOrder
    capacityId?: SortOrder
    capacityEffectZId?: SortOrder
    typeId?: SortOrder
    effectOutsideFightId?: SortOrder
    capacityCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capacity_infoAvgOrderByAggregateInput = {
    id?: SortOrder
    power?: SortOrder
    dynamaxPower?: SortOrder
    precision?: SortOrder
    pp?: SortOrder
    targetId?: SortOrder
    capacityEffectId?: SortOrder
    capacityId?: SortOrder
    capacityEffectZId?: SortOrder
    typeId?: SortOrder
    effectOutsideFightId?: SortOrder
    capacityCategoryId?: SortOrder
  }

  export type capacity_infoMaxOrderByAggregateInput = {
    id?: SortOrder
    power?: SortOrder
    dynamaxPower?: SortOrder
    precision?: SortOrder
    pp?: SortOrder
    hasBacklash?: SortOrder
    targetId?: SortOrder
    capacityEffectId?: SortOrder
    capacityId?: SortOrder
    capacityEffectZId?: SortOrder
    typeId?: SortOrder
    effectOutsideFightId?: SortOrder
    capacityCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capacity_infoMinOrderByAggregateInput = {
    id?: SortOrder
    power?: SortOrder
    dynamaxPower?: SortOrder
    precision?: SortOrder
    pp?: SortOrder
    hasBacklash?: SortOrder
    targetId?: SortOrder
    capacityEffectId?: SortOrder
    capacityId?: SortOrder
    capacityEffectZId?: SortOrder
    typeId?: SortOrder
    effectOutsideFightId?: SortOrder
    capacityCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type capacity_infoSumOrderByAggregateInput = {
    id?: SortOrder
    power?: SortOrder
    dynamaxPower?: SortOrder
    precision?: SortOrder
    pp?: SortOrder
    targetId?: SortOrder
    capacityEffectId?: SortOrder
    capacityId?: SortOrder
    capacityEffectZId?: SortOrder
    typeId?: SortOrder
    effectOutsideFightId?: SortOrder
    capacityCategoryId?: SortOrder
  }

  export type InfluenceScalarRelationFilter = {
    is?: influenceWhereInput
    isNot?: influenceWhereInput
  }

  export type capacity_info_influenceCapacityInfoIdInfluenceIdCompoundUniqueInput = {
    capacityInfoId: number
    influenceId: number
  }

  export type capacity_info_influenceCountOrderByAggregateInput = {
    capacityInfoId?: SortOrder
    influenceId?: SortOrder
  }

  export type capacity_info_influenceAvgOrderByAggregateInput = {
    capacityInfoId?: SortOrder
    influenceId?: SortOrder
  }

  export type capacity_info_influenceMaxOrderByAggregateInput = {
    capacityInfoId?: SortOrder
    influenceId?: SortOrder
  }

  export type capacity_info_influenceMinOrderByAggregateInput = {
    capacityInfoId?: SortOrder
    influenceId?: SortOrder
  }

  export type capacity_info_influenceSumOrderByAggregateInput = {
    capacityInfoId?: SortOrder
    influenceId?: SortOrder
  }

  export type Location_zoneScalarRelationFilter = {
    is?: location_zoneWhereInput
    isNot?: location_zoneWhereInput
  }

  export type Pokemon_obtationScalarRelationFilter = {
    is?: pokemon_obtationWhereInput
    isNot?: pokemon_obtationWhereInput
  }

  export type pokemon_game_locationGameIdRateIdLocationZoneIdPokemonFormIdPokemonObtationIdCompoundUniqueInput = {
    gameId: number
    rateId: number
    locationZoneId: number
    pokemonFormId: number
    pokemonObtationId: number
  }

  export type pokemon_game_locationCountOrderByAggregateInput = {
    gameId?: SortOrder
    rateId?: SortOrder
    locationZoneId?: SortOrder
    pokemonObtationId?: SortOrder
    pokemonFormId?: SortOrder
    id?: SortOrder
  }

  export type pokemon_game_locationAvgOrderByAggregateInput = {
    gameId?: SortOrder
    rateId?: SortOrder
    locationZoneId?: SortOrder
    pokemonObtationId?: SortOrder
    pokemonFormId?: SortOrder
    id?: SortOrder
  }

  export type pokemon_game_locationMaxOrderByAggregateInput = {
    gameId?: SortOrder
    rateId?: SortOrder
    locationZoneId?: SortOrder
    pokemonObtationId?: SortOrder
    pokemonFormId?: SortOrder
    id?: SortOrder
  }

  export type pokemon_game_locationMinOrderByAggregateInput = {
    gameId?: SortOrder
    rateId?: SortOrder
    locationZoneId?: SortOrder
    pokemonObtationId?: SortOrder
    pokemonFormId?: SortOrder
    id?: SortOrder
  }

  export type pokemon_game_locationSumOrderByAggregateInput = {
    gameId?: SortOrder
    rateId?: SortOrder
    locationZoneId?: SortOrder
    pokemonObtationId?: SortOrder
    pokemonFormId?: SortOrder
    id?: SortOrder
  }

  export type Skill_obtation_typeScalarRelationFilter = {
    is?: skill_obtation_typeWhereInput
    isNot?: skill_obtation_typeWhereInput
  }

  export type skill_obtationOrderByRelevanceInput = {
    fields: skill_obtationOrderByRelevanceFieldEnum | skill_obtationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type skill_obtationPokemonIdGroupGameIdCapacityIdSkillObtationTypeIdDetailCompoundUniqueInput = {
    pokemonId: number
    groupGameId: number
    capacityId: number
    skillObtationTypeId: number
    detail: string
  }

  export type skill_obtationCountOrderByAggregateInput = {
    capacityId?: SortOrder
    pokemonId?: SortOrder
    groupGameId?: SortOrder
    skillObtationTypeId?: SortOrder
    detail?: SortOrder
  }

  export type skill_obtationAvgOrderByAggregateInput = {
    capacityId?: SortOrder
    pokemonId?: SortOrder
    groupGameId?: SortOrder
    skillObtationTypeId?: SortOrder
  }

  export type skill_obtationMaxOrderByAggregateInput = {
    capacityId?: SortOrder
    pokemonId?: SortOrder
    groupGameId?: SortOrder
    skillObtationTypeId?: SortOrder
    detail?: SortOrder
  }

  export type skill_obtationMinOrderByAggregateInput = {
    capacityId?: SortOrder
    pokemonId?: SortOrder
    groupGameId?: SortOrder
    skillObtationTypeId?: SortOrder
    detail?: SortOrder
  }

  export type skill_obtationSumOrderByAggregateInput = {
    capacityId?: SortOrder
    pokemonId?: SortOrder
    groupGameId?: SortOrder
    skillObtationTypeId?: SortOrder
  }

  export type refresh_tokenOrderByRelevanceInput = {
    fields: refresh_tokenOrderByRelevanceFieldEnum | refresh_tokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type refresh_tokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type refresh_tokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type refresh_tokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type refresh_tokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type refresh_tokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type translationCreateNestedManyWithoutLangueInput = {
    create?: XOR<translationCreateWithoutLangueInput, translationUncheckedCreateWithoutLangueInput> | translationCreateWithoutLangueInput[] | translationUncheckedCreateWithoutLangueInput[]
    connectOrCreate?: translationCreateOrConnectWithoutLangueInput | translationCreateOrConnectWithoutLangueInput[]
    createMany?: translationCreateManyLangueInputEnvelope
    connect?: translationWhereUniqueInput | translationWhereUniqueInput[]
  }

  export type translationUncheckedCreateNestedManyWithoutLangueInput = {
    create?: XOR<translationCreateWithoutLangueInput, translationUncheckedCreateWithoutLangueInput> | translationCreateWithoutLangueInput[] | translationUncheckedCreateWithoutLangueInput[]
    connectOrCreate?: translationCreateOrConnectWithoutLangueInput | translationCreateOrConnectWithoutLangueInput[]
    createMany?: translationCreateManyLangueInputEnvelope
    connect?: translationWhereUniqueInput | translationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type translationUpdateManyWithoutLangueNestedInput = {
    create?: XOR<translationCreateWithoutLangueInput, translationUncheckedCreateWithoutLangueInput> | translationCreateWithoutLangueInput[] | translationUncheckedCreateWithoutLangueInput[]
    connectOrCreate?: translationCreateOrConnectWithoutLangueInput | translationCreateOrConnectWithoutLangueInput[]
    upsert?: translationUpsertWithWhereUniqueWithoutLangueInput | translationUpsertWithWhereUniqueWithoutLangueInput[]
    createMany?: translationCreateManyLangueInputEnvelope
    set?: translationWhereUniqueInput | translationWhereUniqueInput[]
    disconnect?: translationWhereUniqueInput | translationWhereUniqueInput[]
    delete?: translationWhereUniqueInput | translationWhereUniqueInput[]
    connect?: translationWhereUniqueInput | translationWhereUniqueInput[]
    update?: translationUpdateWithWhereUniqueWithoutLangueInput | translationUpdateWithWhereUniqueWithoutLangueInput[]
    updateMany?: translationUpdateManyWithWhereWithoutLangueInput | translationUpdateManyWithWhereWithoutLangueInput[]
    deleteMany?: translationScalarWhereInput | translationScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type translationUncheckedUpdateManyWithoutLangueNestedInput = {
    create?: XOR<translationCreateWithoutLangueInput, translationUncheckedCreateWithoutLangueInput> | translationCreateWithoutLangueInput[] | translationUncheckedCreateWithoutLangueInput[]
    connectOrCreate?: translationCreateOrConnectWithoutLangueInput | translationCreateOrConnectWithoutLangueInput[]
    upsert?: translationUpsertWithWhereUniqueWithoutLangueInput | translationUpsertWithWhereUniqueWithoutLangueInput[]
    createMany?: translationCreateManyLangueInputEnvelope
    set?: translationWhereUniqueInput | translationWhereUniqueInput[]
    disconnect?: translationWhereUniqueInput | translationWhereUniqueInput[]
    delete?: translationWhereUniqueInput | translationWhereUniqueInput[]
    connect?: translationWhereUniqueInput | translationWhereUniqueInput[]
    update?: translationUpdateWithWhereUniqueWithoutLangueInput | translationUpdateWithWhereUniqueWithoutLangueInput[]
    updateMany?: translationUpdateManyWithWhereWithoutLangueInput | translationUpdateManyWithWhereWithoutLangueInput[]
    deleteMany?: translationScalarWhereInput | translationScalarWhereInput[]
  }

  export type langueCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<langueCreateWithoutTranslationsInput, langueUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: langueCreateOrConnectWithoutTranslationsInput
    connect?: langueWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type Enumreference_tableFieldUpdateOperationsInput = {
    set?: $Enums.reference_table
  }

  export type langueUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<langueCreateWithoutTranslationsInput, langueUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: langueCreateOrConnectWithoutTranslationsInput
    upsert?: langueUpsertWithoutTranslationsInput
    connect?: langueWhereUniqueInput
    update?: XOR<XOR<langueUpdateToOneWithWhereWithoutTranslationsInput, langueUpdateWithoutTranslationsInput>, langueUncheckedUpdateWithoutTranslationsInput>
  }

  export type owned_pokemonCreateNestedManyWithoutUsersInput = {
    create?: XOR<owned_pokemonCreateWithoutUsersInput, owned_pokemonUncheckedCreateWithoutUsersInput> | owned_pokemonCreateWithoutUsersInput[] | owned_pokemonUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutUsersInput | owned_pokemonCreateOrConnectWithoutUsersInput[]
    createMany?: owned_pokemonCreateManyUsersInputEnvelope
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
  }

  export type refresh_tokenCreateNestedManyWithoutUsersInput = {
    create?: XOR<refresh_tokenCreateWithoutUsersInput, refresh_tokenUncheckedCreateWithoutUsersInput> | refresh_tokenCreateWithoutUsersInput[] | refresh_tokenUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: refresh_tokenCreateOrConnectWithoutUsersInput | refresh_tokenCreateOrConnectWithoutUsersInput[]
    createMany?: refresh_tokenCreateManyUsersInputEnvelope
    connect?: refresh_tokenWhereUniqueInput | refresh_tokenWhereUniqueInput[]
  }

  export type owned_pokemonUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<owned_pokemonCreateWithoutUsersInput, owned_pokemonUncheckedCreateWithoutUsersInput> | owned_pokemonCreateWithoutUsersInput[] | owned_pokemonUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutUsersInput | owned_pokemonCreateOrConnectWithoutUsersInput[]
    createMany?: owned_pokemonCreateManyUsersInputEnvelope
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
  }

  export type refresh_tokenUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<refresh_tokenCreateWithoutUsersInput, refresh_tokenUncheckedCreateWithoutUsersInput> | refresh_tokenCreateWithoutUsersInput[] | refresh_tokenUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: refresh_tokenCreateOrConnectWithoutUsersInput | refresh_tokenCreateOrConnectWithoutUsersInput[]
    createMany?: refresh_tokenCreateManyUsersInputEnvelope
    connect?: refresh_tokenWhereUniqueInput | refresh_tokenWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumroleFieldUpdateOperationsInput = {
    set?: $Enums.role
  }

  export type owned_pokemonUpdateManyWithoutUsersNestedInput = {
    create?: XOR<owned_pokemonCreateWithoutUsersInput, owned_pokemonUncheckedCreateWithoutUsersInput> | owned_pokemonCreateWithoutUsersInput[] | owned_pokemonUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutUsersInput | owned_pokemonCreateOrConnectWithoutUsersInput[]
    upsert?: owned_pokemonUpsertWithWhereUniqueWithoutUsersInput | owned_pokemonUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: owned_pokemonCreateManyUsersInputEnvelope
    set?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    disconnect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    delete?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    update?: owned_pokemonUpdateWithWhereUniqueWithoutUsersInput | owned_pokemonUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: owned_pokemonUpdateManyWithWhereWithoutUsersInput | owned_pokemonUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: owned_pokemonScalarWhereInput | owned_pokemonScalarWhereInput[]
  }

  export type refresh_tokenUpdateManyWithoutUsersNestedInput = {
    create?: XOR<refresh_tokenCreateWithoutUsersInput, refresh_tokenUncheckedCreateWithoutUsersInput> | refresh_tokenCreateWithoutUsersInput[] | refresh_tokenUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: refresh_tokenCreateOrConnectWithoutUsersInput | refresh_tokenCreateOrConnectWithoutUsersInput[]
    upsert?: refresh_tokenUpsertWithWhereUniqueWithoutUsersInput | refresh_tokenUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: refresh_tokenCreateManyUsersInputEnvelope
    set?: refresh_tokenWhereUniqueInput | refresh_tokenWhereUniqueInput[]
    disconnect?: refresh_tokenWhereUniqueInput | refresh_tokenWhereUniqueInput[]
    delete?: refresh_tokenWhereUniqueInput | refresh_tokenWhereUniqueInput[]
    connect?: refresh_tokenWhereUniqueInput | refresh_tokenWhereUniqueInput[]
    update?: refresh_tokenUpdateWithWhereUniqueWithoutUsersInput | refresh_tokenUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: refresh_tokenUpdateManyWithWhereWithoutUsersInput | refresh_tokenUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: refresh_tokenScalarWhereInput | refresh_tokenScalarWhereInput[]
  }

  export type owned_pokemonUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<owned_pokemonCreateWithoutUsersInput, owned_pokemonUncheckedCreateWithoutUsersInput> | owned_pokemonCreateWithoutUsersInput[] | owned_pokemonUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutUsersInput | owned_pokemonCreateOrConnectWithoutUsersInput[]
    upsert?: owned_pokemonUpsertWithWhereUniqueWithoutUsersInput | owned_pokemonUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: owned_pokemonCreateManyUsersInputEnvelope
    set?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    disconnect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    delete?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    update?: owned_pokemonUpdateWithWhereUniqueWithoutUsersInput | owned_pokemonUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: owned_pokemonUpdateManyWithWhereWithoutUsersInput | owned_pokemonUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: owned_pokemonScalarWhereInput | owned_pokemonScalarWhereInput[]
  }

  export type refresh_tokenUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<refresh_tokenCreateWithoutUsersInput, refresh_tokenUncheckedCreateWithoutUsersInput> | refresh_tokenCreateWithoutUsersInput[] | refresh_tokenUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: refresh_tokenCreateOrConnectWithoutUsersInput | refresh_tokenCreateOrConnectWithoutUsersInput[]
    upsert?: refresh_tokenUpsertWithWhereUniqueWithoutUsersInput | refresh_tokenUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: refresh_tokenCreateManyUsersInputEnvelope
    set?: refresh_tokenWhereUniqueInput | refresh_tokenWhereUniqueInput[]
    disconnect?: refresh_tokenWhereUniqueInput | refresh_tokenWhereUniqueInput[]
    delete?: refresh_tokenWhereUniqueInput | refresh_tokenWhereUniqueInput[]
    connect?: refresh_tokenWhereUniqueInput | refresh_tokenWhereUniqueInput[]
    update?: refresh_tokenUpdateWithWhereUniqueWithoutUsersInput | refresh_tokenUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: refresh_tokenUpdateManyWithWhereWithoutUsersInput | refresh_tokenUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: refresh_tokenScalarWhereInput | refresh_tokenScalarWhereInput[]
  }

  export type owned_pokemonCreateNestedManyWithoutShinyHuntingMethodInput = {
    create?: XOR<owned_pokemonCreateWithoutShinyHuntingMethodInput, owned_pokemonUncheckedCreateWithoutShinyHuntingMethodInput> | owned_pokemonCreateWithoutShinyHuntingMethodInput[] | owned_pokemonUncheckedCreateWithoutShinyHuntingMethodInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutShinyHuntingMethodInput | owned_pokemonCreateOrConnectWithoutShinyHuntingMethodInput[]
    createMany?: owned_pokemonCreateManyShinyHuntingMethodInputEnvelope
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
  }

  export type shiny_hunting_method_gameCreateNestedManyWithoutShinyHuntingMethodInput = {
    create?: XOR<shiny_hunting_method_gameCreateWithoutShinyHuntingMethodInput, shiny_hunting_method_gameUncheckedCreateWithoutShinyHuntingMethodInput> | shiny_hunting_method_gameCreateWithoutShinyHuntingMethodInput[] | shiny_hunting_method_gameUncheckedCreateWithoutShinyHuntingMethodInput[]
    connectOrCreate?: shiny_hunting_method_gameCreateOrConnectWithoutShinyHuntingMethodInput | shiny_hunting_method_gameCreateOrConnectWithoutShinyHuntingMethodInput[]
    createMany?: shiny_hunting_method_gameCreateManyShinyHuntingMethodInputEnvelope
    connect?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
  }

  export type shiny_hunting_method_rateCreateNestedManyWithoutShinyHuntingMethodInput = {
    create?: XOR<shiny_hunting_method_rateCreateWithoutShinyHuntingMethodInput, shiny_hunting_method_rateUncheckedCreateWithoutShinyHuntingMethodInput> | shiny_hunting_method_rateCreateWithoutShinyHuntingMethodInput[] | shiny_hunting_method_rateUncheckedCreateWithoutShinyHuntingMethodInput[]
    connectOrCreate?: shiny_hunting_method_rateCreateOrConnectWithoutShinyHuntingMethodInput | shiny_hunting_method_rateCreateOrConnectWithoutShinyHuntingMethodInput[]
    createMany?: shiny_hunting_method_rateCreateManyShinyHuntingMethodInputEnvelope
    connect?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
  }

  export type owned_pokemonUncheckedCreateNestedManyWithoutShinyHuntingMethodInput = {
    create?: XOR<owned_pokemonCreateWithoutShinyHuntingMethodInput, owned_pokemonUncheckedCreateWithoutShinyHuntingMethodInput> | owned_pokemonCreateWithoutShinyHuntingMethodInput[] | owned_pokemonUncheckedCreateWithoutShinyHuntingMethodInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutShinyHuntingMethodInput | owned_pokemonCreateOrConnectWithoutShinyHuntingMethodInput[]
    createMany?: owned_pokemonCreateManyShinyHuntingMethodInputEnvelope
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
  }

  export type shiny_hunting_method_gameUncheckedCreateNestedManyWithoutShinyHuntingMethodInput = {
    create?: XOR<shiny_hunting_method_gameCreateWithoutShinyHuntingMethodInput, shiny_hunting_method_gameUncheckedCreateWithoutShinyHuntingMethodInput> | shiny_hunting_method_gameCreateWithoutShinyHuntingMethodInput[] | shiny_hunting_method_gameUncheckedCreateWithoutShinyHuntingMethodInput[]
    connectOrCreate?: shiny_hunting_method_gameCreateOrConnectWithoutShinyHuntingMethodInput | shiny_hunting_method_gameCreateOrConnectWithoutShinyHuntingMethodInput[]
    createMany?: shiny_hunting_method_gameCreateManyShinyHuntingMethodInputEnvelope
    connect?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
  }

  export type shiny_hunting_method_rateUncheckedCreateNestedManyWithoutShinyHuntingMethodInput = {
    create?: XOR<shiny_hunting_method_rateCreateWithoutShinyHuntingMethodInput, shiny_hunting_method_rateUncheckedCreateWithoutShinyHuntingMethodInput> | shiny_hunting_method_rateCreateWithoutShinyHuntingMethodInput[] | shiny_hunting_method_rateUncheckedCreateWithoutShinyHuntingMethodInput[]
    connectOrCreate?: shiny_hunting_method_rateCreateOrConnectWithoutShinyHuntingMethodInput | shiny_hunting_method_rateCreateOrConnectWithoutShinyHuntingMethodInput[]
    createMany?: shiny_hunting_method_rateCreateManyShinyHuntingMethodInputEnvelope
    connect?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
  }

  export type owned_pokemonUpdateManyWithoutShinyHuntingMethodNestedInput = {
    create?: XOR<owned_pokemonCreateWithoutShinyHuntingMethodInput, owned_pokemonUncheckedCreateWithoutShinyHuntingMethodInput> | owned_pokemonCreateWithoutShinyHuntingMethodInput[] | owned_pokemonUncheckedCreateWithoutShinyHuntingMethodInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutShinyHuntingMethodInput | owned_pokemonCreateOrConnectWithoutShinyHuntingMethodInput[]
    upsert?: owned_pokemonUpsertWithWhereUniqueWithoutShinyHuntingMethodInput | owned_pokemonUpsertWithWhereUniqueWithoutShinyHuntingMethodInput[]
    createMany?: owned_pokemonCreateManyShinyHuntingMethodInputEnvelope
    set?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    disconnect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    delete?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    update?: owned_pokemonUpdateWithWhereUniqueWithoutShinyHuntingMethodInput | owned_pokemonUpdateWithWhereUniqueWithoutShinyHuntingMethodInput[]
    updateMany?: owned_pokemonUpdateManyWithWhereWithoutShinyHuntingMethodInput | owned_pokemonUpdateManyWithWhereWithoutShinyHuntingMethodInput[]
    deleteMany?: owned_pokemonScalarWhereInput | owned_pokemonScalarWhereInput[]
  }

  export type shiny_hunting_method_gameUpdateManyWithoutShinyHuntingMethodNestedInput = {
    create?: XOR<shiny_hunting_method_gameCreateWithoutShinyHuntingMethodInput, shiny_hunting_method_gameUncheckedCreateWithoutShinyHuntingMethodInput> | shiny_hunting_method_gameCreateWithoutShinyHuntingMethodInput[] | shiny_hunting_method_gameUncheckedCreateWithoutShinyHuntingMethodInput[]
    connectOrCreate?: shiny_hunting_method_gameCreateOrConnectWithoutShinyHuntingMethodInput | shiny_hunting_method_gameCreateOrConnectWithoutShinyHuntingMethodInput[]
    upsert?: shiny_hunting_method_gameUpsertWithWhereUniqueWithoutShinyHuntingMethodInput | shiny_hunting_method_gameUpsertWithWhereUniqueWithoutShinyHuntingMethodInput[]
    createMany?: shiny_hunting_method_gameCreateManyShinyHuntingMethodInputEnvelope
    set?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    disconnect?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    delete?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    connect?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    update?: shiny_hunting_method_gameUpdateWithWhereUniqueWithoutShinyHuntingMethodInput | shiny_hunting_method_gameUpdateWithWhereUniqueWithoutShinyHuntingMethodInput[]
    updateMany?: shiny_hunting_method_gameUpdateManyWithWhereWithoutShinyHuntingMethodInput | shiny_hunting_method_gameUpdateManyWithWhereWithoutShinyHuntingMethodInput[]
    deleteMany?: shiny_hunting_method_gameScalarWhereInput | shiny_hunting_method_gameScalarWhereInput[]
  }

  export type shiny_hunting_method_rateUpdateManyWithoutShinyHuntingMethodNestedInput = {
    create?: XOR<shiny_hunting_method_rateCreateWithoutShinyHuntingMethodInput, shiny_hunting_method_rateUncheckedCreateWithoutShinyHuntingMethodInput> | shiny_hunting_method_rateCreateWithoutShinyHuntingMethodInput[] | shiny_hunting_method_rateUncheckedCreateWithoutShinyHuntingMethodInput[]
    connectOrCreate?: shiny_hunting_method_rateCreateOrConnectWithoutShinyHuntingMethodInput | shiny_hunting_method_rateCreateOrConnectWithoutShinyHuntingMethodInput[]
    upsert?: shiny_hunting_method_rateUpsertWithWhereUniqueWithoutShinyHuntingMethodInput | shiny_hunting_method_rateUpsertWithWhereUniqueWithoutShinyHuntingMethodInput[]
    createMany?: shiny_hunting_method_rateCreateManyShinyHuntingMethodInputEnvelope
    set?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    disconnect?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    delete?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    connect?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    update?: shiny_hunting_method_rateUpdateWithWhereUniqueWithoutShinyHuntingMethodInput | shiny_hunting_method_rateUpdateWithWhereUniqueWithoutShinyHuntingMethodInput[]
    updateMany?: shiny_hunting_method_rateUpdateManyWithWhereWithoutShinyHuntingMethodInput | shiny_hunting_method_rateUpdateManyWithWhereWithoutShinyHuntingMethodInput[]
    deleteMany?: shiny_hunting_method_rateScalarWhereInput | shiny_hunting_method_rateScalarWhereInput[]
  }

  export type owned_pokemonUncheckedUpdateManyWithoutShinyHuntingMethodNestedInput = {
    create?: XOR<owned_pokemonCreateWithoutShinyHuntingMethodInput, owned_pokemonUncheckedCreateWithoutShinyHuntingMethodInput> | owned_pokemonCreateWithoutShinyHuntingMethodInput[] | owned_pokemonUncheckedCreateWithoutShinyHuntingMethodInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutShinyHuntingMethodInput | owned_pokemonCreateOrConnectWithoutShinyHuntingMethodInput[]
    upsert?: owned_pokemonUpsertWithWhereUniqueWithoutShinyHuntingMethodInput | owned_pokemonUpsertWithWhereUniqueWithoutShinyHuntingMethodInput[]
    createMany?: owned_pokemonCreateManyShinyHuntingMethodInputEnvelope
    set?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    disconnect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    delete?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    update?: owned_pokemonUpdateWithWhereUniqueWithoutShinyHuntingMethodInput | owned_pokemonUpdateWithWhereUniqueWithoutShinyHuntingMethodInput[]
    updateMany?: owned_pokemonUpdateManyWithWhereWithoutShinyHuntingMethodInput | owned_pokemonUpdateManyWithWhereWithoutShinyHuntingMethodInput[]
    deleteMany?: owned_pokemonScalarWhereInput | owned_pokemonScalarWhereInput[]
  }

  export type shiny_hunting_method_gameUncheckedUpdateManyWithoutShinyHuntingMethodNestedInput = {
    create?: XOR<shiny_hunting_method_gameCreateWithoutShinyHuntingMethodInput, shiny_hunting_method_gameUncheckedCreateWithoutShinyHuntingMethodInput> | shiny_hunting_method_gameCreateWithoutShinyHuntingMethodInput[] | shiny_hunting_method_gameUncheckedCreateWithoutShinyHuntingMethodInput[]
    connectOrCreate?: shiny_hunting_method_gameCreateOrConnectWithoutShinyHuntingMethodInput | shiny_hunting_method_gameCreateOrConnectWithoutShinyHuntingMethodInput[]
    upsert?: shiny_hunting_method_gameUpsertWithWhereUniqueWithoutShinyHuntingMethodInput | shiny_hunting_method_gameUpsertWithWhereUniqueWithoutShinyHuntingMethodInput[]
    createMany?: shiny_hunting_method_gameCreateManyShinyHuntingMethodInputEnvelope
    set?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    disconnect?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    delete?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    connect?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    update?: shiny_hunting_method_gameUpdateWithWhereUniqueWithoutShinyHuntingMethodInput | shiny_hunting_method_gameUpdateWithWhereUniqueWithoutShinyHuntingMethodInput[]
    updateMany?: shiny_hunting_method_gameUpdateManyWithWhereWithoutShinyHuntingMethodInput | shiny_hunting_method_gameUpdateManyWithWhereWithoutShinyHuntingMethodInput[]
    deleteMany?: shiny_hunting_method_gameScalarWhereInput | shiny_hunting_method_gameScalarWhereInput[]
  }

  export type shiny_hunting_method_rateUncheckedUpdateManyWithoutShinyHuntingMethodNestedInput = {
    create?: XOR<shiny_hunting_method_rateCreateWithoutShinyHuntingMethodInput, shiny_hunting_method_rateUncheckedCreateWithoutShinyHuntingMethodInput> | shiny_hunting_method_rateCreateWithoutShinyHuntingMethodInput[] | shiny_hunting_method_rateUncheckedCreateWithoutShinyHuntingMethodInput[]
    connectOrCreate?: shiny_hunting_method_rateCreateOrConnectWithoutShinyHuntingMethodInput | shiny_hunting_method_rateCreateOrConnectWithoutShinyHuntingMethodInput[]
    upsert?: shiny_hunting_method_rateUpsertWithWhereUniqueWithoutShinyHuntingMethodInput | shiny_hunting_method_rateUpsertWithWhereUniqueWithoutShinyHuntingMethodInput[]
    createMany?: shiny_hunting_method_rateCreateManyShinyHuntingMethodInputEnvelope
    set?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    disconnect?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    delete?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    connect?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    update?: shiny_hunting_method_rateUpdateWithWhereUniqueWithoutShinyHuntingMethodInput | shiny_hunting_method_rateUpdateWithWhereUniqueWithoutShinyHuntingMethodInput[]
    updateMany?: shiny_hunting_method_rateUpdateManyWithWhereWithoutShinyHuntingMethodInput | shiny_hunting_method_rateUpdateManyWithWhereWithoutShinyHuntingMethodInput[]
    deleteMany?: shiny_hunting_method_rateScalarWhereInput | shiny_hunting_method_rateScalarWhereInput[]
  }

  export type owned_pokemon_detailCreateNestedManyWithoutPokeballInput = {
    create?: XOR<owned_pokemon_detailCreateWithoutPokeballInput, owned_pokemon_detailUncheckedCreateWithoutPokeballInput> | owned_pokemon_detailCreateWithoutPokeballInput[] | owned_pokemon_detailUncheckedCreateWithoutPokeballInput[]
    connectOrCreate?: owned_pokemon_detailCreateOrConnectWithoutPokeballInput | owned_pokemon_detailCreateOrConnectWithoutPokeballInput[]
    createMany?: owned_pokemon_detailCreateManyPokeballInputEnvelope
    connect?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
  }

  export type owned_pokemon_detailUncheckedCreateNestedManyWithoutPokeballInput = {
    create?: XOR<owned_pokemon_detailCreateWithoutPokeballInput, owned_pokemon_detailUncheckedCreateWithoutPokeballInput> | owned_pokemon_detailCreateWithoutPokeballInput[] | owned_pokemon_detailUncheckedCreateWithoutPokeballInput[]
    connectOrCreate?: owned_pokemon_detailCreateOrConnectWithoutPokeballInput | owned_pokemon_detailCreateOrConnectWithoutPokeballInput[]
    createMany?: owned_pokemon_detailCreateManyPokeballInputEnvelope
    connect?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
  }

  export type owned_pokemon_detailUpdateManyWithoutPokeballNestedInput = {
    create?: XOR<owned_pokemon_detailCreateWithoutPokeballInput, owned_pokemon_detailUncheckedCreateWithoutPokeballInput> | owned_pokemon_detailCreateWithoutPokeballInput[] | owned_pokemon_detailUncheckedCreateWithoutPokeballInput[]
    connectOrCreate?: owned_pokemon_detailCreateOrConnectWithoutPokeballInput | owned_pokemon_detailCreateOrConnectWithoutPokeballInput[]
    upsert?: owned_pokemon_detailUpsertWithWhereUniqueWithoutPokeballInput | owned_pokemon_detailUpsertWithWhereUniqueWithoutPokeballInput[]
    createMany?: owned_pokemon_detailCreateManyPokeballInputEnvelope
    set?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    disconnect?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    delete?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    connect?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    update?: owned_pokemon_detailUpdateWithWhereUniqueWithoutPokeballInput | owned_pokemon_detailUpdateWithWhereUniqueWithoutPokeballInput[]
    updateMany?: owned_pokemon_detailUpdateManyWithWhereWithoutPokeballInput | owned_pokemon_detailUpdateManyWithWhereWithoutPokeballInput[]
    deleteMany?: owned_pokemon_detailScalarWhereInput | owned_pokemon_detailScalarWhereInput[]
  }

  export type owned_pokemon_detailUncheckedUpdateManyWithoutPokeballNestedInput = {
    create?: XOR<owned_pokemon_detailCreateWithoutPokeballInput, owned_pokemon_detailUncheckedCreateWithoutPokeballInput> | owned_pokemon_detailCreateWithoutPokeballInput[] | owned_pokemon_detailUncheckedCreateWithoutPokeballInput[]
    connectOrCreate?: owned_pokemon_detailCreateOrConnectWithoutPokeballInput | owned_pokemon_detailCreateOrConnectWithoutPokeballInput[]
    upsert?: owned_pokemon_detailUpsertWithWhereUniqueWithoutPokeballInput | owned_pokemon_detailUpsertWithWhereUniqueWithoutPokeballInput[]
    createMany?: owned_pokemon_detailCreateManyPokeballInputEnvelope
    set?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    disconnect?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    delete?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    connect?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    update?: owned_pokemon_detailUpdateWithWhereUniqueWithoutPokeballInput | owned_pokemon_detailUpdateWithWhereUniqueWithoutPokeballInput[]
    updateMany?: owned_pokemon_detailUpdateManyWithWhereWithoutPokeballInput | owned_pokemon_detailUpdateManyWithWhereWithoutPokeballInput[]
    deleteMany?: owned_pokemon_detailScalarWhereInput | owned_pokemon_detailScalarWhereInput[]
  }

  export type abilityCreateNestedManyWithoutGenerationInput = {
    create?: XOR<abilityCreateWithoutGenerationInput, abilityUncheckedCreateWithoutGenerationInput> | abilityCreateWithoutGenerationInput[] | abilityUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: abilityCreateOrConnectWithoutGenerationInput | abilityCreateOrConnectWithoutGenerationInput[]
    createMany?: abilityCreateManyGenerationInputEnvelope
    connect?: abilityWhereUniqueInput | abilityWhereUniqueInput[]
  }

  export type ability_infoCreateNestedManyWithoutGenerationInput = {
    create?: XOR<ability_infoCreateWithoutGenerationInput, ability_infoUncheckedCreateWithoutGenerationInput> | ability_infoCreateWithoutGenerationInput[] | ability_infoUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: ability_infoCreateOrConnectWithoutGenerationInput | ability_infoCreateOrConnectWithoutGenerationInput[]
    createMany?: ability_infoCreateManyGenerationInputEnvelope
    connect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
  }

  export type gameCreateNestedManyWithoutGenerationInput = {
    create?: XOR<gameCreateWithoutGenerationInput, gameUncheckedCreateWithoutGenerationInput> | gameCreateWithoutGenerationInput[] | gameUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: gameCreateOrConnectWithoutGenerationInput | gameCreateOrConnectWithoutGenerationInput[]
    createMany?: gameCreateManyGenerationInputEnvelope
    connect?: gameWhereUniqueInput | gameWhereUniqueInput[]
  }

  export type pokemonCreateNestedManyWithoutGenerationInput = {
    create?: XOR<pokemonCreateWithoutGenerationInput, pokemonUncheckedCreateWithoutGenerationInput> | pokemonCreateWithoutGenerationInput[] | pokemonUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: pokemonCreateOrConnectWithoutGenerationInput | pokemonCreateOrConnectWithoutGenerationInput[]
    createMany?: pokemonCreateManyGenerationInputEnvelope
    connect?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
  }

  export type pokemon_infoCreateNestedManyWithoutGenerationInput = {
    create?: XOR<pokemon_infoCreateWithoutGenerationInput, pokemon_infoUncheckedCreateWithoutGenerationInput> | pokemon_infoCreateWithoutGenerationInput[] | pokemon_infoUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: pokemon_infoCreateOrConnectWithoutGenerationInput | pokemon_infoCreateOrConnectWithoutGenerationInput[]
    createMany?: pokemon_infoCreateManyGenerationInputEnvelope
    connect?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
  }

  export type abilityUncheckedCreateNestedManyWithoutGenerationInput = {
    create?: XOR<abilityCreateWithoutGenerationInput, abilityUncheckedCreateWithoutGenerationInput> | abilityCreateWithoutGenerationInput[] | abilityUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: abilityCreateOrConnectWithoutGenerationInput | abilityCreateOrConnectWithoutGenerationInput[]
    createMany?: abilityCreateManyGenerationInputEnvelope
    connect?: abilityWhereUniqueInput | abilityWhereUniqueInput[]
  }

  export type ability_infoUncheckedCreateNestedManyWithoutGenerationInput = {
    create?: XOR<ability_infoCreateWithoutGenerationInput, ability_infoUncheckedCreateWithoutGenerationInput> | ability_infoCreateWithoutGenerationInput[] | ability_infoUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: ability_infoCreateOrConnectWithoutGenerationInput | ability_infoCreateOrConnectWithoutGenerationInput[]
    createMany?: ability_infoCreateManyGenerationInputEnvelope
    connect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
  }

  export type gameUncheckedCreateNestedManyWithoutGenerationInput = {
    create?: XOR<gameCreateWithoutGenerationInput, gameUncheckedCreateWithoutGenerationInput> | gameCreateWithoutGenerationInput[] | gameUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: gameCreateOrConnectWithoutGenerationInput | gameCreateOrConnectWithoutGenerationInput[]
    createMany?: gameCreateManyGenerationInputEnvelope
    connect?: gameWhereUniqueInput | gameWhereUniqueInput[]
  }

  export type pokemonUncheckedCreateNestedManyWithoutGenerationInput = {
    create?: XOR<pokemonCreateWithoutGenerationInput, pokemonUncheckedCreateWithoutGenerationInput> | pokemonCreateWithoutGenerationInput[] | pokemonUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: pokemonCreateOrConnectWithoutGenerationInput | pokemonCreateOrConnectWithoutGenerationInput[]
    createMany?: pokemonCreateManyGenerationInputEnvelope
    connect?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
  }

  export type pokemon_infoUncheckedCreateNestedManyWithoutGenerationInput = {
    create?: XOR<pokemon_infoCreateWithoutGenerationInput, pokemon_infoUncheckedCreateWithoutGenerationInput> | pokemon_infoCreateWithoutGenerationInput[] | pokemon_infoUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: pokemon_infoCreateOrConnectWithoutGenerationInput | pokemon_infoCreateOrConnectWithoutGenerationInput[]
    createMany?: pokemon_infoCreateManyGenerationInputEnvelope
    connect?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
  }

  export type abilityUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<abilityCreateWithoutGenerationInput, abilityUncheckedCreateWithoutGenerationInput> | abilityCreateWithoutGenerationInput[] | abilityUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: abilityCreateOrConnectWithoutGenerationInput | abilityCreateOrConnectWithoutGenerationInput[]
    upsert?: abilityUpsertWithWhereUniqueWithoutGenerationInput | abilityUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: abilityCreateManyGenerationInputEnvelope
    set?: abilityWhereUniqueInput | abilityWhereUniqueInput[]
    disconnect?: abilityWhereUniqueInput | abilityWhereUniqueInput[]
    delete?: abilityWhereUniqueInput | abilityWhereUniqueInput[]
    connect?: abilityWhereUniqueInput | abilityWhereUniqueInput[]
    update?: abilityUpdateWithWhereUniqueWithoutGenerationInput | abilityUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: abilityUpdateManyWithWhereWithoutGenerationInput | abilityUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: abilityScalarWhereInput | abilityScalarWhereInput[]
  }

  export type ability_infoUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<ability_infoCreateWithoutGenerationInput, ability_infoUncheckedCreateWithoutGenerationInput> | ability_infoCreateWithoutGenerationInput[] | ability_infoUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: ability_infoCreateOrConnectWithoutGenerationInput | ability_infoCreateOrConnectWithoutGenerationInput[]
    upsert?: ability_infoUpsertWithWhereUniqueWithoutGenerationInput | ability_infoUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: ability_infoCreateManyGenerationInputEnvelope
    set?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    disconnect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    delete?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    connect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    update?: ability_infoUpdateWithWhereUniqueWithoutGenerationInput | ability_infoUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: ability_infoUpdateManyWithWhereWithoutGenerationInput | ability_infoUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: ability_infoScalarWhereInput | ability_infoScalarWhereInput[]
  }

  export type gameUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<gameCreateWithoutGenerationInput, gameUncheckedCreateWithoutGenerationInput> | gameCreateWithoutGenerationInput[] | gameUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: gameCreateOrConnectWithoutGenerationInput | gameCreateOrConnectWithoutGenerationInput[]
    upsert?: gameUpsertWithWhereUniqueWithoutGenerationInput | gameUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: gameCreateManyGenerationInputEnvelope
    set?: gameWhereUniqueInput | gameWhereUniqueInput[]
    disconnect?: gameWhereUniqueInput | gameWhereUniqueInput[]
    delete?: gameWhereUniqueInput | gameWhereUniqueInput[]
    connect?: gameWhereUniqueInput | gameWhereUniqueInput[]
    update?: gameUpdateWithWhereUniqueWithoutGenerationInput | gameUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: gameUpdateManyWithWhereWithoutGenerationInput | gameUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: gameScalarWhereInput | gameScalarWhereInput[]
  }

  export type pokemonUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<pokemonCreateWithoutGenerationInput, pokemonUncheckedCreateWithoutGenerationInput> | pokemonCreateWithoutGenerationInput[] | pokemonUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: pokemonCreateOrConnectWithoutGenerationInput | pokemonCreateOrConnectWithoutGenerationInput[]
    upsert?: pokemonUpsertWithWhereUniqueWithoutGenerationInput | pokemonUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: pokemonCreateManyGenerationInputEnvelope
    set?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    disconnect?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    delete?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    connect?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    update?: pokemonUpdateWithWhereUniqueWithoutGenerationInput | pokemonUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: pokemonUpdateManyWithWhereWithoutGenerationInput | pokemonUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: pokemonScalarWhereInput | pokemonScalarWhereInput[]
  }

  export type pokemon_infoUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<pokemon_infoCreateWithoutGenerationInput, pokemon_infoUncheckedCreateWithoutGenerationInput> | pokemon_infoCreateWithoutGenerationInput[] | pokemon_infoUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: pokemon_infoCreateOrConnectWithoutGenerationInput | pokemon_infoCreateOrConnectWithoutGenerationInput[]
    upsert?: pokemon_infoUpsertWithWhereUniqueWithoutGenerationInput | pokemon_infoUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: pokemon_infoCreateManyGenerationInputEnvelope
    set?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    disconnect?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    delete?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    connect?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    update?: pokemon_infoUpdateWithWhereUniqueWithoutGenerationInput | pokemon_infoUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: pokemon_infoUpdateManyWithWhereWithoutGenerationInput | pokemon_infoUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: pokemon_infoScalarWhereInput | pokemon_infoScalarWhereInput[]
  }

  export type abilityUncheckedUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<abilityCreateWithoutGenerationInput, abilityUncheckedCreateWithoutGenerationInput> | abilityCreateWithoutGenerationInput[] | abilityUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: abilityCreateOrConnectWithoutGenerationInput | abilityCreateOrConnectWithoutGenerationInput[]
    upsert?: abilityUpsertWithWhereUniqueWithoutGenerationInput | abilityUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: abilityCreateManyGenerationInputEnvelope
    set?: abilityWhereUniqueInput | abilityWhereUniqueInput[]
    disconnect?: abilityWhereUniqueInput | abilityWhereUniqueInput[]
    delete?: abilityWhereUniqueInput | abilityWhereUniqueInput[]
    connect?: abilityWhereUniqueInput | abilityWhereUniqueInput[]
    update?: abilityUpdateWithWhereUniqueWithoutGenerationInput | abilityUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: abilityUpdateManyWithWhereWithoutGenerationInput | abilityUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: abilityScalarWhereInput | abilityScalarWhereInput[]
  }

  export type ability_infoUncheckedUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<ability_infoCreateWithoutGenerationInput, ability_infoUncheckedCreateWithoutGenerationInput> | ability_infoCreateWithoutGenerationInput[] | ability_infoUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: ability_infoCreateOrConnectWithoutGenerationInput | ability_infoCreateOrConnectWithoutGenerationInput[]
    upsert?: ability_infoUpsertWithWhereUniqueWithoutGenerationInput | ability_infoUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: ability_infoCreateManyGenerationInputEnvelope
    set?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    disconnect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    delete?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    connect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    update?: ability_infoUpdateWithWhereUniqueWithoutGenerationInput | ability_infoUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: ability_infoUpdateManyWithWhereWithoutGenerationInput | ability_infoUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: ability_infoScalarWhereInput | ability_infoScalarWhereInput[]
  }

  export type gameUncheckedUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<gameCreateWithoutGenerationInput, gameUncheckedCreateWithoutGenerationInput> | gameCreateWithoutGenerationInput[] | gameUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: gameCreateOrConnectWithoutGenerationInput | gameCreateOrConnectWithoutGenerationInput[]
    upsert?: gameUpsertWithWhereUniqueWithoutGenerationInput | gameUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: gameCreateManyGenerationInputEnvelope
    set?: gameWhereUniqueInput | gameWhereUniqueInput[]
    disconnect?: gameWhereUniqueInput | gameWhereUniqueInput[]
    delete?: gameWhereUniqueInput | gameWhereUniqueInput[]
    connect?: gameWhereUniqueInput | gameWhereUniqueInput[]
    update?: gameUpdateWithWhereUniqueWithoutGenerationInput | gameUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: gameUpdateManyWithWhereWithoutGenerationInput | gameUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: gameScalarWhereInput | gameScalarWhereInput[]
  }

  export type pokemonUncheckedUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<pokemonCreateWithoutGenerationInput, pokemonUncheckedCreateWithoutGenerationInput> | pokemonCreateWithoutGenerationInput[] | pokemonUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: pokemonCreateOrConnectWithoutGenerationInput | pokemonCreateOrConnectWithoutGenerationInput[]
    upsert?: pokemonUpsertWithWhereUniqueWithoutGenerationInput | pokemonUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: pokemonCreateManyGenerationInputEnvelope
    set?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    disconnect?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    delete?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    connect?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    update?: pokemonUpdateWithWhereUniqueWithoutGenerationInput | pokemonUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: pokemonUpdateManyWithWhereWithoutGenerationInput | pokemonUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: pokemonScalarWhereInput | pokemonScalarWhereInput[]
  }

  export type pokemon_infoUncheckedUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<pokemon_infoCreateWithoutGenerationInput, pokemon_infoUncheckedCreateWithoutGenerationInput> | pokemon_infoCreateWithoutGenerationInput[] | pokemon_infoUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: pokemon_infoCreateOrConnectWithoutGenerationInput | pokemon_infoCreateOrConnectWithoutGenerationInput[]
    upsert?: pokemon_infoUpsertWithWhereUniqueWithoutGenerationInput | pokemon_infoUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: pokemon_infoCreateManyGenerationInputEnvelope
    set?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    disconnect?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    delete?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    connect?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    update?: pokemon_infoUpdateWithWhereUniqueWithoutGenerationInput | pokemon_infoUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: pokemon_infoUpdateManyWithWhereWithoutGenerationInput | pokemon_infoUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: pokemon_infoScalarWhereInput | pokemon_infoScalarWhereInput[]
  }

  export type generationCreateNestedOneWithoutGamesInput = {
    create?: XOR<generationCreateWithoutGamesInput, generationUncheckedCreateWithoutGamesInput>
    connectOrCreate?: generationCreateOrConnectWithoutGamesInput
    connect?: generationWhereUniqueInput
  }

  export type game_group_gameCreateNestedManyWithoutGameInput = {
    create?: XOR<game_group_gameCreateWithoutGameInput, game_group_gameUncheckedCreateWithoutGameInput> | game_group_gameCreateWithoutGameInput[] | game_group_gameUncheckedCreateWithoutGameInput[]
    connectOrCreate?: game_group_gameCreateOrConnectWithoutGameInput | game_group_gameCreateOrConnectWithoutGameInput[]
    createMany?: game_group_gameCreateManyGameInputEnvelope
    connect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
  }

  export type owned_pokemonCreateNestedManyWithoutGameInput = {
    create?: XOR<owned_pokemonCreateWithoutGameInput, owned_pokemonUncheckedCreateWithoutGameInput> | owned_pokemonCreateWithoutGameInput[] | owned_pokemonUncheckedCreateWithoutGameInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutGameInput | owned_pokemonCreateOrConnectWithoutGameInput[]
    createMany?: owned_pokemonCreateManyGameInputEnvelope
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
  }

  export type pokemon_game_locationCreateNestedManyWithoutGameInput = {
    create?: XOR<pokemon_game_locationCreateWithoutGameInput, pokemon_game_locationUncheckedCreateWithoutGameInput> | pokemon_game_locationCreateWithoutGameInput[] | pokemon_game_locationUncheckedCreateWithoutGameInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutGameInput | pokemon_game_locationCreateOrConnectWithoutGameInput[]
    createMany?: pokemon_game_locationCreateManyGameInputEnvelope
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
  }

  export type game_group_gameUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<game_group_gameCreateWithoutGameInput, game_group_gameUncheckedCreateWithoutGameInput> | game_group_gameCreateWithoutGameInput[] | game_group_gameUncheckedCreateWithoutGameInput[]
    connectOrCreate?: game_group_gameCreateOrConnectWithoutGameInput | game_group_gameCreateOrConnectWithoutGameInput[]
    createMany?: game_group_gameCreateManyGameInputEnvelope
    connect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
  }

  export type owned_pokemonUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<owned_pokemonCreateWithoutGameInput, owned_pokemonUncheckedCreateWithoutGameInput> | owned_pokemonCreateWithoutGameInput[] | owned_pokemonUncheckedCreateWithoutGameInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutGameInput | owned_pokemonCreateOrConnectWithoutGameInput[]
    createMany?: owned_pokemonCreateManyGameInputEnvelope
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
  }

  export type pokemon_game_locationUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<pokemon_game_locationCreateWithoutGameInput, pokemon_game_locationUncheckedCreateWithoutGameInput> | pokemon_game_locationCreateWithoutGameInput[] | pokemon_game_locationUncheckedCreateWithoutGameInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutGameInput | pokemon_game_locationCreateOrConnectWithoutGameInput[]
    createMany?: pokemon_game_locationCreateManyGameInputEnvelope
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
  }

  export type generationUpdateOneRequiredWithoutGamesNestedInput = {
    create?: XOR<generationCreateWithoutGamesInput, generationUncheckedCreateWithoutGamesInput>
    connectOrCreate?: generationCreateOrConnectWithoutGamesInput
    upsert?: generationUpsertWithoutGamesInput
    connect?: generationWhereUniqueInput
    update?: XOR<XOR<generationUpdateToOneWithWhereWithoutGamesInput, generationUpdateWithoutGamesInput>, generationUncheckedUpdateWithoutGamesInput>
  }

  export type game_group_gameUpdateManyWithoutGameNestedInput = {
    create?: XOR<game_group_gameCreateWithoutGameInput, game_group_gameUncheckedCreateWithoutGameInput> | game_group_gameCreateWithoutGameInput[] | game_group_gameUncheckedCreateWithoutGameInput[]
    connectOrCreate?: game_group_gameCreateOrConnectWithoutGameInput | game_group_gameCreateOrConnectWithoutGameInput[]
    upsert?: game_group_gameUpsertWithWhereUniqueWithoutGameInput | game_group_gameUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: game_group_gameCreateManyGameInputEnvelope
    set?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    disconnect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    delete?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    connect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    update?: game_group_gameUpdateWithWhereUniqueWithoutGameInput | game_group_gameUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: game_group_gameUpdateManyWithWhereWithoutGameInput | game_group_gameUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: game_group_gameScalarWhereInput | game_group_gameScalarWhereInput[]
  }

  export type owned_pokemonUpdateManyWithoutGameNestedInput = {
    create?: XOR<owned_pokemonCreateWithoutGameInput, owned_pokemonUncheckedCreateWithoutGameInput> | owned_pokemonCreateWithoutGameInput[] | owned_pokemonUncheckedCreateWithoutGameInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutGameInput | owned_pokemonCreateOrConnectWithoutGameInput[]
    upsert?: owned_pokemonUpsertWithWhereUniqueWithoutGameInput | owned_pokemonUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: owned_pokemonCreateManyGameInputEnvelope
    set?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    disconnect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    delete?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    update?: owned_pokemonUpdateWithWhereUniqueWithoutGameInput | owned_pokemonUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: owned_pokemonUpdateManyWithWhereWithoutGameInput | owned_pokemonUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: owned_pokemonScalarWhereInput | owned_pokemonScalarWhereInput[]
  }

  export type pokemon_game_locationUpdateManyWithoutGameNestedInput = {
    create?: XOR<pokemon_game_locationCreateWithoutGameInput, pokemon_game_locationUncheckedCreateWithoutGameInput> | pokemon_game_locationCreateWithoutGameInput[] | pokemon_game_locationUncheckedCreateWithoutGameInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutGameInput | pokemon_game_locationCreateOrConnectWithoutGameInput[]
    upsert?: pokemon_game_locationUpsertWithWhereUniqueWithoutGameInput | pokemon_game_locationUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: pokemon_game_locationCreateManyGameInputEnvelope
    set?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    disconnect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    delete?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    update?: pokemon_game_locationUpdateWithWhereUniqueWithoutGameInput | pokemon_game_locationUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: pokemon_game_locationUpdateManyWithWhereWithoutGameInput | pokemon_game_locationUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: pokemon_game_locationScalarWhereInput | pokemon_game_locationScalarWhereInput[]
  }

  export type game_group_gameUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<game_group_gameCreateWithoutGameInput, game_group_gameUncheckedCreateWithoutGameInput> | game_group_gameCreateWithoutGameInput[] | game_group_gameUncheckedCreateWithoutGameInput[]
    connectOrCreate?: game_group_gameCreateOrConnectWithoutGameInput | game_group_gameCreateOrConnectWithoutGameInput[]
    upsert?: game_group_gameUpsertWithWhereUniqueWithoutGameInput | game_group_gameUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: game_group_gameCreateManyGameInputEnvelope
    set?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    disconnect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    delete?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    connect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    update?: game_group_gameUpdateWithWhereUniqueWithoutGameInput | game_group_gameUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: game_group_gameUpdateManyWithWhereWithoutGameInput | game_group_gameUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: game_group_gameScalarWhereInput | game_group_gameScalarWhereInput[]
  }

  export type owned_pokemonUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<owned_pokemonCreateWithoutGameInput, owned_pokemonUncheckedCreateWithoutGameInput> | owned_pokemonCreateWithoutGameInput[] | owned_pokemonUncheckedCreateWithoutGameInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutGameInput | owned_pokemonCreateOrConnectWithoutGameInput[]
    upsert?: owned_pokemonUpsertWithWhereUniqueWithoutGameInput | owned_pokemonUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: owned_pokemonCreateManyGameInputEnvelope
    set?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    disconnect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    delete?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    update?: owned_pokemonUpdateWithWhereUniqueWithoutGameInput | owned_pokemonUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: owned_pokemonUpdateManyWithWhereWithoutGameInput | owned_pokemonUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: owned_pokemonScalarWhereInput | owned_pokemonScalarWhereInput[]
  }

  export type pokemon_game_locationUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<pokemon_game_locationCreateWithoutGameInput, pokemon_game_locationUncheckedCreateWithoutGameInput> | pokemon_game_locationCreateWithoutGameInput[] | pokemon_game_locationUncheckedCreateWithoutGameInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutGameInput | pokemon_game_locationCreateOrConnectWithoutGameInput[]
    upsert?: pokemon_game_locationUpsertWithWhereUniqueWithoutGameInput | pokemon_game_locationUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: pokemon_game_locationCreateManyGameInputEnvelope
    set?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    disconnect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    delete?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    update?: pokemon_game_locationUpdateWithWhereUniqueWithoutGameInput | pokemon_game_locationUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: pokemon_game_locationUpdateManyWithWhereWithoutGameInput | pokemon_game_locationUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: pokemon_game_locationScalarWhereInput | pokemon_game_locationScalarWhereInput[]
  }

  export type gameCreateNestedOneWithoutGameGroupGamesInput = {
    create?: XOR<gameCreateWithoutGameGroupGamesInput, gameUncheckedCreateWithoutGameGroupGamesInput>
    connectOrCreate?: gameCreateOrConnectWithoutGameGroupGamesInput
    connect?: gameWhereUniqueInput
  }

  export type group_gameCreateNestedOneWithoutGameGroupGamesInput = {
    create?: XOR<group_gameCreateWithoutGameGroupGamesInput, group_gameUncheckedCreateWithoutGameGroupGamesInput>
    connectOrCreate?: group_gameCreateOrConnectWithoutGameGroupGamesInput
    connect?: group_gameWhereUniqueInput
  }

  export type landCreateNestedOneWithoutGame_group_gameInput = {
    create?: XOR<landCreateWithoutGame_group_gameInput, landUncheckedCreateWithoutGame_group_gameInput>
    connectOrCreate?: landCreateOrConnectWithoutGame_group_gameInput
    connect?: landWhereUniqueInput
  }

  export type gameUpdateOneRequiredWithoutGameGroupGamesNestedInput = {
    create?: XOR<gameCreateWithoutGameGroupGamesInput, gameUncheckedCreateWithoutGameGroupGamesInput>
    connectOrCreate?: gameCreateOrConnectWithoutGameGroupGamesInput
    upsert?: gameUpsertWithoutGameGroupGamesInput
    connect?: gameWhereUniqueInput
    update?: XOR<XOR<gameUpdateToOneWithWhereWithoutGameGroupGamesInput, gameUpdateWithoutGameGroupGamesInput>, gameUncheckedUpdateWithoutGameGroupGamesInput>
  }

  export type group_gameUpdateOneRequiredWithoutGameGroupGamesNestedInput = {
    create?: XOR<group_gameCreateWithoutGameGroupGamesInput, group_gameUncheckedCreateWithoutGameGroupGamesInput>
    connectOrCreate?: group_gameCreateOrConnectWithoutGameGroupGamesInput
    upsert?: group_gameUpsertWithoutGameGroupGamesInput
    connect?: group_gameWhereUniqueInput
    update?: XOR<XOR<group_gameUpdateToOneWithWhereWithoutGameGroupGamesInput, group_gameUpdateWithoutGameGroupGamesInput>, group_gameUncheckedUpdateWithoutGameGroupGamesInput>
  }

  export type landUpdateOneRequiredWithoutGame_group_gameNestedInput = {
    create?: XOR<landCreateWithoutGame_group_gameInput, landUncheckedCreateWithoutGame_group_gameInput>
    connectOrCreate?: landCreateOrConnectWithoutGame_group_gameInput
    upsert?: landUpsertWithoutGame_group_gameInput
    connect?: landWhereUniqueInput
    update?: XOR<XOR<landUpdateToOneWithWhereWithoutGame_group_gameInput, landUpdateWithoutGame_group_gameInput>, landUncheckedUpdateWithoutGame_group_gameInput>
  }

  export type capsule_game_capacity_infoCreateNestedManyWithoutGroupGameInput = {
    create?: XOR<capsule_game_capacity_infoCreateWithoutGroupGameInput, capsule_game_capacity_infoUncheckedCreateWithoutGroupGameInput> | capsule_game_capacity_infoCreateWithoutGroupGameInput[] | capsule_game_capacity_infoUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: capsule_game_capacity_infoCreateOrConnectWithoutGroupGameInput | capsule_game_capacity_infoCreateOrConnectWithoutGroupGameInput[]
    createMany?: capsule_game_capacity_infoCreateManyGroupGameInputEnvelope
    connect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
  }

  export type game_group_gameCreateNestedManyWithoutGroupGameInput = {
    create?: XOR<game_group_gameCreateWithoutGroupGameInput, game_group_gameUncheckedCreateWithoutGroupGameInput> | game_group_gameCreateWithoutGroupGameInput[] | game_group_gameUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: game_group_gameCreateOrConnectWithoutGroupGameInput | game_group_gameCreateOrConnectWithoutGroupGameInput[]
    createMany?: game_group_gameCreateManyGroupGameInputEnvelope
    connect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
  }

  export type national_numberCreateNestedManyWithoutGroupGameInput = {
    create?: XOR<national_numberCreateWithoutGroupGameInput, national_numberUncheckedCreateWithoutGroupGameInput> | national_numberCreateWithoutGroupGameInput[] | national_numberUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: national_numberCreateOrConnectWithoutGroupGameInput | national_numberCreateOrConnectWithoutGroupGameInput[]
    createMany?: national_numberCreateManyGroupGameInputEnvelope
    connect?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
  }

  export type shiny_hunting_method_gameCreateNestedManyWithoutGroupGameInput = {
    create?: XOR<shiny_hunting_method_gameCreateWithoutGroupGameInput, shiny_hunting_method_gameUncheckedCreateWithoutGroupGameInput> | shiny_hunting_method_gameCreateWithoutGroupGameInput[] | shiny_hunting_method_gameUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: shiny_hunting_method_gameCreateOrConnectWithoutGroupGameInput | shiny_hunting_method_gameCreateOrConnectWithoutGroupGameInput[]
    createMany?: shiny_hunting_method_gameCreateManyGroupGameInputEnvelope
    connect?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
  }

  export type skill_obtationCreateNestedManyWithoutGroupGameInput = {
    create?: XOR<skill_obtationCreateWithoutGroupGameInput, skill_obtationUncheckedCreateWithoutGroupGameInput> | skill_obtationCreateWithoutGroupGameInput[] | skill_obtationUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutGroupGameInput | skill_obtationCreateOrConnectWithoutGroupGameInput[]
    createMany?: skill_obtationCreateManyGroupGameInputEnvelope
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
  }

  export type statistic_group_gameCreateNestedManyWithoutGroupGameInput = {
    create?: XOR<statistic_group_gameCreateWithoutGroupGameInput, statistic_group_gameUncheckedCreateWithoutGroupGameInput> | statistic_group_gameCreateWithoutGroupGameInput[] | statistic_group_gameUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: statistic_group_gameCreateOrConnectWithoutGroupGameInput | statistic_group_gameCreateOrConnectWithoutGroupGameInput[]
    createMany?: statistic_group_gameCreateManyGroupGameInputEnvelope
    connect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
  }

  export type capsule_game_capacity_infoUncheckedCreateNestedManyWithoutGroupGameInput = {
    create?: XOR<capsule_game_capacity_infoCreateWithoutGroupGameInput, capsule_game_capacity_infoUncheckedCreateWithoutGroupGameInput> | capsule_game_capacity_infoCreateWithoutGroupGameInput[] | capsule_game_capacity_infoUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: capsule_game_capacity_infoCreateOrConnectWithoutGroupGameInput | capsule_game_capacity_infoCreateOrConnectWithoutGroupGameInput[]
    createMany?: capsule_game_capacity_infoCreateManyGroupGameInputEnvelope
    connect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
  }

  export type game_group_gameUncheckedCreateNestedManyWithoutGroupGameInput = {
    create?: XOR<game_group_gameCreateWithoutGroupGameInput, game_group_gameUncheckedCreateWithoutGroupGameInput> | game_group_gameCreateWithoutGroupGameInput[] | game_group_gameUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: game_group_gameCreateOrConnectWithoutGroupGameInput | game_group_gameCreateOrConnectWithoutGroupGameInput[]
    createMany?: game_group_gameCreateManyGroupGameInputEnvelope
    connect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
  }

  export type national_numberUncheckedCreateNestedManyWithoutGroupGameInput = {
    create?: XOR<national_numberCreateWithoutGroupGameInput, national_numberUncheckedCreateWithoutGroupGameInput> | national_numberCreateWithoutGroupGameInput[] | national_numberUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: national_numberCreateOrConnectWithoutGroupGameInput | national_numberCreateOrConnectWithoutGroupGameInput[]
    createMany?: national_numberCreateManyGroupGameInputEnvelope
    connect?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
  }

  export type shiny_hunting_method_gameUncheckedCreateNestedManyWithoutGroupGameInput = {
    create?: XOR<shiny_hunting_method_gameCreateWithoutGroupGameInput, shiny_hunting_method_gameUncheckedCreateWithoutGroupGameInput> | shiny_hunting_method_gameCreateWithoutGroupGameInput[] | shiny_hunting_method_gameUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: shiny_hunting_method_gameCreateOrConnectWithoutGroupGameInput | shiny_hunting_method_gameCreateOrConnectWithoutGroupGameInput[]
    createMany?: shiny_hunting_method_gameCreateManyGroupGameInputEnvelope
    connect?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
  }

  export type skill_obtationUncheckedCreateNestedManyWithoutGroupGameInput = {
    create?: XOR<skill_obtationCreateWithoutGroupGameInput, skill_obtationUncheckedCreateWithoutGroupGameInput> | skill_obtationCreateWithoutGroupGameInput[] | skill_obtationUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutGroupGameInput | skill_obtationCreateOrConnectWithoutGroupGameInput[]
    createMany?: skill_obtationCreateManyGroupGameInputEnvelope
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
  }

  export type statistic_group_gameUncheckedCreateNestedManyWithoutGroupGameInput = {
    create?: XOR<statistic_group_gameCreateWithoutGroupGameInput, statistic_group_gameUncheckedCreateWithoutGroupGameInput> | statistic_group_gameCreateWithoutGroupGameInput[] | statistic_group_gameUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: statistic_group_gameCreateOrConnectWithoutGroupGameInput | statistic_group_gameCreateOrConnectWithoutGroupGameInput[]
    createMany?: statistic_group_gameCreateManyGroupGameInputEnvelope
    connect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
  }

  export type capsule_game_capacity_infoUpdateManyWithoutGroupGameNestedInput = {
    create?: XOR<capsule_game_capacity_infoCreateWithoutGroupGameInput, capsule_game_capacity_infoUncheckedCreateWithoutGroupGameInput> | capsule_game_capacity_infoCreateWithoutGroupGameInput[] | capsule_game_capacity_infoUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: capsule_game_capacity_infoCreateOrConnectWithoutGroupGameInput | capsule_game_capacity_infoCreateOrConnectWithoutGroupGameInput[]
    upsert?: capsule_game_capacity_infoUpsertWithWhereUniqueWithoutGroupGameInput | capsule_game_capacity_infoUpsertWithWhereUniqueWithoutGroupGameInput[]
    createMany?: capsule_game_capacity_infoCreateManyGroupGameInputEnvelope
    set?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    disconnect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    delete?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    connect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    update?: capsule_game_capacity_infoUpdateWithWhereUniqueWithoutGroupGameInput | capsule_game_capacity_infoUpdateWithWhereUniqueWithoutGroupGameInput[]
    updateMany?: capsule_game_capacity_infoUpdateManyWithWhereWithoutGroupGameInput | capsule_game_capacity_infoUpdateManyWithWhereWithoutGroupGameInput[]
    deleteMany?: capsule_game_capacity_infoScalarWhereInput | capsule_game_capacity_infoScalarWhereInput[]
  }

  export type game_group_gameUpdateManyWithoutGroupGameNestedInput = {
    create?: XOR<game_group_gameCreateWithoutGroupGameInput, game_group_gameUncheckedCreateWithoutGroupGameInput> | game_group_gameCreateWithoutGroupGameInput[] | game_group_gameUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: game_group_gameCreateOrConnectWithoutGroupGameInput | game_group_gameCreateOrConnectWithoutGroupGameInput[]
    upsert?: game_group_gameUpsertWithWhereUniqueWithoutGroupGameInput | game_group_gameUpsertWithWhereUniqueWithoutGroupGameInput[]
    createMany?: game_group_gameCreateManyGroupGameInputEnvelope
    set?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    disconnect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    delete?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    connect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    update?: game_group_gameUpdateWithWhereUniqueWithoutGroupGameInput | game_group_gameUpdateWithWhereUniqueWithoutGroupGameInput[]
    updateMany?: game_group_gameUpdateManyWithWhereWithoutGroupGameInput | game_group_gameUpdateManyWithWhereWithoutGroupGameInput[]
    deleteMany?: game_group_gameScalarWhereInput | game_group_gameScalarWhereInput[]
  }

  export type national_numberUpdateManyWithoutGroupGameNestedInput = {
    create?: XOR<national_numberCreateWithoutGroupGameInput, national_numberUncheckedCreateWithoutGroupGameInput> | national_numberCreateWithoutGroupGameInput[] | national_numberUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: national_numberCreateOrConnectWithoutGroupGameInput | national_numberCreateOrConnectWithoutGroupGameInput[]
    upsert?: national_numberUpsertWithWhereUniqueWithoutGroupGameInput | national_numberUpsertWithWhereUniqueWithoutGroupGameInput[]
    createMany?: national_numberCreateManyGroupGameInputEnvelope
    set?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    disconnect?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    delete?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    connect?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    update?: national_numberUpdateWithWhereUniqueWithoutGroupGameInput | national_numberUpdateWithWhereUniqueWithoutGroupGameInput[]
    updateMany?: national_numberUpdateManyWithWhereWithoutGroupGameInput | national_numberUpdateManyWithWhereWithoutGroupGameInput[]
    deleteMany?: national_numberScalarWhereInput | national_numberScalarWhereInput[]
  }

  export type shiny_hunting_method_gameUpdateManyWithoutGroupGameNestedInput = {
    create?: XOR<shiny_hunting_method_gameCreateWithoutGroupGameInput, shiny_hunting_method_gameUncheckedCreateWithoutGroupGameInput> | shiny_hunting_method_gameCreateWithoutGroupGameInput[] | shiny_hunting_method_gameUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: shiny_hunting_method_gameCreateOrConnectWithoutGroupGameInput | shiny_hunting_method_gameCreateOrConnectWithoutGroupGameInput[]
    upsert?: shiny_hunting_method_gameUpsertWithWhereUniqueWithoutGroupGameInput | shiny_hunting_method_gameUpsertWithWhereUniqueWithoutGroupGameInput[]
    createMany?: shiny_hunting_method_gameCreateManyGroupGameInputEnvelope
    set?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    disconnect?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    delete?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    connect?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    update?: shiny_hunting_method_gameUpdateWithWhereUniqueWithoutGroupGameInput | shiny_hunting_method_gameUpdateWithWhereUniqueWithoutGroupGameInput[]
    updateMany?: shiny_hunting_method_gameUpdateManyWithWhereWithoutGroupGameInput | shiny_hunting_method_gameUpdateManyWithWhereWithoutGroupGameInput[]
    deleteMany?: shiny_hunting_method_gameScalarWhereInput | shiny_hunting_method_gameScalarWhereInput[]
  }

  export type skill_obtationUpdateManyWithoutGroupGameNestedInput = {
    create?: XOR<skill_obtationCreateWithoutGroupGameInput, skill_obtationUncheckedCreateWithoutGroupGameInput> | skill_obtationCreateWithoutGroupGameInput[] | skill_obtationUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutGroupGameInput | skill_obtationCreateOrConnectWithoutGroupGameInput[]
    upsert?: skill_obtationUpsertWithWhereUniqueWithoutGroupGameInput | skill_obtationUpsertWithWhereUniqueWithoutGroupGameInput[]
    createMany?: skill_obtationCreateManyGroupGameInputEnvelope
    set?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    disconnect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    delete?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    update?: skill_obtationUpdateWithWhereUniqueWithoutGroupGameInput | skill_obtationUpdateWithWhereUniqueWithoutGroupGameInput[]
    updateMany?: skill_obtationUpdateManyWithWhereWithoutGroupGameInput | skill_obtationUpdateManyWithWhereWithoutGroupGameInput[]
    deleteMany?: skill_obtationScalarWhereInput | skill_obtationScalarWhereInput[]
  }

  export type statistic_group_gameUpdateManyWithoutGroupGameNestedInput = {
    create?: XOR<statistic_group_gameCreateWithoutGroupGameInput, statistic_group_gameUncheckedCreateWithoutGroupGameInput> | statistic_group_gameCreateWithoutGroupGameInput[] | statistic_group_gameUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: statistic_group_gameCreateOrConnectWithoutGroupGameInput | statistic_group_gameCreateOrConnectWithoutGroupGameInput[]
    upsert?: statistic_group_gameUpsertWithWhereUniqueWithoutGroupGameInput | statistic_group_gameUpsertWithWhereUniqueWithoutGroupGameInput[]
    createMany?: statistic_group_gameCreateManyGroupGameInputEnvelope
    set?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    disconnect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    delete?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    connect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    update?: statistic_group_gameUpdateWithWhereUniqueWithoutGroupGameInput | statistic_group_gameUpdateWithWhereUniqueWithoutGroupGameInput[]
    updateMany?: statistic_group_gameUpdateManyWithWhereWithoutGroupGameInput | statistic_group_gameUpdateManyWithWhereWithoutGroupGameInput[]
    deleteMany?: statistic_group_gameScalarWhereInput | statistic_group_gameScalarWhereInput[]
  }

  export type capsule_game_capacity_infoUncheckedUpdateManyWithoutGroupGameNestedInput = {
    create?: XOR<capsule_game_capacity_infoCreateWithoutGroupGameInput, capsule_game_capacity_infoUncheckedCreateWithoutGroupGameInput> | capsule_game_capacity_infoCreateWithoutGroupGameInput[] | capsule_game_capacity_infoUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: capsule_game_capacity_infoCreateOrConnectWithoutGroupGameInput | capsule_game_capacity_infoCreateOrConnectWithoutGroupGameInput[]
    upsert?: capsule_game_capacity_infoUpsertWithWhereUniqueWithoutGroupGameInput | capsule_game_capacity_infoUpsertWithWhereUniqueWithoutGroupGameInput[]
    createMany?: capsule_game_capacity_infoCreateManyGroupGameInputEnvelope
    set?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    disconnect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    delete?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    connect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    update?: capsule_game_capacity_infoUpdateWithWhereUniqueWithoutGroupGameInput | capsule_game_capacity_infoUpdateWithWhereUniqueWithoutGroupGameInput[]
    updateMany?: capsule_game_capacity_infoUpdateManyWithWhereWithoutGroupGameInput | capsule_game_capacity_infoUpdateManyWithWhereWithoutGroupGameInput[]
    deleteMany?: capsule_game_capacity_infoScalarWhereInput | capsule_game_capacity_infoScalarWhereInput[]
  }

  export type game_group_gameUncheckedUpdateManyWithoutGroupGameNestedInput = {
    create?: XOR<game_group_gameCreateWithoutGroupGameInput, game_group_gameUncheckedCreateWithoutGroupGameInput> | game_group_gameCreateWithoutGroupGameInput[] | game_group_gameUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: game_group_gameCreateOrConnectWithoutGroupGameInput | game_group_gameCreateOrConnectWithoutGroupGameInput[]
    upsert?: game_group_gameUpsertWithWhereUniqueWithoutGroupGameInput | game_group_gameUpsertWithWhereUniqueWithoutGroupGameInput[]
    createMany?: game_group_gameCreateManyGroupGameInputEnvelope
    set?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    disconnect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    delete?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    connect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    update?: game_group_gameUpdateWithWhereUniqueWithoutGroupGameInput | game_group_gameUpdateWithWhereUniqueWithoutGroupGameInput[]
    updateMany?: game_group_gameUpdateManyWithWhereWithoutGroupGameInput | game_group_gameUpdateManyWithWhereWithoutGroupGameInput[]
    deleteMany?: game_group_gameScalarWhereInput | game_group_gameScalarWhereInput[]
  }

  export type national_numberUncheckedUpdateManyWithoutGroupGameNestedInput = {
    create?: XOR<national_numberCreateWithoutGroupGameInput, national_numberUncheckedCreateWithoutGroupGameInput> | national_numberCreateWithoutGroupGameInput[] | national_numberUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: national_numberCreateOrConnectWithoutGroupGameInput | national_numberCreateOrConnectWithoutGroupGameInput[]
    upsert?: national_numberUpsertWithWhereUniqueWithoutGroupGameInput | national_numberUpsertWithWhereUniqueWithoutGroupGameInput[]
    createMany?: national_numberCreateManyGroupGameInputEnvelope
    set?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    disconnect?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    delete?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    connect?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    update?: national_numberUpdateWithWhereUniqueWithoutGroupGameInput | national_numberUpdateWithWhereUniqueWithoutGroupGameInput[]
    updateMany?: national_numberUpdateManyWithWhereWithoutGroupGameInput | national_numberUpdateManyWithWhereWithoutGroupGameInput[]
    deleteMany?: national_numberScalarWhereInput | national_numberScalarWhereInput[]
  }

  export type shiny_hunting_method_gameUncheckedUpdateManyWithoutGroupGameNestedInput = {
    create?: XOR<shiny_hunting_method_gameCreateWithoutGroupGameInput, shiny_hunting_method_gameUncheckedCreateWithoutGroupGameInput> | shiny_hunting_method_gameCreateWithoutGroupGameInput[] | shiny_hunting_method_gameUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: shiny_hunting_method_gameCreateOrConnectWithoutGroupGameInput | shiny_hunting_method_gameCreateOrConnectWithoutGroupGameInput[]
    upsert?: shiny_hunting_method_gameUpsertWithWhereUniqueWithoutGroupGameInput | shiny_hunting_method_gameUpsertWithWhereUniqueWithoutGroupGameInput[]
    createMany?: shiny_hunting_method_gameCreateManyGroupGameInputEnvelope
    set?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    disconnect?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    delete?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    connect?: shiny_hunting_method_gameWhereUniqueInput | shiny_hunting_method_gameWhereUniqueInput[]
    update?: shiny_hunting_method_gameUpdateWithWhereUniqueWithoutGroupGameInput | shiny_hunting_method_gameUpdateWithWhereUniqueWithoutGroupGameInput[]
    updateMany?: shiny_hunting_method_gameUpdateManyWithWhereWithoutGroupGameInput | shiny_hunting_method_gameUpdateManyWithWhereWithoutGroupGameInput[]
    deleteMany?: shiny_hunting_method_gameScalarWhereInput | shiny_hunting_method_gameScalarWhereInput[]
  }

  export type skill_obtationUncheckedUpdateManyWithoutGroupGameNestedInput = {
    create?: XOR<skill_obtationCreateWithoutGroupGameInput, skill_obtationUncheckedCreateWithoutGroupGameInput> | skill_obtationCreateWithoutGroupGameInput[] | skill_obtationUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutGroupGameInput | skill_obtationCreateOrConnectWithoutGroupGameInput[]
    upsert?: skill_obtationUpsertWithWhereUniqueWithoutGroupGameInput | skill_obtationUpsertWithWhereUniqueWithoutGroupGameInput[]
    createMany?: skill_obtationCreateManyGroupGameInputEnvelope
    set?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    disconnect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    delete?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    update?: skill_obtationUpdateWithWhereUniqueWithoutGroupGameInput | skill_obtationUpdateWithWhereUniqueWithoutGroupGameInput[]
    updateMany?: skill_obtationUpdateManyWithWhereWithoutGroupGameInput | skill_obtationUpdateManyWithWhereWithoutGroupGameInput[]
    deleteMany?: skill_obtationScalarWhereInput | skill_obtationScalarWhereInput[]
  }

  export type statistic_group_gameUncheckedUpdateManyWithoutGroupGameNestedInput = {
    create?: XOR<statistic_group_gameCreateWithoutGroupGameInput, statistic_group_gameUncheckedCreateWithoutGroupGameInput> | statistic_group_gameCreateWithoutGroupGameInput[] | statistic_group_gameUncheckedCreateWithoutGroupGameInput[]
    connectOrCreate?: statistic_group_gameCreateOrConnectWithoutGroupGameInput | statistic_group_gameCreateOrConnectWithoutGroupGameInput[]
    upsert?: statistic_group_gameUpsertWithWhereUniqueWithoutGroupGameInput | statistic_group_gameUpsertWithWhereUniqueWithoutGroupGameInput[]
    createMany?: statistic_group_gameCreateManyGroupGameInputEnvelope
    set?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    disconnect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    delete?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    connect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    update?: statistic_group_gameUpdateWithWhereUniqueWithoutGroupGameInput | statistic_group_gameUpdateWithWhereUniqueWithoutGroupGameInput[]
    updateMany?: statistic_group_gameUpdateManyWithWhereWithoutGroupGameInput | statistic_group_gameUpdateManyWithWhereWithoutGroupGameInput[]
    deleteMany?: statistic_group_gameScalarWhereInput | statistic_group_gameScalarWhereInput[]
  }

  export type capacity_infoCreateNestedOneWithoutCapsuleGameCapacityInfosInput = {
    create?: XOR<capacity_infoCreateWithoutCapsuleGameCapacityInfosInput, capacity_infoUncheckedCreateWithoutCapsuleGameCapacityInfosInput>
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapsuleGameCapacityInfosInput
    connect?: capacity_infoWhereUniqueInput
  }

  export type capsuleCreateNestedOneWithoutCapsule_game_capacity_infoInput = {
    create?: XOR<capsuleCreateWithoutCapsule_game_capacity_infoInput, capsuleUncheckedCreateWithoutCapsule_game_capacity_infoInput>
    connectOrCreate?: capsuleCreateOrConnectWithoutCapsule_game_capacity_infoInput
    connect?: capsuleWhereUniqueInput
  }

  export type group_gameCreateNestedOneWithoutCapsuleGameCapacityIinfosInput = {
    create?: XOR<group_gameCreateWithoutCapsuleGameCapacityIinfosInput, group_gameUncheckedCreateWithoutCapsuleGameCapacityIinfosInput>
    connectOrCreate?: group_gameCreateOrConnectWithoutCapsuleGameCapacityIinfosInput
    connect?: group_gameWhereUniqueInput
  }

  export type capacity_infoUpdateOneRequiredWithoutCapsuleGameCapacityInfosNestedInput = {
    create?: XOR<capacity_infoCreateWithoutCapsuleGameCapacityInfosInput, capacity_infoUncheckedCreateWithoutCapsuleGameCapacityInfosInput>
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapsuleGameCapacityInfosInput
    upsert?: capacity_infoUpsertWithoutCapsuleGameCapacityInfosInput
    connect?: capacity_infoWhereUniqueInput
    update?: XOR<XOR<capacity_infoUpdateToOneWithWhereWithoutCapsuleGameCapacityInfosInput, capacity_infoUpdateWithoutCapsuleGameCapacityInfosInput>, capacity_infoUncheckedUpdateWithoutCapsuleGameCapacityInfosInput>
  }

  export type capsuleUpdateOneRequiredWithoutCapsule_game_capacity_infoNestedInput = {
    create?: XOR<capsuleCreateWithoutCapsule_game_capacity_infoInput, capsuleUncheckedCreateWithoutCapsule_game_capacity_infoInput>
    connectOrCreate?: capsuleCreateOrConnectWithoutCapsule_game_capacity_infoInput
    upsert?: capsuleUpsertWithoutCapsule_game_capacity_infoInput
    connect?: capsuleWhereUniqueInput
    update?: XOR<XOR<capsuleUpdateToOneWithWhereWithoutCapsule_game_capacity_infoInput, capsuleUpdateWithoutCapsule_game_capacity_infoInput>, capsuleUncheckedUpdateWithoutCapsule_game_capacity_infoInput>
  }

  export type group_gameUpdateOneRequiredWithoutCapsuleGameCapacityIinfosNestedInput = {
    create?: XOR<group_gameCreateWithoutCapsuleGameCapacityIinfosInput, group_gameUncheckedCreateWithoutCapsuleGameCapacityIinfosInput>
    connectOrCreate?: group_gameCreateOrConnectWithoutCapsuleGameCapacityIinfosInput
    upsert?: group_gameUpsertWithoutCapsuleGameCapacityIinfosInput
    connect?: group_gameWhereUniqueInput
    update?: XOR<XOR<group_gameUpdateToOneWithWhereWithoutCapsuleGameCapacityIinfosInput, group_gameUpdateWithoutCapsuleGameCapacityIinfosInput>, group_gameUncheckedUpdateWithoutCapsuleGameCapacityIinfosInput>
  }

  export type pokemonCreateNestedManyWithoutPokemon_categoryInput = {
    create?: XOR<pokemonCreateWithoutPokemon_categoryInput, pokemonUncheckedCreateWithoutPokemon_categoryInput> | pokemonCreateWithoutPokemon_categoryInput[] | pokemonUncheckedCreateWithoutPokemon_categoryInput[]
    connectOrCreate?: pokemonCreateOrConnectWithoutPokemon_categoryInput | pokemonCreateOrConnectWithoutPokemon_categoryInput[]
    createMany?: pokemonCreateManyPokemon_categoryInputEnvelope
    connect?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
  }

  export type pokemonUncheckedCreateNestedManyWithoutPokemon_categoryInput = {
    create?: XOR<pokemonCreateWithoutPokemon_categoryInput, pokemonUncheckedCreateWithoutPokemon_categoryInput> | pokemonCreateWithoutPokemon_categoryInput[] | pokemonUncheckedCreateWithoutPokemon_categoryInput[]
    connectOrCreate?: pokemonCreateOrConnectWithoutPokemon_categoryInput | pokemonCreateOrConnectWithoutPokemon_categoryInput[]
    createMany?: pokemonCreateManyPokemon_categoryInputEnvelope
    connect?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
  }

  export type pokemonUpdateManyWithoutPokemon_categoryNestedInput = {
    create?: XOR<pokemonCreateWithoutPokemon_categoryInput, pokemonUncheckedCreateWithoutPokemon_categoryInput> | pokemonCreateWithoutPokemon_categoryInput[] | pokemonUncheckedCreateWithoutPokemon_categoryInput[]
    connectOrCreate?: pokemonCreateOrConnectWithoutPokemon_categoryInput | pokemonCreateOrConnectWithoutPokemon_categoryInput[]
    upsert?: pokemonUpsertWithWhereUniqueWithoutPokemon_categoryInput | pokemonUpsertWithWhereUniqueWithoutPokemon_categoryInput[]
    createMany?: pokemonCreateManyPokemon_categoryInputEnvelope
    set?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    disconnect?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    delete?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    connect?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    update?: pokemonUpdateWithWhereUniqueWithoutPokemon_categoryInput | pokemonUpdateWithWhereUniqueWithoutPokemon_categoryInput[]
    updateMany?: pokemonUpdateManyWithWhereWithoutPokemon_categoryInput | pokemonUpdateManyWithWhereWithoutPokemon_categoryInput[]
    deleteMany?: pokemonScalarWhereInput | pokemonScalarWhereInput[]
  }

  export type pokemonUncheckedUpdateManyWithoutPokemon_categoryNestedInput = {
    create?: XOR<pokemonCreateWithoutPokemon_categoryInput, pokemonUncheckedCreateWithoutPokemon_categoryInput> | pokemonCreateWithoutPokemon_categoryInput[] | pokemonUncheckedCreateWithoutPokemon_categoryInput[]
    connectOrCreate?: pokemonCreateOrConnectWithoutPokemon_categoryInput | pokemonCreateOrConnectWithoutPokemon_categoryInput[]
    upsert?: pokemonUpsertWithWhereUniqueWithoutPokemon_categoryInput | pokemonUpsertWithWhereUniqueWithoutPokemon_categoryInput[]
    createMany?: pokemonCreateManyPokemon_categoryInputEnvelope
    set?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    disconnect?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    delete?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    connect?: pokemonWhereUniqueInput | pokemonWhereUniqueInput[]
    update?: pokemonUpdateWithWhereUniqueWithoutPokemon_categoryInput | pokemonUpdateWithWhereUniqueWithoutPokemon_categoryInput[]
    updateMany?: pokemonUpdateManyWithWhereWithoutPokemon_categoryInput | pokemonUpdateManyWithWhereWithoutPokemon_categoryInput[]
    deleteMany?: pokemonScalarWhereInput | pokemonScalarWhereInput[]
  }

  export type national_numberCreateNestedManyWithoutPokemonInput = {
    create?: XOR<national_numberCreateWithoutPokemonInput, national_numberUncheckedCreateWithoutPokemonInput> | national_numberCreateWithoutPokemonInput[] | national_numberUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: national_numberCreateOrConnectWithoutPokemonInput | national_numberCreateOrConnectWithoutPokemonInput[]
    createMany?: national_numberCreateManyPokemonInputEnvelope
    connect?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
  }

  export type pokemon_categoryCreateNestedOneWithoutPokemonsInput = {
    create?: XOR<pokemon_categoryCreateWithoutPokemonsInput, pokemon_categoryUncheckedCreateWithoutPokemonsInput>
    connectOrCreate?: pokemon_categoryCreateOrConnectWithoutPokemonsInput
    connect?: pokemon_categoryWhereUniqueInput
  }

  export type generationCreateNestedOneWithoutPokemonsInput = {
    create?: XOR<generationCreateWithoutPokemonsInput, generationUncheckedCreateWithoutPokemonsInput>
    connectOrCreate?: generationCreateOrConnectWithoutPokemonsInput
    connect?: generationWhereUniqueInput
  }

  export type pokemon_formCreateNestedManyWithoutPokemonInput = {
    create?: XOR<pokemon_formCreateWithoutPokemonInput, pokemon_formUncheckedCreateWithoutPokemonInput> | pokemon_formCreateWithoutPokemonInput[] | pokemon_formUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: pokemon_formCreateOrConnectWithoutPokemonInput | pokemon_formCreateOrConnectWithoutPokemonInput[]
    createMany?: pokemon_formCreateManyPokemonInputEnvelope
    connect?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
  }

  export type pokemon_infoCreateNestedManyWithoutPokemonInput = {
    create?: XOR<pokemon_infoCreateWithoutPokemonInput, pokemon_infoUncheckedCreateWithoutPokemonInput> | pokemon_infoCreateWithoutPokemonInput[] | pokemon_infoUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: pokemon_infoCreateOrConnectWithoutPokemonInput | pokemon_infoCreateOrConnectWithoutPokemonInput[]
    createMany?: pokemon_infoCreateManyPokemonInputEnvelope
    connect?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
  }

  export type skill_obtationCreateNestedManyWithoutPokemonInput = {
    create?: XOR<skill_obtationCreateWithoutPokemonInput, skill_obtationUncheckedCreateWithoutPokemonInput> | skill_obtationCreateWithoutPokemonInput[] | skill_obtationUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutPokemonInput | skill_obtationCreateOrConnectWithoutPokemonInput[]
    createMany?: skill_obtationCreateManyPokemonInputEnvelope
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
  }

  export type statistic_group_gameCreateNestedManyWithoutPokemonInput = {
    create?: XOR<statistic_group_gameCreateWithoutPokemonInput, statistic_group_gameUncheckedCreateWithoutPokemonInput> | statistic_group_gameCreateWithoutPokemonInput[] | statistic_group_gameUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: statistic_group_gameCreateOrConnectWithoutPokemonInput | statistic_group_gameCreateOrConnectWithoutPokemonInput[]
    createMany?: statistic_group_gameCreateManyPokemonInputEnvelope
    connect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
  }

  export type national_numberUncheckedCreateNestedManyWithoutPokemonInput = {
    create?: XOR<national_numberCreateWithoutPokemonInput, national_numberUncheckedCreateWithoutPokemonInput> | national_numberCreateWithoutPokemonInput[] | national_numberUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: national_numberCreateOrConnectWithoutPokemonInput | national_numberCreateOrConnectWithoutPokemonInput[]
    createMany?: national_numberCreateManyPokemonInputEnvelope
    connect?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
  }

  export type pokemon_formUncheckedCreateNestedManyWithoutPokemonInput = {
    create?: XOR<pokemon_formCreateWithoutPokemonInput, pokemon_formUncheckedCreateWithoutPokemonInput> | pokemon_formCreateWithoutPokemonInput[] | pokemon_formUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: pokemon_formCreateOrConnectWithoutPokemonInput | pokemon_formCreateOrConnectWithoutPokemonInput[]
    createMany?: pokemon_formCreateManyPokemonInputEnvelope
    connect?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
  }

  export type pokemon_infoUncheckedCreateNestedManyWithoutPokemonInput = {
    create?: XOR<pokemon_infoCreateWithoutPokemonInput, pokemon_infoUncheckedCreateWithoutPokemonInput> | pokemon_infoCreateWithoutPokemonInput[] | pokemon_infoUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: pokemon_infoCreateOrConnectWithoutPokemonInput | pokemon_infoCreateOrConnectWithoutPokemonInput[]
    createMany?: pokemon_infoCreateManyPokemonInputEnvelope
    connect?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
  }

  export type skill_obtationUncheckedCreateNestedManyWithoutPokemonInput = {
    create?: XOR<skill_obtationCreateWithoutPokemonInput, skill_obtationUncheckedCreateWithoutPokemonInput> | skill_obtationCreateWithoutPokemonInput[] | skill_obtationUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutPokemonInput | skill_obtationCreateOrConnectWithoutPokemonInput[]
    createMany?: skill_obtationCreateManyPokemonInputEnvelope
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
  }

  export type statistic_group_gameUncheckedCreateNestedManyWithoutPokemonInput = {
    create?: XOR<statistic_group_gameCreateWithoutPokemonInput, statistic_group_gameUncheckedCreateWithoutPokemonInput> | statistic_group_gameCreateWithoutPokemonInput[] | statistic_group_gameUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: statistic_group_gameCreateOrConnectWithoutPokemonInput | statistic_group_gameCreateOrConnectWithoutPokemonInput[]
    createMany?: statistic_group_gameCreateManyPokemonInputEnvelope
    connect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type national_numberUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<national_numberCreateWithoutPokemonInput, national_numberUncheckedCreateWithoutPokemonInput> | national_numberCreateWithoutPokemonInput[] | national_numberUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: national_numberCreateOrConnectWithoutPokemonInput | national_numberCreateOrConnectWithoutPokemonInput[]
    upsert?: national_numberUpsertWithWhereUniqueWithoutPokemonInput | national_numberUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: national_numberCreateManyPokemonInputEnvelope
    set?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    disconnect?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    delete?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    connect?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    update?: national_numberUpdateWithWhereUniqueWithoutPokemonInput | national_numberUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: national_numberUpdateManyWithWhereWithoutPokemonInput | national_numberUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: national_numberScalarWhereInput | national_numberScalarWhereInput[]
  }

  export type pokemon_categoryUpdateOneRequiredWithoutPokemonsNestedInput = {
    create?: XOR<pokemon_categoryCreateWithoutPokemonsInput, pokemon_categoryUncheckedCreateWithoutPokemonsInput>
    connectOrCreate?: pokemon_categoryCreateOrConnectWithoutPokemonsInput
    upsert?: pokemon_categoryUpsertWithoutPokemonsInput
    connect?: pokemon_categoryWhereUniqueInput
    update?: XOR<XOR<pokemon_categoryUpdateToOneWithWhereWithoutPokemonsInput, pokemon_categoryUpdateWithoutPokemonsInput>, pokemon_categoryUncheckedUpdateWithoutPokemonsInput>
  }

  export type generationUpdateOneRequiredWithoutPokemonsNestedInput = {
    create?: XOR<generationCreateWithoutPokemonsInput, generationUncheckedCreateWithoutPokemonsInput>
    connectOrCreate?: generationCreateOrConnectWithoutPokemonsInput
    upsert?: generationUpsertWithoutPokemonsInput
    connect?: generationWhereUniqueInput
    update?: XOR<XOR<generationUpdateToOneWithWhereWithoutPokemonsInput, generationUpdateWithoutPokemonsInput>, generationUncheckedUpdateWithoutPokemonsInput>
  }

  export type pokemon_formUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<pokemon_formCreateWithoutPokemonInput, pokemon_formUncheckedCreateWithoutPokemonInput> | pokemon_formCreateWithoutPokemonInput[] | pokemon_formUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: pokemon_formCreateOrConnectWithoutPokemonInput | pokemon_formCreateOrConnectWithoutPokemonInput[]
    upsert?: pokemon_formUpsertWithWhereUniqueWithoutPokemonInput | pokemon_formUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: pokemon_formCreateManyPokemonInputEnvelope
    set?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    disconnect?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    delete?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    connect?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    update?: pokemon_formUpdateWithWhereUniqueWithoutPokemonInput | pokemon_formUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: pokemon_formUpdateManyWithWhereWithoutPokemonInput | pokemon_formUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: pokemon_formScalarWhereInput | pokemon_formScalarWhereInput[]
  }

  export type pokemon_infoUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<pokemon_infoCreateWithoutPokemonInput, pokemon_infoUncheckedCreateWithoutPokemonInput> | pokemon_infoCreateWithoutPokemonInput[] | pokemon_infoUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: pokemon_infoCreateOrConnectWithoutPokemonInput | pokemon_infoCreateOrConnectWithoutPokemonInput[]
    upsert?: pokemon_infoUpsertWithWhereUniqueWithoutPokemonInput | pokemon_infoUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: pokemon_infoCreateManyPokemonInputEnvelope
    set?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    disconnect?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    delete?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    connect?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    update?: pokemon_infoUpdateWithWhereUniqueWithoutPokemonInput | pokemon_infoUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: pokemon_infoUpdateManyWithWhereWithoutPokemonInput | pokemon_infoUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: pokemon_infoScalarWhereInput | pokemon_infoScalarWhereInput[]
  }

  export type skill_obtationUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<skill_obtationCreateWithoutPokemonInput, skill_obtationUncheckedCreateWithoutPokemonInput> | skill_obtationCreateWithoutPokemonInput[] | skill_obtationUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutPokemonInput | skill_obtationCreateOrConnectWithoutPokemonInput[]
    upsert?: skill_obtationUpsertWithWhereUniqueWithoutPokemonInput | skill_obtationUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: skill_obtationCreateManyPokemonInputEnvelope
    set?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    disconnect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    delete?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    update?: skill_obtationUpdateWithWhereUniqueWithoutPokemonInput | skill_obtationUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: skill_obtationUpdateManyWithWhereWithoutPokemonInput | skill_obtationUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: skill_obtationScalarWhereInput | skill_obtationScalarWhereInput[]
  }

  export type statistic_group_gameUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<statistic_group_gameCreateWithoutPokemonInput, statistic_group_gameUncheckedCreateWithoutPokemonInput> | statistic_group_gameCreateWithoutPokemonInput[] | statistic_group_gameUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: statistic_group_gameCreateOrConnectWithoutPokemonInput | statistic_group_gameCreateOrConnectWithoutPokemonInput[]
    upsert?: statistic_group_gameUpsertWithWhereUniqueWithoutPokemonInput | statistic_group_gameUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: statistic_group_gameCreateManyPokemonInputEnvelope
    set?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    disconnect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    delete?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    connect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    update?: statistic_group_gameUpdateWithWhereUniqueWithoutPokemonInput | statistic_group_gameUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: statistic_group_gameUpdateManyWithWhereWithoutPokemonInput | statistic_group_gameUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: statistic_group_gameScalarWhereInput | statistic_group_gameScalarWhereInput[]
  }

  export type national_numberUncheckedUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<national_numberCreateWithoutPokemonInput, national_numberUncheckedCreateWithoutPokemonInput> | national_numberCreateWithoutPokemonInput[] | national_numberUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: national_numberCreateOrConnectWithoutPokemonInput | national_numberCreateOrConnectWithoutPokemonInput[]
    upsert?: national_numberUpsertWithWhereUniqueWithoutPokemonInput | national_numberUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: national_numberCreateManyPokemonInputEnvelope
    set?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    disconnect?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    delete?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    connect?: national_numberWhereUniqueInput | national_numberWhereUniqueInput[]
    update?: national_numberUpdateWithWhereUniqueWithoutPokemonInput | national_numberUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: national_numberUpdateManyWithWhereWithoutPokemonInput | national_numberUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: national_numberScalarWhereInput | national_numberScalarWhereInput[]
  }

  export type pokemon_formUncheckedUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<pokemon_formCreateWithoutPokemonInput, pokemon_formUncheckedCreateWithoutPokemonInput> | pokemon_formCreateWithoutPokemonInput[] | pokemon_formUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: pokemon_formCreateOrConnectWithoutPokemonInput | pokemon_formCreateOrConnectWithoutPokemonInput[]
    upsert?: pokemon_formUpsertWithWhereUniqueWithoutPokemonInput | pokemon_formUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: pokemon_formCreateManyPokemonInputEnvelope
    set?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    disconnect?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    delete?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    connect?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    update?: pokemon_formUpdateWithWhereUniqueWithoutPokemonInput | pokemon_formUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: pokemon_formUpdateManyWithWhereWithoutPokemonInput | pokemon_formUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: pokemon_formScalarWhereInput | pokemon_formScalarWhereInput[]
  }

  export type pokemon_infoUncheckedUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<pokemon_infoCreateWithoutPokemonInput, pokemon_infoUncheckedCreateWithoutPokemonInput> | pokemon_infoCreateWithoutPokemonInput[] | pokemon_infoUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: pokemon_infoCreateOrConnectWithoutPokemonInput | pokemon_infoCreateOrConnectWithoutPokemonInput[]
    upsert?: pokemon_infoUpsertWithWhereUniqueWithoutPokemonInput | pokemon_infoUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: pokemon_infoCreateManyPokemonInputEnvelope
    set?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    disconnect?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    delete?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    connect?: pokemon_infoWhereUniqueInput | pokemon_infoWhereUniqueInput[]
    update?: pokemon_infoUpdateWithWhereUniqueWithoutPokemonInput | pokemon_infoUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: pokemon_infoUpdateManyWithWhereWithoutPokemonInput | pokemon_infoUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: pokemon_infoScalarWhereInput | pokemon_infoScalarWhereInput[]
  }

  export type skill_obtationUncheckedUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<skill_obtationCreateWithoutPokemonInput, skill_obtationUncheckedCreateWithoutPokemonInput> | skill_obtationCreateWithoutPokemonInput[] | skill_obtationUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutPokemonInput | skill_obtationCreateOrConnectWithoutPokemonInput[]
    upsert?: skill_obtationUpsertWithWhereUniqueWithoutPokemonInput | skill_obtationUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: skill_obtationCreateManyPokemonInputEnvelope
    set?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    disconnect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    delete?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    update?: skill_obtationUpdateWithWhereUniqueWithoutPokemonInput | skill_obtationUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: skill_obtationUpdateManyWithWhereWithoutPokemonInput | skill_obtationUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: skill_obtationScalarWhereInput | skill_obtationScalarWhereInput[]
  }

  export type statistic_group_gameUncheckedUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<statistic_group_gameCreateWithoutPokemonInput, statistic_group_gameUncheckedCreateWithoutPokemonInput> | statistic_group_gameCreateWithoutPokemonInput[] | statistic_group_gameUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: statistic_group_gameCreateOrConnectWithoutPokemonInput | statistic_group_gameCreateOrConnectWithoutPokemonInput[]
    upsert?: statistic_group_gameUpsertWithWhereUniqueWithoutPokemonInput | statistic_group_gameUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: statistic_group_gameCreateManyPokemonInputEnvelope
    set?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    disconnect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    delete?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    connect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    update?: statistic_group_gameUpdateWithWhereUniqueWithoutPokemonInput | statistic_group_gameUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: statistic_group_gameUpdateManyWithWhereWithoutPokemonInput | statistic_group_gameUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: statistic_group_gameScalarWhereInput | statistic_group_gameScalarWhereInput[]
  }

  export type pokemon_form_genderCreateNestedManyWithoutGenderInput = {
    create?: XOR<pokemon_form_genderCreateWithoutGenderInput, pokemon_form_genderUncheckedCreateWithoutGenderInput> | pokemon_form_genderCreateWithoutGenderInput[] | pokemon_form_genderUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: pokemon_form_genderCreateOrConnectWithoutGenderInput | pokemon_form_genderCreateOrConnectWithoutGenderInput[]
    createMany?: pokemon_form_genderCreateManyGenderInputEnvelope
    connect?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
  }

  export type pokemon_form_genderUncheckedCreateNestedManyWithoutGenderInput = {
    create?: XOR<pokemon_form_genderCreateWithoutGenderInput, pokemon_form_genderUncheckedCreateWithoutGenderInput> | pokemon_form_genderCreateWithoutGenderInput[] | pokemon_form_genderUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: pokemon_form_genderCreateOrConnectWithoutGenderInput | pokemon_form_genderCreateOrConnectWithoutGenderInput[]
    createMany?: pokemon_form_genderCreateManyGenderInputEnvelope
    connect?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
  }

  export type pokemon_form_genderUpdateManyWithoutGenderNestedInput = {
    create?: XOR<pokemon_form_genderCreateWithoutGenderInput, pokemon_form_genderUncheckedCreateWithoutGenderInput> | pokemon_form_genderCreateWithoutGenderInput[] | pokemon_form_genderUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: pokemon_form_genderCreateOrConnectWithoutGenderInput | pokemon_form_genderCreateOrConnectWithoutGenderInput[]
    upsert?: pokemon_form_genderUpsertWithWhereUniqueWithoutGenderInput | pokemon_form_genderUpsertWithWhereUniqueWithoutGenderInput[]
    createMany?: pokemon_form_genderCreateManyGenderInputEnvelope
    set?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    disconnect?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    delete?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    connect?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    update?: pokemon_form_genderUpdateWithWhereUniqueWithoutGenderInput | pokemon_form_genderUpdateWithWhereUniqueWithoutGenderInput[]
    updateMany?: pokemon_form_genderUpdateManyWithWhereWithoutGenderInput | pokemon_form_genderUpdateManyWithWhereWithoutGenderInput[]
    deleteMany?: pokemon_form_genderScalarWhereInput | pokemon_form_genderScalarWhereInput[]
  }

  export type pokemon_form_genderUncheckedUpdateManyWithoutGenderNestedInput = {
    create?: XOR<pokemon_form_genderCreateWithoutGenderInput, pokemon_form_genderUncheckedCreateWithoutGenderInput> | pokemon_form_genderCreateWithoutGenderInput[] | pokemon_form_genderUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: pokemon_form_genderCreateOrConnectWithoutGenderInput | pokemon_form_genderCreateOrConnectWithoutGenderInput[]
    upsert?: pokemon_form_genderUpsertWithWhereUniqueWithoutGenderInput | pokemon_form_genderUpsertWithWhereUniqueWithoutGenderInput[]
    createMany?: pokemon_form_genderCreateManyGenderInputEnvelope
    set?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    disconnect?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    delete?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    connect?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    update?: pokemon_form_genderUpdateWithWhereUniqueWithoutGenderInput | pokemon_form_genderUpdateWithWhereUniqueWithoutGenderInput[]
    updateMany?: pokemon_form_genderUpdateManyWithWhereWithoutGenderInput | pokemon_form_genderUpdateManyWithWhereWithoutGenderInput[]
    deleteMany?: pokemon_form_genderScalarWhereInput | pokemon_form_genderScalarWhereInput[]
  }

  export type pokemon_formCreateNestedManyWithoutFormInput = {
    create?: XOR<pokemon_formCreateWithoutFormInput, pokemon_formUncheckedCreateWithoutFormInput> | pokemon_formCreateWithoutFormInput[] | pokemon_formUncheckedCreateWithoutFormInput[]
    connectOrCreate?: pokemon_formCreateOrConnectWithoutFormInput | pokemon_formCreateOrConnectWithoutFormInput[]
    createMany?: pokemon_formCreateManyFormInputEnvelope
    connect?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
  }

  export type pokemon_formUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<pokemon_formCreateWithoutFormInput, pokemon_formUncheckedCreateWithoutFormInput> | pokemon_formCreateWithoutFormInput[] | pokemon_formUncheckedCreateWithoutFormInput[]
    connectOrCreate?: pokemon_formCreateOrConnectWithoutFormInput | pokemon_formCreateOrConnectWithoutFormInput[]
    createMany?: pokemon_formCreateManyFormInputEnvelope
    connect?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
  }

  export type pokemon_formUpdateManyWithoutFormNestedInput = {
    create?: XOR<pokemon_formCreateWithoutFormInput, pokemon_formUncheckedCreateWithoutFormInput> | pokemon_formCreateWithoutFormInput[] | pokemon_formUncheckedCreateWithoutFormInput[]
    connectOrCreate?: pokemon_formCreateOrConnectWithoutFormInput | pokemon_formCreateOrConnectWithoutFormInput[]
    upsert?: pokemon_formUpsertWithWhereUniqueWithoutFormInput | pokemon_formUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: pokemon_formCreateManyFormInputEnvelope
    set?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    disconnect?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    delete?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    connect?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    update?: pokemon_formUpdateWithWhereUniqueWithoutFormInput | pokemon_formUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: pokemon_formUpdateManyWithWhereWithoutFormInput | pokemon_formUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: pokemon_formScalarWhereInput | pokemon_formScalarWhereInput[]
  }

  export type pokemon_formUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<pokemon_formCreateWithoutFormInput, pokemon_formUncheckedCreateWithoutFormInput> | pokemon_formCreateWithoutFormInput[] | pokemon_formUncheckedCreateWithoutFormInput[]
    connectOrCreate?: pokemon_formCreateOrConnectWithoutFormInput | pokemon_formCreateOrConnectWithoutFormInput[]
    upsert?: pokemon_formUpsertWithWhereUniqueWithoutFormInput | pokemon_formUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: pokemon_formCreateManyFormInputEnvelope
    set?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    disconnect?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    delete?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    connect?: pokemon_formWhereUniqueInput | pokemon_formWhereUniqueInput[]
    update?: pokemon_formUpdateWithWhereUniqueWithoutFormInput | pokemon_formUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: pokemon_formUpdateManyWithWhereWithoutFormInput | pokemon_formUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: pokemon_formScalarWhereInput | pokemon_formScalarWhereInput[]
  }

  export type genderCreateNestedOneWithoutPokemonFormGendersInput = {
    create?: XOR<genderCreateWithoutPokemonFormGendersInput, genderUncheckedCreateWithoutPokemonFormGendersInput>
    connectOrCreate?: genderCreateOrConnectWithoutPokemonFormGendersInput
    connect?: genderWhereUniqueInput
  }

  export type pokemon_formCreateNestedOneWithoutPokemonFormGendersInput = {
    create?: XOR<pokemon_formCreateWithoutPokemonFormGendersInput, pokemon_formUncheckedCreateWithoutPokemonFormGendersInput>
    connectOrCreate?: pokemon_formCreateOrConnectWithoutPokemonFormGendersInput
    connect?: pokemon_formWhereUniqueInput
  }

  export type genderUpdateOneRequiredWithoutPokemonFormGendersNestedInput = {
    create?: XOR<genderCreateWithoutPokemonFormGendersInput, genderUncheckedCreateWithoutPokemonFormGendersInput>
    connectOrCreate?: genderCreateOrConnectWithoutPokemonFormGendersInput
    upsert?: genderUpsertWithoutPokemonFormGendersInput
    connect?: genderWhereUniqueInput
    update?: XOR<XOR<genderUpdateToOneWithWhereWithoutPokemonFormGendersInput, genderUpdateWithoutPokemonFormGendersInput>, genderUncheckedUpdateWithoutPokemonFormGendersInput>
  }

  export type pokemon_formUpdateOneRequiredWithoutPokemonFormGendersNestedInput = {
    create?: XOR<pokemon_formCreateWithoutPokemonFormGendersInput, pokemon_formUncheckedCreateWithoutPokemonFormGendersInput>
    connectOrCreate?: pokemon_formCreateOrConnectWithoutPokemonFormGendersInput
    upsert?: pokemon_formUpsertWithoutPokemonFormGendersInput
    connect?: pokemon_formWhereUniqueInput
    update?: XOR<XOR<pokemon_formUpdateToOneWithWhereWithoutPokemonFormGendersInput, pokemon_formUpdateWithoutPokemonFormGendersInput>, pokemon_formUncheckedUpdateWithoutPokemonFormGendersInput>
  }

  export type evolutionCreateNestedManyWithoutPokemonEndInput = {
    create?: XOR<evolutionCreateWithoutPokemonEndInput, evolutionUncheckedCreateWithoutPokemonEndInput> | evolutionCreateWithoutPokemonEndInput[] | evolutionUncheckedCreateWithoutPokemonEndInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutPokemonEndInput | evolutionCreateOrConnectWithoutPokemonEndInput[]
    createMany?: evolutionCreateManyPokemonEndInputEnvelope
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
  }

  export type evolutionCreateNestedManyWithoutPokemonStartInput = {
    create?: XOR<evolutionCreateWithoutPokemonStartInput, evolutionUncheckedCreateWithoutPokemonStartInput> | evolutionCreateWithoutPokemonStartInput[] | evolutionUncheckedCreateWithoutPokemonStartInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutPokemonStartInput | evolutionCreateOrConnectWithoutPokemonStartInput[]
    createMany?: evolutionCreateManyPokemonStartInputEnvelope
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
  }

  export type owned_pokemonCreateNestedManyWithoutPokemonFormsInput = {
    create?: XOR<owned_pokemonCreateWithoutPokemonFormsInput, owned_pokemonUncheckedCreateWithoutPokemonFormsInput> | owned_pokemonCreateWithoutPokemonFormsInput[] | owned_pokemonUncheckedCreateWithoutPokemonFormsInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutPokemonFormsInput | owned_pokemonCreateOrConnectWithoutPokemonFormsInput[]
    createMany?: owned_pokemonCreateManyPokemonFormsInputEnvelope
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
  }

  export type formCreateNestedOneWithoutPokemonFormsInput = {
    create?: XOR<formCreateWithoutPokemonFormsInput, formUncheckedCreateWithoutPokemonFormsInput>
    connectOrCreate?: formCreateOrConnectWithoutPokemonFormsInput
    connect?: formWhereUniqueInput
  }

  export type pokemonCreateNestedOneWithoutPokemonFormsInput = {
    create?: XOR<pokemonCreateWithoutPokemonFormsInput, pokemonUncheckedCreateWithoutPokemonFormsInput>
    connectOrCreate?: pokemonCreateOrConnectWithoutPokemonFormsInput
    connect?: pokemonWhereUniqueInput
  }

  export type pokemon_form_genderCreateNestedManyWithoutPokemon_formInput = {
    create?: XOR<pokemon_form_genderCreateWithoutPokemon_formInput, pokemon_form_genderUncheckedCreateWithoutPokemon_formInput> | pokemon_form_genderCreateWithoutPokemon_formInput[] | pokemon_form_genderUncheckedCreateWithoutPokemon_formInput[]
    connectOrCreate?: pokemon_form_genderCreateOrConnectWithoutPokemon_formInput | pokemon_form_genderCreateOrConnectWithoutPokemon_formInput[]
    createMany?: pokemon_form_genderCreateManyPokemon_formInputEnvelope
    connect?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
  }

  export type pokemon_game_locationCreateNestedManyWithoutPokemonFormInput = {
    create?: XOR<pokemon_game_locationCreateWithoutPokemonFormInput, pokemon_game_locationUncheckedCreateWithoutPokemonFormInput> | pokemon_game_locationCreateWithoutPokemonFormInput[] | pokemon_game_locationUncheckedCreateWithoutPokemonFormInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutPokemonFormInput | pokemon_game_locationCreateOrConnectWithoutPokemonFormInput[]
    createMany?: pokemon_game_locationCreateManyPokemonFormInputEnvelope
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
  }

  export type evolutionUncheckedCreateNestedManyWithoutPokemonEndInput = {
    create?: XOR<evolutionCreateWithoutPokemonEndInput, evolutionUncheckedCreateWithoutPokemonEndInput> | evolutionCreateWithoutPokemonEndInput[] | evolutionUncheckedCreateWithoutPokemonEndInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutPokemonEndInput | evolutionCreateOrConnectWithoutPokemonEndInput[]
    createMany?: evolutionCreateManyPokemonEndInputEnvelope
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
  }

  export type evolutionUncheckedCreateNestedManyWithoutPokemonStartInput = {
    create?: XOR<evolutionCreateWithoutPokemonStartInput, evolutionUncheckedCreateWithoutPokemonStartInput> | evolutionCreateWithoutPokemonStartInput[] | evolutionUncheckedCreateWithoutPokemonStartInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutPokemonStartInput | evolutionCreateOrConnectWithoutPokemonStartInput[]
    createMany?: evolutionCreateManyPokemonStartInputEnvelope
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
  }

  export type owned_pokemonUncheckedCreateNestedManyWithoutPokemonFormsInput = {
    create?: XOR<owned_pokemonCreateWithoutPokemonFormsInput, owned_pokemonUncheckedCreateWithoutPokemonFormsInput> | owned_pokemonCreateWithoutPokemonFormsInput[] | owned_pokemonUncheckedCreateWithoutPokemonFormsInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutPokemonFormsInput | owned_pokemonCreateOrConnectWithoutPokemonFormsInput[]
    createMany?: owned_pokemonCreateManyPokemonFormsInputEnvelope
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
  }

  export type pokemon_form_genderUncheckedCreateNestedManyWithoutPokemon_formInput = {
    create?: XOR<pokemon_form_genderCreateWithoutPokemon_formInput, pokemon_form_genderUncheckedCreateWithoutPokemon_formInput> | pokemon_form_genderCreateWithoutPokemon_formInput[] | pokemon_form_genderUncheckedCreateWithoutPokemon_formInput[]
    connectOrCreate?: pokemon_form_genderCreateOrConnectWithoutPokemon_formInput | pokemon_form_genderCreateOrConnectWithoutPokemon_formInput[]
    createMany?: pokemon_form_genderCreateManyPokemon_formInputEnvelope
    connect?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
  }

  export type pokemon_game_locationUncheckedCreateNestedManyWithoutPokemonFormInput = {
    create?: XOR<pokemon_game_locationCreateWithoutPokemonFormInput, pokemon_game_locationUncheckedCreateWithoutPokemonFormInput> | pokemon_game_locationCreateWithoutPokemonFormInput[] | pokemon_game_locationUncheckedCreateWithoutPokemonFormInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutPokemonFormInput | pokemon_game_locationCreateOrConnectWithoutPokemonFormInput[]
    createMany?: pokemon_game_locationCreateManyPokemonFormInputEnvelope
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
  }

  export type evolutionUpdateManyWithoutPokemonEndNestedInput = {
    create?: XOR<evolutionCreateWithoutPokemonEndInput, evolutionUncheckedCreateWithoutPokemonEndInput> | evolutionCreateWithoutPokemonEndInput[] | evolutionUncheckedCreateWithoutPokemonEndInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutPokemonEndInput | evolutionCreateOrConnectWithoutPokemonEndInput[]
    upsert?: evolutionUpsertWithWhereUniqueWithoutPokemonEndInput | evolutionUpsertWithWhereUniqueWithoutPokemonEndInput[]
    createMany?: evolutionCreateManyPokemonEndInputEnvelope
    set?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    disconnect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    delete?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    update?: evolutionUpdateWithWhereUniqueWithoutPokemonEndInput | evolutionUpdateWithWhereUniqueWithoutPokemonEndInput[]
    updateMany?: evolutionUpdateManyWithWhereWithoutPokemonEndInput | evolutionUpdateManyWithWhereWithoutPokemonEndInput[]
    deleteMany?: evolutionScalarWhereInput | evolutionScalarWhereInput[]
  }

  export type evolutionUpdateManyWithoutPokemonStartNestedInput = {
    create?: XOR<evolutionCreateWithoutPokemonStartInput, evolutionUncheckedCreateWithoutPokemonStartInput> | evolutionCreateWithoutPokemonStartInput[] | evolutionUncheckedCreateWithoutPokemonStartInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutPokemonStartInput | evolutionCreateOrConnectWithoutPokemonStartInput[]
    upsert?: evolutionUpsertWithWhereUniqueWithoutPokemonStartInput | evolutionUpsertWithWhereUniqueWithoutPokemonStartInput[]
    createMany?: evolutionCreateManyPokemonStartInputEnvelope
    set?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    disconnect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    delete?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    update?: evolutionUpdateWithWhereUniqueWithoutPokemonStartInput | evolutionUpdateWithWhereUniqueWithoutPokemonStartInput[]
    updateMany?: evolutionUpdateManyWithWhereWithoutPokemonStartInput | evolutionUpdateManyWithWhereWithoutPokemonStartInput[]
    deleteMany?: evolutionScalarWhereInput | evolutionScalarWhereInput[]
  }

  export type owned_pokemonUpdateManyWithoutPokemonFormsNestedInput = {
    create?: XOR<owned_pokemonCreateWithoutPokemonFormsInput, owned_pokemonUncheckedCreateWithoutPokemonFormsInput> | owned_pokemonCreateWithoutPokemonFormsInput[] | owned_pokemonUncheckedCreateWithoutPokemonFormsInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutPokemonFormsInput | owned_pokemonCreateOrConnectWithoutPokemonFormsInput[]
    upsert?: owned_pokemonUpsertWithWhereUniqueWithoutPokemonFormsInput | owned_pokemonUpsertWithWhereUniqueWithoutPokemonFormsInput[]
    createMany?: owned_pokemonCreateManyPokemonFormsInputEnvelope
    set?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    disconnect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    delete?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    update?: owned_pokemonUpdateWithWhereUniqueWithoutPokemonFormsInput | owned_pokemonUpdateWithWhereUniqueWithoutPokemonFormsInput[]
    updateMany?: owned_pokemonUpdateManyWithWhereWithoutPokemonFormsInput | owned_pokemonUpdateManyWithWhereWithoutPokemonFormsInput[]
    deleteMany?: owned_pokemonScalarWhereInput | owned_pokemonScalarWhereInput[]
  }

  export type formUpdateOneRequiredWithoutPokemonFormsNestedInput = {
    create?: XOR<formCreateWithoutPokemonFormsInput, formUncheckedCreateWithoutPokemonFormsInput>
    connectOrCreate?: formCreateOrConnectWithoutPokemonFormsInput
    upsert?: formUpsertWithoutPokemonFormsInput
    connect?: formWhereUniqueInput
    update?: XOR<XOR<formUpdateToOneWithWhereWithoutPokemonFormsInput, formUpdateWithoutPokemonFormsInput>, formUncheckedUpdateWithoutPokemonFormsInput>
  }

  export type pokemonUpdateOneRequiredWithoutPokemonFormsNestedInput = {
    create?: XOR<pokemonCreateWithoutPokemonFormsInput, pokemonUncheckedCreateWithoutPokemonFormsInput>
    connectOrCreate?: pokemonCreateOrConnectWithoutPokemonFormsInput
    upsert?: pokemonUpsertWithoutPokemonFormsInput
    connect?: pokemonWhereUniqueInput
    update?: XOR<XOR<pokemonUpdateToOneWithWhereWithoutPokemonFormsInput, pokemonUpdateWithoutPokemonFormsInput>, pokemonUncheckedUpdateWithoutPokemonFormsInput>
  }

  export type pokemon_form_genderUpdateManyWithoutPokemon_formNestedInput = {
    create?: XOR<pokemon_form_genderCreateWithoutPokemon_formInput, pokemon_form_genderUncheckedCreateWithoutPokemon_formInput> | pokemon_form_genderCreateWithoutPokemon_formInput[] | pokemon_form_genderUncheckedCreateWithoutPokemon_formInput[]
    connectOrCreate?: pokemon_form_genderCreateOrConnectWithoutPokemon_formInput | pokemon_form_genderCreateOrConnectWithoutPokemon_formInput[]
    upsert?: pokemon_form_genderUpsertWithWhereUniqueWithoutPokemon_formInput | pokemon_form_genderUpsertWithWhereUniqueWithoutPokemon_formInput[]
    createMany?: pokemon_form_genderCreateManyPokemon_formInputEnvelope
    set?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    disconnect?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    delete?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    connect?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    update?: pokemon_form_genderUpdateWithWhereUniqueWithoutPokemon_formInput | pokemon_form_genderUpdateWithWhereUniqueWithoutPokemon_formInput[]
    updateMany?: pokemon_form_genderUpdateManyWithWhereWithoutPokemon_formInput | pokemon_form_genderUpdateManyWithWhereWithoutPokemon_formInput[]
    deleteMany?: pokemon_form_genderScalarWhereInput | pokemon_form_genderScalarWhereInput[]
  }

  export type pokemon_game_locationUpdateManyWithoutPokemonFormNestedInput = {
    create?: XOR<pokemon_game_locationCreateWithoutPokemonFormInput, pokemon_game_locationUncheckedCreateWithoutPokemonFormInput> | pokemon_game_locationCreateWithoutPokemonFormInput[] | pokemon_game_locationUncheckedCreateWithoutPokemonFormInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutPokemonFormInput | pokemon_game_locationCreateOrConnectWithoutPokemonFormInput[]
    upsert?: pokemon_game_locationUpsertWithWhereUniqueWithoutPokemonFormInput | pokemon_game_locationUpsertWithWhereUniqueWithoutPokemonFormInput[]
    createMany?: pokemon_game_locationCreateManyPokemonFormInputEnvelope
    set?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    disconnect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    delete?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    update?: pokemon_game_locationUpdateWithWhereUniqueWithoutPokemonFormInput | pokemon_game_locationUpdateWithWhereUniqueWithoutPokemonFormInput[]
    updateMany?: pokemon_game_locationUpdateManyWithWhereWithoutPokemonFormInput | pokemon_game_locationUpdateManyWithWhereWithoutPokemonFormInput[]
    deleteMany?: pokemon_game_locationScalarWhereInput | pokemon_game_locationScalarWhereInput[]
  }

  export type evolutionUncheckedUpdateManyWithoutPokemonEndNestedInput = {
    create?: XOR<evolutionCreateWithoutPokemonEndInput, evolutionUncheckedCreateWithoutPokemonEndInput> | evolutionCreateWithoutPokemonEndInput[] | evolutionUncheckedCreateWithoutPokemonEndInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutPokemonEndInput | evolutionCreateOrConnectWithoutPokemonEndInput[]
    upsert?: evolutionUpsertWithWhereUniqueWithoutPokemonEndInput | evolutionUpsertWithWhereUniqueWithoutPokemonEndInput[]
    createMany?: evolutionCreateManyPokemonEndInputEnvelope
    set?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    disconnect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    delete?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    update?: evolutionUpdateWithWhereUniqueWithoutPokemonEndInput | evolutionUpdateWithWhereUniqueWithoutPokemonEndInput[]
    updateMany?: evolutionUpdateManyWithWhereWithoutPokemonEndInput | evolutionUpdateManyWithWhereWithoutPokemonEndInput[]
    deleteMany?: evolutionScalarWhereInput | evolutionScalarWhereInput[]
  }

  export type evolutionUncheckedUpdateManyWithoutPokemonStartNestedInput = {
    create?: XOR<evolutionCreateWithoutPokemonStartInput, evolutionUncheckedCreateWithoutPokemonStartInput> | evolutionCreateWithoutPokemonStartInput[] | evolutionUncheckedCreateWithoutPokemonStartInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutPokemonStartInput | evolutionCreateOrConnectWithoutPokemonStartInput[]
    upsert?: evolutionUpsertWithWhereUniqueWithoutPokemonStartInput | evolutionUpsertWithWhereUniqueWithoutPokemonStartInput[]
    createMany?: evolutionCreateManyPokemonStartInputEnvelope
    set?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    disconnect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    delete?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    update?: evolutionUpdateWithWhereUniqueWithoutPokemonStartInput | evolutionUpdateWithWhereUniqueWithoutPokemonStartInput[]
    updateMany?: evolutionUpdateManyWithWhereWithoutPokemonStartInput | evolutionUpdateManyWithWhereWithoutPokemonStartInput[]
    deleteMany?: evolutionScalarWhereInput | evolutionScalarWhereInput[]
  }

  export type owned_pokemonUncheckedUpdateManyWithoutPokemonFormsNestedInput = {
    create?: XOR<owned_pokemonCreateWithoutPokemonFormsInput, owned_pokemonUncheckedCreateWithoutPokemonFormsInput> | owned_pokemonCreateWithoutPokemonFormsInput[] | owned_pokemonUncheckedCreateWithoutPokemonFormsInput[]
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutPokemonFormsInput | owned_pokemonCreateOrConnectWithoutPokemonFormsInput[]
    upsert?: owned_pokemonUpsertWithWhereUniqueWithoutPokemonFormsInput | owned_pokemonUpsertWithWhereUniqueWithoutPokemonFormsInput[]
    createMany?: owned_pokemonCreateManyPokemonFormsInputEnvelope
    set?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    disconnect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    delete?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    connect?: owned_pokemonWhereUniqueInput | owned_pokemonWhereUniqueInput[]
    update?: owned_pokemonUpdateWithWhereUniqueWithoutPokemonFormsInput | owned_pokemonUpdateWithWhereUniqueWithoutPokemonFormsInput[]
    updateMany?: owned_pokemonUpdateManyWithWhereWithoutPokemonFormsInput | owned_pokemonUpdateManyWithWhereWithoutPokemonFormsInput[]
    deleteMany?: owned_pokemonScalarWhereInput | owned_pokemonScalarWhereInput[]
  }

  export type pokemon_form_genderUncheckedUpdateManyWithoutPokemon_formNestedInput = {
    create?: XOR<pokemon_form_genderCreateWithoutPokemon_formInput, pokemon_form_genderUncheckedCreateWithoutPokemon_formInput> | pokemon_form_genderCreateWithoutPokemon_formInput[] | pokemon_form_genderUncheckedCreateWithoutPokemon_formInput[]
    connectOrCreate?: pokemon_form_genderCreateOrConnectWithoutPokemon_formInput | pokemon_form_genderCreateOrConnectWithoutPokemon_formInput[]
    upsert?: pokemon_form_genderUpsertWithWhereUniqueWithoutPokemon_formInput | pokemon_form_genderUpsertWithWhereUniqueWithoutPokemon_formInput[]
    createMany?: pokemon_form_genderCreateManyPokemon_formInputEnvelope
    set?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    disconnect?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    delete?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    connect?: pokemon_form_genderWhereUniqueInput | pokemon_form_genderWhereUniqueInput[]
    update?: pokemon_form_genderUpdateWithWhereUniqueWithoutPokemon_formInput | pokemon_form_genderUpdateWithWhereUniqueWithoutPokemon_formInput[]
    updateMany?: pokemon_form_genderUpdateManyWithWhereWithoutPokemon_formInput | pokemon_form_genderUpdateManyWithWhereWithoutPokemon_formInput[]
    deleteMany?: pokemon_form_genderScalarWhereInput | pokemon_form_genderScalarWhereInput[]
  }

  export type pokemon_game_locationUncheckedUpdateManyWithoutPokemonFormNestedInput = {
    create?: XOR<pokemon_game_locationCreateWithoutPokemonFormInput, pokemon_game_locationUncheckedCreateWithoutPokemonFormInput> | pokemon_game_locationCreateWithoutPokemonFormInput[] | pokemon_game_locationUncheckedCreateWithoutPokemonFormInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutPokemonFormInput | pokemon_game_locationCreateOrConnectWithoutPokemonFormInput[]
    upsert?: pokemon_game_locationUpsertWithWhereUniqueWithoutPokemonFormInput | pokemon_game_locationUpsertWithWhereUniqueWithoutPokemonFormInput[]
    createMany?: pokemon_game_locationCreateManyPokemonFormInputEnvelope
    set?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    disconnect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    delete?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    update?: pokemon_game_locationUpdateWithWhereUniqueWithoutPokemonFormInput | pokemon_game_locationUpdateWithWhereUniqueWithoutPokemonFormInput[]
    updateMany?: pokemon_game_locationUpdateManyWithWhereWithoutPokemonFormInput | pokemon_game_locationUpdateManyWithWhereWithoutPokemonFormInput[]
    deleteMany?: pokemon_game_locationScalarWhereInput | pokemon_game_locationScalarWhereInput[]
  }

  export type gameCreateNestedOneWithoutOwnedPokemonsInput = {
    create?: XOR<gameCreateWithoutOwnedPokemonsInput, gameUncheckedCreateWithoutOwnedPokemonsInput>
    connectOrCreate?: gameCreateOrConnectWithoutOwnedPokemonsInput
    connect?: gameWhereUniqueInput
  }

  export type shiny_hunting_methodCreateNestedOneWithoutOwnedPokemonsInput = {
    create?: XOR<shiny_hunting_methodCreateWithoutOwnedPokemonsInput, shiny_hunting_methodUncheckedCreateWithoutOwnedPokemonsInput>
    connectOrCreate?: shiny_hunting_methodCreateOrConnectWithoutOwnedPokemonsInput
    connect?: shiny_hunting_methodWhereUniqueInput
  }

  export type pokemon_formCreateNestedOneWithoutOwnedPokemonsInput = {
    create?: XOR<pokemon_formCreateWithoutOwnedPokemonsInput, pokemon_formUncheckedCreateWithoutOwnedPokemonsInput>
    connectOrCreate?: pokemon_formCreateOrConnectWithoutOwnedPokemonsInput
    connect?: pokemon_formWhereUniqueInput
  }

  export type userCreateNestedOneWithoutOwnedPokemonsInput = {
    create?: XOR<userCreateWithoutOwnedPokemonsInput, userUncheckedCreateWithoutOwnedPokemonsInput>
    connectOrCreate?: userCreateOrConnectWithoutOwnedPokemonsInput
    connect?: userWhereUniqueInput
  }

  export type owned_pokemon_detailCreateNestedManyWithoutOwnedPokemonInput = {
    create?: XOR<owned_pokemon_detailCreateWithoutOwnedPokemonInput, owned_pokemon_detailUncheckedCreateWithoutOwnedPokemonInput> | owned_pokemon_detailCreateWithoutOwnedPokemonInput[] | owned_pokemon_detailUncheckedCreateWithoutOwnedPokemonInput[]
    connectOrCreate?: owned_pokemon_detailCreateOrConnectWithoutOwnedPokemonInput | owned_pokemon_detailCreateOrConnectWithoutOwnedPokemonInput[]
    createMany?: owned_pokemon_detailCreateManyOwnedPokemonInputEnvelope
    connect?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
  }

  export type owned_pokemon_detailUncheckedCreateNestedManyWithoutOwnedPokemonInput = {
    create?: XOR<owned_pokemon_detailCreateWithoutOwnedPokemonInput, owned_pokemon_detailUncheckedCreateWithoutOwnedPokemonInput> | owned_pokemon_detailCreateWithoutOwnedPokemonInput[] | owned_pokemon_detailUncheckedCreateWithoutOwnedPokemonInput[]
    connectOrCreate?: owned_pokemon_detailCreateOrConnectWithoutOwnedPokemonInput | owned_pokemon_detailCreateOrConnectWithoutOwnedPokemonInput[]
    createMany?: owned_pokemon_detailCreateManyOwnedPokemonInputEnvelope
    connect?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type gameUpdateOneRequiredWithoutOwnedPokemonsNestedInput = {
    create?: XOR<gameCreateWithoutOwnedPokemonsInput, gameUncheckedCreateWithoutOwnedPokemonsInput>
    connectOrCreate?: gameCreateOrConnectWithoutOwnedPokemonsInput
    upsert?: gameUpsertWithoutOwnedPokemonsInput
    connect?: gameWhereUniqueInput
    update?: XOR<XOR<gameUpdateToOneWithWhereWithoutOwnedPokemonsInput, gameUpdateWithoutOwnedPokemonsInput>, gameUncheckedUpdateWithoutOwnedPokemonsInput>
  }

  export type shiny_hunting_methodUpdateOneRequiredWithoutOwnedPokemonsNestedInput = {
    create?: XOR<shiny_hunting_methodCreateWithoutOwnedPokemonsInput, shiny_hunting_methodUncheckedCreateWithoutOwnedPokemonsInput>
    connectOrCreate?: shiny_hunting_methodCreateOrConnectWithoutOwnedPokemonsInput
    upsert?: shiny_hunting_methodUpsertWithoutOwnedPokemonsInput
    connect?: shiny_hunting_methodWhereUniqueInput
    update?: XOR<XOR<shiny_hunting_methodUpdateToOneWithWhereWithoutOwnedPokemonsInput, shiny_hunting_methodUpdateWithoutOwnedPokemonsInput>, shiny_hunting_methodUncheckedUpdateWithoutOwnedPokemonsInput>
  }

  export type pokemon_formUpdateOneRequiredWithoutOwnedPokemonsNestedInput = {
    create?: XOR<pokemon_formCreateWithoutOwnedPokemonsInput, pokemon_formUncheckedCreateWithoutOwnedPokemonsInput>
    connectOrCreate?: pokemon_formCreateOrConnectWithoutOwnedPokemonsInput
    upsert?: pokemon_formUpsertWithoutOwnedPokemonsInput
    connect?: pokemon_formWhereUniqueInput
    update?: XOR<XOR<pokemon_formUpdateToOneWithWhereWithoutOwnedPokemonsInput, pokemon_formUpdateWithoutOwnedPokemonsInput>, pokemon_formUncheckedUpdateWithoutOwnedPokemonsInput>
  }

  export type userUpdateOneRequiredWithoutOwnedPokemonsNestedInput = {
    create?: XOR<userCreateWithoutOwnedPokemonsInput, userUncheckedCreateWithoutOwnedPokemonsInput>
    connectOrCreate?: userCreateOrConnectWithoutOwnedPokemonsInput
    upsert?: userUpsertWithoutOwnedPokemonsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutOwnedPokemonsInput, userUpdateWithoutOwnedPokemonsInput>, userUncheckedUpdateWithoutOwnedPokemonsInput>
  }

  export type owned_pokemon_detailUpdateManyWithoutOwnedPokemonNestedInput = {
    create?: XOR<owned_pokemon_detailCreateWithoutOwnedPokemonInput, owned_pokemon_detailUncheckedCreateWithoutOwnedPokemonInput> | owned_pokemon_detailCreateWithoutOwnedPokemonInput[] | owned_pokemon_detailUncheckedCreateWithoutOwnedPokemonInput[]
    connectOrCreate?: owned_pokemon_detailCreateOrConnectWithoutOwnedPokemonInput | owned_pokemon_detailCreateOrConnectWithoutOwnedPokemonInput[]
    upsert?: owned_pokemon_detailUpsertWithWhereUniqueWithoutOwnedPokemonInput | owned_pokemon_detailUpsertWithWhereUniqueWithoutOwnedPokemonInput[]
    createMany?: owned_pokemon_detailCreateManyOwnedPokemonInputEnvelope
    set?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    disconnect?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    delete?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    connect?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    update?: owned_pokemon_detailUpdateWithWhereUniqueWithoutOwnedPokemonInput | owned_pokemon_detailUpdateWithWhereUniqueWithoutOwnedPokemonInput[]
    updateMany?: owned_pokemon_detailUpdateManyWithWhereWithoutOwnedPokemonInput | owned_pokemon_detailUpdateManyWithWhereWithoutOwnedPokemonInput[]
    deleteMany?: owned_pokemon_detailScalarWhereInput | owned_pokemon_detailScalarWhereInput[]
  }

  export type owned_pokemon_detailUncheckedUpdateManyWithoutOwnedPokemonNestedInput = {
    create?: XOR<owned_pokemon_detailCreateWithoutOwnedPokemonInput, owned_pokemon_detailUncheckedCreateWithoutOwnedPokemonInput> | owned_pokemon_detailCreateWithoutOwnedPokemonInput[] | owned_pokemon_detailUncheckedCreateWithoutOwnedPokemonInput[]
    connectOrCreate?: owned_pokemon_detailCreateOrConnectWithoutOwnedPokemonInput | owned_pokemon_detailCreateOrConnectWithoutOwnedPokemonInput[]
    upsert?: owned_pokemon_detailUpsertWithWhereUniqueWithoutOwnedPokemonInput | owned_pokemon_detailUpsertWithWhereUniqueWithoutOwnedPokemonInput[]
    createMany?: owned_pokemon_detailCreateManyOwnedPokemonInputEnvelope
    set?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    disconnect?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    delete?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    connect?: owned_pokemon_detailWhereUniqueInput | owned_pokemon_detailWhereUniqueInput[]
    update?: owned_pokemon_detailUpdateWithWhereUniqueWithoutOwnedPokemonInput | owned_pokemon_detailUpdateWithWhereUniqueWithoutOwnedPokemonInput[]
    updateMany?: owned_pokemon_detailUpdateManyWithWhereWithoutOwnedPokemonInput | owned_pokemon_detailUpdateManyWithWhereWithoutOwnedPokemonInput[]
    deleteMany?: owned_pokemon_detailScalarWhereInput | owned_pokemon_detailScalarWhereInput[]
  }

  export type owned_pokemonCreateNestedOneWithoutOwnedPokemonDetailsInput = {
    create?: XOR<owned_pokemonCreateWithoutOwnedPokemonDetailsInput, owned_pokemonUncheckedCreateWithoutOwnedPokemonDetailsInput>
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutOwnedPokemonDetailsInput
    connect?: owned_pokemonWhereUniqueInput
  }

  export type pokeballCreateNestedOneWithoutOwnedPokemonDetailsInput = {
    create?: XOR<pokeballCreateWithoutOwnedPokemonDetailsInput, pokeballUncheckedCreateWithoutOwnedPokemonDetailsInput>
    connectOrCreate?: pokeballCreateOrConnectWithoutOwnedPokemonDetailsInput
    connect?: pokeballWhereUniqueInput
  }

  export type owned_pokemonUpdateOneRequiredWithoutOwnedPokemonDetailsNestedInput = {
    create?: XOR<owned_pokemonCreateWithoutOwnedPokemonDetailsInput, owned_pokemonUncheckedCreateWithoutOwnedPokemonDetailsInput>
    connectOrCreate?: owned_pokemonCreateOrConnectWithoutOwnedPokemonDetailsInput
    upsert?: owned_pokemonUpsertWithoutOwnedPokemonDetailsInput
    connect?: owned_pokemonWhereUniqueInput
    update?: XOR<XOR<owned_pokemonUpdateToOneWithWhereWithoutOwnedPokemonDetailsInput, owned_pokemonUpdateWithoutOwnedPokemonDetailsInput>, owned_pokemonUncheckedUpdateWithoutOwnedPokemonDetailsInput>
  }

  export type pokeballUpdateOneRequiredWithoutOwnedPokemonDetailsNestedInput = {
    create?: XOR<pokeballCreateWithoutOwnedPokemonDetailsInput, pokeballUncheckedCreateWithoutOwnedPokemonDetailsInput>
    connectOrCreate?: pokeballCreateOrConnectWithoutOwnedPokemonDetailsInput
    upsert?: pokeballUpsertWithoutOwnedPokemonDetailsInput
    connect?: pokeballWhereUniqueInput
    update?: XOR<XOR<pokeballUpdateToOneWithWhereWithoutOwnedPokemonDetailsInput, pokeballUpdateWithoutOwnedPokemonDetailsInput>, pokeballUncheckedUpdateWithoutOwnedPokemonDetailsInput>
  }

  export type generationCreateNestedOneWithoutAbilitiesInput = {
    create?: XOR<generationCreateWithoutAbilitiesInput, generationUncheckedCreateWithoutAbilitiesInput>
    connectOrCreate?: generationCreateOrConnectWithoutAbilitiesInput
    connect?: generationWhereUniqueInput
  }

  export type ability_infoCreateNestedManyWithoutAbilitiesInput = {
    create?: XOR<ability_infoCreateWithoutAbilitiesInput, ability_infoUncheckedCreateWithoutAbilitiesInput> | ability_infoCreateWithoutAbilitiesInput[] | ability_infoUncheckedCreateWithoutAbilitiesInput[]
    connectOrCreate?: ability_infoCreateOrConnectWithoutAbilitiesInput | ability_infoCreateOrConnectWithoutAbilitiesInput[]
    createMany?: ability_infoCreateManyAbilitiesInputEnvelope
    connect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
  }

  export type ability_orderCreateNestedManyWithoutAbilityInput = {
    create?: XOR<ability_orderCreateWithoutAbilityInput, ability_orderUncheckedCreateWithoutAbilityInput> | ability_orderCreateWithoutAbilityInput[] | ability_orderUncheckedCreateWithoutAbilityInput[]
    connectOrCreate?: ability_orderCreateOrConnectWithoutAbilityInput | ability_orderCreateOrConnectWithoutAbilityInput[]
    createMany?: ability_orderCreateManyAbilityInputEnvelope
    connect?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
  }

  export type ability_infoUncheckedCreateNestedManyWithoutAbilitiesInput = {
    create?: XOR<ability_infoCreateWithoutAbilitiesInput, ability_infoUncheckedCreateWithoutAbilitiesInput> | ability_infoCreateWithoutAbilitiesInput[] | ability_infoUncheckedCreateWithoutAbilitiesInput[]
    connectOrCreate?: ability_infoCreateOrConnectWithoutAbilitiesInput | ability_infoCreateOrConnectWithoutAbilitiesInput[]
    createMany?: ability_infoCreateManyAbilitiesInputEnvelope
    connect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
  }

  export type ability_orderUncheckedCreateNestedManyWithoutAbilityInput = {
    create?: XOR<ability_orderCreateWithoutAbilityInput, ability_orderUncheckedCreateWithoutAbilityInput> | ability_orderCreateWithoutAbilityInput[] | ability_orderUncheckedCreateWithoutAbilityInput[]
    connectOrCreate?: ability_orderCreateOrConnectWithoutAbilityInput | ability_orderCreateOrConnectWithoutAbilityInput[]
    createMany?: ability_orderCreateManyAbilityInputEnvelope
    connect?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
  }

  export type generationUpdateOneRequiredWithoutAbilitiesNestedInput = {
    create?: XOR<generationCreateWithoutAbilitiesInput, generationUncheckedCreateWithoutAbilitiesInput>
    connectOrCreate?: generationCreateOrConnectWithoutAbilitiesInput
    upsert?: generationUpsertWithoutAbilitiesInput
    connect?: generationWhereUniqueInput
    update?: XOR<XOR<generationUpdateToOneWithWhereWithoutAbilitiesInput, generationUpdateWithoutAbilitiesInput>, generationUncheckedUpdateWithoutAbilitiesInput>
  }

  export type ability_infoUpdateManyWithoutAbilitiesNestedInput = {
    create?: XOR<ability_infoCreateWithoutAbilitiesInput, ability_infoUncheckedCreateWithoutAbilitiesInput> | ability_infoCreateWithoutAbilitiesInput[] | ability_infoUncheckedCreateWithoutAbilitiesInput[]
    connectOrCreate?: ability_infoCreateOrConnectWithoutAbilitiesInput | ability_infoCreateOrConnectWithoutAbilitiesInput[]
    upsert?: ability_infoUpsertWithWhereUniqueWithoutAbilitiesInput | ability_infoUpsertWithWhereUniqueWithoutAbilitiesInput[]
    createMany?: ability_infoCreateManyAbilitiesInputEnvelope
    set?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    disconnect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    delete?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    connect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    update?: ability_infoUpdateWithWhereUniqueWithoutAbilitiesInput | ability_infoUpdateWithWhereUniqueWithoutAbilitiesInput[]
    updateMany?: ability_infoUpdateManyWithWhereWithoutAbilitiesInput | ability_infoUpdateManyWithWhereWithoutAbilitiesInput[]
    deleteMany?: ability_infoScalarWhereInput | ability_infoScalarWhereInput[]
  }

  export type ability_orderUpdateManyWithoutAbilityNestedInput = {
    create?: XOR<ability_orderCreateWithoutAbilityInput, ability_orderUncheckedCreateWithoutAbilityInput> | ability_orderCreateWithoutAbilityInput[] | ability_orderUncheckedCreateWithoutAbilityInput[]
    connectOrCreate?: ability_orderCreateOrConnectWithoutAbilityInput | ability_orderCreateOrConnectWithoutAbilityInput[]
    upsert?: ability_orderUpsertWithWhereUniqueWithoutAbilityInput | ability_orderUpsertWithWhereUniqueWithoutAbilityInput[]
    createMany?: ability_orderCreateManyAbilityInputEnvelope
    set?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    disconnect?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    delete?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    connect?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    update?: ability_orderUpdateWithWhereUniqueWithoutAbilityInput | ability_orderUpdateWithWhereUniqueWithoutAbilityInput[]
    updateMany?: ability_orderUpdateManyWithWhereWithoutAbilityInput | ability_orderUpdateManyWithWhereWithoutAbilityInput[]
    deleteMany?: ability_orderScalarWhereInput | ability_orderScalarWhereInput[]
  }

  export type ability_infoUncheckedUpdateManyWithoutAbilitiesNestedInput = {
    create?: XOR<ability_infoCreateWithoutAbilitiesInput, ability_infoUncheckedCreateWithoutAbilitiesInput> | ability_infoCreateWithoutAbilitiesInput[] | ability_infoUncheckedCreateWithoutAbilitiesInput[]
    connectOrCreate?: ability_infoCreateOrConnectWithoutAbilitiesInput | ability_infoCreateOrConnectWithoutAbilitiesInput[]
    upsert?: ability_infoUpsertWithWhereUniqueWithoutAbilitiesInput | ability_infoUpsertWithWhereUniqueWithoutAbilitiesInput[]
    createMany?: ability_infoCreateManyAbilitiesInputEnvelope
    set?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    disconnect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    delete?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    connect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    update?: ability_infoUpdateWithWhereUniqueWithoutAbilitiesInput | ability_infoUpdateWithWhereUniqueWithoutAbilitiesInput[]
    updateMany?: ability_infoUpdateManyWithWhereWithoutAbilitiesInput | ability_infoUpdateManyWithWhereWithoutAbilitiesInput[]
    deleteMany?: ability_infoScalarWhereInput | ability_infoScalarWhereInput[]
  }

  export type ability_orderUncheckedUpdateManyWithoutAbilityNestedInput = {
    create?: XOR<ability_orderCreateWithoutAbilityInput, ability_orderUncheckedCreateWithoutAbilityInput> | ability_orderCreateWithoutAbilityInput[] | ability_orderUncheckedCreateWithoutAbilityInput[]
    connectOrCreate?: ability_orderCreateOrConnectWithoutAbilityInput | ability_orderCreateOrConnectWithoutAbilityInput[]
    upsert?: ability_orderUpsertWithWhereUniqueWithoutAbilityInput | ability_orderUpsertWithWhereUniqueWithoutAbilityInput[]
    createMany?: ability_orderCreateManyAbilityInputEnvelope
    set?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    disconnect?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    delete?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    connect?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    update?: ability_orderUpdateWithWhereUniqueWithoutAbilityInput | ability_orderUpdateWithWhereUniqueWithoutAbilityInput[]
    updateMany?: ability_orderUpdateManyWithWhereWithoutAbilityInput | ability_orderUpdateManyWithWhereWithoutAbilityInput[]
    deleteMany?: ability_orderScalarWhereInput | ability_orderScalarWhereInput[]
  }

  export type abilityCreateNestedOneWithoutAbilityInfosInput = {
    create?: XOR<abilityCreateWithoutAbilityInfosInput, abilityUncheckedCreateWithoutAbilityInfosInput>
    connectOrCreate?: abilityCreateOrConnectWithoutAbilityInfosInput
    connect?: abilityWhereUniqueInput
  }

  export type effect_outside_fightCreateNestedOneWithoutAbilityInfosInput = {
    create?: XOR<effect_outside_fightCreateWithoutAbilityInfosInput, effect_outside_fightUncheckedCreateWithoutAbilityInfosInput>
    connectOrCreate?: effect_outside_fightCreateOrConnectWithoutAbilityInfosInput
    connect?: effect_outside_fightWhereUniqueInput
  }

  export type generationCreateNestedOneWithoutAbilityInfosInput = {
    create?: XOR<generationCreateWithoutAbilityInfosInput, generationUncheckedCreateWithoutAbilityInfosInput>
    connectOrCreate?: generationCreateOrConnectWithoutAbilityInfosInput
    connect?: generationWhereUniqueInput
  }

  export type abilityUpdateOneRequiredWithoutAbilityInfosNestedInput = {
    create?: XOR<abilityCreateWithoutAbilityInfosInput, abilityUncheckedCreateWithoutAbilityInfosInput>
    connectOrCreate?: abilityCreateOrConnectWithoutAbilityInfosInput
    upsert?: abilityUpsertWithoutAbilityInfosInput
    connect?: abilityWhereUniqueInput
    update?: XOR<XOR<abilityUpdateToOneWithWhereWithoutAbilityInfosInput, abilityUpdateWithoutAbilityInfosInput>, abilityUncheckedUpdateWithoutAbilityInfosInput>
  }

  export type effect_outside_fightUpdateOneRequiredWithoutAbilityInfosNestedInput = {
    create?: XOR<effect_outside_fightCreateWithoutAbilityInfosInput, effect_outside_fightUncheckedCreateWithoutAbilityInfosInput>
    connectOrCreate?: effect_outside_fightCreateOrConnectWithoutAbilityInfosInput
    upsert?: effect_outside_fightUpsertWithoutAbilityInfosInput
    connect?: effect_outside_fightWhereUniqueInput
    update?: XOR<XOR<effect_outside_fightUpdateToOneWithWhereWithoutAbilityInfosInput, effect_outside_fightUpdateWithoutAbilityInfosInput>, effect_outside_fightUncheckedUpdateWithoutAbilityInfosInput>
  }

  export type generationUpdateOneRequiredWithoutAbilityInfosNestedInput = {
    create?: XOR<generationCreateWithoutAbilityInfosInput, generationUncheckedCreateWithoutAbilityInfosInput>
    connectOrCreate?: generationCreateOrConnectWithoutAbilityInfosInput
    upsert?: generationUpsertWithoutAbilityInfosInput
    connect?: generationWhereUniqueInput
    update?: XOR<XOR<generationUpdateToOneWithWhereWithoutAbilityInfosInput, generationUpdateWithoutAbilityInfosInput>, generationUncheckedUpdateWithoutAbilityInfosInput>
  }

  export type ability_orderCreateNestedManyWithoutPokemonInfoInput = {
    create?: XOR<ability_orderCreateWithoutPokemonInfoInput, ability_orderUncheckedCreateWithoutPokemonInfoInput> | ability_orderCreateWithoutPokemonInfoInput[] | ability_orderUncheckedCreateWithoutPokemonInfoInput[]
    connectOrCreate?: ability_orderCreateOrConnectWithoutPokemonInfoInput | ability_orderCreateOrConnectWithoutPokemonInfoInput[]
    createMany?: ability_orderCreateManyPokemonInfoInputEnvelope
    connect?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
  }

  export type egg_group_orderCreateNestedManyWithoutPokemonInfoInput = {
    create?: XOR<egg_group_orderCreateWithoutPokemonInfoInput, egg_group_orderUncheckedCreateWithoutPokemonInfoInput> | egg_group_orderCreateWithoutPokemonInfoInput[] | egg_group_orderUncheckedCreateWithoutPokemonInfoInput[]
    connectOrCreate?: egg_group_orderCreateOrConnectWithoutPokemonInfoInput | egg_group_orderCreateOrConnectWithoutPokemonInfoInput[]
    createMany?: egg_group_orderCreateManyPokemonInfoInputEnvelope
    connect?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
  }

  export type generationCreateNestedOneWithoutPokemonInfosInput = {
    create?: XOR<generationCreateWithoutPokemonInfosInput, generationUncheckedCreateWithoutPokemonInfosInput>
    connectOrCreate?: generationCreateOrConnectWithoutPokemonInfosInput
    connect?: generationWhereUniqueInput
  }

  export type pokemonCreateNestedOneWithoutPokemonInfosInput = {
    create?: XOR<pokemonCreateWithoutPokemonInfosInput, pokemonUncheckedCreateWithoutPokemonInfosInput>
    connectOrCreate?: pokemonCreateOrConnectWithoutPokemonInfosInput
    connect?: pokemonWhereUniqueInput
  }

  export type type_orderCreateNestedManyWithoutPokemonInfoInput = {
    create?: XOR<type_orderCreateWithoutPokemonInfoInput, type_orderUncheckedCreateWithoutPokemonInfoInput> | type_orderCreateWithoutPokemonInfoInput[] | type_orderUncheckedCreateWithoutPokemonInfoInput[]
    connectOrCreate?: type_orderCreateOrConnectWithoutPokemonInfoInput | type_orderCreateOrConnectWithoutPokemonInfoInput[]
    createMany?: type_orderCreateManyPokemonInfoInputEnvelope
    connect?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
  }

  export type ability_orderUncheckedCreateNestedManyWithoutPokemonInfoInput = {
    create?: XOR<ability_orderCreateWithoutPokemonInfoInput, ability_orderUncheckedCreateWithoutPokemonInfoInput> | ability_orderCreateWithoutPokemonInfoInput[] | ability_orderUncheckedCreateWithoutPokemonInfoInput[]
    connectOrCreate?: ability_orderCreateOrConnectWithoutPokemonInfoInput | ability_orderCreateOrConnectWithoutPokemonInfoInput[]
    createMany?: ability_orderCreateManyPokemonInfoInputEnvelope
    connect?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
  }

  export type egg_group_orderUncheckedCreateNestedManyWithoutPokemonInfoInput = {
    create?: XOR<egg_group_orderCreateWithoutPokemonInfoInput, egg_group_orderUncheckedCreateWithoutPokemonInfoInput> | egg_group_orderCreateWithoutPokemonInfoInput[] | egg_group_orderUncheckedCreateWithoutPokemonInfoInput[]
    connectOrCreate?: egg_group_orderCreateOrConnectWithoutPokemonInfoInput | egg_group_orderCreateOrConnectWithoutPokemonInfoInput[]
    createMany?: egg_group_orderCreateManyPokemonInfoInputEnvelope
    connect?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
  }

  export type type_orderUncheckedCreateNestedManyWithoutPokemonInfoInput = {
    create?: XOR<type_orderCreateWithoutPokemonInfoInput, type_orderUncheckedCreateWithoutPokemonInfoInput> | type_orderCreateWithoutPokemonInfoInput[] | type_orderUncheckedCreateWithoutPokemonInfoInput[]
    connectOrCreate?: type_orderCreateOrConnectWithoutPokemonInfoInput | type_orderCreateOrConnectWithoutPokemonInfoInput[]
    createMany?: type_orderCreateManyPokemonInfoInputEnvelope
    connect?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
  }

  export type ability_orderUpdateManyWithoutPokemonInfoNestedInput = {
    create?: XOR<ability_orderCreateWithoutPokemonInfoInput, ability_orderUncheckedCreateWithoutPokemonInfoInput> | ability_orderCreateWithoutPokemonInfoInput[] | ability_orderUncheckedCreateWithoutPokemonInfoInput[]
    connectOrCreate?: ability_orderCreateOrConnectWithoutPokemonInfoInput | ability_orderCreateOrConnectWithoutPokemonInfoInput[]
    upsert?: ability_orderUpsertWithWhereUniqueWithoutPokemonInfoInput | ability_orderUpsertWithWhereUniqueWithoutPokemonInfoInput[]
    createMany?: ability_orderCreateManyPokemonInfoInputEnvelope
    set?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    disconnect?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    delete?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    connect?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    update?: ability_orderUpdateWithWhereUniqueWithoutPokemonInfoInput | ability_orderUpdateWithWhereUniqueWithoutPokemonInfoInput[]
    updateMany?: ability_orderUpdateManyWithWhereWithoutPokemonInfoInput | ability_orderUpdateManyWithWhereWithoutPokemonInfoInput[]
    deleteMany?: ability_orderScalarWhereInput | ability_orderScalarWhereInput[]
  }

  export type egg_group_orderUpdateManyWithoutPokemonInfoNestedInput = {
    create?: XOR<egg_group_orderCreateWithoutPokemonInfoInput, egg_group_orderUncheckedCreateWithoutPokemonInfoInput> | egg_group_orderCreateWithoutPokemonInfoInput[] | egg_group_orderUncheckedCreateWithoutPokemonInfoInput[]
    connectOrCreate?: egg_group_orderCreateOrConnectWithoutPokemonInfoInput | egg_group_orderCreateOrConnectWithoutPokemonInfoInput[]
    upsert?: egg_group_orderUpsertWithWhereUniqueWithoutPokemonInfoInput | egg_group_orderUpsertWithWhereUniqueWithoutPokemonInfoInput[]
    createMany?: egg_group_orderCreateManyPokemonInfoInputEnvelope
    set?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    disconnect?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    delete?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    connect?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    update?: egg_group_orderUpdateWithWhereUniqueWithoutPokemonInfoInput | egg_group_orderUpdateWithWhereUniqueWithoutPokemonInfoInput[]
    updateMany?: egg_group_orderUpdateManyWithWhereWithoutPokemonInfoInput | egg_group_orderUpdateManyWithWhereWithoutPokemonInfoInput[]
    deleteMany?: egg_group_orderScalarWhereInput | egg_group_orderScalarWhereInput[]
  }

  export type generationUpdateOneRequiredWithoutPokemonInfosNestedInput = {
    create?: XOR<generationCreateWithoutPokemonInfosInput, generationUncheckedCreateWithoutPokemonInfosInput>
    connectOrCreate?: generationCreateOrConnectWithoutPokemonInfosInput
    upsert?: generationUpsertWithoutPokemonInfosInput
    connect?: generationWhereUniqueInput
    update?: XOR<XOR<generationUpdateToOneWithWhereWithoutPokemonInfosInput, generationUpdateWithoutPokemonInfosInput>, generationUncheckedUpdateWithoutPokemonInfosInput>
  }

  export type pokemonUpdateOneRequiredWithoutPokemonInfosNestedInput = {
    create?: XOR<pokemonCreateWithoutPokemonInfosInput, pokemonUncheckedCreateWithoutPokemonInfosInput>
    connectOrCreate?: pokemonCreateOrConnectWithoutPokemonInfosInput
    upsert?: pokemonUpsertWithoutPokemonInfosInput
    connect?: pokemonWhereUniqueInput
    update?: XOR<XOR<pokemonUpdateToOneWithWhereWithoutPokemonInfosInput, pokemonUpdateWithoutPokemonInfosInput>, pokemonUncheckedUpdateWithoutPokemonInfosInput>
  }

  export type type_orderUpdateManyWithoutPokemonInfoNestedInput = {
    create?: XOR<type_orderCreateWithoutPokemonInfoInput, type_orderUncheckedCreateWithoutPokemonInfoInput> | type_orderCreateWithoutPokemonInfoInput[] | type_orderUncheckedCreateWithoutPokemonInfoInput[]
    connectOrCreate?: type_orderCreateOrConnectWithoutPokemonInfoInput | type_orderCreateOrConnectWithoutPokemonInfoInput[]
    upsert?: type_orderUpsertWithWhereUniqueWithoutPokemonInfoInput | type_orderUpsertWithWhereUniqueWithoutPokemonInfoInput[]
    createMany?: type_orderCreateManyPokemonInfoInputEnvelope
    set?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    disconnect?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    delete?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    connect?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    update?: type_orderUpdateWithWhereUniqueWithoutPokemonInfoInput | type_orderUpdateWithWhereUniqueWithoutPokemonInfoInput[]
    updateMany?: type_orderUpdateManyWithWhereWithoutPokemonInfoInput | type_orderUpdateManyWithWhereWithoutPokemonInfoInput[]
    deleteMany?: type_orderScalarWhereInput | type_orderScalarWhereInput[]
  }

  export type ability_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput = {
    create?: XOR<ability_orderCreateWithoutPokemonInfoInput, ability_orderUncheckedCreateWithoutPokemonInfoInput> | ability_orderCreateWithoutPokemonInfoInput[] | ability_orderUncheckedCreateWithoutPokemonInfoInput[]
    connectOrCreate?: ability_orderCreateOrConnectWithoutPokemonInfoInput | ability_orderCreateOrConnectWithoutPokemonInfoInput[]
    upsert?: ability_orderUpsertWithWhereUniqueWithoutPokemonInfoInput | ability_orderUpsertWithWhereUniqueWithoutPokemonInfoInput[]
    createMany?: ability_orderCreateManyPokemonInfoInputEnvelope
    set?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    disconnect?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    delete?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    connect?: ability_orderWhereUniqueInput | ability_orderWhereUniqueInput[]
    update?: ability_orderUpdateWithWhereUniqueWithoutPokemonInfoInput | ability_orderUpdateWithWhereUniqueWithoutPokemonInfoInput[]
    updateMany?: ability_orderUpdateManyWithWhereWithoutPokemonInfoInput | ability_orderUpdateManyWithWhereWithoutPokemonInfoInput[]
    deleteMany?: ability_orderScalarWhereInput | ability_orderScalarWhereInput[]
  }

  export type egg_group_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput = {
    create?: XOR<egg_group_orderCreateWithoutPokemonInfoInput, egg_group_orderUncheckedCreateWithoutPokemonInfoInput> | egg_group_orderCreateWithoutPokemonInfoInput[] | egg_group_orderUncheckedCreateWithoutPokemonInfoInput[]
    connectOrCreate?: egg_group_orderCreateOrConnectWithoutPokemonInfoInput | egg_group_orderCreateOrConnectWithoutPokemonInfoInput[]
    upsert?: egg_group_orderUpsertWithWhereUniqueWithoutPokemonInfoInput | egg_group_orderUpsertWithWhereUniqueWithoutPokemonInfoInput[]
    createMany?: egg_group_orderCreateManyPokemonInfoInputEnvelope
    set?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    disconnect?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    delete?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    connect?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    update?: egg_group_orderUpdateWithWhereUniqueWithoutPokemonInfoInput | egg_group_orderUpdateWithWhereUniqueWithoutPokemonInfoInput[]
    updateMany?: egg_group_orderUpdateManyWithWhereWithoutPokemonInfoInput | egg_group_orderUpdateManyWithWhereWithoutPokemonInfoInput[]
    deleteMany?: egg_group_orderScalarWhereInput | egg_group_orderScalarWhereInput[]
  }

  export type type_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput = {
    create?: XOR<type_orderCreateWithoutPokemonInfoInput, type_orderUncheckedCreateWithoutPokemonInfoInput> | type_orderCreateWithoutPokemonInfoInput[] | type_orderUncheckedCreateWithoutPokemonInfoInput[]
    connectOrCreate?: type_orderCreateOrConnectWithoutPokemonInfoInput | type_orderCreateOrConnectWithoutPokemonInfoInput[]
    upsert?: type_orderUpsertWithWhereUniqueWithoutPokemonInfoInput | type_orderUpsertWithWhereUniqueWithoutPokemonInfoInput[]
    createMany?: type_orderCreateManyPokemonInfoInputEnvelope
    set?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    disconnect?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    delete?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    connect?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    update?: type_orderUpdateWithWhereUniqueWithoutPokemonInfoInput | type_orderUpdateWithWhereUniqueWithoutPokemonInfoInput[]
    updateMany?: type_orderUpdateManyWithWhereWithoutPokemonInfoInput | type_orderUpdateManyWithWhereWithoutPokemonInfoInput[]
    deleteMany?: type_orderScalarWhereInput | type_orderScalarWhereInput[]
  }

  export type abilityCreateNestedOneWithoutAbilityOrdersInput = {
    create?: XOR<abilityCreateWithoutAbilityOrdersInput, abilityUncheckedCreateWithoutAbilityOrdersInput>
    connectOrCreate?: abilityCreateOrConnectWithoutAbilityOrdersInput
    connect?: abilityWhereUniqueInput
  }

  export type pokemon_infoCreateNestedOneWithoutAbilityOrdersInput = {
    create?: XOR<pokemon_infoCreateWithoutAbilityOrdersInput, pokemon_infoUncheckedCreateWithoutAbilityOrdersInput>
    connectOrCreate?: pokemon_infoCreateOrConnectWithoutAbilityOrdersInput
    connect?: pokemon_infoWhereUniqueInput
  }

  export type abilityUpdateOneRequiredWithoutAbilityOrdersNestedInput = {
    create?: XOR<abilityCreateWithoutAbilityOrdersInput, abilityUncheckedCreateWithoutAbilityOrdersInput>
    connectOrCreate?: abilityCreateOrConnectWithoutAbilityOrdersInput
    upsert?: abilityUpsertWithoutAbilityOrdersInput
    connect?: abilityWhereUniqueInput
    update?: XOR<XOR<abilityUpdateToOneWithWhereWithoutAbilityOrdersInput, abilityUpdateWithoutAbilityOrdersInput>, abilityUncheckedUpdateWithoutAbilityOrdersInput>
  }

  export type pokemon_infoUpdateOneRequiredWithoutAbilityOrdersNestedInput = {
    create?: XOR<pokemon_infoCreateWithoutAbilityOrdersInput, pokemon_infoUncheckedCreateWithoutAbilityOrdersInput>
    connectOrCreate?: pokemon_infoCreateOrConnectWithoutAbilityOrdersInput
    upsert?: pokemon_infoUpsertWithoutAbilityOrdersInput
    connect?: pokemon_infoWhereUniqueInput
    update?: XOR<XOR<pokemon_infoUpdateToOneWithWhereWithoutAbilityOrdersInput, pokemon_infoUpdateWithoutAbilityOrdersInput>, pokemon_infoUncheckedUpdateWithoutAbilityOrdersInput>
  }

  export type evolutionCreateNestedManyWithoutEvolutionMethodInput = {
    create?: XOR<evolutionCreateWithoutEvolutionMethodInput, evolutionUncheckedCreateWithoutEvolutionMethodInput> | evolutionCreateWithoutEvolutionMethodInput[] | evolutionUncheckedCreateWithoutEvolutionMethodInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutEvolutionMethodInput | evolutionCreateOrConnectWithoutEvolutionMethodInput[]
    createMany?: evolutionCreateManyEvolutionMethodInputEnvelope
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
  }

  export type evolutionUncheckedCreateNestedManyWithoutEvolutionMethodInput = {
    create?: XOR<evolutionCreateWithoutEvolutionMethodInput, evolutionUncheckedCreateWithoutEvolutionMethodInput> | evolutionCreateWithoutEvolutionMethodInput[] | evolutionUncheckedCreateWithoutEvolutionMethodInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutEvolutionMethodInput | evolutionCreateOrConnectWithoutEvolutionMethodInput[]
    createMany?: evolutionCreateManyEvolutionMethodInputEnvelope
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
  }

  export type evolutionUpdateManyWithoutEvolutionMethodNestedInput = {
    create?: XOR<evolutionCreateWithoutEvolutionMethodInput, evolutionUncheckedCreateWithoutEvolutionMethodInput> | evolutionCreateWithoutEvolutionMethodInput[] | evolutionUncheckedCreateWithoutEvolutionMethodInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutEvolutionMethodInput | evolutionCreateOrConnectWithoutEvolutionMethodInput[]
    upsert?: evolutionUpsertWithWhereUniqueWithoutEvolutionMethodInput | evolutionUpsertWithWhereUniqueWithoutEvolutionMethodInput[]
    createMany?: evolutionCreateManyEvolutionMethodInputEnvelope
    set?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    disconnect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    delete?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    update?: evolutionUpdateWithWhereUniqueWithoutEvolutionMethodInput | evolutionUpdateWithWhereUniqueWithoutEvolutionMethodInput[]
    updateMany?: evolutionUpdateManyWithWhereWithoutEvolutionMethodInput | evolutionUpdateManyWithWhereWithoutEvolutionMethodInput[]
    deleteMany?: evolutionScalarWhereInput | evolutionScalarWhereInput[]
  }

  export type evolutionUncheckedUpdateManyWithoutEvolutionMethodNestedInput = {
    create?: XOR<evolutionCreateWithoutEvolutionMethodInput, evolutionUncheckedCreateWithoutEvolutionMethodInput> | evolutionCreateWithoutEvolutionMethodInput[] | evolutionUncheckedCreateWithoutEvolutionMethodInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutEvolutionMethodInput | evolutionCreateOrConnectWithoutEvolutionMethodInput[]
    upsert?: evolutionUpsertWithWhereUniqueWithoutEvolutionMethodInput | evolutionUpsertWithWhereUniqueWithoutEvolutionMethodInput[]
    createMany?: evolutionCreateManyEvolutionMethodInputEnvelope
    set?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    disconnect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    delete?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    update?: evolutionUpdateWithWhereUniqueWithoutEvolutionMethodInput | evolutionUpdateWithWhereUniqueWithoutEvolutionMethodInput[]
    updateMany?: evolutionUpdateManyWithWhereWithoutEvolutionMethodInput | evolutionUpdateManyWithWhereWithoutEvolutionMethodInput[]
    deleteMany?: evolutionScalarWhereInput | evolutionScalarWhereInput[]
  }

  export type evolution_infoCreateNestedOneWithoutEvolutionsInput = {
    create?: XOR<evolution_infoCreateWithoutEvolutionsInput, evolution_infoUncheckedCreateWithoutEvolutionsInput>
    connectOrCreate?: evolution_infoCreateOrConnectWithoutEvolutionsInput
    connect?: evolution_infoWhereUniqueInput
  }

  export type evolution_methodCreateNestedOneWithoutEvolutionsInput = {
    create?: XOR<evolution_methodCreateWithoutEvolutionsInput, evolution_methodUncheckedCreateWithoutEvolutionsInput>
    connectOrCreate?: evolution_methodCreateOrConnectWithoutEvolutionsInput
    connect?: evolution_methodWhereUniqueInput
  }

  export type pokemon_formCreateNestedOneWithoutEvolutionEndsInput = {
    create?: XOR<pokemon_formCreateWithoutEvolutionEndsInput, pokemon_formUncheckedCreateWithoutEvolutionEndsInput>
    connectOrCreate?: pokemon_formCreateOrConnectWithoutEvolutionEndsInput
    connect?: pokemon_formWhereUniqueInput
  }

  export type pokemon_formCreateNestedOneWithoutEvolutionStartsInput = {
    create?: XOR<pokemon_formCreateWithoutEvolutionStartsInput, pokemon_formUncheckedCreateWithoutEvolutionStartsInput>
    connectOrCreate?: pokemon_formCreateOrConnectWithoutEvolutionStartsInput
    connect?: pokemon_formWhereUniqueInput
  }

  export type evolution_infoUpdateOneRequiredWithoutEvolutionsNestedInput = {
    create?: XOR<evolution_infoCreateWithoutEvolutionsInput, evolution_infoUncheckedCreateWithoutEvolutionsInput>
    connectOrCreate?: evolution_infoCreateOrConnectWithoutEvolutionsInput
    upsert?: evolution_infoUpsertWithoutEvolutionsInput
    connect?: evolution_infoWhereUniqueInput
    update?: XOR<XOR<evolution_infoUpdateToOneWithWhereWithoutEvolutionsInput, evolution_infoUpdateWithoutEvolutionsInput>, evolution_infoUncheckedUpdateWithoutEvolutionsInput>
  }

  export type evolution_methodUpdateOneRequiredWithoutEvolutionsNestedInput = {
    create?: XOR<evolution_methodCreateWithoutEvolutionsInput, evolution_methodUncheckedCreateWithoutEvolutionsInput>
    connectOrCreate?: evolution_methodCreateOrConnectWithoutEvolutionsInput
    upsert?: evolution_methodUpsertWithoutEvolutionsInput
    connect?: evolution_methodWhereUniqueInput
    update?: XOR<XOR<evolution_methodUpdateToOneWithWhereWithoutEvolutionsInput, evolution_methodUpdateWithoutEvolutionsInput>, evolution_methodUncheckedUpdateWithoutEvolutionsInput>
  }

  export type pokemon_formUpdateOneRequiredWithoutEvolutionEndsNestedInput = {
    create?: XOR<pokemon_formCreateWithoutEvolutionEndsInput, pokemon_formUncheckedCreateWithoutEvolutionEndsInput>
    connectOrCreate?: pokemon_formCreateOrConnectWithoutEvolutionEndsInput
    upsert?: pokemon_formUpsertWithoutEvolutionEndsInput
    connect?: pokemon_formWhereUniqueInput
    update?: XOR<XOR<pokemon_formUpdateToOneWithWhereWithoutEvolutionEndsInput, pokemon_formUpdateWithoutEvolutionEndsInput>, pokemon_formUncheckedUpdateWithoutEvolutionEndsInput>
  }

  export type pokemon_formUpdateOneRequiredWithoutEvolutionStartsNestedInput = {
    create?: XOR<pokemon_formCreateWithoutEvolutionStartsInput, pokemon_formUncheckedCreateWithoutEvolutionStartsInput>
    connectOrCreate?: pokemon_formCreateOrConnectWithoutEvolutionStartsInput
    upsert?: pokemon_formUpsertWithoutEvolutionStartsInput
    connect?: pokemon_formWhereUniqueInput
    update?: XOR<XOR<pokemon_formUpdateToOneWithWhereWithoutEvolutionStartsInput, pokemon_formUpdateWithoutEvolutionStartsInput>, pokemon_formUncheckedUpdateWithoutEvolutionStartsInput>
  }

  export type evolutionCreateNestedManyWithoutEvolutionInfoInput = {
    create?: XOR<evolutionCreateWithoutEvolutionInfoInput, evolutionUncheckedCreateWithoutEvolutionInfoInput> | evolutionCreateWithoutEvolutionInfoInput[] | evolutionUncheckedCreateWithoutEvolutionInfoInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutEvolutionInfoInput | evolutionCreateOrConnectWithoutEvolutionInfoInput[]
    createMany?: evolutionCreateManyEvolutionInfoInputEnvelope
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
  }

  export type evolutionUncheckedCreateNestedManyWithoutEvolutionInfoInput = {
    create?: XOR<evolutionCreateWithoutEvolutionInfoInput, evolutionUncheckedCreateWithoutEvolutionInfoInput> | evolutionCreateWithoutEvolutionInfoInput[] | evolutionUncheckedCreateWithoutEvolutionInfoInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutEvolutionInfoInput | evolutionCreateOrConnectWithoutEvolutionInfoInput[]
    createMany?: evolutionCreateManyEvolutionInfoInputEnvelope
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
  }

  export type evolutionUpdateManyWithoutEvolutionInfoNestedInput = {
    create?: XOR<evolutionCreateWithoutEvolutionInfoInput, evolutionUncheckedCreateWithoutEvolutionInfoInput> | evolutionCreateWithoutEvolutionInfoInput[] | evolutionUncheckedCreateWithoutEvolutionInfoInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutEvolutionInfoInput | evolutionCreateOrConnectWithoutEvolutionInfoInput[]
    upsert?: evolutionUpsertWithWhereUniqueWithoutEvolutionInfoInput | evolutionUpsertWithWhereUniqueWithoutEvolutionInfoInput[]
    createMany?: evolutionCreateManyEvolutionInfoInputEnvelope
    set?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    disconnect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    delete?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    update?: evolutionUpdateWithWhereUniqueWithoutEvolutionInfoInput | evolutionUpdateWithWhereUniqueWithoutEvolutionInfoInput[]
    updateMany?: evolutionUpdateManyWithWhereWithoutEvolutionInfoInput | evolutionUpdateManyWithWhereWithoutEvolutionInfoInput[]
    deleteMany?: evolutionScalarWhereInput | evolutionScalarWhereInput[]
  }

  export type evolutionUncheckedUpdateManyWithoutEvolutionInfoNestedInput = {
    create?: XOR<evolutionCreateWithoutEvolutionInfoInput, evolutionUncheckedCreateWithoutEvolutionInfoInput> | evolutionCreateWithoutEvolutionInfoInput[] | evolutionUncheckedCreateWithoutEvolutionInfoInput[]
    connectOrCreate?: evolutionCreateOrConnectWithoutEvolutionInfoInput | evolutionCreateOrConnectWithoutEvolutionInfoInput[]
    upsert?: evolutionUpsertWithWhereUniqueWithoutEvolutionInfoInput | evolutionUpsertWithWhereUniqueWithoutEvolutionInfoInput[]
    createMany?: evolutionCreateManyEvolutionInfoInputEnvelope
    set?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    disconnect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    delete?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    connect?: evolutionWhereUniqueInput | evolutionWhereUniqueInput[]
    update?: evolutionUpdateWithWhereUniqueWithoutEvolutionInfoInput | evolutionUpdateWithWhereUniqueWithoutEvolutionInfoInput[]
    updateMany?: evolutionUpdateManyWithWhereWithoutEvolutionInfoInput | evolutionUpdateManyWithWhereWithoutEvolutionInfoInput[]
    deleteMany?: evolutionScalarWhereInput | evolutionScalarWhereInput[]
  }

  export type egg_group_orderCreateNestedManyWithoutEggGroupInput = {
    create?: XOR<egg_group_orderCreateWithoutEggGroupInput, egg_group_orderUncheckedCreateWithoutEggGroupInput> | egg_group_orderCreateWithoutEggGroupInput[] | egg_group_orderUncheckedCreateWithoutEggGroupInput[]
    connectOrCreate?: egg_group_orderCreateOrConnectWithoutEggGroupInput | egg_group_orderCreateOrConnectWithoutEggGroupInput[]
    createMany?: egg_group_orderCreateManyEggGroupInputEnvelope
    connect?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
  }

  export type egg_group_orderUncheckedCreateNestedManyWithoutEggGroupInput = {
    create?: XOR<egg_group_orderCreateWithoutEggGroupInput, egg_group_orderUncheckedCreateWithoutEggGroupInput> | egg_group_orderCreateWithoutEggGroupInput[] | egg_group_orderUncheckedCreateWithoutEggGroupInput[]
    connectOrCreate?: egg_group_orderCreateOrConnectWithoutEggGroupInput | egg_group_orderCreateOrConnectWithoutEggGroupInput[]
    createMany?: egg_group_orderCreateManyEggGroupInputEnvelope
    connect?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
  }

  export type egg_group_orderUpdateManyWithoutEggGroupNestedInput = {
    create?: XOR<egg_group_orderCreateWithoutEggGroupInput, egg_group_orderUncheckedCreateWithoutEggGroupInput> | egg_group_orderCreateWithoutEggGroupInput[] | egg_group_orderUncheckedCreateWithoutEggGroupInput[]
    connectOrCreate?: egg_group_orderCreateOrConnectWithoutEggGroupInput | egg_group_orderCreateOrConnectWithoutEggGroupInput[]
    upsert?: egg_group_orderUpsertWithWhereUniqueWithoutEggGroupInput | egg_group_orderUpsertWithWhereUniqueWithoutEggGroupInput[]
    createMany?: egg_group_orderCreateManyEggGroupInputEnvelope
    set?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    disconnect?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    delete?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    connect?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    update?: egg_group_orderUpdateWithWhereUniqueWithoutEggGroupInput | egg_group_orderUpdateWithWhereUniqueWithoutEggGroupInput[]
    updateMany?: egg_group_orderUpdateManyWithWhereWithoutEggGroupInput | egg_group_orderUpdateManyWithWhereWithoutEggGroupInput[]
    deleteMany?: egg_group_orderScalarWhereInput | egg_group_orderScalarWhereInput[]
  }

  export type egg_group_orderUncheckedUpdateManyWithoutEggGroupNestedInput = {
    create?: XOR<egg_group_orderCreateWithoutEggGroupInput, egg_group_orderUncheckedCreateWithoutEggGroupInput> | egg_group_orderCreateWithoutEggGroupInput[] | egg_group_orderUncheckedCreateWithoutEggGroupInput[]
    connectOrCreate?: egg_group_orderCreateOrConnectWithoutEggGroupInput | egg_group_orderCreateOrConnectWithoutEggGroupInput[]
    upsert?: egg_group_orderUpsertWithWhereUniqueWithoutEggGroupInput | egg_group_orderUpsertWithWhereUniqueWithoutEggGroupInput[]
    createMany?: egg_group_orderCreateManyEggGroupInputEnvelope
    set?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    disconnect?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    delete?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    connect?: egg_group_orderWhereUniqueInput | egg_group_orderWhereUniqueInput[]
    update?: egg_group_orderUpdateWithWhereUniqueWithoutEggGroupInput | egg_group_orderUpdateWithWhereUniqueWithoutEggGroupInput[]
    updateMany?: egg_group_orderUpdateManyWithWhereWithoutEggGroupInput | egg_group_orderUpdateManyWithWhereWithoutEggGroupInput[]
    deleteMany?: egg_group_orderScalarWhereInput | egg_group_orderScalarWhereInput[]
  }

  export type egg_groupCreateNestedOneWithoutEggGroupOrdersInput = {
    create?: XOR<egg_groupCreateWithoutEggGroupOrdersInput, egg_groupUncheckedCreateWithoutEggGroupOrdersInput>
    connectOrCreate?: egg_groupCreateOrConnectWithoutEggGroupOrdersInput
    connect?: egg_groupWhereUniqueInput
  }

  export type pokemon_infoCreateNestedOneWithoutEggGroupOrdersInput = {
    create?: XOR<pokemon_infoCreateWithoutEggGroupOrdersInput, pokemon_infoUncheckedCreateWithoutEggGroupOrdersInput>
    connectOrCreate?: pokemon_infoCreateOrConnectWithoutEggGroupOrdersInput
    connect?: pokemon_infoWhereUniqueInput
  }

  export type egg_groupUpdateOneRequiredWithoutEggGroupOrdersNestedInput = {
    create?: XOR<egg_groupCreateWithoutEggGroupOrdersInput, egg_groupUncheckedCreateWithoutEggGroupOrdersInput>
    connectOrCreate?: egg_groupCreateOrConnectWithoutEggGroupOrdersInput
    upsert?: egg_groupUpsertWithoutEggGroupOrdersInput
    connect?: egg_groupWhereUniqueInput
    update?: XOR<XOR<egg_groupUpdateToOneWithWhereWithoutEggGroupOrdersInput, egg_groupUpdateWithoutEggGroupOrdersInput>, egg_groupUncheckedUpdateWithoutEggGroupOrdersInput>
  }

  export type pokemon_infoUpdateOneRequiredWithoutEggGroupOrdersNestedInput = {
    create?: XOR<pokemon_infoCreateWithoutEggGroupOrdersInput, pokemon_infoUncheckedCreateWithoutEggGroupOrdersInput>
    connectOrCreate?: pokemon_infoCreateOrConnectWithoutEggGroupOrdersInput
    upsert?: pokemon_infoUpsertWithoutEggGroupOrdersInput
    connect?: pokemon_infoWhereUniqueInput
    update?: XOR<XOR<pokemon_infoUpdateToOneWithWhereWithoutEggGroupOrdersInput, pokemon_infoUpdateWithoutEggGroupOrdersInput>, pokemon_infoUncheckedUpdateWithoutEggGroupOrdersInput>
  }

  export type capacity_infoCreateNestedManyWithoutTypeInput = {
    create?: XOR<capacity_infoCreateWithoutTypeInput, capacity_infoUncheckedCreateWithoutTypeInput> | capacity_infoCreateWithoutTypeInput[] | capacity_infoUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutTypeInput | capacity_infoCreateOrConnectWithoutTypeInput[]
    createMany?: capacity_infoCreateManyTypeInputEnvelope
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
  }

  export type type_orderCreateNestedManyWithoutTypeInput = {
    create?: XOR<type_orderCreateWithoutTypeInput, type_orderUncheckedCreateWithoutTypeInput> | type_orderCreateWithoutTypeInput[] | type_orderUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: type_orderCreateOrConnectWithoutTypeInput | type_orderCreateOrConnectWithoutTypeInput[]
    createMany?: type_orderCreateManyTypeInputEnvelope
    connect?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
  }

  export type capacity_infoUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<capacity_infoCreateWithoutTypeInput, capacity_infoUncheckedCreateWithoutTypeInput> | capacity_infoCreateWithoutTypeInput[] | capacity_infoUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutTypeInput | capacity_infoCreateOrConnectWithoutTypeInput[]
    createMany?: capacity_infoCreateManyTypeInputEnvelope
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
  }

  export type type_orderUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<type_orderCreateWithoutTypeInput, type_orderUncheckedCreateWithoutTypeInput> | type_orderCreateWithoutTypeInput[] | type_orderUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: type_orderCreateOrConnectWithoutTypeInput | type_orderCreateOrConnectWithoutTypeInput[]
    createMany?: type_orderCreateManyTypeInputEnvelope
    connect?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
  }

  export type capacity_infoUpdateManyWithoutTypeNestedInput = {
    create?: XOR<capacity_infoCreateWithoutTypeInput, capacity_infoUncheckedCreateWithoutTypeInput> | capacity_infoCreateWithoutTypeInput[] | capacity_infoUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutTypeInput | capacity_infoCreateOrConnectWithoutTypeInput[]
    upsert?: capacity_infoUpsertWithWhereUniqueWithoutTypeInput | capacity_infoUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: capacity_infoCreateManyTypeInputEnvelope
    set?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    disconnect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    delete?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    update?: capacity_infoUpdateWithWhereUniqueWithoutTypeInput | capacity_infoUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: capacity_infoUpdateManyWithWhereWithoutTypeInput | capacity_infoUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
  }

  export type type_orderUpdateManyWithoutTypeNestedInput = {
    create?: XOR<type_orderCreateWithoutTypeInput, type_orderUncheckedCreateWithoutTypeInput> | type_orderCreateWithoutTypeInput[] | type_orderUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: type_orderCreateOrConnectWithoutTypeInput | type_orderCreateOrConnectWithoutTypeInput[]
    upsert?: type_orderUpsertWithWhereUniqueWithoutTypeInput | type_orderUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: type_orderCreateManyTypeInputEnvelope
    set?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    disconnect?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    delete?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    connect?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    update?: type_orderUpdateWithWhereUniqueWithoutTypeInput | type_orderUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: type_orderUpdateManyWithWhereWithoutTypeInput | type_orderUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: type_orderScalarWhereInput | type_orderScalarWhereInput[]
  }

  export type capacity_infoUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<capacity_infoCreateWithoutTypeInput, capacity_infoUncheckedCreateWithoutTypeInput> | capacity_infoCreateWithoutTypeInput[] | capacity_infoUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutTypeInput | capacity_infoCreateOrConnectWithoutTypeInput[]
    upsert?: capacity_infoUpsertWithWhereUniqueWithoutTypeInput | capacity_infoUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: capacity_infoCreateManyTypeInputEnvelope
    set?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    disconnect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    delete?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    update?: capacity_infoUpdateWithWhereUniqueWithoutTypeInput | capacity_infoUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: capacity_infoUpdateManyWithWhereWithoutTypeInput | capacity_infoUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
  }

  export type type_orderUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<type_orderCreateWithoutTypeInput, type_orderUncheckedCreateWithoutTypeInput> | type_orderCreateWithoutTypeInput[] | type_orderUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: type_orderCreateOrConnectWithoutTypeInput | type_orderCreateOrConnectWithoutTypeInput[]
    upsert?: type_orderUpsertWithWhereUniqueWithoutTypeInput | type_orderUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: type_orderCreateManyTypeInputEnvelope
    set?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    disconnect?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    delete?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    connect?: type_orderWhereUniqueInput | type_orderWhereUniqueInput[]
    update?: type_orderUpdateWithWhereUniqueWithoutTypeInput | type_orderUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: type_orderUpdateManyWithWhereWithoutTypeInput | type_orderUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: type_orderScalarWhereInput | type_orderScalarWhereInput[]
  }

  export type pokemon_infoCreateNestedOneWithoutTypeOrdersInput = {
    create?: XOR<pokemon_infoCreateWithoutTypeOrdersInput, pokemon_infoUncheckedCreateWithoutTypeOrdersInput>
    connectOrCreate?: pokemon_infoCreateOrConnectWithoutTypeOrdersInput
    connect?: pokemon_infoWhereUniqueInput
  }

  export type typeCreateNestedOneWithoutTypeOrdersInput = {
    create?: XOR<typeCreateWithoutTypeOrdersInput, typeUncheckedCreateWithoutTypeOrdersInput>
    connectOrCreate?: typeCreateOrConnectWithoutTypeOrdersInput
    connect?: typeWhereUniqueInput
  }

  export type pokemon_infoUpdateOneRequiredWithoutTypeOrdersNestedInput = {
    create?: XOR<pokemon_infoCreateWithoutTypeOrdersInput, pokemon_infoUncheckedCreateWithoutTypeOrdersInput>
    connectOrCreate?: pokemon_infoCreateOrConnectWithoutTypeOrdersInput
    upsert?: pokemon_infoUpsertWithoutTypeOrdersInput
    connect?: pokemon_infoWhereUniqueInput
    update?: XOR<XOR<pokemon_infoUpdateToOneWithWhereWithoutTypeOrdersInput, pokemon_infoUpdateWithoutTypeOrdersInput>, pokemon_infoUncheckedUpdateWithoutTypeOrdersInput>
  }

  export type typeUpdateOneRequiredWithoutTypeOrdersNestedInput = {
    create?: XOR<typeCreateWithoutTypeOrdersInput, typeUncheckedCreateWithoutTypeOrdersInput>
    connectOrCreate?: typeCreateOrConnectWithoutTypeOrdersInput
    upsert?: typeUpsertWithoutTypeOrdersInput
    connect?: typeWhereUniqueInput
    update?: XOR<XOR<typeUpdateToOneWithWhereWithoutTypeOrdersInput, typeUpdateWithoutTypeOrdersInput>, typeUncheckedUpdateWithoutTypeOrdersInput>
  }

  export type group_gameCreateNestedOneWithoutNationnalNumbersInput = {
    create?: XOR<group_gameCreateWithoutNationnalNumbersInput, group_gameUncheckedCreateWithoutNationnalNumbersInput>
    connectOrCreate?: group_gameCreateOrConnectWithoutNationnalNumbersInput
    connect?: group_gameWhereUniqueInput
  }

  export type pokemonCreateNestedOneWithoutNationalNumbersInput = {
    create?: XOR<pokemonCreateWithoutNationalNumbersInput, pokemonUncheckedCreateWithoutNationalNumbersInput>
    connectOrCreate?: pokemonCreateOrConnectWithoutNationalNumbersInput
    connect?: pokemonWhereUniqueInput
  }

  export type group_gameUpdateOneRequiredWithoutNationnalNumbersNestedInput = {
    create?: XOR<group_gameCreateWithoutNationnalNumbersInput, group_gameUncheckedCreateWithoutNationnalNumbersInput>
    connectOrCreate?: group_gameCreateOrConnectWithoutNationnalNumbersInput
    upsert?: group_gameUpsertWithoutNationnalNumbersInput
    connect?: group_gameWhereUniqueInput
    update?: XOR<XOR<group_gameUpdateToOneWithWhereWithoutNationnalNumbersInput, group_gameUpdateWithoutNationnalNumbersInput>, group_gameUncheckedUpdateWithoutNationnalNumbersInput>
  }

  export type pokemonUpdateOneRequiredWithoutNationalNumbersNestedInput = {
    create?: XOR<pokemonCreateWithoutNationalNumbersInput, pokemonUncheckedCreateWithoutNationalNumbersInput>
    connectOrCreate?: pokemonCreateOrConnectWithoutNationalNumbersInput
    upsert?: pokemonUpsertWithoutNationalNumbersInput
    connect?: pokemonWhereUniqueInput
    update?: XOR<XOR<pokemonUpdateToOneWithWhereWithoutNationalNumbersInput, pokemonUpdateWithoutNationalNumbersInput>, pokemonUncheckedUpdateWithoutNationalNumbersInput>
  }

  export type game_group_gameCreateNestedManyWithoutLandInput = {
    create?: XOR<game_group_gameCreateWithoutLandInput, game_group_gameUncheckedCreateWithoutLandInput> | game_group_gameCreateWithoutLandInput[] | game_group_gameUncheckedCreateWithoutLandInput[]
    connectOrCreate?: game_group_gameCreateOrConnectWithoutLandInput | game_group_gameCreateOrConnectWithoutLandInput[]
    createMany?: game_group_gameCreateManyLandInputEnvelope
    connect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
  }

  export type game_group_gameUncheckedCreateNestedManyWithoutLandInput = {
    create?: XOR<game_group_gameCreateWithoutLandInput, game_group_gameUncheckedCreateWithoutLandInput> | game_group_gameCreateWithoutLandInput[] | game_group_gameUncheckedCreateWithoutLandInput[]
    connectOrCreate?: game_group_gameCreateOrConnectWithoutLandInput | game_group_gameCreateOrConnectWithoutLandInput[]
    createMany?: game_group_gameCreateManyLandInputEnvelope
    connect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
  }

  export type game_group_gameUpdateManyWithoutLandNestedInput = {
    create?: XOR<game_group_gameCreateWithoutLandInput, game_group_gameUncheckedCreateWithoutLandInput> | game_group_gameCreateWithoutLandInput[] | game_group_gameUncheckedCreateWithoutLandInput[]
    connectOrCreate?: game_group_gameCreateOrConnectWithoutLandInput | game_group_gameCreateOrConnectWithoutLandInput[]
    upsert?: game_group_gameUpsertWithWhereUniqueWithoutLandInput | game_group_gameUpsertWithWhereUniqueWithoutLandInput[]
    createMany?: game_group_gameCreateManyLandInputEnvelope
    set?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    disconnect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    delete?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    connect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    update?: game_group_gameUpdateWithWhereUniqueWithoutLandInput | game_group_gameUpdateWithWhereUniqueWithoutLandInput[]
    updateMany?: game_group_gameUpdateManyWithWhereWithoutLandInput | game_group_gameUpdateManyWithWhereWithoutLandInput[]
    deleteMany?: game_group_gameScalarWhereInput | game_group_gameScalarWhereInput[]
  }

  export type game_group_gameUncheckedUpdateManyWithoutLandNestedInput = {
    create?: XOR<game_group_gameCreateWithoutLandInput, game_group_gameUncheckedCreateWithoutLandInput> | game_group_gameCreateWithoutLandInput[] | game_group_gameUncheckedCreateWithoutLandInput[]
    connectOrCreate?: game_group_gameCreateOrConnectWithoutLandInput | game_group_gameCreateOrConnectWithoutLandInput[]
    upsert?: game_group_gameUpsertWithWhereUniqueWithoutLandInput | game_group_gameUpsertWithWhereUniqueWithoutLandInput[]
    createMany?: game_group_gameCreateManyLandInputEnvelope
    set?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    disconnect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    delete?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    connect?: game_group_gameWhereUniqueInput | game_group_gameWhereUniqueInput[]
    update?: game_group_gameUpdateWithWhereUniqueWithoutLandInput | game_group_gameUpdateWithWhereUniqueWithoutLandInput[]
    updateMany?: game_group_gameUpdateManyWithWhereWithoutLandInput | game_group_gameUpdateManyWithWhereWithoutLandInput[]
    deleteMany?: game_group_gameScalarWhereInput | game_group_gameScalarWhereInput[]
  }

  export type capacity_infoCreateNestedManyWithoutCapacityInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityInput, capacity_infoUncheckedCreateWithoutCapacityInput> | capacity_infoCreateWithoutCapacityInput[] | capacity_infoUncheckedCreateWithoutCapacityInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityInput | capacity_infoCreateOrConnectWithoutCapacityInput[]
    createMany?: capacity_infoCreateManyCapacityInputEnvelope
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
  }

  export type skill_obtationCreateNestedManyWithoutCapacityInput = {
    create?: XOR<skill_obtationCreateWithoutCapacityInput, skill_obtationUncheckedCreateWithoutCapacityInput> | skill_obtationCreateWithoutCapacityInput[] | skill_obtationUncheckedCreateWithoutCapacityInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutCapacityInput | skill_obtationCreateOrConnectWithoutCapacityInput[]
    createMany?: skill_obtationCreateManyCapacityInputEnvelope
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
  }

  export type capacity_infoUncheckedCreateNestedManyWithoutCapacityInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityInput, capacity_infoUncheckedCreateWithoutCapacityInput> | capacity_infoCreateWithoutCapacityInput[] | capacity_infoUncheckedCreateWithoutCapacityInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityInput | capacity_infoCreateOrConnectWithoutCapacityInput[]
    createMany?: capacity_infoCreateManyCapacityInputEnvelope
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
  }

  export type skill_obtationUncheckedCreateNestedManyWithoutCapacityInput = {
    create?: XOR<skill_obtationCreateWithoutCapacityInput, skill_obtationUncheckedCreateWithoutCapacityInput> | skill_obtationCreateWithoutCapacityInput[] | skill_obtationUncheckedCreateWithoutCapacityInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutCapacityInput | skill_obtationCreateOrConnectWithoutCapacityInput[]
    createMany?: skill_obtationCreateManyCapacityInputEnvelope
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
  }

  export type capacity_infoUpdateManyWithoutCapacityNestedInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityInput, capacity_infoUncheckedCreateWithoutCapacityInput> | capacity_infoCreateWithoutCapacityInput[] | capacity_infoUncheckedCreateWithoutCapacityInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityInput | capacity_infoCreateOrConnectWithoutCapacityInput[]
    upsert?: capacity_infoUpsertWithWhereUniqueWithoutCapacityInput | capacity_infoUpsertWithWhereUniqueWithoutCapacityInput[]
    createMany?: capacity_infoCreateManyCapacityInputEnvelope
    set?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    disconnect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    delete?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    update?: capacity_infoUpdateWithWhereUniqueWithoutCapacityInput | capacity_infoUpdateWithWhereUniqueWithoutCapacityInput[]
    updateMany?: capacity_infoUpdateManyWithWhereWithoutCapacityInput | capacity_infoUpdateManyWithWhereWithoutCapacityInput[]
    deleteMany?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
  }

  export type skill_obtationUpdateManyWithoutCapacityNestedInput = {
    create?: XOR<skill_obtationCreateWithoutCapacityInput, skill_obtationUncheckedCreateWithoutCapacityInput> | skill_obtationCreateWithoutCapacityInput[] | skill_obtationUncheckedCreateWithoutCapacityInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutCapacityInput | skill_obtationCreateOrConnectWithoutCapacityInput[]
    upsert?: skill_obtationUpsertWithWhereUniqueWithoutCapacityInput | skill_obtationUpsertWithWhereUniqueWithoutCapacityInput[]
    createMany?: skill_obtationCreateManyCapacityInputEnvelope
    set?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    disconnect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    delete?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    update?: skill_obtationUpdateWithWhereUniqueWithoutCapacityInput | skill_obtationUpdateWithWhereUniqueWithoutCapacityInput[]
    updateMany?: skill_obtationUpdateManyWithWhereWithoutCapacityInput | skill_obtationUpdateManyWithWhereWithoutCapacityInput[]
    deleteMany?: skill_obtationScalarWhereInput | skill_obtationScalarWhereInput[]
  }

  export type capacity_infoUncheckedUpdateManyWithoutCapacityNestedInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityInput, capacity_infoUncheckedCreateWithoutCapacityInput> | capacity_infoCreateWithoutCapacityInput[] | capacity_infoUncheckedCreateWithoutCapacityInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityInput | capacity_infoCreateOrConnectWithoutCapacityInput[]
    upsert?: capacity_infoUpsertWithWhereUniqueWithoutCapacityInput | capacity_infoUpsertWithWhereUniqueWithoutCapacityInput[]
    createMany?: capacity_infoCreateManyCapacityInputEnvelope
    set?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    disconnect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    delete?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    update?: capacity_infoUpdateWithWhereUniqueWithoutCapacityInput | capacity_infoUpdateWithWhereUniqueWithoutCapacityInput[]
    updateMany?: capacity_infoUpdateManyWithWhereWithoutCapacityInput | capacity_infoUpdateManyWithWhereWithoutCapacityInput[]
    deleteMany?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
  }

  export type skill_obtationUncheckedUpdateManyWithoutCapacityNestedInput = {
    create?: XOR<skill_obtationCreateWithoutCapacityInput, skill_obtationUncheckedCreateWithoutCapacityInput> | skill_obtationCreateWithoutCapacityInput[] | skill_obtationUncheckedCreateWithoutCapacityInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutCapacityInput | skill_obtationCreateOrConnectWithoutCapacityInput[]
    upsert?: skill_obtationUpsertWithWhereUniqueWithoutCapacityInput | skill_obtationUpsertWithWhereUniqueWithoutCapacityInput[]
    createMany?: skill_obtationCreateManyCapacityInputEnvelope
    set?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    disconnect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    delete?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    update?: skill_obtationUpdateWithWhereUniqueWithoutCapacityInput | skill_obtationUpdateWithWhereUniqueWithoutCapacityInput[]
    updateMany?: skill_obtationUpdateManyWithWhereWithoutCapacityInput | skill_obtationUpdateManyWithWhereWithoutCapacityInput[]
    deleteMany?: skill_obtationScalarWhereInput | skill_obtationScalarWhereInput[]
  }

  export type capacity_infoCreateNestedManyWithoutCapacityEffectInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityEffectInput, capacity_infoUncheckedCreateWithoutCapacityEffectInput> | capacity_infoCreateWithoutCapacityEffectInput[] | capacity_infoUncheckedCreateWithoutCapacityEffectInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityEffectInput | capacity_infoCreateOrConnectWithoutCapacityEffectInput[]
    createMany?: capacity_infoCreateManyCapacityEffectInputEnvelope
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
  }

  export type capacity_infoCreateNestedManyWithoutCapacityEffectZInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityEffectZInput, capacity_infoUncheckedCreateWithoutCapacityEffectZInput> | capacity_infoCreateWithoutCapacityEffectZInput[] | capacity_infoUncheckedCreateWithoutCapacityEffectZInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityEffectZInput | capacity_infoCreateOrConnectWithoutCapacityEffectZInput[]
    createMany?: capacity_infoCreateManyCapacityEffectZInputEnvelope
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
  }

  export type capacity_infoUncheckedCreateNestedManyWithoutCapacityEffectInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityEffectInput, capacity_infoUncheckedCreateWithoutCapacityEffectInput> | capacity_infoCreateWithoutCapacityEffectInput[] | capacity_infoUncheckedCreateWithoutCapacityEffectInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityEffectInput | capacity_infoCreateOrConnectWithoutCapacityEffectInput[]
    createMany?: capacity_infoCreateManyCapacityEffectInputEnvelope
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
  }

  export type capacity_infoUncheckedCreateNestedManyWithoutCapacityEffectZInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityEffectZInput, capacity_infoUncheckedCreateWithoutCapacityEffectZInput> | capacity_infoCreateWithoutCapacityEffectZInput[] | capacity_infoUncheckedCreateWithoutCapacityEffectZInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityEffectZInput | capacity_infoCreateOrConnectWithoutCapacityEffectZInput[]
    createMany?: capacity_infoCreateManyCapacityEffectZInputEnvelope
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
  }

  export type capacity_infoUpdateManyWithoutCapacityEffectNestedInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityEffectInput, capacity_infoUncheckedCreateWithoutCapacityEffectInput> | capacity_infoCreateWithoutCapacityEffectInput[] | capacity_infoUncheckedCreateWithoutCapacityEffectInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityEffectInput | capacity_infoCreateOrConnectWithoutCapacityEffectInput[]
    upsert?: capacity_infoUpsertWithWhereUniqueWithoutCapacityEffectInput | capacity_infoUpsertWithWhereUniqueWithoutCapacityEffectInput[]
    createMany?: capacity_infoCreateManyCapacityEffectInputEnvelope
    set?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    disconnect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    delete?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    update?: capacity_infoUpdateWithWhereUniqueWithoutCapacityEffectInput | capacity_infoUpdateWithWhereUniqueWithoutCapacityEffectInput[]
    updateMany?: capacity_infoUpdateManyWithWhereWithoutCapacityEffectInput | capacity_infoUpdateManyWithWhereWithoutCapacityEffectInput[]
    deleteMany?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
  }

  export type capacity_infoUpdateManyWithoutCapacityEffectZNestedInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityEffectZInput, capacity_infoUncheckedCreateWithoutCapacityEffectZInput> | capacity_infoCreateWithoutCapacityEffectZInput[] | capacity_infoUncheckedCreateWithoutCapacityEffectZInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityEffectZInput | capacity_infoCreateOrConnectWithoutCapacityEffectZInput[]
    upsert?: capacity_infoUpsertWithWhereUniqueWithoutCapacityEffectZInput | capacity_infoUpsertWithWhereUniqueWithoutCapacityEffectZInput[]
    createMany?: capacity_infoCreateManyCapacityEffectZInputEnvelope
    set?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    disconnect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    delete?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    update?: capacity_infoUpdateWithWhereUniqueWithoutCapacityEffectZInput | capacity_infoUpdateWithWhereUniqueWithoutCapacityEffectZInput[]
    updateMany?: capacity_infoUpdateManyWithWhereWithoutCapacityEffectZInput | capacity_infoUpdateManyWithWhereWithoutCapacityEffectZInput[]
    deleteMany?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
  }

  export type capacity_infoUncheckedUpdateManyWithoutCapacityEffectNestedInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityEffectInput, capacity_infoUncheckedCreateWithoutCapacityEffectInput> | capacity_infoCreateWithoutCapacityEffectInput[] | capacity_infoUncheckedCreateWithoutCapacityEffectInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityEffectInput | capacity_infoCreateOrConnectWithoutCapacityEffectInput[]
    upsert?: capacity_infoUpsertWithWhereUniqueWithoutCapacityEffectInput | capacity_infoUpsertWithWhereUniqueWithoutCapacityEffectInput[]
    createMany?: capacity_infoCreateManyCapacityEffectInputEnvelope
    set?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    disconnect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    delete?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    update?: capacity_infoUpdateWithWhereUniqueWithoutCapacityEffectInput | capacity_infoUpdateWithWhereUniqueWithoutCapacityEffectInput[]
    updateMany?: capacity_infoUpdateManyWithWhereWithoutCapacityEffectInput | capacity_infoUpdateManyWithWhereWithoutCapacityEffectInput[]
    deleteMany?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
  }

  export type capacity_infoUncheckedUpdateManyWithoutCapacityEffectZNestedInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityEffectZInput, capacity_infoUncheckedCreateWithoutCapacityEffectZInput> | capacity_infoCreateWithoutCapacityEffectZInput[] | capacity_infoUncheckedCreateWithoutCapacityEffectZInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityEffectZInput | capacity_infoCreateOrConnectWithoutCapacityEffectZInput[]
    upsert?: capacity_infoUpsertWithWhereUniqueWithoutCapacityEffectZInput | capacity_infoUpsertWithWhereUniqueWithoutCapacityEffectZInput[]
    createMany?: capacity_infoCreateManyCapacityEffectZInputEnvelope
    set?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    disconnect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    delete?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    update?: capacity_infoUpdateWithWhereUniqueWithoutCapacityEffectZInput | capacity_infoUpdateWithWhereUniqueWithoutCapacityEffectZInput[]
    updateMany?: capacity_infoUpdateManyWithWhereWithoutCapacityEffectZInput | capacity_infoUpdateManyWithWhereWithoutCapacityEffectZInput[]
    deleteMany?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
  }

  export type capacity_infoCreateNestedManyWithoutCapacityCategoryInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityCategoryInput, capacity_infoUncheckedCreateWithoutCapacityCategoryInput> | capacity_infoCreateWithoutCapacityCategoryInput[] | capacity_infoUncheckedCreateWithoutCapacityCategoryInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityCategoryInput | capacity_infoCreateOrConnectWithoutCapacityCategoryInput[]
    createMany?: capacity_infoCreateManyCapacityCategoryInputEnvelope
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
  }

  export type capacity_infoUncheckedCreateNestedManyWithoutCapacityCategoryInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityCategoryInput, capacity_infoUncheckedCreateWithoutCapacityCategoryInput> | capacity_infoCreateWithoutCapacityCategoryInput[] | capacity_infoUncheckedCreateWithoutCapacityCategoryInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityCategoryInput | capacity_infoCreateOrConnectWithoutCapacityCategoryInput[]
    createMany?: capacity_infoCreateManyCapacityCategoryInputEnvelope
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
  }

  export type capacity_infoUpdateManyWithoutCapacityCategoryNestedInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityCategoryInput, capacity_infoUncheckedCreateWithoutCapacityCategoryInput> | capacity_infoCreateWithoutCapacityCategoryInput[] | capacity_infoUncheckedCreateWithoutCapacityCategoryInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityCategoryInput | capacity_infoCreateOrConnectWithoutCapacityCategoryInput[]
    upsert?: capacity_infoUpsertWithWhereUniqueWithoutCapacityCategoryInput | capacity_infoUpsertWithWhereUniqueWithoutCapacityCategoryInput[]
    createMany?: capacity_infoCreateManyCapacityCategoryInputEnvelope
    set?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    disconnect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    delete?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    update?: capacity_infoUpdateWithWhereUniqueWithoutCapacityCategoryInput | capacity_infoUpdateWithWhereUniqueWithoutCapacityCategoryInput[]
    updateMany?: capacity_infoUpdateManyWithWhereWithoutCapacityCategoryInput | capacity_infoUpdateManyWithWhereWithoutCapacityCategoryInput[]
    deleteMany?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
  }

  export type capacity_infoUncheckedUpdateManyWithoutCapacityCategoryNestedInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityCategoryInput, capacity_infoUncheckedCreateWithoutCapacityCategoryInput> | capacity_infoCreateWithoutCapacityCategoryInput[] | capacity_infoUncheckedCreateWithoutCapacityCategoryInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityCategoryInput | capacity_infoCreateOrConnectWithoutCapacityCategoryInput[]
    upsert?: capacity_infoUpsertWithWhereUniqueWithoutCapacityCategoryInput | capacity_infoUpsertWithWhereUniqueWithoutCapacityCategoryInput[]
    createMany?: capacity_infoCreateManyCapacityCategoryInputEnvelope
    set?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    disconnect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    delete?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    update?: capacity_infoUpdateWithWhereUniqueWithoutCapacityCategoryInput | capacity_infoUpdateWithWhereUniqueWithoutCapacityCategoryInput[]
    updateMany?: capacity_infoUpdateManyWithWhereWithoutCapacityCategoryInput | capacity_infoUpdateManyWithWhereWithoutCapacityCategoryInput[]
    deleteMany?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
  }

  export type capsule_game_capacity_infoCreateNestedManyWithoutCapsuleInput = {
    create?: XOR<capsule_game_capacity_infoCreateWithoutCapsuleInput, capsule_game_capacity_infoUncheckedCreateWithoutCapsuleInput> | capsule_game_capacity_infoCreateWithoutCapsuleInput[] | capsule_game_capacity_infoUncheckedCreateWithoutCapsuleInput[]
    connectOrCreate?: capsule_game_capacity_infoCreateOrConnectWithoutCapsuleInput | capsule_game_capacity_infoCreateOrConnectWithoutCapsuleInput[]
    createMany?: capsule_game_capacity_infoCreateManyCapsuleInputEnvelope
    connect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
  }

  export type capsule_game_capacity_infoUncheckedCreateNestedManyWithoutCapsuleInput = {
    create?: XOR<capsule_game_capacity_infoCreateWithoutCapsuleInput, capsule_game_capacity_infoUncheckedCreateWithoutCapsuleInput> | capsule_game_capacity_infoCreateWithoutCapsuleInput[] | capsule_game_capacity_infoUncheckedCreateWithoutCapsuleInput[]
    connectOrCreate?: capsule_game_capacity_infoCreateOrConnectWithoutCapsuleInput | capsule_game_capacity_infoCreateOrConnectWithoutCapsuleInput[]
    createMany?: capsule_game_capacity_infoCreateManyCapsuleInputEnvelope
    connect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
  }

  export type capsule_game_capacity_infoUpdateManyWithoutCapsuleNestedInput = {
    create?: XOR<capsule_game_capacity_infoCreateWithoutCapsuleInput, capsule_game_capacity_infoUncheckedCreateWithoutCapsuleInput> | capsule_game_capacity_infoCreateWithoutCapsuleInput[] | capsule_game_capacity_infoUncheckedCreateWithoutCapsuleInput[]
    connectOrCreate?: capsule_game_capacity_infoCreateOrConnectWithoutCapsuleInput | capsule_game_capacity_infoCreateOrConnectWithoutCapsuleInput[]
    upsert?: capsule_game_capacity_infoUpsertWithWhereUniqueWithoutCapsuleInput | capsule_game_capacity_infoUpsertWithWhereUniqueWithoutCapsuleInput[]
    createMany?: capsule_game_capacity_infoCreateManyCapsuleInputEnvelope
    set?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    disconnect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    delete?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    connect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    update?: capsule_game_capacity_infoUpdateWithWhereUniqueWithoutCapsuleInput | capsule_game_capacity_infoUpdateWithWhereUniqueWithoutCapsuleInput[]
    updateMany?: capsule_game_capacity_infoUpdateManyWithWhereWithoutCapsuleInput | capsule_game_capacity_infoUpdateManyWithWhereWithoutCapsuleInput[]
    deleteMany?: capsule_game_capacity_infoScalarWhereInput | capsule_game_capacity_infoScalarWhereInput[]
  }

  export type capsule_game_capacity_infoUncheckedUpdateManyWithoutCapsuleNestedInput = {
    create?: XOR<capsule_game_capacity_infoCreateWithoutCapsuleInput, capsule_game_capacity_infoUncheckedCreateWithoutCapsuleInput> | capsule_game_capacity_infoCreateWithoutCapsuleInput[] | capsule_game_capacity_infoUncheckedCreateWithoutCapsuleInput[]
    connectOrCreate?: capsule_game_capacity_infoCreateOrConnectWithoutCapsuleInput | capsule_game_capacity_infoCreateOrConnectWithoutCapsuleInput[]
    upsert?: capsule_game_capacity_infoUpsertWithWhereUniqueWithoutCapsuleInput | capsule_game_capacity_infoUpsertWithWhereUniqueWithoutCapsuleInput[]
    createMany?: capsule_game_capacity_infoCreateManyCapsuleInputEnvelope
    set?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    disconnect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    delete?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    connect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    update?: capsule_game_capacity_infoUpdateWithWhereUniqueWithoutCapsuleInput | capsule_game_capacity_infoUpdateWithWhereUniqueWithoutCapsuleInput[]
    updateMany?: capsule_game_capacity_infoUpdateManyWithWhereWithoutCapsuleInput | capsule_game_capacity_infoUpdateManyWithWhereWithoutCapsuleInput[]
    deleteMany?: capsule_game_capacity_infoScalarWhereInput | capsule_game_capacity_infoScalarWhereInput[]
  }

  export type rateCreateNestedManyWithoutConditionRateInput = {
    create?: XOR<rateCreateWithoutConditionRateInput, rateUncheckedCreateWithoutConditionRateInput> | rateCreateWithoutConditionRateInput[] | rateUncheckedCreateWithoutConditionRateInput[]
    connectOrCreate?: rateCreateOrConnectWithoutConditionRateInput | rateCreateOrConnectWithoutConditionRateInput[]
    createMany?: rateCreateManyConditionRateInputEnvelope
    connect?: rateWhereUniqueInput | rateWhereUniqueInput[]
  }

  export type rateCreateNestedManyWithoutDetailRateInput = {
    create?: XOR<rateCreateWithoutDetailRateInput, rateUncheckedCreateWithoutDetailRateInput> | rateCreateWithoutDetailRateInput[] | rateUncheckedCreateWithoutDetailRateInput[]
    connectOrCreate?: rateCreateOrConnectWithoutDetailRateInput | rateCreateOrConnectWithoutDetailRateInput[]
    createMany?: rateCreateManyDetailRateInputEnvelope
    connect?: rateWhereUniqueInput | rateWhereUniqueInput[]
  }

  export type rateUncheckedCreateNestedManyWithoutConditionRateInput = {
    create?: XOR<rateCreateWithoutConditionRateInput, rateUncheckedCreateWithoutConditionRateInput> | rateCreateWithoutConditionRateInput[] | rateUncheckedCreateWithoutConditionRateInput[]
    connectOrCreate?: rateCreateOrConnectWithoutConditionRateInput | rateCreateOrConnectWithoutConditionRateInput[]
    createMany?: rateCreateManyConditionRateInputEnvelope
    connect?: rateWhereUniqueInput | rateWhereUniqueInput[]
  }

  export type rateUncheckedCreateNestedManyWithoutDetailRateInput = {
    create?: XOR<rateCreateWithoutDetailRateInput, rateUncheckedCreateWithoutDetailRateInput> | rateCreateWithoutDetailRateInput[] | rateUncheckedCreateWithoutDetailRateInput[]
    connectOrCreate?: rateCreateOrConnectWithoutDetailRateInput | rateCreateOrConnectWithoutDetailRateInput[]
    createMany?: rateCreateManyDetailRateInputEnvelope
    connect?: rateWhereUniqueInput | rateWhereUniqueInput[]
  }

  export type rateUpdateManyWithoutConditionRateNestedInput = {
    create?: XOR<rateCreateWithoutConditionRateInput, rateUncheckedCreateWithoutConditionRateInput> | rateCreateWithoutConditionRateInput[] | rateUncheckedCreateWithoutConditionRateInput[]
    connectOrCreate?: rateCreateOrConnectWithoutConditionRateInput | rateCreateOrConnectWithoutConditionRateInput[]
    upsert?: rateUpsertWithWhereUniqueWithoutConditionRateInput | rateUpsertWithWhereUniqueWithoutConditionRateInput[]
    createMany?: rateCreateManyConditionRateInputEnvelope
    set?: rateWhereUniqueInput | rateWhereUniqueInput[]
    disconnect?: rateWhereUniqueInput | rateWhereUniqueInput[]
    delete?: rateWhereUniqueInput | rateWhereUniqueInput[]
    connect?: rateWhereUniqueInput | rateWhereUniqueInput[]
    update?: rateUpdateWithWhereUniqueWithoutConditionRateInput | rateUpdateWithWhereUniqueWithoutConditionRateInput[]
    updateMany?: rateUpdateManyWithWhereWithoutConditionRateInput | rateUpdateManyWithWhereWithoutConditionRateInput[]
    deleteMany?: rateScalarWhereInput | rateScalarWhereInput[]
  }

  export type rateUpdateManyWithoutDetailRateNestedInput = {
    create?: XOR<rateCreateWithoutDetailRateInput, rateUncheckedCreateWithoutDetailRateInput> | rateCreateWithoutDetailRateInput[] | rateUncheckedCreateWithoutDetailRateInput[]
    connectOrCreate?: rateCreateOrConnectWithoutDetailRateInput | rateCreateOrConnectWithoutDetailRateInput[]
    upsert?: rateUpsertWithWhereUniqueWithoutDetailRateInput | rateUpsertWithWhereUniqueWithoutDetailRateInput[]
    createMany?: rateCreateManyDetailRateInputEnvelope
    set?: rateWhereUniqueInput | rateWhereUniqueInput[]
    disconnect?: rateWhereUniqueInput | rateWhereUniqueInput[]
    delete?: rateWhereUniqueInput | rateWhereUniqueInput[]
    connect?: rateWhereUniqueInput | rateWhereUniqueInput[]
    update?: rateUpdateWithWhereUniqueWithoutDetailRateInput | rateUpdateWithWhereUniqueWithoutDetailRateInput[]
    updateMany?: rateUpdateManyWithWhereWithoutDetailRateInput | rateUpdateManyWithWhereWithoutDetailRateInput[]
    deleteMany?: rateScalarWhereInput | rateScalarWhereInput[]
  }

  export type rateUncheckedUpdateManyWithoutConditionRateNestedInput = {
    create?: XOR<rateCreateWithoutConditionRateInput, rateUncheckedCreateWithoutConditionRateInput> | rateCreateWithoutConditionRateInput[] | rateUncheckedCreateWithoutConditionRateInput[]
    connectOrCreate?: rateCreateOrConnectWithoutConditionRateInput | rateCreateOrConnectWithoutConditionRateInput[]
    upsert?: rateUpsertWithWhereUniqueWithoutConditionRateInput | rateUpsertWithWhereUniqueWithoutConditionRateInput[]
    createMany?: rateCreateManyConditionRateInputEnvelope
    set?: rateWhereUniqueInput | rateWhereUniqueInput[]
    disconnect?: rateWhereUniqueInput | rateWhereUniqueInput[]
    delete?: rateWhereUniqueInput | rateWhereUniqueInput[]
    connect?: rateWhereUniqueInput | rateWhereUniqueInput[]
    update?: rateUpdateWithWhereUniqueWithoutConditionRateInput | rateUpdateWithWhereUniqueWithoutConditionRateInput[]
    updateMany?: rateUpdateManyWithWhereWithoutConditionRateInput | rateUpdateManyWithWhereWithoutConditionRateInput[]
    deleteMany?: rateScalarWhereInput | rateScalarWhereInput[]
  }

  export type rateUncheckedUpdateManyWithoutDetailRateNestedInput = {
    create?: XOR<rateCreateWithoutDetailRateInput, rateUncheckedCreateWithoutDetailRateInput> | rateCreateWithoutDetailRateInput[] | rateUncheckedCreateWithoutDetailRateInput[]
    connectOrCreate?: rateCreateOrConnectWithoutDetailRateInput | rateCreateOrConnectWithoutDetailRateInput[]
    upsert?: rateUpsertWithWhereUniqueWithoutDetailRateInput | rateUpsertWithWhereUniqueWithoutDetailRateInput[]
    createMany?: rateCreateManyDetailRateInputEnvelope
    set?: rateWhereUniqueInput | rateWhereUniqueInput[]
    disconnect?: rateWhereUniqueInput | rateWhereUniqueInput[]
    delete?: rateWhereUniqueInput | rateWhereUniqueInput[]
    connect?: rateWhereUniqueInput | rateWhereUniqueInput[]
    update?: rateUpdateWithWhereUniqueWithoutDetailRateInput | rateUpdateWithWhereUniqueWithoutDetailRateInput[]
    updateMany?: rateUpdateManyWithWhereWithoutDetailRateInput | rateUpdateManyWithWhereWithoutDetailRateInput[]
    deleteMany?: rateScalarWhereInput | rateScalarWhereInput[]
  }

  export type ability_infoCreateNestedManyWithoutEffectWithoutFightInput = {
    create?: XOR<ability_infoCreateWithoutEffectWithoutFightInput, ability_infoUncheckedCreateWithoutEffectWithoutFightInput> | ability_infoCreateWithoutEffectWithoutFightInput[] | ability_infoUncheckedCreateWithoutEffectWithoutFightInput[]
    connectOrCreate?: ability_infoCreateOrConnectWithoutEffectWithoutFightInput | ability_infoCreateOrConnectWithoutEffectWithoutFightInput[]
    createMany?: ability_infoCreateManyEffectWithoutFightInputEnvelope
    connect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
  }

  export type capacity_infoCreateNestedManyWithoutEffectOutsideFightInput = {
    create?: XOR<capacity_infoCreateWithoutEffectOutsideFightInput, capacity_infoUncheckedCreateWithoutEffectOutsideFightInput> | capacity_infoCreateWithoutEffectOutsideFightInput[] | capacity_infoUncheckedCreateWithoutEffectOutsideFightInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutEffectOutsideFightInput | capacity_infoCreateOrConnectWithoutEffectOutsideFightInput[]
    createMany?: capacity_infoCreateManyEffectOutsideFightInputEnvelope
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
  }

  export type ability_infoUncheckedCreateNestedManyWithoutEffectWithoutFightInput = {
    create?: XOR<ability_infoCreateWithoutEffectWithoutFightInput, ability_infoUncheckedCreateWithoutEffectWithoutFightInput> | ability_infoCreateWithoutEffectWithoutFightInput[] | ability_infoUncheckedCreateWithoutEffectWithoutFightInput[]
    connectOrCreate?: ability_infoCreateOrConnectWithoutEffectWithoutFightInput | ability_infoCreateOrConnectWithoutEffectWithoutFightInput[]
    createMany?: ability_infoCreateManyEffectWithoutFightInputEnvelope
    connect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
  }

  export type capacity_infoUncheckedCreateNestedManyWithoutEffectOutsideFightInput = {
    create?: XOR<capacity_infoCreateWithoutEffectOutsideFightInput, capacity_infoUncheckedCreateWithoutEffectOutsideFightInput> | capacity_infoCreateWithoutEffectOutsideFightInput[] | capacity_infoUncheckedCreateWithoutEffectOutsideFightInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutEffectOutsideFightInput | capacity_infoCreateOrConnectWithoutEffectOutsideFightInput[]
    createMany?: capacity_infoCreateManyEffectOutsideFightInputEnvelope
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
  }

  export type ability_infoUpdateManyWithoutEffectWithoutFightNestedInput = {
    create?: XOR<ability_infoCreateWithoutEffectWithoutFightInput, ability_infoUncheckedCreateWithoutEffectWithoutFightInput> | ability_infoCreateWithoutEffectWithoutFightInput[] | ability_infoUncheckedCreateWithoutEffectWithoutFightInput[]
    connectOrCreate?: ability_infoCreateOrConnectWithoutEffectWithoutFightInput | ability_infoCreateOrConnectWithoutEffectWithoutFightInput[]
    upsert?: ability_infoUpsertWithWhereUniqueWithoutEffectWithoutFightInput | ability_infoUpsertWithWhereUniqueWithoutEffectWithoutFightInput[]
    createMany?: ability_infoCreateManyEffectWithoutFightInputEnvelope
    set?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    disconnect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    delete?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    connect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    update?: ability_infoUpdateWithWhereUniqueWithoutEffectWithoutFightInput | ability_infoUpdateWithWhereUniqueWithoutEffectWithoutFightInput[]
    updateMany?: ability_infoUpdateManyWithWhereWithoutEffectWithoutFightInput | ability_infoUpdateManyWithWhereWithoutEffectWithoutFightInput[]
    deleteMany?: ability_infoScalarWhereInput | ability_infoScalarWhereInput[]
  }

  export type capacity_infoUpdateManyWithoutEffectOutsideFightNestedInput = {
    create?: XOR<capacity_infoCreateWithoutEffectOutsideFightInput, capacity_infoUncheckedCreateWithoutEffectOutsideFightInput> | capacity_infoCreateWithoutEffectOutsideFightInput[] | capacity_infoUncheckedCreateWithoutEffectOutsideFightInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutEffectOutsideFightInput | capacity_infoCreateOrConnectWithoutEffectOutsideFightInput[]
    upsert?: capacity_infoUpsertWithWhereUniqueWithoutEffectOutsideFightInput | capacity_infoUpsertWithWhereUniqueWithoutEffectOutsideFightInput[]
    createMany?: capacity_infoCreateManyEffectOutsideFightInputEnvelope
    set?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    disconnect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    delete?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    update?: capacity_infoUpdateWithWhereUniqueWithoutEffectOutsideFightInput | capacity_infoUpdateWithWhereUniqueWithoutEffectOutsideFightInput[]
    updateMany?: capacity_infoUpdateManyWithWhereWithoutEffectOutsideFightInput | capacity_infoUpdateManyWithWhereWithoutEffectOutsideFightInput[]
    deleteMany?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
  }

  export type ability_infoUncheckedUpdateManyWithoutEffectWithoutFightNestedInput = {
    create?: XOR<ability_infoCreateWithoutEffectWithoutFightInput, ability_infoUncheckedCreateWithoutEffectWithoutFightInput> | ability_infoCreateWithoutEffectWithoutFightInput[] | ability_infoUncheckedCreateWithoutEffectWithoutFightInput[]
    connectOrCreate?: ability_infoCreateOrConnectWithoutEffectWithoutFightInput | ability_infoCreateOrConnectWithoutEffectWithoutFightInput[]
    upsert?: ability_infoUpsertWithWhereUniqueWithoutEffectWithoutFightInput | ability_infoUpsertWithWhereUniqueWithoutEffectWithoutFightInput[]
    createMany?: ability_infoCreateManyEffectWithoutFightInputEnvelope
    set?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    disconnect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    delete?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    connect?: ability_infoWhereUniqueInput | ability_infoWhereUniqueInput[]
    update?: ability_infoUpdateWithWhereUniqueWithoutEffectWithoutFightInput | ability_infoUpdateWithWhereUniqueWithoutEffectWithoutFightInput[]
    updateMany?: ability_infoUpdateManyWithWhereWithoutEffectWithoutFightInput | ability_infoUpdateManyWithWhereWithoutEffectWithoutFightInput[]
    deleteMany?: ability_infoScalarWhereInput | ability_infoScalarWhereInput[]
  }

  export type capacity_infoUncheckedUpdateManyWithoutEffectOutsideFightNestedInput = {
    create?: XOR<capacity_infoCreateWithoutEffectOutsideFightInput, capacity_infoUncheckedCreateWithoutEffectOutsideFightInput> | capacity_infoCreateWithoutEffectOutsideFightInput[] | capacity_infoUncheckedCreateWithoutEffectOutsideFightInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutEffectOutsideFightInput | capacity_infoCreateOrConnectWithoutEffectOutsideFightInput[]
    upsert?: capacity_infoUpsertWithWhereUniqueWithoutEffectOutsideFightInput | capacity_infoUpsertWithWhereUniqueWithoutEffectOutsideFightInput[]
    createMany?: capacity_infoCreateManyEffectOutsideFightInputEnvelope
    set?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    disconnect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    delete?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    update?: capacity_infoUpdateWithWhereUniqueWithoutEffectOutsideFightInput | capacity_infoUpdateWithWhereUniqueWithoutEffectOutsideFightInput[]
    updateMany?: capacity_infoUpdateManyWithWhereWithoutEffectOutsideFightInput | capacity_infoUpdateManyWithWhereWithoutEffectOutsideFightInput[]
    deleteMany?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
  }

  export type capacity_info_influenceCreateNestedManyWithoutInfluenceInput = {
    create?: XOR<capacity_info_influenceCreateWithoutInfluenceInput, capacity_info_influenceUncheckedCreateWithoutInfluenceInput> | capacity_info_influenceCreateWithoutInfluenceInput[] | capacity_info_influenceUncheckedCreateWithoutInfluenceInput[]
    connectOrCreate?: capacity_info_influenceCreateOrConnectWithoutInfluenceInput | capacity_info_influenceCreateOrConnectWithoutInfluenceInput[]
    createMany?: capacity_info_influenceCreateManyInfluenceInputEnvelope
    connect?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
  }

  export type capacity_info_influenceUncheckedCreateNestedManyWithoutInfluenceInput = {
    create?: XOR<capacity_info_influenceCreateWithoutInfluenceInput, capacity_info_influenceUncheckedCreateWithoutInfluenceInput> | capacity_info_influenceCreateWithoutInfluenceInput[] | capacity_info_influenceUncheckedCreateWithoutInfluenceInput[]
    connectOrCreate?: capacity_info_influenceCreateOrConnectWithoutInfluenceInput | capacity_info_influenceCreateOrConnectWithoutInfluenceInput[]
    createMany?: capacity_info_influenceCreateManyInfluenceInputEnvelope
    connect?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
  }

  export type capacity_info_influenceUpdateManyWithoutInfluenceNestedInput = {
    create?: XOR<capacity_info_influenceCreateWithoutInfluenceInput, capacity_info_influenceUncheckedCreateWithoutInfluenceInput> | capacity_info_influenceCreateWithoutInfluenceInput[] | capacity_info_influenceUncheckedCreateWithoutInfluenceInput[]
    connectOrCreate?: capacity_info_influenceCreateOrConnectWithoutInfluenceInput | capacity_info_influenceCreateOrConnectWithoutInfluenceInput[]
    upsert?: capacity_info_influenceUpsertWithWhereUniqueWithoutInfluenceInput | capacity_info_influenceUpsertWithWhereUniqueWithoutInfluenceInput[]
    createMany?: capacity_info_influenceCreateManyInfluenceInputEnvelope
    set?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    disconnect?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    delete?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    connect?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    update?: capacity_info_influenceUpdateWithWhereUniqueWithoutInfluenceInput | capacity_info_influenceUpdateWithWhereUniqueWithoutInfluenceInput[]
    updateMany?: capacity_info_influenceUpdateManyWithWhereWithoutInfluenceInput | capacity_info_influenceUpdateManyWithWhereWithoutInfluenceInput[]
    deleteMany?: capacity_info_influenceScalarWhereInput | capacity_info_influenceScalarWhereInput[]
  }

  export type capacity_info_influenceUncheckedUpdateManyWithoutInfluenceNestedInput = {
    create?: XOR<capacity_info_influenceCreateWithoutInfluenceInput, capacity_info_influenceUncheckedCreateWithoutInfluenceInput> | capacity_info_influenceCreateWithoutInfluenceInput[] | capacity_info_influenceUncheckedCreateWithoutInfluenceInput[]
    connectOrCreate?: capacity_info_influenceCreateOrConnectWithoutInfluenceInput | capacity_info_influenceCreateOrConnectWithoutInfluenceInput[]
    upsert?: capacity_info_influenceUpsertWithWhereUniqueWithoutInfluenceInput | capacity_info_influenceUpsertWithWhereUniqueWithoutInfluenceInput[]
    createMany?: capacity_info_influenceCreateManyInfluenceInputEnvelope
    set?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    disconnect?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    delete?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    connect?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    update?: capacity_info_influenceUpdateWithWhereUniqueWithoutInfluenceInput | capacity_info_influenceUpdateWithWhereUniqueWithoutInfluenceInput[]
    updateMany?: capacity_info_influenceUpdateManyWithWhereWithoutInfluenceInput | capacity_info_influenceUpdateManyWithWhereWithoutInfluenceInput[]
    deleteMany?: capacity_info_influenceScalarWhereInput | capacity_info_influenceScalarWhereInput[]
  }

  export type location_zoneCreateNestedManyWithoutLocationInput = {
    create?: XOR<location_zoneCreateWithoutLocationInput, location_zoneUncheckedCreateWithoutLocationInput> | location_zoneCreateWithoutLocationInput[] | location_zoneUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: location_zoneCreateOrConnectWithoutLocationInput | location_zoneCreateOrConnectWithoutLocationInput[]
    createMany?: location_zoneCreateManyLocationInputEnvelope
    connect?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
  }

  export type location_zoneUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<location_zoneCreateWithoutLocationInput, location_zoneUncheckedCreateWithoutLocationInput> | location_zoneCreateWithoutLocationInput[] | location_zoneUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: location_zoneCreateOrConnectWithoutLocationInput | location_zoneCreateOrConnectWithoutLocationInput[]
    createMany?: location_zoneCreateManyLocationInputEnvelope
    connect?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
  }

  export type location_zoneUpdateManyWithoutLocationNestedInput = {
    create?: XOR<location_zoneCreateWithoutLocationInput, location_zoneUncheckedCreateWithoutLocationInput> | location_zoneCreateWithoutLocationInput[] | location_zoneUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: location_zoneCreateOrConnectWithoutLocationInput | location_zoneCreateOrConnectWithoutLocationInput[]
    upsert?: location_zoneUpsertWithWhereUniqueWithoutLocationInput | location_zoneUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: location_zoneCreateManyLocationInputEnvelope
    set?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    disconnect?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    delete?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    connect?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    update?: location_zoneUpdateWithWhereUniqueWithoutLocationInput | location_zoneUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: location_zoneUpdateManyWithWhereWithoutLocationInput | location_zoneUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: location_zoneScalarWhereInput | location_zoneScalarWhereInput[]
  }

  export type location_zoneUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<location_zoneCreateWithoutLocationInput, location_zoneUncheckedCreateWithoutLocationInput> | location_zoneCreateWithoutLocationInput[] | location_zoneUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: location_zoneCreateOrConnectWithoutLocationInput | location_zoneCreateOrConnectWithoutLocationInput[]
    upsert?: location_zoneUpsertWithWhereUniqueWithoutLocationInput | location_zoneUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: location_zoneCreateManyLocationInputEnvelope
    set?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    disconnect?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    delete?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    connect?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    update?: location_zoneUpdateWithWhereUniqueWithoutLocationInput | location_zoneUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: location_zoneUpdateManyWithWhereWithoutLocationInput | location_zoneUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: location_zoneScalarWhereInput | location_zoneScalarWhereInput[]
  }

  export type location_zoneCreateNestedManyWithoutZoneInput = {
    create?: XOR<location_zoneCreateWithoutZoneInput, location_zoneUncheckedCreateWithoutZoneInput> | location_zoneCreateWithoutZoneInput[] | location_zoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: location_zoneCreateOrConnectWithoutZoneInput | location_zoneCreateOrConnectWithoutZoneInput[]
    createMany?: location_zoneCreateManyZoneInputEnvelope
    connect?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
  }

  export type location_zoneUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<location_zoneCreateWithoutZoneInput, location_zoneUncheckedCreateWithoutZoneInput> | location_zoneCreateWithoutZoneInput[] | location_zoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: location_zoneCreateOrConnectWithoutZoneInput | location_zoneCreateOrConnectWithoutZoneInput[]
    createMany?: location_zoneCreateManyZoneInputEnvelope
    connect?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
  }

  export type location_zoneUpdateManyWithoutZoneNestedInput = {
    create?: XOR<location_zoneCreateWithoutZoneInput, location_zoneUncheckedCreateWithoutZoneInput> | location_zoneCreateWithoutZoneInput[] | location_zoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: location_zoneCreateOrConnectWithoutZoneInput | location_zoneCreateOrConnectWithoutZoneInput[]
    upsert?: location_zoneUpsertWithWhereUniqueWithoutZoneInput | location_zoneUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: location_zoneCreateManyZoneInputEnvelope
    set?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    disconnect?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    delete?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    connect?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    update?: location_zoneUpdateWithWhereUniqueWithoutZoneInput | location_zoneUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: location_zoneUpdateManyWithWhereWithoutZoneInput | location_zoneUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: location_zoneScalarWhereInput | location_zoneScalarWhereInput[]
  }

  export type location_zoneUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<location_zoneCreateWithoutZoneInput, location_zoneUncheckedCreateWithoutZoneInput> | location_zoneCreateWithoutZoneInput[] | location_zoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: location_zoneCreateOrConnectWithoutZoneInput | location_zoneCreateOrConnectWithoutZoneInput[]
    upsert?: location_zoneUpsertWithWhereUniqueWithoutZoneInput | location_zoneUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: location_zoneCreateManyZoneInputEnvelope
    set?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    disconnect?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    delete?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    connect?: location_zoneWhereUniqueInput | location_zoneWhereUniqueInput[]
    update?: location_zoneUpdateWithWhereUniqueWithoutZoneInput | location_zoneUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: location_zoneUpdateManyWithWhereWithoutZoneInput | location_zoneUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: location_zoneScalarWhereInput | location_zoneScalarWhereInput[]
  }

  export type locationCreateNestedOneWithoutLocationZonesInput = {
    create?: XOR<locationCreateWithoutLocationZonesInput, locationUncheckedCreateWithoutLocationZonesInput>
    connectOrCreate?: locationCreateOrConnectWithoutLocationZonesInput
    connect?: locationWhereUniqueInput
  }

  export type zoneCreateNestedOneWithoutLocationZonesInput = {
    create?: XOR<zoneCreateWithoutLocationZonesInput, zoneUncheckedCreateWithoutLocationZonesInput>
    connectOrCreate?: zoneCreateOrConnectWithoutLocationZonesInput
    connect?: zoneWhereUniqueInput
  }

  export type pokemon_game_locationCreateNestedManyWithoutLocationZoneInput = {
    create?: XOR<pokemon_game_locationCreateWithoutLocationZoneInput, pokemon_game_locationUncheckedCreateWithoutLocationZoneInput> | pokemon_game_locationCreateWithoutLocationZoneInput[] | pokemon_game_locationUncheckedCreateWithoutLocationZoneInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutLocationZoneInput | pokemon_game_locationCreateOrConnectWithoutLocationZoneInput[]
    createMany?: pokemon_game_locationCreateManyLocationZoneInputEnvelope
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
  }

  export type pokemon_game_locationUncheckedCreateNestedManyWithoutLocationZoneInput = {
    create?: XOR<pokemon_game_locationCreateWithoutLocationZoneInput, pokemon_game_locationUncheckedCreateWithoutLocationZoneInput> | pokemon_game_locationCreateWithoutLocationZoneInput[] | pokemon_game_locationUncheckedCreateWithoutLocationZoneInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutLocationZoneInput | pokemon_game_locationCreateOrConnectWithoutLocationZoneInput[]
    createMany?: pokemon_game_locationCreateManyLocationZoneInputEnvelope
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
  }

  export type locationUpdateOneRequiredWithoutLocationZonesNestedInput = {
    create?: XOR<locationCreateWithoutLocationZonesInput, locationUncheckedCreateWithoutLocationZonesInput>
    connectOrCreate?: locationCreateOrConnectWithoutLocationZonesInput
    upsert?: locationUpsertWithoutLocationZonesInput
    connect?: locationWhereUniqueInput
    update?: XOR<XOR<locationUpdateToOneWithWhereWithoutLocationZonesInput, locationUpdateWithoutLocationZonesInput>, locationUncheckedUpdateWithoutLocationZonesInput>
  }

  export type zoneUpdateOneRequiredWithoutLocationZonesNestedInput = {
    create?: XOR<zoneCreateWithoutLocationZonesInput, zoneUncheckedCreateWithoutLocationZonesInput>
    connectOrCreate?: zoneCreateOrConnectWithoutLocationZonesInput
    upsert?: zoneUpsertWithoutLocationZonesInput
    connect?: zoneWhereUniqueInput
    update?: XOR<XOR<zoneUpdateToOneWithWhereWithoutLocationZonesInput, zoneUpdateWithoutLocationZonesInput>, zoneUncheckedUpdateWithoutLocationZonesInput>
  }

  export type pokemon_game_locationUpdateManyWithoutLocationZoneNestedInput = {
    create?: XOR<pokemon_game_locationCreateWithoutLocationZoneInput, pokemon_game_locationUncheckedCreateWithoutLocationZoneInput> | pokemon_game_locationCreateWithoutLocationZoneInput[] | pokemon_game_locationUncheckedCreateWithoutLocationZoneInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutLocationZoneInput | pokemon_game_locationCreateOrConnectWithoutLocationZoneInput[]
    upsert?: pokemon_game_locationUpsertWithWhereUniqueWithoutLocationZoneInput | pokemon_game_locationUpsertWithWhereUniqueWithoutLocationZoneInput[]
    createMany?: pokemon_game_locationCreateManyLocationZoneInputEnvelope
    set?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    disconnect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    delete?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    update?: pokemon_game_locationUpdateWithWhereUniqueWithoutLocationZoneInput | pokemon_game_locationUpdateWithWhereUniqueWithoutLocationZoneInput[]
    updateMany?: pokemon_game_locationUpdateManyWithWhereWithoutLocationZoneInput | pokemon_game_locationUpdateManyWithWhereWithoutLocationZoneInput[]
    deleteMany?: pokemon_game_locationScalarWhereInput | pokemon_game_locationScalarWhereInput[]
  }

  export type pokemon_game_locationUncheckedUpdateManyWithoutLocationZoneNestedInput = {
    create?: XOR<pokemon_game_locationCreateWithoutLocationZoneInput, pokemon_game_locationUncheckedCreateWithoutLocationZoneInput> | pokemon_game_locationCreateWithoutLocationZoneInput[] | pokemon_game_locationUncheckedCreateWithoutLocationZoneInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutLocationZoneInput | pokemon_game_locationCreateOrConnectWithoutLocationZoneInput[]
    upsert?: pokemon_game_locationUpsertWithWhereUniqueWithoutLocationZoneInput | pokemon_game_locationUpsertWithWhereUniqueWithoutLocationZoneInput[]
    createMany?: pokemon_game_locationCreateManyLocationZoneInputEnvelope
    set?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    disconnect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    delete?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    update?: pokemon_game_locationUpdateWithWhereUniqueWithoutLocationZoneInput | pokemon_game_locationUpdateWithWhereUniqueWithoutLocationZoneInput[]
    updateMany?: pokemon_game_locationUpdateManyWithWhereWithoutLocationZoneInput | pokemon_game_locationUpdateManyWithWhereWithoutLocationZoneInput[]
    deleteMany?: pokemon_game_locationScalarWhereInput | pokemon_game_locationScalarWhereInput[]
  }

  export type rateCreateNestedManyWithoutMeteoInput = {
    create?: XOR<rateCreateWithoutMeteoInput, rateUncheckedCreateWithoutMeteoInput> | rateCreateWithoutMeteoInput[] | rateUncheckedCreateWithoutMeteoInput[]
    connectOrCreate?: rateCreateOrConnectWithoutMeteoInput | rateCreateOrConnectWithoutMeteoInput[]
    createMany?: rateCreateManyMeteoInputEnvelope
    connect?: rateWhereUniqueInput | rateWhereUniqueInput[]
  }

  export type rateUncheckedCreateNestedManyWithoutMeteoInput = {
    create?: XOR<rateCreateWithoutMeteoInput, rateUncheckedCreateWithoutMeteoInput> | rateCreateWithoutMeteoInput[] | rateUncheckedCreateWithoutMeteoInput[]
    connectOrCreate?: rateCreateOrConnectWithoutMeteoInput | rateCreateOrConnectWithoutMeteoInput[]
    createMany?: rateCreateManyMeteoInputEnvelope
    connect?: rateWhereUniqueInput | rateWhereUniqueInput[]
  }

  export type rateUpdateManyWithoutMeteoNestedInput = {
    create?: XOR<rateCreateWithoutMeteoInput, rateUncheckedCreateWithoutMeteoInput> | rateCreateWithoutMeteoInput[] | rateUncheckedCreateWithoutMeteoInput[]
    connectOrCreate?: rateCreateOrConnectWithoutMeteoInput | rateCreateOrConnectWithoutMeteoInput[]
    upsert?: rateUpsertWithWhereUniqueWithoutMeteoInput | rateUpsertWithWhereUniqueWithoutMeteoInput[]
    createMany?: rateCreateManyMeteoInputEnvelope
    set?: rateWhereUniqueInput | rateWhereUniqueInput[]
    disconnect?: rateWhereUniqueInput | rateWhereUniqueInput[]
    delete?: rateWhereUniqueInput | rateWhereUniqueInput[]
    connect?: rateWhereUniqueInput | rateWhereUniqueInput[]
    update?: rateUpdateWithWhereUniqueWithoutMeteoInput | rateUpdateWithWhereUniqueWithoutMeteoInput[]
    updateMany?: rateUpdateManyWithWhereWithoutMeteoInput | rateUpdateManyWithWhereWithoutMeteoInput[]
    deleteMany?: rateScalarWhereInput | rateScalarWhereInput[]
  }

  export type rateUncheckedUpdateManyWithoutMeteoNestedInput = {
    create?: XOR<rateCreateWithoutMeteoInput, rateUncheckedCreateWithoutMeteoInput> | rateCreateWithoutMeteoInput[] | rateUncheckedCreateWithoutMeteoInput[]
    connectOrCreate?: rateCreateOrConnectWithoutMeteoInput | rateCreateOrConnectWithoutMeteoInput[]
    upsert?: rateUpsertWithWhereUniqueWithoutMeteoInput | rateUpsertWithWhereUniqueWithoutMeteoInput[]
    createMany?: rateCreateManyMeteoInputEnvelope
    set?: rateWhereUniqueInput | rateWhereUniqueInput[]
    disconnect?: rateWhereUniqueInput | rateWhereUniqueInput[]
    delete?: rateWhereUniqueInput | rateWhereUniqueInput[]
    connect?: rateWhereUniqueInput | rateWhereUniqueInput[]
    update?: rateUpdateWithWhereUniqueWithoutMeteoInput | rateUpdateWithWhereUniqueWithoutMeteoInput[]
    updateMany?: rateUpdateManyWithWhereWithoutMeteoInput | rateUpdateManyWithWhereWithoutMeteoInput[]
    deleteMany?: rateScalarWhereInput | rateScalarWhereInput[]
  }

  export type pokemon_game_locationCreateNestedManyWithoutPokemonObtationInput = {
    create?: XOR<pokemon_game_locationCreateWithoutPokemonObtationInput, pokemon_game_locationUncheckedCreateWithoutPokemonObtationInput> | pokemon_game_locationCreateWithoutPokemonObtationInput[] | pokemon_game_locationUncheckedCreateWithoutPokemonObtationInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutPokemonObtationInput | pokemon_game_locationCreateOrConnectWithoutPokemonObtationInput[]
    createMany?: pokemon_game_locationCreateManyPokemonObtationInputEnvelope
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
  }

  export type pokemon_game_locationUncheckedCreateNestedManyWithoutPokemonObtationInput = {
    create?: XOR<pokemon_game_locationCreateWithoutPokemonObtationInput, pokemon_game_locationUncheckedCreateWithoutPokemonObtationInput> | pokemon_game_locationCreateWithoutPokemonObtationInput[] | pokemon_game_locationUncheckedCreateWithoutPokemonObtationInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutPokemonObtationInput | pokemon_game_locationCreateOrConnectWithoutPokemonObtationInput[]
    createMany?: pokemon_game_locationCreateManyPokemonObtationInputEnvelope
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
  }

  export type pokemon_game_locationUpdateManyWithoutPokemonObtationNestedInput = {
    create?: XOR<pokemon_game_locationCreateWithoutPokemonObtationInput, pokemon_game_locationUncheckedCreateWithoutPokemonObtationInput> | pokemon_game_locationCreateWithoutPokemonObtationInput[] | pokemon_game_locationUncheckedCreateWithoutPokemonObtationInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutPokemonObtationInput | pokemon_game_locationCreateOrConnectWithoutPokemonObtationInput[]
    upsert?: pokemon_game_locationUpsertWithWhereUniqueWithoutPokemonObtationInput | pokemon_game_locationUpsertWithWhereUniqueWithoutPokemonObtationInput[]
    createMany?: pokemon_game_locationCreateManyPokemonObtationInputEnvelope
    set?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    disconnect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    delete?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    update?: pokemon_game_locationUpdateWithWhereUniqueWithoutPokemonObtationInput | pokemon_game_locationUpdateWithWhereUniqueWithoutPokemonObtationInput[]
    updateMany?: pokemon_game_locationUpdateManyWithWhereWithoutPokemonObtationInput | pokemon_game_locationUpdateManyWithWhereWithoutPokemonObtationInput[]
    deleteMany?: pokemon_game_locationScalarWhereInput | pokemon_game_locationScalarWhereInput[]
  }

  export type pokemon_game_locationUncheckedUpdateManyWithoutPokemonObtationNestedInput = {
    create?: XOR<pokemon_game_locationCreateWithoutPokemonObtationInput, pokemon_game_locationUncheckedCreateWithoutPokemonObtationInput> | pokemon_game_locationCreateWithoutPokemonObtationInput[] | pokemon_game_locationUncheckedCreateWithoutPokemonObtationInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutPokemonObtationInput | pokemon_game_locationCreateOrConnectWithoutPokemonObtationInput[]
    upsert?: pokemon_game_locationUpsertWithWhereUniqueWithoutPokemonObtationInput | pokemon_game_locationUpsertWithWhereUniqueWithoutPokemonObtationInput[]
    createMany?: pokemon_game_locationCreateManyPokemonObtationInputEnvelope
    set?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    disconnect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    delete?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    update?: pokemon_game_locationUpdateWithWhereUniqueWithoutPokemonObtationInput | pokemon_game_locationUpdateWithWhereUniqueWithoutPokemonObtationInput[]
    updateMany?: pokemon_game_locationUpdateManyWithWhereWithoutPokemonObtationInput | pokemon_game_locationUpdateManyWithWhereWithoutPokemonObtationInput[]
    deleteMany?: pokemon_game_locationScalarWhereInput | pokemon_game_locationScalarWhereInput[]
  }

  export type pokemon_game_locationCreateNestedManyWithoutRateInput = {
    create?: XOR<pokemon_game_locationCreateWithoutRateInput, pokemon_game_locationUncheckedCreateWithoutRateInput> | pokemon_game_locationCreateWithoutRateInput[] | pokemon_game_locationUncheckedCreateWithoutRateInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutRateInput | pokemon_game_locationCreateOrConnectWithoutRateInput[]
    createMany?: pokemon_game_locationCreateManyRateInputEnvelope
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
  }

  export type detailCreateNestedOneWithoutConditionRatesInput = {
    create?: XOR<detailCreateWithoutConditionRatesInput, detailUncheckedCreateWithoutConditionRatesInput>
    connectOrCreate?: detailCreateOrConnectWithoutConditionRatesInput
    connect?: detailWhereUniqueInput
  }

  export type detailCreateNestedOneWithoutDetailRatesInput = {
    create?: XOR<detailCreateWithoutDetailRatesInput, detailUncheckedCreateWithoutDetailRatesInput>
    connectOrCreate?: detailCreateOrConnectWithoutDetailRatesInput
    connect?: detailWhereUniqueInput
  }

  export type meteoCreateNestedOneWithoutRatesInput = {
    create?: XOR<meteoCreateWithoutRatesInput, meteoUncheckedCreateWithoutRatesInput>
    connectOrCreate?: meteoCreateOrConnectWithoutRatesInput
    connect?: meteoWhereUniqueInput
  }

  export type shiny_hunting_method_rateCreateNestedManyWithoutRateInput = {
    create?: XOR<shiny_hunting_method_rateCreateWithoutRateInput, shiny_hunting_method_rateUncheckedCreateWithoutRateInput> | shiny_hunting_method_rateCreateWithoutRateInput[] | shiny_hunting_method_rateUncheckedCreateWithoutRateInput[]
    connectOrCreate?: shiny_hunting_method_rateCreateOrConnectWithoutRateInput | shiny_hunting_method_rateCreateOrConnectWithoutRateInput[]
    createMany?: shiny_hunting_method_rateCreateManyRateInputEnvelope
    connect?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
  }

  export type pokemon_game_locationUncheckedCreateNestedManyWithoutRateInput = {
    create?: XOR<pokemon_game_locationCreateWithoutRateInput, pokemon_game_locationUncheckedCreateWithoutRateInput> | pokemon_game_locationCreateWithoutRateInput[] | pokemon_game_locationUncheckedCreateWithoutRateInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutRateInput | pokemon_game_locationCreateOrConnectWithoutRateInput[]
    createMany?: pokemon_game_locationCreateManyRateInputEnvelope
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
  }

  export type shiny_hunting_method_rateUncheckedCreateNestedManyWithoutRateInput = {
    create?: XOR<shiny_hunting_method_rateCreateWithoutRateInput, shiny_hunting_method_rateUncheckedCreateWithoutRateInput> | shiny_hunting_method_rateCreateWithoutRateInput[] | shiny_hunting_method_rateUncheckedCreateWithoutRateInput[]
    connectOrCreate?: shiny_hunting_method_rateCreateOrConnectWithoutRateInput | shiny_hunting_method_rateCreateOrConnectWithoutRateInput[]
    createMany?: shiny_hunting_method_rateCreateManyRateInputEnvelope
    connect?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
  }

  export type pokemon_game_locationUpdateManyWithoutRateNestedInput = {
    create?: XOR<pokemon_game_locationCreateWithoutRateInput, pokemon_game_locationUncheckedCreateWithoutRateInput> | pokemon_game_locationCreateWithoutRateInput[] | pokemon_game_locationUncheckedCreateWithoutRateInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutRateInput | pokemon_game_locationCreateOrConnectWithoutRateInput[]
    upsert?: pokemon_game_locationUpsertWithWhereUniqueWithoutRateInput | pokemon_game_locationUpsertWithWhereUniqueWithoutRateInput[]
    createMany?: pokemon_game_locationCreateManyRateInputEnvelope
    set?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    disconnect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    delete?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    update?: pokemon_game_locationUpdateWithWhereUniqueWithoutRateInput | pokemon_game_locationUpdateWithWhereUniqueWithoutRateInput[]
    updateMany?: pokemon_game_locationUpdateManyWithWhereWithoutRateInput | pokemon_game_locationUpdateManyWithWhereWithoutRateInput[]
    deleteMany?: pokemon_game_locationScalarWhereInput | pokemon_game_locationScalarWhereInput[]
  }

  export type detailUpdateOneRequiredWithoutConditionRatesNestedInput = {
    create?: XOR<detailCreateWithoutConditionRatesInput, detailUncheckedCreateWithoutConditionRatesInput>
    connectOrCreate?: detailCreateOrConnectWithoutConditionRatesInput
    upsert?: detailUpsertWithoutConditionRatesInput
    connect?: detailWhereUniqueInput
    update?: XOR<XOR<detailUpdateToOneWithWhereWithoutConditionRatesInput, detailUpdateWithoutConditionRatesInput>, detailUncheckedUpdateWithoutConditionRatesInput>
  }

  export type detailUpdateOneRequiredWithoutDetailRatesNestedInput = {
    create?: XOR<detailCreateWithoutDetailRatesInput, detailUncheckedCreateWithoutDetailRatesInput>
    connectOrCreate?: detailCreateOrConnectWithoutDetailRatesInput
    upsert?: detailUpsertWithoutDetailRatesInput
    connect?: detailWhereUniqueInput
    update?: XOR<XOR<detailUpdateToOneWithWhereWithoutDetailRatesInput, detailUpdateWithoutDetailRatesInput>, detailUncheckedUpdateWithoutDetailRatesInput>
  }

  export type meteoUpdateOneRequiredWithoutRatesNestedInput = {
    create?: XOR<meteoCreateWithoutRatesInput, meteoUncheckedCreateWithoutRatesInput>
    connectOrCreate?: meteoCreateOrConnectWithoutRatesInput
    upsert?: meteoUpsertWithoutRatesInput
    connect?: meteoWhereUniqueInput
    update?: XOR<XOR<meteoUpdateToOneWithWhereWithoutRatesInput, meteoUpdateWithoutRatesInput>, meteoUncheckedUpdateWithoutRatesInput>
  }

  export type shiny_hunting_method_rateUpdateManyWithoutRateNestedInput = {
    create?: XOR<shiny_hunting_method_rateCreateWithoutRateInput, shiny_hunting_method_rateUncheckedCreateWithoutRateInput> | shiny_hunting_method_rateCreateWithoutRateInput[] | shiny_hunting_method_rateUncheckedCreateWithoutRateInput[]
    connectOrCreate?: shiny_hunting_method_rateCreateOrConnectWithoutRateInput | shiny_hunting_method_rateCreateOrConnectWithoutRateInput[]
    upsert?: shiny_hunting_method_rateUpsertWithWhereUniqueWithoutRateInput | shiny_hunting_method_rateUpsertWithWhereUniqueWithoutRateInput[]
    createMany?: shiny_hunting_method_rateCreateManyRateInputEnvelope
    set?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    disconnect?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    delete?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    connect?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    update?: shiny_hunting_method_rateUpdateWithWhereUniqueWithoutRateInput | shiny_hunting_method_rateUpdateWithWhereUniqueWithoutRateInput[]
    updateMany?: shiny_hunting_method_rateUpdateManyWithWhereWithoutRateInput | shiny_hunting_method_rateUpdateManyWithWhereWithoutRateInput[]
    deleteMany?: shiny_hunting_method_rateScalarWhereInput | shiny_hunting_method_rateScalarWhereInput[]
  }

  export type pokemon_game_locationUncheckedUpdateManyWithoutRateNestedInput = {
    create?: XOR<pokemon_game_locationCreateWithoutRateInput, pokemon_game_locationUncheckedCreateWithoutRateInput> | pokemon_game_locationCreateWithoutRateInput[] | pokemon_game_locationUncheckedCreateWithoutRateInput[]
    connectOrCreate?: pokemon_game_locationCreateOrConnectWithoutRateInput | pokemon_game_locationCreateOrConnectWithoutRateInput[]
    upsert?: pokemon_game_locationUpsertWithWhereUniqueWithoutRateInput | pokemon_game_locationUpsertWithWhereUniqueWithoutRateInput[]
    createMany?: pokemon_game_locationCreateManyRateInputEnvelope
    set?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    disconnect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    delete?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    connect?: pokemon_game_locationWhereUniqueInput | pokemon_game_locationWhereUniqueInput[]
    update?: pokemon_game_locationUpdateWithWhereUniqueWithoutRateInput | pokemon_game_locationUpdateWithWhereUniqueWithoutRateInput[]
    updateMany?: pokemon_game_locationUpdateManyWithWhereWithoutRateInput | pokemon_game_locationUpdateManyWithWhereWithoutRateInput[]
    deleteMany?: pokemon_game_locationScalarWhereInput | pokemon_game_locationScalarWhereInput[]
  }

  export type shiny_hunting_method_rateUncheckedUpdateManyWithoutRateNestedInput = {
    create?: XOR<shiny_hunting_method_rateCreateWithoutRateInput, shiny_hunting_method_rateUncheckedCreateWithoutRateInput> | shiny_hunting_method_rateCreateWithoutRateInput[] | shiny_hunting_method_rateUncheckedCreateWithoutRateInput[]
    connectOrCreate?: shiny_hunting_method_rateCreateOrConnectWithoutRateInput | shiny_hunting_method_rateCreateOrConnectWithoutRateInput[]
    upsert?: shiny_hunting_method_rateUpsertWithWhereUniqueWithoutRateInput | shiny_hunting_method_rateUpsertWithWhereUniqueWithoutRateInput[]
    createMany?: shiny_hunting_method_rateCreateManyRateInputEnvelope
    set?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    disconnect?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    delete?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    connect?: shiny_hunting_method_rateWhereUniqueInput | shiny_hunting_method_rateWhereUniqueInput[]
    update?: shiny_hunting_method_rateUpdateWithWhereUniqueWithoutRateInput | shiny_hunting_method_rateUpdateWithWhereUniqueWithoutRateInput[]
    updateMany?: shiny_hunting_method_rateUpdateManyWithWhereWithoutRateInput | shiny_hunting_method_rateUpdateManyWithWhereWithoutRateInput[]
    deleteMany?: shiny_hunting_method_rateScalarWhereInput | shiny_hunting_method_rateScalarWhereInput[]
  }

  export type group_gameCreateNestedOneWithoutShinyHuntingMethodGamesInput = {
    create?: XOR<group_gameCreateWithoutShinyHuntingMethodGamesInput, group_gameUncheckedCreateWithoutShinyHuntingMethodGamesInput>
    connectOrCreate?: group_gameCreateOrConnectWithoutShinyHuntingMethodGamesInput
    connect?: group_gameWhereUniqueInput
  }

  export type shiny_hunting_methodCreateNestedOneWithoutShinyHuntingMethodGamesInput = {
    create?: XOR<shiny_hunting_methodCreateWithoutShinyHuntingMethodGamesInput, shiny_hunting_methodUncheckedCreateWithoutShinyHuntingMethodGamesInput>
    connectOrCreate?: shiny_hunting_methodCreateOrConnectWithoutShinyHuntingMethodGamesInput
    connect?: shiny_hunting_methodWhereUniqueInput
  }

  export type group_gameUpdateOneRequiredWithoutShinyHuntingMethodGamesNestedInput = {
    create?: XOR<group_gameCreateWithoutShinyHuntingMethodGamesInput, group_gameUncheckedCreateWithoutShinyHuntingMethodGamesInput>
    connectOrCreate?: group_gameCreateOrConnectWithoutShinyHuntingMethodGamesInput
    upsert?: group_gameUpsertWithoutShinyHuntingMethodGamesInput
    connect?: group_gameWhereUniqueInput
    update?: XOR<XOR<group_gameUpdateToOneWithWhereWithoutShinyHuntingMethodGamesInput, group_gameUpdateWithoutShinyHuntingMethodGamesInput>, group_gameUncheckedUpdateWithoutShinyHuntingMethodGamesInput>
  }

  export type shiny_hunting_methodUpdateOneRequiredWithoutShinyHuntingMethodGamesNestedInput = {
    create?: XOR<shiny_hunting_methodCreateWithoutShinyHuntingMethodGamesInput, shiny_hunting_methodUncheckedCreateWithoutShinyHuntingMethodGamesInput>
    connectOrCreate?: shiny_hunting_methodCreateOrConnectWithoutShinyHuntingMethodGamesInput
    upsert?: shiny_hunting_methodUpsertWithoutShinyHuntingMethodGamesInput
    connect?: shiny_hunting_methodWhereUniqueInput
    update?: XOR<XOR<shiny_hunting_methodUpdateToOneWithWhereWithoutShinyHuntingMethodGamesInput, shiny_hunting_methodUpdateWithoutShinyHuntingMethodGamesInput>, shiny_hunting_methodUncheckedUpdateWithoutShinyHuntingMethodGamesInput>
  }

  export type rateCreateNestedOneWithoutShinyHuntingMethodRatesInput = {
    create?: XOR<rateCreateWithoutShinyHuntingMethodRatesInput, rateUncheckedCreateWithoutShinyHuntingMethodRatesInput>
    connectOrCreate?: rateCreateOrConnectWithoutShinyHuntingMethodRatesInput
    connect?: rateWhereUniqueInput
  }

  export type shiny_hunting_methodCreateNestedOneWithoutShinyHuntingMethodRatesInput = {
    create?: XOR<shiny_hunting_methodCreateWithoutShinyHuntingMethodRatesInput, shiny_hunting_methodUncheckedCreateWithoutShinyHuntingMethodRatesInput>
    connectOrCreate?: shiny_hunting_methodCreateOrConnectWithoutShinyHuntingMethodRatesInput
    connect?: shiny_hunting_methodWhereUniqueInput
  }

  export type rateUpdateOneRequiredWithoutShinyHuntingMethodRatesNestedInput = {
    create?: XOR<rateCreateWithoutShinyHuntingMethodRatesInput, rateUncheckedCreateWithoutShinyHuntingMethodRatesInput>
    connectOrCreate?: rateCreateOrConnectWithoutShinyHuntingMethodRatesInput
    upsert?: rateUpsertWithoutShinyHuntingMethodRatesInput
    connect?: rateWhereUniqueInput
    update?: XOR<XOR<rateUpdateToOneWithWhereWithoutShinyHuntingMethodRatesInput, rateUpdateWithoutShinyHuntingMethodRatesInput>, rateUncheckedUpdateWithoutShinyHuntingMethodRatesInput>
  }

  export type shiny_hunting_methodUpdateOneRequiredWithoutShinyHuntingMethodRatesNestedInput = {
    create?: XOR<shiny_hunting_methodCreateWithoutShinyHuntingMethodRatesInput, shiny_hunting_methodUncheckedCreateWithoutShinyHuntingMethodRatesInput>
    connectOrCreate?: shiny_hunting_methodCreateOrConnectWithoutShinyHuntingMethodRatesInput
    upsert?: shiny_hunting_methodUpsertWithoutShinyHuntingMethodRatesInput
    connect?: shiny_hunting_methodWhereUniqueInput
    update?: XOR<XOR<shiny_hunting_methodUpdateToOneWithWhereWithoutShinyHuntingMethodRatesInput, shiny_hunting_methodUpdateWithoutShinyHuntingMethodRatesInput>, shiny_hunting_methodUncheckedUpdateWithoutShinyHuntingMethodRatesInput>
  }

  export type skill_obtationCreateNestedManyWithoutSkillObtationTypeInput = {
    create?: XOR<skill_obtationCreateWithoutSkillObtationTypeInput, skill_obtationUncheckedCreateWithoutSkillObtationTypeInput> | skill_obtationCreateWithoutSkillObtationTypeInput[] | skill_obtationUncheckedCreateWithoutSkillObtationTypeInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutSkillObtationTypeInput | skill_obtationCreateOrConnectWithoutSkillObtationTypeInput[]
    createMany?: skill_obtationCreateManySkillObtationTypeInputEnvelope
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
  }

  export type skill_obtationUncheckedCreateNestedManyWithoutSkillObtationTypeInput = {
    create?: XOR<skill_obtationCreateWithoutSkillObtationTypeInput, skill_obtationUncheckedCreateWithoutSkillObtationTypeInput> | skill_obtationCreateWithoutSkillObtationTypeInput[] | skill_obtationUncheckedCreateWithoutSkillObtationTypeInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutSkillObtationTypeInput | skill_obtationCreateOrConnectWithoutSkillObtationTypeInput[]
    createMany?: skill_obtationCreateManySkillObtationTypeInputEnvelope
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
  }

  export type skill_obtationUpdateManyWithoutSkillObtationTypeNestedInput = {
    create?: XOR<skill_obtationCreateWithoutSkillObtationTypeInput, skill_obtationUncheckedCreateWithoutSkillObtationTypeInput> | skill_obtationCreateWithoutSkillObtationTypeInput[] | skill_obtationUncheckedCreateWithoutSkillObtationTypeInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutSkillObtationTypeInput | skill_obtationCreateOrConnectWithoutSkillObtationTypeInput[]
    upsert?: skill_obtationUpsertWithWhereUniqueWithoutSkillObtationTypeInput | skill_obtationUpsertWithWhereUniqueWithoutSkillObtationTypeInput[]
    createMany?: skill_obtationCreateManySkillObtationTypeInputEnvelope
    set?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    disconnect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    delete?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    update?: skill_obtationUpdateWithWhereUniqueWithoutSkillObtationTypeInput | skill_obtationUpdateWithWhereUniqueWithoutSkillObtationTypeInput[]
    updateMany?: skill_obtationUpdateManyWithWhereWithoutSkillObtationTypeInput | skill_obtationUpdateManyWithWhereWithoutSkillObtationTypeInput[]
    deleteMany?: skill_obtationScalarWhereInput | skill_obtationScalarWhereInput[]
  }

  export type skill_obtationUncheckedUpdateManyWithoutSkillObtationTypeNestedInput = {
    create?: XOR<skill_obtationCreateWithoutSkillObtationTypeInput, skill_obtationUncheckedCreateWithoutSkillObtationTypeInput> | skill_obtationCreateWithoutSkillObtationTypeInput[] | skill_obtationUncheckedCreateWithoutSkillObtationTypeInput[]
    connectOrCreate?: skill_obtationCreateOrConnectWithoutSkillObtationTypeInput | skill_obtationCreateOrConnectWithoutSkillObtationTypeInput[]
    upsert?: skill_obtationUpsertWithWhereUniqueWithoutSkillObtationTypeInput | skill_obtationUpsertWithWhereUniqueWithoutSkillObtationTypeInput[]
    createMany?: skill_obtationCreateManySkillObtationTypeInputEnvelope
    set?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    disconnect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    delete?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    connect?: skill_obtationWhereUniqueInput | skill_obtationWhereUniqueInput[]
    update?: skill_obtationUpdateWithWhereUniqueWithoutSkillObtationTypeInput | skill_obtationUpdateWithWhereUniqueWithoutSkillObtationTypeInput[]
    updateMany?: skill_obtationUpdateManyWithWhereWithoutSkillObtationTypeInput | skill_obtationUpdateManyWithWhereWithoutSkillObtationTypeInput[]
    deleteMany?: skill_obtationScalarWhereInput | skill_obtationScalarWhereInput[]
  }

  export type statistic_group_gameCreateNestedManyWithoutStatisticInput = {
    create?: XOR<statistic_group_gameCreateWithoutStatisticInput, statistic_group_gameUncheckedCreateWithoutStatisticInput> | statistic_group_gameCreateWithoutStatisticInput[] | statistic_group_gameUncheckedCreateWithoutStatisticInput[]
    connectOrCreate?: statistic_group_gameCreateOrConnectWithoutStatisticInput | statistic_group_gameCreateOrConnectWithoutStatisticInput[]
    createMany?: statistic_group_gameCreateManyStatisticInputEnvelope
    connect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
  }

  export type statistic_group_gameUncheckedCreateNestedManyWithoutStatisticInput = {
    create?: XOR<statistic_group_gameCreateWithoutStatisticInput, statistic_group_gameUncheckedCreateWithoutStatisticInput> | statistic_group_gameCreateWithoutStatisticInput[] | statistic_group_gameUncheckedCreateWithoutStatisticInput[]
    connectOrCreate?: statistic_group_gameCreateOrConnectWithoutStatisticInput | statistic_group_gameCreateOrConnectWithoutStatisticInput[]
    createMany?: statistic_group_gameCreateManyStatisticInputEnvelope
    connect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
  }

  export type statistic_group_gameUpdateManyWithoutStatisticNestedInput = {
    create?: XOR<statistic_group_gameCreateWithoutStatisticInput, statistic_group_gameUncheckedCreateWithoutStatisticInput> | statistic_group_gameCreateWithoutStatisticInput[] | statistic_group_gameUncheckedCreateWithoutStatisticInput[]
    connectOrCreate?: statistic_group_gameCreateOrConnectWithoutStatisticInput | statistic_group_gameCreateOrConnectWithoutStatisticInput[]
    upsert?: statistic_group_gameUpsertWithWhereUniqueWithoutStatisticInput | statistic_group_gameUpsertWithWhereUniqueWithoutStatisticInput[]
    createMany?: statistic_group_gameCreateManyStatisticInputEnvelope
    set?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    disconnect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    delete?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    connect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    update?: statistic_group_gameUpdateWithWhereUniqueWithoutStatisticInput | statistic_group_gameUpdateWithWhereUniqueWithoutStatisticInput[]
    updateMany?: statistic_group_gameUpdateManyWithWhereWithoutStatisticInput | statistic_group_gameUpdateManyWithWhereWithoutStatisticInput[]
    deleteMany?: statistic_group_gameScalarWhereInput | statistic_group_gameScalarWhereInput[]
  }

  export type statistic_group_gameUncheckedUpdateManyWithoutStatisticNestedInput = {
    create?: XOR<statistic_group_gameCreateWithoutStatisticInput, statistic_group_gameUncheckedCreateWithoutStatisticInput> | statistic_group_gameCreateWithoutStatisticInput[] | statistic_group_gameUncheckedCreateWithoutStatisticInput[]
    connectOrCreate?: statistic_group_gameCreateOrConnectWithoutStatisticInput | statistic_group_gameCreateOrConnectWithoutStatisticInput[]
    upsert?: statistic_group_gameUpsertWithWhereUniqueWithoutStatisticInput | statistic_group_gameUpsertWithWhereUniqueWithoutStatisticInput[]
    createMany?: statistic_group_gameCreateManyStatisticInputEnvelope
    set?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    disconnect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    delete?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    connect?: statistic_group_gameWhereUniqueInput | statistic_group_gameWhereUniqueInput[]
    update?: statistic_group_gameUpdateWithWhereUniqueWithoutStatisticInput | statistic_group_gameUpdateWithWhereUniqueWithoutStatisticInput[]
    updateMany?: statistic_group_gameUpdateManyWithWhereWithoutStatisticInput | statistic_group_gameUpdateManyWithWhereWithoutStatisticInput[]
    deleteMany?: statistic_group_gameScalarWhereInput | statistic_group_gameScalarWhereInput[]
  }

  export type group_gameCreateNestedOneWithoutStatisticGroupGamesInput = {
    create?: XOR<group_gameCreateWithoutStatisticGroupGamesInput, group_gameUncheckedCreateWithoutStatisticGroupGamesInput>
    connectOrCreate?: group_gameCreateOrConnectWithoutStatisticGroupGamesInput
    connect?: group_gameWhereUniqueInput
  }

  export type pokemonCreateNestedOneWithoutStatisticGroupGamesInput = {
    create?: XOR<pokemonCreateWithoutStatisticGroupGamesInput, pokemonUncheckedCreateWithoutStatisticGroupGamesInput>
    connectOrCreate?: pokemonCreateOrConnectWithoutStatisticGroupGamesInput
    connect?: pokemonWhereUniqueInput
  }

  export type statisticCreateNestedOneWithoutStatisticGroupGamesInput = {
    create?: XOR<statisticCreateWithoutStatisticGroupGamesInput, statisticUncheckedCreateWithoutStatisticGroupGamesInput>
    connectOrCreate?: statisticCreateOrConnectWithoutStatisticGroupGamesInput
    connect?: statisticWhereUniqueInput
  }

  export type group_gameUpdateOneRequiredWithoutStatisticGroupGamesNestedInput = {
    create?: XOR<group_gameCreateWithoutStatisticGroupGamesInput, group_gameUncheckedCreateWithoutStatisticGroupGamesInput>
    connectOrCreate?: group_gameCreateOrConnectWithoutStatisticGroupGamesInput
    upsert?: group_gameUpsertWithoutStatisticGroupGamesInput
    connect?: group_gameWhereUniqueInput
    update?: XOR<XOR<group_gameUpdateToOneWithWhereWithoutStatisticGroupGamesInput, group_gameUpdateWithoutStatisticGroupGamesInput>, group_gameUncheckedUpdateWithoutStatisticGroupGamesInput>
  }

  export type pokemonUpdateOneRequiredWithoutStatisticGroupGamesNestedInput = {
    create?: XOR<pokemonCreateWithoutStatisticGroupGamesInput, pokemonUncheckedCreateWithoutStatisticGroupGamesInput>
    connectOrCreate?: pokemonCreateOrConnectWithoutStatisticGroupGamesInput
    upsert?: pokemonUpsertWithoutStatisticGroupGamesInput
    connect?: pokemonWhereUniqueInput
    update?: XOR<XOR<pokemonUpdateToOneWithWhereWithoutStatisticGroupGamesInput, pokemonUpdateWithoutStatisticGroupGamesInput>, pokemonUncheckedUpdateWithoutStatisticGroupGamesInput>
  }

  export type statisticUpdateOneRequiredWithoutStatisticGroupGamesNestedInput = {
    create?: XOR<statisticCreateWithoutStatisticGroupGamesInput, statisticUncheckedCreateWithoutStatisticGroupGamesInput>
    connectOrCreate?: statisticCreateOrConnectWithoutStatisticGroupGamesInput
    upsert?: statisticUpsertWithoutStatisticGroupGamesInput
    connect?: statisticWhereUniqueInput
    update?: XOR<XOR<statisticUpdateToOneWithWhereWithoutStatisticGroupGamesInput, statisticUpdateWithoutStatisticGroupGamesInput>, statisticUncheckedUpdateWithoutStatisticGroupGamesInput>
  }

  export type capacity_infoCreateNestedManyWithoutTargetInput = {
    create?: XOR<capacity_infoCreateWithoutTargetInput, capacity_infoUncheckedCreateWithoutTargetInput> | capacity_infoCreateWithoutTargetInput[] | capacity_infoUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutTargetInput | capacity_infoCreateOrConnectWithoutTargetInput[]
    createMany?: capacity_infoCreateManyTargetInputEnvelope
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
  }

  export type capacity_infoUncheckedCreateNestedManyWithoutTargetInput = {
    create?: XOR<capacity_infoCreateWithoutTargetInput, capacity_infoUncheckedCreateWithoutTargetInput> | capacity_infoCreateWithoutTargetInput[] | capacity_infoUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutTargetInput | capacity_infoCreateOrConnectWithoutTargetInput[]
    createMany?: capacity_infoCreateManyTargetInputEnvelope
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
  }

  export type capacity_infoUpdateManyWithoutTargetNestedInput = {
    create?: XOR<capacity_infoCreateWithoutTargetInput, capacity_infoUncheckedCreateWithoutTargetInput> | capacity_infoCreateWithoutTargetInput[] | capacity_infoUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutTargetInput | capacity_infoCreateOrConnectWithoutTargetInput[]
    upsert?: capacity_infoUpsertWithWhereUniqueWithoutTargetInput | capacity_infoUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: capacity_infoCreateManyTargetInputEnvelope
    set?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    disconnect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    delete?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    update?: capacity_infoUpdateWithWhereUniqueWithoutTargetInput | capacity_infoUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: capacity_infoUpdateManyWithWhereWithoutTargetInput | capacity_infoUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
  }

  export type capacity_infoUncheckedUpdateManyWithoutTargetNestedInput = {
    create?: XOR<capacity_infoCreateWithoutTargetInput, capacity_infoUncheckedCreateWithoutTargetInput> | capacity_infoCreateWithoutTargetInput[] | capacity_infoUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: capacity_infoCreateOrConnectWithoutTargetInput | capacity_infoCreateOrConnectWithoutTargetInput[]
    upsert?: capacity_infoUpsertWithWhereUniqueWithoutTargetInput | capacity_infoUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: capacity_infoCreateManyTargetInputEnvelope
    set?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    disconnect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    delete?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    connect?: capacity_infoWhereUniqueInput | capacity_infoWhereUniqueInput[]
    update?: capacity_infoUpdateWithWhereUniqueWithoutTargetInput | capacity_infoUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: capacity_infoUpdateManyWithWhereWithoutTargetInput | capacity_infoUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
  }

  export type capacity_categoryCreateNestedOneWithoutCapacityInfosInput = {
    create?: XOR<capacity_categoryCreateWithoutCapacityInfosInput, capacity_categoryUncheckedCreateWithoutCapacityInfosInput>
    connectOrCreate?: capacity_categoryCreateOrConnectWithoutCapacityInfosInput
    connect?: capacity_categoryWhereUniqueInput
  }

  export type capacity_effectCreateNestedOneWithoutCapacityInfosInput = {
    create?: XOR<capacity_effectCreateWithoutCapacityInfosInput, capacity_effectUncheckedCreateWithoutCapacityInfosInput>
    connectOrCreate?: capacity_effectCreateOrConnectWithoutCapacityInfosInput
    connect?: capacity_effectWhereUniqueInput
  }

  export type capacity_effectCreateNestedOneWithoutCapacityZInfosInput = {
    create?: XOR<capacity_effectCreateWithoutCapacityZInfosInput, capacity_effectUncheckedCreateWithoutCapacityZInfosInput>
    connectOrCreate?: capacity_effectCreateOrConnectWithoutCapacityZInfosInput
    connect?: capacity_effectWhereUniqueInput
  }

  export type capacityCreateNestedOneWithoutCapacityInfosInput = {
    create?: XOR<capacityCreateWithoutCapacityInfosInput, capacityUncheckedCreateWithoutCapacityInfosInput>
    connectOrCreate?: capacityCreateOrConnectWithoutCapacityInfosInput
    connect?: capacityWhereUniqueInput
  }

  export type effect_outside_fightCreateNestedOneWithoutCapacityInfosInput = {
    create?: XOR<effect_outside_fightCreateWithoutCapacityInfosInput, effect_outside_fightUncheckedCreateWithoutCapacityInfosInput>
    connectOrCreate?: effect_outside_fightCreateOrConnectWithoutCapacityInfosInput
    connect?: effect_outside_fightWhereUniqueInput
  }

  export type targetCreateNestedOneWithoutCapacityInfosInput = {
    create?: XOR<targetCreateWithoutCapacityInfosInput, targetUncheckedCreateWithoutCapacityInfosInput>
    connectOrCreate?: targetCreateOrConnectWithoutCapacityInfosInput
    connect?: targetWhereUniqueInput
  }

  export type typeCreateNestedOneWithoutCapacityInfosInput = {
    create?: XOR<typeCreateWithoutCapacityInfosInput, typeUncheckedCreateWithoutCapacityInfosInput>
    connectOrCreate?: typeCreateOrConnectWithoutCapacityInfosInput
    connect?: typeWhereUniqueInput
  }

  export type capacity_info_influenceCreateNestedManyWithoutCapacityInfoInput = {
    create?: XOR<capacity_info_influenceCreateWithoutCapacityInfoInput, capacity_info_influenceUncheckedCreateWithoutCapacityInfoInput> | capacity_info_influenceCreateWithoutCapacityInfoInput[] | capacity_info_influenceUncheckedCreateWithoutCapacityInfoInput[]
    connectOrCreate?: capacity_info_influenceCreateOrConnectWithoutCapacityInfoInput | capacity_info_influenceCreateOrConnectWithoutCapacityInfoInput[]
    createMany?: capacity_info_influenceCreateManyCapacityInfoInputEnvelope
    connect?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
  }

  export type capsule_game_capacity_infoCreateNestedManyWithoutCapacityInfoInput = {
    create?: XOR<capsule_game_capacity_infoCreateWithoutCapacityInfoInput, capsule_game_capacity_infoUncheckedCreateWithoutCapacityInfoInput> | capsule_game_capacity_infoCreateWithoutCapacityInfoInput[] | capsule_game_capacity_infoUncheckedCreateWithoutCapacityInfoInput[]
    connectOrCreate?: capsule_game_capacity_infoCreateOrConnectWithoutCapacityInfoInput | capsule_game_capacity_infoCreateOrConnectWithoutCapacityInfoInput[]
    createMany?: capsule_game_capacity_infoCreateManyCapacityInfoInputEnvelope
    connect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
  }

  export type capacity_info_influenceUncheckedCreateNestedManyWithoutCapacityInfoInput = {
    create?: XOR<capacity_info_influenceCreateWithoutCapacityInfoInput, capacity_info_influenceUncheckedCreateWithoutCapacityInfoInput> | capacity_info_influenceCreateWithoutCapacityInfoInput[] | capacity_info_influenceUncheckedCreateWithoutCapacityInfoInput[]
    connectOrCreate?: capacity_info_influenceCreateOrConnectWithoutCapacityInfoInput | capacity_info_influenceCreateOrConnectWithoutCapacityInfoInput[]
    createMany?: capacity_info_influenceCreateManyCapacityInfoInputEnvelope
    connect?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
  }

  export type capsule_game_capacity_infoUncheckedCreateNestedManyWithoutCapacityInfoInput = {
    create?: XOR<capsule_game_capacity_infoCreateWithoutCapacityInfoInput, capsule_game_capacity_infoUncheckedCreateWithoutCapacityInfoInput> | capsule_game_capacity_infoCreateWithoutCapacityInfoInput[] | capsule_game_capacity_infoUncheckedCreateWithoutCapacityInfoInput[]
    connectOrCreate?: capsule_game_capacity_infoCreateOrConnectWithoutCapacityInfoInput | capsule_game_capacity_infoCreateOrConnectWithoutCapacityInfoInput[]
    createMany?: capsule_game_capacity_infoCreateManyCapacityInfoInputEnvelope
    connect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
  }

  export type capacity_categoryUpdateOneRequiredWithoutCapacityInfosNestedInput = {
    create?: XOR<capacity_categoryCreateWithoutCapacityInfosInput, capacity_categoryUncheckedCreateWithoutCapacityInfosInput>
    connectOrCreate?: capacity_categoryCreateOrConnectWithoutCapacityInfosInput
    upsert?: capacity_categoryUpsertWithoutCapacityInfosInput
    connect?: capacity_categoryWhereUniqueInput
    update?: XOR<XOR<capacity_categoryUpdateToOneWithWhereWithoutCapacityInfosInput, capacity_categoryUpdateWithoutCapacityInfosInput>, capacity_categoryUncheckedUpdateWithoutCapacityInfosInput>
  }

  export type capacity_effectUpdateOneRequiredWithoutCapacityInfosNestedInput = {
    create?: XOR<capacity_effectCreateWithoutCapacityInfosInput, capacity_effectUncheckedCreateWithoutCapacityInfosInput>
    connectOrCreate?: capacity_effectCreateOrConnectWithoutCapacityInfosInput
    upsert?: capacity_effectUpsertWithoutCapacityInfosInput
    connect?: capacity_effectWhereUniqueInput
    update?: XOR<XOR<capacity_effectUpdateToOneWithWhereWithoutCapacityInfosInput, capacity_effectUpdateWithoutCapacityInfosInput>, capacity_effectUncheckedUpdateWithoutCapacityInfosInput>
  }

  export type capacity_effectUpdateOneRequiredWithoutCapacityZInfosNestedInput = {
    create?: XOR<capacity_effectCreateWithoutCapacityZInfosInput, capacity_effectUncheckedCreateWithoutCapacityZInfosInput>
    connectOrCreate?: capacity_effectCreateOrConnectWithoutCapacityZInfosInput
    upsert?: capacity_effectUpsertWithoutCapacityZInfosInput
    connect?: capacity_effectWhereUniqueInput
    update?: XOR<XOR<capacity_effectUpdateToOneWithWhereWithoutCapacityZInfosInput, capacity_effectUpdateWithoutCapacityZInfosInput>, capacity_effectUncheckedUpdateWithoutCapacityZInfosInput>
  }

  export type capacityUpdateOneRequiredWithoutCapacityInfosNestedInput = {
    create?: XOR<capacityCreateWithoutCapacityInfosInput, capacityUncheckedCreateWithoutCapacityInfosInput>
    connectOrCreate?: capacityCreateOrConnectWithoutCapacityInfosInput
    upsert?: capacityUpsertWithoutCapacityInfosInput
    connect?: capacityWhereUniqueInput
    update?: XOR<XOR<capacityUpdateToOneWithWhereWithoutCapacityInfosInput, capacityUpdateWithoutCapacityInfosInput>, capacityUncheckedUpdateWithoutCapacityInfosInput>
  }

  export type effect_outside_fightUpdateOneRequiredWithoutCapacityInfosNestedInput = {
    create?: XOR<effect_outside_fightCreateWithoutCapacityInfosInput, effect_outside_fightUncheckedCreateWithoutCapacityInfosInput>
    connectOrCreate?: effect_outside_fightCreateOrConnectWithoutCapacityInfosInput
    upsert?: effect_outside_fightUpsertWithoutCapacityInfosInput
    connect?: effect_outside_fightWhereUniqueInput
    update?: XOR<XOR<effect_outside_fightUpdateToOneWithWhereWithoutCapacityInfosInput, effect_outside_fightUpdateWithoutCapacityInfosInput>, effect_outside_fightUncheckedUpdateWithoutCapacityInfosInput>
  }

  export type targetUpdateOneRequiredWithoutCapacityInfosNestedInput = {
    create?: XOR<targetCreateWithoutCapacityInfosInput, targetUncheckedCreateWithoutCapacityInfosInput>
    connectOrCreate?: targetCreateOrConnectWithoutCapacityInfosInput
    upsert?: targetUpsertWithoutCapacityInfosInput
    connect?: targetWhereUniqueInput
    update?: XOR<XOR<targetUpdateToOneWithWhereWithoutCapacityInfosInput, targetUpdateWithoutCapacityInfosInput>, targetUncheckedUpdateWithoutCapacityInfosInput>
  }

  export type typeUpdateOneRequiredWithoutCapacityInfosNestedInput = {
    create?: XOR<typeCreateWithoutCapacityInfosInput, typeUncheckedCreateWithoutCapacityInfosInput>
    connectOrCreate?: typeCreateOrConnectWithoutCapacityInfosInput
    upsert?: typeUpsertWithoutCapacityInfosInput
    connect?: typeWhereUniqueInput
    update?: XOR<XOR<typeUpdateToOneWithWhereWithoutCapacityInfosInput, typeUpdateWithoutCapacityInfosInput>, typeUncheckedUpdateWithoutCapacityInfosInput>
  }

  export type capacity_info_influenceUpdateManyWithoutCapacityInfoNestedInput = {
    create?: XOR<capacity_info_influenceCreateWithoutCapacityInfoInput, capacity_info_influenceUncheckedCreateWithoutCapacityInfoInput> | capacity_info_influenceCreateWithoutCapacityInfoInput[] | capacity_info_influenceUncheckedCreateWithoutCapacityInfoInput[]
    connectOrCreate?: capacity_info_influenceCreateOrConnectWithoutCapacityInfoInput | capacity_info_influenceCreateOrConnectWithoutCapacityInfoInput[]
    upsert?: capacity_info_influenceUpsertWithWhereUniqueWithoutCapacityInfoInput | capacity_info_influenceUpsertWithWhereUniqueWithoutCapacityInfoInput[]
    createMany?: capacity_info_influenceCreateManyCapacityInfoInputEnvelope
    set?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    disconnect?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    delete?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    connect?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    update?: capacity_info_influenceUpdateWithWhereUniqueWithoutCapacityInfoInput | capacity_info_influenceUpdateWithWhereUniqueWithoutCapacityInfoInput[]
    updateMany?: capacity_info_influenceUpdateManyWithWhereWithoutCapacityInfoInput | capacity_info_influenceUpdateManyWithWhereWithoutCapacityInfoInput[]
    deleteMany?: capacity_info_influenceScalarWhereInput | capacity_info_influenceScalarWhereInput[]
  }

  export type capsule_game_capacity_infoUpdateManyWithoutCapacityInfoNestedInput = {
    create?: XOR<capsule_game_capacity_infoCreateWithoutCapacityInfoInput, capsule_game_capacity_infoUncheckedCreateWithoutCapacityInfoInput> | capsule_game_capacity_infoCreateWithoutCapacityInfoInput[] | capsule_game_capacity_infoUncheckedCreateWithoutCapacityInfoInput[]
    connectOrCreate?: capsule_game_capacity_infoCreateOrConnectWithoutCapacityInfoInput | capsule_game_capacity_infoCreateOrConnectWithoutCapacityInfoInput[]
    upsert?: capsule_game_capacity_infoUpsertWithWhereUniqueWithoutCapacityInfoInput | capsule_game_capacity_infoUpsertWithWhereUniqueWithoutCapacityInfoInput[]
    createMany?: capsule_game_capacity_infoCreateManyCapacityInfoInputEnvelope
    set?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    disconnect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    delete?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    connect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    update?: capsule_game_capacity_infoUpdateWithWhereUniqueWithoutCapacityInfoInput | capsule_game_capacity_infoUpdateWithWhereUniqueWithoutCapacityInfoInput[]
    updateMany?: capsule_game_capacity_infoUpdateManyWithWhereWithoutCapacityInfoInput | capsule_game_capacity_infoUpdateManyWithWhereWithoutCapacityInfoInput[]
    deleteMany?: capsule_game_capacity_infoScalarWhereInput | capsule_game_capacity_infoScalarWhereInput[]
  }

  export type capacity_info_influenceUncheckedUpdateManyWithoutCapacityInfoNestedInput = {
    create?: XOR<capacity_info_influenceCreateWithoutCapacityInfoInput, capacity_info_influenceUncheckedCreateWithoutCapacityInfoInput> | capacity_info_influenceCreateWithoutCapacityInfoInput[] | capacity_info_influenceUncheckedCreateWithoutCapacityInfoInput[]
    connectOrCreate?: capacity_info_influenceCreateOrConnectWithoutCapacityInfoInput | capacity_info_influenceCreateOrConnectWithoutCapacityInfoInput[]
    upsert?: capacity_info_influenceUpsertWithWhereUniqueWithoutCapacityInfoInput | capacity_info_influenceUpsertWithWhereUniqueWithoutCapacityInfoInput[]
    createMany?: capacity_info_influenceCreateManyCapacityInfoInputEnvelope
    set?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    disconnect?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    delete?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    connect?: capacity_info_influenceWhereUniqueInput | capacity_info_influenceWhereUniqueInput[]
    update?: capacity_info_influenceUpdateWithWhereUniqueWithoutCapacityInfoInput | capacity_info_influenceUpdateWithWhereUniqueWithoutCapacityInfoInput[]
    updateMany?: capacity_info_influenceUpdateManyWithWhereWithoutCapacityInfoInput | capacity_info_influenceUpdateManyWithWhereWithoutCapacityInfoInput[]
    deleteMany?: capacity_info_influenceScalarWhereInput | capacity_info_influenceScalarWhereInput[]
  }

  export type capsule_game_capacity_infoUncheckedUpdateManyWithoutCapacityInfoNestedInput = {
    create?: XOR<capsule_game_capacity_infoCreateWithoutCapacityInfoInput, capsule_game_capacity_infoUncheckedCreateWithoutCapacityInfoInput> | capsule_game_capacity_infoCreateWithoutCapacityInfoInput[] | capsule_game_capacity_infoUncheckedCreateWithoutCapacityInfoInput[]
    connectOrCreate?: capsule_game_capacity_infoCreateOrConnectWithoutCapacityInfoInput | capsule_game_capacity_infoCreateOrConnectWithoutCapacityInfoInput[]
    upsert?: capsule_game_capacity_infoUpsertWithWhereUniqueWithoutCapacityInfoInput | capsule_game_capacity_infoUpsertWithWhereUniqueWithoutCapacityInfoInput[]
    createMany?: capsule_game_capacity_infoCreateManyCapacityInfoInputEnvelope
    set?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    disconnect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    delete?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    connect?: capsule_game_capacity_infoWhereUniqueInput | capsule_game_capacity_infoWhereUniqueInput[]
    update?: capsule_game_capacity_infoUpdateWithWhereUniqueWithoutCapacityInfoInput | capsule_game_capacity_infoUpdateWithWhereUniqueWithoutCapacityInfoInput[]
    updateMany?: capsule_game_capacity_infoUpdateManyWithWhereWithoutCapacityInfoInput | capsule_game_capacity_infoUpdateManyWithWhereWithoutCapacityInfoInput[]
    deleteMany?: capsule_game_capacity_infoScalarWhereInput | capsule_game_capacity_infoScalarWhereInput[]
  }

  export type capacity_infoCreateNestedOneWithoutCapacityInfoInfluencesInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityInfoInfluencesInput, capacity_infoUncheckedCreateWithoutCapacityInfoInfluencesInput>
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityInfoInfluencesInput
    connect?: capacity_infoWhereUniqueInput
  }

  export type influenceCreateNestedOneWithoutCapacityInfoInfluencesInput = {
    create?: XOR<influenceCreateWithoutCapacityInfoInfluencesInput, influenceUncheckedCreateWithoutCapacityInfoInfluencesInput>
    connectOrCreate?: influenceCreateOrConnectWithoutCapacityInfoInfluencesInput
    connect?: influenceWhereUniqueInput
  }

  export type capacity_infoUpdateOneRequiredWithoutCapacityInfoInfluencesNestedInput = {
    create?: XOR<capacity_infoCreateWithoutCapacityInfoInfluencesInput, capacity_infoUncheckedCreateWithoutCapacityInfoInfluencesInput>
    connectOrCreate?: capacity_infoCreateOrConnectWithoutCapacityInfoInfluencesInput
    upsert?: capacity_infoUpsertWithoutCapacityInfoInfluencesInput
    connect?: capacity_infoWhereUniqueInput
    update?: XOR<XOR<capacity_infoUpdateToOneWithWhereWithoutCapacityInfoInfluencesInput, capacity_infoUpdateWithoutCapacityInfoInfluencesInput>, capacity_infoUncheckedUpdateWithoutCapacityInfoInfluencesInput>
  }

  export type influenceUpdateOneRequiredWithoutCapacityInfoInfluencesNestedInput = {
    create?: XOR<influenceCreateWithoutCapacityInfoInfluencesInput, influenceUncheckedCreateWithoutCapacityInfoInfluencesInput>
    connectOrCreate?: influenceCreateOrConnectWithoutCapacityInfoInfluencesInput
    upsert?: influenceUpsertWithoutCapacityInfoInfluencesInput
    connect?: influenceWhereUniqueInput
    update?: XOR<XOR<influenceUpdateToOneWithWhereWithoutCapacityInfoInfluencesInput, influenceUpdateWithoutCapacityInfoInfluencesInput>, influenceUncheckedUpdateWithoutCapacityInfoInfluencesInput>
  }

  export type gameCreateNestedOneWithoutPokemonRatingGamesInput = {
    create?: XOR<gameCreateWithoutPokemonRatingGamesInput, gameUncheckedCreateWithoutPokemonRatingGamesInput>
    connectOrCreate?: gameCreateOrConnectWithoutPokemonRatingGamesInput
    connect?: gameWhereUniqueInput
  }

  export type location_zoneCreateNestedOneWithoutPokemonRatingGamesInput = {
    create?: XOR<location_zoneCreateWithoutPokemonRatingGamesInput, location_zoneUncheckedCreateWithoutPokemonRatingGamesInput>
    connectOrCreate?: location_zoneCreateOrConnectWithoutPokemonRatingGamesInput
    connect?: location_zoneWhereUniqueInput
  }

  export type pokemon_formCreateNestedOneWithoutPokemonRatingGamesInput = {
    create?: XOR<pokemon_formCreateWithoutPokemonRatingGamesInput, pokemon_formUncheckedCreateWithoutPokemonRatingGamesInput>
    connectOrCreate?: pokemon_formCreateOrConnectWithoutPokemonRatingGamesInput
    connect?: pokemon_formWhereUniqueInput
  }

  export type pokemon_obtationCreateNestedOneWithoutPokemonRatingGamesInput = {
    create?: XOR<pokemon_obtationCreateWithoutPokemonRatingGamesInput, pokemon_obtationUncheckedCreateWithoutPokemonRatingGamesInput>
    connectOrCreate?: pokemon_obtationCreateOrConnectWithoutPokemonRatingGamesInput
    connect?: pokemon_obtationWhereUniqueInput
  }

  export type rateCreateNestedOneWithoutPokemonRatingGamesInput = {
    create?: XOR<rateCreateWithoutPokemonRatingGamesInput, rateUncheckedCreateWithoutPokemonRatingGamesInput>
    connectOrCreate?: rateCreateOrConnectWithoutPokemonRatingGamesInput
    connect?: rateWhereUniqueInput
  }

  export type gameUpdateOneRequiredWithoutPokemonRatingGamesNestedInput = {
    create?: XOR<gameCreateWithoutPokemonRatingGamesInput, gameUncheckedCreateWithoutPokemonRatingGamesInput>
    connectOrCreate?: gameCreateOrConnectWithoutPokemonRatingGamesInput
    upsert?: gameUpsertWithoutPokemonRatingGamesInput
    connect?: gameWhereUniqueInput
    update?: XOR<XOR<gameUpdateToOneWithWhereWithoutPokemonRatingGamesInput, gameUpdateWithoutPokemonRatingGamesInput>, gameUncheckedUpdateWithoutPokemonRatingGamesInput>
  }

  export type location_zoneUpdateOneRequiredWithoutPokemonRatingGamesNestedInput = {
    create?: XOR<location_zoneCreateWithoutPokemonRatingGamesInput, location_zoneUncheckedCreateWithoutPokemonRatingGamesInput>
    connectOrCreate?: location_zoneCreateOrConnectWithoutPokemonRatingGamesInput
    upsert?: location_zoneUpsertWithoutPokemonRatingGamesInput
    connect?: location_zoneWhereUniqueInput
    update?: XOR<XOR<location_zoneUpdateToOneWithWhereWithoutPokemonRatingGamesInput, location_zoneUpdateWithoutPokemonRatingGamesInput>, location_zoneUncheckedUpdateWithoutPokemonRatingGamesInput>
  }

  export type pokemon_formUpdateOneRequiredWithoutPokemonRatingGamesNestedInput = {
    create?: XOR<pokemon_formCreateWithoutPokemonRatingGamesInput, pokemon_formUncheckedCreateWithoutPokemonRatingGamesInput>
    connectOrCreate?: pokemon_formCreateOrConnectWithoutPokemonRatingGamesInput
    upsert?: pokemon_formUpsertWithoutPokemonRatingGamesInput
    connect?: pokemon_formWhereUniqueInput
    update?: XOR<XOR<pokemon_formUpdateToOneWithWhereWithoutPokemonRatingGamesInput, pokemon_formUpdateWithoutPokemonRatingGamesInput>, pokemon_formUncheckedUpdateWithoutPokemonRatingGamesInput>
  }

  export type pokemon_obtationUpdateOneRequiredWithoutPokemonRatingGamesNestedInput = {
    create?: XOR<pokemon_obtationCreateWithoutPokemonRatingGamesInput, pokemon_obtationUncheckedCreateWithoutPokemonRatingGamesInput>
    connectOrCreate?: pokemon_obtationCreateOrConnectWithoutPokemonRatingGamesInput
    upsert?: pokemon_obtationUpsertWithoutPokemonRatingGamesInput
    connect?: pokemon_obtationWhereUniqueInput
    update?: XOR<XOR<pokemon_obtationUpdateToOneWithWhereWithoutPokemonRatingGamesInput, pokemon_obtationUpdateWithoutPokemonRatingGamesInput>, pokemon_obtationUncheckedUpdateWithoutPokemonRatingGamesInput>
  }

  export type rateUpdateOneRequiredWithoutPokemonRatingGamesNestedInput = {
    create?: XOR<rateCreateWithoutPokemonRatingGamesInput, rateUncheckedCreateWithoutPokemonRatingGamesInput>
    connectOrCreate?: rateCreateOrConnectWithoutPokemonRatingGamesInput
    upsert?: rateUpsertWithoutPokemonRatingGamesInput
    connect?: rateWhereUniqueInput
    update?: XOR<XOR<rateUpdateToOneWithWhereWithoutPokemonRatingGamesInput, rateUpdateWithoutPokemonRatingGamesInput>, rateUncheckedUpdateWithoutPokemonRatingGamesInput>
  }

  export type capacityCreateNestedOneWithoutSkillObtationsInput = {
    create?: XOR<capacityCreateWithoutSkillObtationsInput, capacityUncheckedCreateWithoutSkillObtationsInput>
    connectOrCreate?: capacityCreateOrConnectWithoutSkillObtationsInput
    connect?: capacityWhereUniqueInput
  }

  export type group_gameCreateNestedOneWithoutSkillObtationsInput = {
    create?: XOR<group_gameCreateWithoutSkillObtationsInput, group_gameUncheckedCreateWithoutSkillObtationsInput>
    connectOrCreate?: group_gameCreateOrConnectWithoutSkillObtationsInput
    connect?: group_gameWhereUniqueInput
  }

  export type pokemonCreateNestedOneWithoutSkillObtationsInput = {
    create?: XOR<pokemonCreateWithoutSkillObtationsInput, pokemonUncheckedCreateWithoutSkillObtationsInput>
    connectOrCreate?: pokemonCreateOrConnectWithoutSkillObtationsInput
    connect?: pokemonWhereUniqueInput
  }

  export type skill_obtation_typeCreateNestedOneWithoutSkillObtationsInput = {
    create?: XOR<skill_obtation_typeCreateWithoutSkillObtationsInput, skill_obtation_typeUncheckedCreateWithoutSkillObtationsInput>
    connectOrCreate?: skill_obtation_typeCreateOrConnectWithoutSkillObtationsInput
    connect?: skill_obtation_typeWhereUniqueInput
  }

  export type capacityUpdateOneRequiredWithoutSkillObtationsNestedInput = {
    create?: XOR<capacityCreateWithoutSkillObtationsInput, capacityUncheckedCreateWithoutSkillObtationsInput>
    connectOrCreate?: capacityCreateOrConnectWithoutSkillObtationsInput
    upsert?: capacityUpsertWithoutSkillObtationsInput
    connect?: capacityWhereUniqueInput
    update?: XOR<XOR<capacityUpdateToOneWithWhereWithoutSkillObtationsInput, capacityUpdateWithoutSkillObtationsInput>, capacityUncheckedUpdateWithoutSkillObtationsInput>
  }

  export type group_gameUpdateOneRequiredWithoutSkillObtationsNestedInput = {
    create?: XOR<group_gameCreateWithoutSkillObtationsInput, group_gameUncheckedCreateWithoutSkillObtationsInput>
    connectOrCreate?: group_gameCreateOrConnectWithoutSkillObtationsInput
    upsert?: group_gameUpsertWithoutSkillObtationsInput
    connect?: group_gameWhereUniqueInput
    update?: XOR<XOR<group_gameUpdateToOneWithWhereWithoutSkillObtationsInput, group_gameUpdateWithoutSkillObtationsInput>, group_gameUncheckedUpdateWithoutSkillObtationsInput>
  }

  export type pokemonUpdateOneRequiredWithoutSkillObtationsNestedInput = {
    create?: XOR<pokemonCreateWithoutSkillObtationsInput, pokemonUncheckedCreateWithoutSkillObtationsInput>
    connectOrCreate?: pokemonCreateOrConnectWithoutSkillObtationsInput
    upsert?: pokemonUpsertWithoutSkillObtationsInput
    connect?: pokemonWhereUniqueInput
    update?: XOR<XOR<pokemonUpdateToOneWithWhereWithoutSkillObtationsInput, pokemonUpdateWithoutSkillObtationsInput>, pokemonUncheckedUpdateWithoutSkillObtationsInput>
  }

  export type skill_obtation_typeUpdateOneRequiredWithoutSkillObtationsNestedInput = {
    create?: XOR<skill_obtation_typeCreateWithoutSkillObtationsInput, skill_obtation_typeUncheckedCreateWithoutSkillObtationsInput>
    connectOrCreate?: skill_obtation_typeCreateOrConnectWithoutSkillObtationsInput
    upsert?: skill_obtation_typeUpsertWithoutSkillObtationsInput
    connect?: skill_obtation_typeWhereUniqueInput
    update?: XOR<XOR<skill_obtation_typeUpdateToOneWithWhereWithoutSkillObtationsInput, skill_obtation_typeUpdateWithoutSkillObtationsInput>, skill_obtation_typeUncheckedUpdateWithoutSkillObtationsInput>
  }

  export type userCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<userCreateWithoutRefreshTokensInput, userUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: userCreateOrConnectWithoutRefreshTokensInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<userCreateWithoutRefreshTokensInput, userUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: userCreateOrConnectWithoutRefreshTokensInput
    upsert?: userUpsertWithoutRefreshTokensInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRefreshTokensInput, userUpdateWithoutRefreshTokensInput>, userUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumreference_tableFilter<$PrismaModel = never> = {
    equals?: $Enums.reference_table | Enumreference_tableFieldRefInput<$PrismaModel>
    in?: $Enums.reference_table[]
    notIn?: $Enums.reference_table[]
    not?: NestedEnumreference_tableFilter<$PrismaModel> | $Enums.reference_table
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumreference_tableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.reference_table | Enumreference_tableFieldRefInput<$PrismaModel>
    in?: $Enums.reference_table[]
    notIn?: $Enums.reference_table[]
    not?: NestedEnumreference_tableWithAggregatesFilter<$PrismaModel> | $Enums.reference_table
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreference_tableFilter<$PrismaModel>
    _max?: NestedEnumreference_tableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedEnumroleFilter<$PrismaModel = never> = {
    equals?: $Enums.role | EnumroleFieldRefInput<$PrismaModel>
    in?: $Enums.role[]
    notIn?: $Enums.role[]
    not?: NestedEnumroleFilter<$PrismaModel> | $Enums.role
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumroleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.role | EnumroleFieldRefInput<$PrismaModel>
    in?: $Enums.role[]
    notIn?: $Enums.role[]
    not?: NestedEnumroleWithAggregatesFilter<$PrismaModel> | $Enums.role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroleFilter<$PrismaModel>
    _max?: NestedEnumroleFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type translationCreateWithoutLangueInput = {
    referenceId: bigint | number
    referenceTable: $Enums.reference_table
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type translationUncheckedCreateWithoutLangueInput = {
    referenceId: bigint | number
    referenceTable: $Enums.reference_table
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type translationCreateOrConnectWithoutLangueInput = {
    where: translationWhereUniqueInput
    create: XOR<translationCreateWithoutLangueInput, translationUncheckedCreateWithoutLangueInput>
  }

  export type translationCreateManyLangueInputEnvelope = {
    data: translationCreateManyLangueInput | translationCreateManyLangueInput[]
    skipDuplicates?: boolean
  }

  export type translationUpsertWithWhereUniqueWithoutLangueInput = {
    where: translationWhereUniqueInput
    update: XOR<translationUpdateWithoutLangueInput, translationUncheckedUpdateWithoutLangueInput>
    create: XOR<translationCreateWithoutLangueInput, translationUncheckedCreateWithoutLangueInput>
  }

  export type translationUpdateWithWhereUniqueWithoutLangueInput = {
    where: translationWhereUniqueInput
    data: XOR<translationUpdateWithoutLangueInput, translationUncheckedUpdateWithoutLangueInput>
  }

  export type translationUpdateManyWithWhereWithoutLangueInput = {
    where: translationScalarWhereInput
    data: XOR<translationUpdateManyMutationInput, translationUncheckedUpdateManyWithoutLangueInput>
  }

  export type translationScalarWhereInput = {
    AND?: translationScalarWhereInput | translationScalarWhereInput[]
    OR?: translationScalarWhereInput[]
    NOT?: translationScalarWhereInput | translationScalarWhereInput[]
    langueId?: IntFilter<"translation"> | number
    referenceId?: BigIntFilter<"translation"> | bigint | number
    referenceTable?: Enumreference_tableFilter<"translation"> | $Enums.reference_table
    name?: StringFilter<"translation"> | string
    createdAt?: DateTimeFilter<"translation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"translation"> | Date | string | null
    status?: StringFilter<"translation"> | string
  }

  export type langueCreateWithoutTranslationsInput = {
    name: string
    isoCode: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type langueUncheckedCreateWithoutTranslationsInput = {
    id?: number
    name: string
    isoCode: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type langueCreateOrConnectWithoutTranslationsInput = {
    where: langueWhereUniqueInput
    create: XOR<langueCreateWithoutTranslationsInput, langueUncheckedCreateWithoutTranslationsInput>
  }

  export type langueUpsertWithoutTranslationsInput = {
    update: XOR<langueUpdateWithoutTranslationsInput, langueUncheckedUpdateWithoutTranslationsInput>
    create: XOR<langueCreateWithoutTranslationsInput, langueUncheckedCreateWithoutTranslationsInput>
    where?: langueWhereInput
  }

  export type langueUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: langueWhereInput
    data: XOR<langueUpdateWithoutTranslationsInput, langueUncheckedUpdateWithoutTranslationsInput>
  }

  export type langueUpdateWithoutTranslationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    isoCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type langueUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isoCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type owned_pokemonCreateWithoutUsersInput = {
    id?: bigint | number
    isShiny: boolean
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    game: gameCreateNestedOneWithoutOwnedPokemonsInput
    shinyHuntingMethod: shiny_hunting_methodCreateNestedOneWithoutOwnedPokemonsInput
    pokemonForms: pokemon_formCreateNestedOneWithoutOwnedPokemonsInput
    ownedPokemonDetails?: owned_pokemon_detailCreateNestedManyWithoutOwnedPokemonInput
  }

  export type owned_pokemonUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    pokemonFormId: number
    gameId: number
    isShiny: boolean
    methodId: number
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemonDetails?: owned_pokemon_detailUncheckedCreateNestedManyWithoutOwnedPokemonInput
  }

  export type owned_pokemonCreateOrConnectWithoutUsersInput = {
    where: owned_pokemonWhereUniqueInput
    create: XOR<owned_pokemonCreateWithoutUsersInput, owned_pokemonUncheckedCreateWithoutUsersInput>
  }

  export type owned_pokemonCreateManyUsersInputEnvelope = {
    data: owned_pokemonCreateManyUsersInput | owned_pokemonCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type refresh_tokenCreateWithoutUsersInput = {
    token: string
    expiresAt: Date | string
  }

  export type refresh_tokenUncheckedCreateWithoutUsersInput = {
    id?: number
    token: string
    expiresAt: Date | string
  }

  export type refresh_tokenCreateOrConnectWithoutUsersInput = {
    where: refresh_tokenWhereUniqueInput
    create: XOR<refresh_tokenCreateWithoutUsersInput, refresh_tokenUncheckedCreateWithoutUsersInput>
  }

  export type refresh_tokenCreateManyUsersInputEnvelope = {
    data: refresh_tokenCreateManyUsersInput | refresh_tokenCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type owned_pokemonUpsertWithWhereUniqueWithoutUsersInput = {
    where: owned_pokemonWhereUniqueInput
    update: XOR<owned_pokemonUpdateWithoutUsersInput, owned_pokemonUncheckedUpdateWithoutUsersInput>
    create: XOR<owned_pokemonCreateWithoutUsersInput, owned_pokemonUncheckedCreateWithoutUsersInput>
  }

  export type owned_pokemonUpdateWithWhereUniqueWithoutUsersInput = {
    where: owned_pokemonWhereUniqueInput
    data: XOR<owned_pokemonUpdateWithoutUsersInput, owned_pokemonUncheckedUpdateWithoutUsersInput>
  }

  export type owned_pokemonUpdateManyWithWhereWithoutUsersInput = {
    where: owned_pokemonScalarWhereInput
    data: XOR<owned_pokemonUpdateManyMutationInput, owned_pokemonUncheckedUpdateManyWithoutUsersInput>
  }

  export type owned_pokemonScalarWhereInput = {
    AND?: owned_pokemonScalarWhereInput | owned_pokemonScalarWhereInput[]
    OR?: owned_pokemonScalarWhereInput[]
    NOT?: owned_pokemonScalarWhereInput | owned_pokemonScalarWhereInput[]
    id?: BigIntFilter<"owned_pokemon"> | bigint | number
    userId?: IntFilter<"owned_pokemon"> | number
    pokemonFormId?: IntFilter<"owned_pokemon"> | number
    gameId?: IntFilter<"owned_pokemon"> | number
    isShiny?: BoolFilter<"owned_pokemon"> | boolean
    methodId?: IntFilter<"owned_pokemon"> | number
    meetingNumber?: IntNullableFilter<"owned_pokemon"> | number | null
    time?: DateTimeNullableFilter<"owned_pokemon"> | Date | string | null
    isFinish?: BoolFilter<"owned_pokemon"> | boolean
    useCharmChroma?: BoolFilter<"owned_pokemon"> | boolean
    creationDate?: DateTimeFilter<"owned_pokemon"> | Date | string
    finishDate?: DateTimeNullableFilter<"owned_pokemon"> | Date | string | null
    createdAt?: DateTimeFilter<"owned_pokemon"> | Date | string
    updatedAt?: DateTimeNullableFilter<"owned_pokemon"> | Date | string | null
    status?: StringFilter<"owned_pokemon"> | string
  }

  export type refresh_tokenUpsertWithWhereUniqueWithoutUsersInput = {
    where: refresh_tokenWhereUniqueInput
    update: XOR<refresh_tokenUpdateWithoutUsersInput, refresh_tokenUncheckedUpdateWithoutUsersInput>
    create: XOR<refresh_tokenCreateWithoutUsersInput, refresh_tokenUncheckedCreateWithoutUsersInput>
  }

  export type refresh_tokenUpdateWithWhereUniqueWithoutUsersInput = {
    where: refresh_tokenWhereUniqueInput
    data: XOR<refresh_tokenUpdateWithoutUsersInput, refresh_tokenUncheckedUpdateWithoutUsersInput>
  }

  export type refresh_tokenUpdateManyWithWhereWithoutUsersInput = {
    where: refresh_tokenScalarWhereInput
    data: XOR<refresh_tokenUpdateManyMutationInput, refresh_tokenUncheckedUpdateManyWithoutUsersInput>
  }

  export type refresh_tokenScalarWhereInput = {
    AND?: refresh_tokenScalarWhereInput | refresh_tokenScalarWhereInput[]
    OR?: refresh_tokenScalarWhereInput[]
    NOT?: refresh_tokenScalarWhereInput | refresh_tokenScalarWhereInput[]
    id?: IntFilter<"refresh_token"> | number
    userId?: IntFilter<"refresh_token"> | number
    token?: StringFilter<"refresh_token"> | string
    expiresAt?: DateTimeFilter<"refresh_token"> | Date | string
  }

  export type owned_pokemonCreateWithoutShinyHuntingMethodInput = {
    id?: bigint | number
    isShiny: boolean
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    game: gameCreateNestedOneWithoutOwnedPokemonsInput
    pokemonForms: pokemon_formCreateNestedOneWithoutOwnedPokemonsInput
    users: userCreateNestedOneWithoutOwnedPokemonsInput
    ownedPokemonDetails?: owned_pokemon_detailCreateNestedManyWithoutOwnedPokemonInput
  }

  export type owned_pokemonUncheckedCreateWithoutShinyHuntingMethodInput = {
    id?: bigint | number
    userId: number
    pokemonFormId: number
    gameId: number
    isShiny: boolean
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemonDetails?: owned_pokemon_detailUncheckedCreateNestedManyWithoutOwnedPokemonInput
  }

  export type owned_pokemonCreateOrConnectWithoutShinyHuntingMethodInput = {
    where: owned_pokemonWhereUniqueInput
    create: XOR<owned_pokemonCreateWithoutShinyHuntingMethodInput, owned_pokemonUncheckedCreateWithoutShinyHuntingMethodInput>
  }

  export type owned_pokemonCreateManyShinyHuntingMethodInputEnvelope = {
    data: owned_pokemonCreateManyShinyHuntingMethodInput | owned_pokemonCreateManyShinyHuntingMethodInput[]
    skipDuplicates?: boolean
  }

  export type shiny_hunting_method_gameCreateWithoutShinyHuntingMethodInput = {
    groupGame: group_gameCreateNestedOneWithoutShinyHuntingMethodGamesInput
  }

  export type shiny_hunting_method_gameUncheckedCreateWithoutShinyHuntingMethodInput = {
    groupGameId: number
  }

  export type shiny_hunting_method_gameCreateOrConnectWithoutShinyHuntingMethodInput = {
    where: shiny_hunting_method_gameWhereUniqueInput
    create: XOR<shiny_hunting_method_gameCreateWithoutShinyHuntingMethodInput, shiny_hunting_method_gameUncheckedCreateWithoutShinyHuntingMethodInput>
  }

  export type shiny_hunting_method_gameCreateManyShinyHuntingMethodInputEnvelope = {
    data: shiny_hunting_method_gameCreateManyShinyHuntingMethodInput | shiny_hunting_method_gameCreateManyShinyHuntingMethodInput[]
    skipDuplicates?: boolean
  }

  export type shiny_hunting_method_rateCreateWithoutShinyHuntingMethodInput = {
    rate: rateCreateNestedOneWithoutShinyHuntingMethodRatesInput
  }

  export type shiny_hunting_method_rateUncheckedCreateWithoutShinyHuntingMethodInput = {
    rateId: number
  }

  export type shiny_hunting_method_rateCreateOrConnectWithoutShinyHuntingMethodInput = {
    where: shiny_hunting_method_rateWhereUniqueInput
    create: XOR<shiny_hunting_method_rateCreateWithoutShinyHuntingMethodInput, shiny_hunting_method_rateUncheckedCreateWithoutShinyHuntingMethodInput>
  }

  export type shiny_hunting_method_rateCreateManyShinyHuntingMethodInputEnvelope = {
    data: shiny_hunting_method_rateCreateManyShinyHuntingMethodInput | shiny_hunting_method_rateCreateManyShinyHuntingMethodInput[]
    skipDuplicates?: boolean
  }

  export type owned_pokemonUpsertWithWhereUniqueWithoutShinyHuntingMethodInput = {
    where: owned_pokemonWhereUniqueInput
    update: XOR<owned_pokemonUpdateWithoutShinyHuntingMethodInput, owned_pokemonUncheckedUpdateWithoutShinyHuntingMethodInput>
    create: XOR<owned_pokemonCreateWithoutShinyHuntingMethodInput, owned_pokemonUncheckedCreateWithoutShinyHuntingMethodInput>
  }

  export type owned_pokemonUpdateWithWhereUniqueWithoutShinyHuntingMethodInput = {
    where: owned_pokemonWhereUniqueInput
    data: XOR<owned_pokemonUpdateWithoutShinyHuntingMethodInput, owned_pokemonUncheckedUpdateWithoutShinyHuntingMethodInput>
  }

  export type owned_pokemonUpdateManyWithWhereWithoutShinyHuntingMethodInput = {
    where: owned_pokemonScalarWhereInput
    data: XOR<owned_pokemonUpdateManyMutationInput, owned_pokemonUncheckedUpdateManyWithoutShinyHuntingMethodInput>
  }

  export type shiny_hunting_method_gameUpsertWithWhereUniqueWithoutShinyHuntingMethodInput = {
    where: shiny_hunting_method_gameWhereUniqueInput
    update: XOR<shiny_hunting_method_gameUpdateWithoutShinyHuntingMethodInput, shiny_hunting_method_gameUncheckedUpdateWithoutShinyHuntingMethodInput>
    create: XOR<shiny_hunting_method_gameCreateWithoutShinyHuntingMethodInput, shiny_hunting_method_gameUncheckedCreateWithoutShinyHuntingMethodInput>
  }

  export type shiny_hunting_method_gameUpdateWithWhereUniqueWithoutShinyHuntingMethodInput = {
    where: shiny_hunting_method_gameWhereUniqueInput
    data: XOR<shiny_hunting_method_gameUpdateWithoutShinyHuntingMethodInput, shiny_hunting_method_gameUncheckedUpdateWithoutShinyHuntingMethodInput>
  }

  export type shiny_hunting_method_gameUpdateManyWithWhereWithoutShinyHuntingMethodInput = {
    where: shiny_hunting_method_gameScalarWhereInput
    data: XOR<shiny_hunting_method_gameUpdateManyMutationInput, shiny_hunting_method_gameUncheckedUpdateManyWithoutShinyHuntingMethodInput>
  }

  export type shiny_hunting_method_gameScalarWhereInput = {
    AND?: shiny_hunting_method_gameScalarWhereInput | shiny_hunting_method_gameScalarWhereInput[]
    OR?: shiny_hunting_method_gameScalarWhereInput[]
    NOT?: shiny_hunting_method_gameScalarWhereInput | shiny_hunting_method_gameScalarWhereInput[]
    shinyHuntingMethodId?: IntFilter<"shiny_hunting_method_game"> | number
    groupGameId?: IntFilter<"shiny_hunting_method_game"> | number
  }

  export type shiny_hunting_method_rateUpsertWithWhereUniqueWithoutShinyHuntingMethodInput = {
    where: shiny_hunting_method_rateWhereUniqueInput
    update: XOR<shiny_hunting_method_rateUpdateWithoutShinyHuntingMethodInput, shiny_hunting_method_rateUncheckedUpdateWithoutShinyHuntingMethodInput>
    create: XOR<shiny_hunting_method_rateCreateWithoutShinyHuntingMethodInput, shiny_hunting_method_rateUncheckedCreateWithoutShinyHuntingMethodInput>
  }

  export type shiny_hunting_method_rateUpdateWithWhereUniqueWithoutShinyHuntingMethodInput = {
    where: shiny_hunting_method_rateWhereUniqueInput
    data: XOR<shiny_hunting_method_rateUpdateWithoutShinyHuntingMethodInput, shiny_hunting_method_rateUncheckedUpdateWithoutShinyHuntingMethodInput>
  }

  export type shiny_hunting_method_rateUpdateManyWithWhereWithoutShinyHuntingMethodInput = {
    where: shiny_hunting_method_rateScalarWhereInput
    data: XOR<shiny_hunting_method_rateUpdateManyMutationInput, shiny_hunting_method_rateUncheckedUpdateManyWithoutShinyHuntingMethodInput>
  }

  export type shiny_hunting_method_rateScalarWhereInput = {
    AND?: shiny_hunting_method_rateScalarWhereInput | shiny_hunting_method_rateScalarWhereInput[]
    OR?: shiny_hunting_method_rateScalarWhereInput[]
    NOT?: shiny_hunting_method_rateScalarWhereInput | shiny_hunting_method_rateScalarWhereInput[]
    shinyHuntingMethodId?: IntFilter<"shiny_hunting_method_rate"> | number
    rateId?: IntFilter<"shiny_hunting_method_rate"> | number
  }

  export type owned_pokemon_detailCreateWithoutPokeballInput = {
    id?: bigint | number
    nickname: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemon: owned_pokemonCreateNestedOneWithoutOwnedPokemonDetailsInput
  }

  export type owned_pokemon_detailUncheckedCreateWithoutPokeballInput = {
    id?: bigint | number
    nickname: string
    ownedPokemonId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type owned_pokemon_detailCreateOrConnectWithoutPokeballInput = {
    where: owned_pokemon_detailWhereUniqueInput
    create: XOR<owned_pokemon_detailCreateWithoutPokeballInput, owned_pokemon_detailUncheckedCreateWithoutPokeballInput>
  }

  export type owned_pokemon_detailCreateManyPokeballInputEnvelope = {
    data: owned_pokemon_detailCreateManyPokeballInput | owned_pokemon_detailCreateManyPokeballInput[]
    skipDuplicates?: boolean
  }

  export type owned_pokemon_detailUpsertWithWhereUniqueWithoutPokeballInput = {
    where: owned_pokemon_detailWhereUniqueInput
    update: XOR<owned_pokemon_detailUpdateWithoutPokeballInput, owned_pokemon_detailUncheckedUpdateWithoutPokeballInput>
    create: XOR<owned_pokemon_detailCreateWithoutPokeballInput, owned_pokemon_detailUncheckedCreateWithoutPokeballInput>
  }

  export type owned_pokemon_detailUpdateWithWhereUniqueWithoutPokeballInput = {
    where: owned_pokemon_detailWhereUniqueInput
    data: XOR<owned_pokemon_detailUpdateWithoutPokeballInput, owned_pokemon_detailUncheckedUpdateWithoutPokeballInput>
  }

  export type owned_pokemon_detailUpdateManyWithWhereWithoutPokeballInput = {
    where: owned_pokemon_detailScalarWhereInput
    data: XOR<owned_pokemon_detailUpdateManyMutationInput, owned_pokemon_detailUncheckedUpdateManyWithoutPokeballInput>
  }

  export type owned_pokemon_detailScalarWhereInput = {
    AND?: owned_pokemon_detailScalarWhereInput | owned_pokemon_detailScalarWhereInput[]
    OR?: owned_pokemon_detailScalarWhereInput[]
    NOT?: owned_pokemon_detailScalarWhereInput | owned_pokemon_detailScalarWhereInput[]
    id?: BigIntFilter<"owned_pokemon_detail"> | bigint | number
    nickname?: StringFilter<"owned_pokemon_detail"> | string
    pokeballId?: IntFilter<"owned_pokemon_detail"> | number
    ownedPokemonId?: BigIntFilter<"owned_pokemon_detail"> | bigint | number
    createdAt?: DateTimeFilter<"owned_pokemon_detail"> | Date | string
    updatedAt?: DateTimeNullableFilter<"owned_pokemon_detail"> | Date | string | null
    status?: StringFilter<"owned_pokemon_detail"> | string
  }

  export type abilityCreateWithoutGenerationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityInfos?: ability_infoCreateNestedManyWithoutAbilitiesInput
    abilityOrders?: ability_orderCreateNestedManyWithoutAbilityInput
  }

  export type abilityUncheckedCreateWithoutGenerationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityInfos?: ability_infoUncheckedCreateNestedManyWithoutAbilitiesInput
    abilityOrders?: ability_orderUncheckedCreateNestedManyWithoutAbilityInput
  }

  export type abilityCreateOrConnectWithoutGenerationInput = {
    where: abilityWhereUniqueInput
    create: XOR<abilityCreateWithoutGenerationInput, abilityUncheckedCreateWithoutGenerationInput>
  }

  export type abilityCreateManyGenerationInputEnvelope = {
    data: abilityCreateManyGenerationInput | abilityCreateManyGenerationInput[]
    skipDuplicates?: boolean
  }

  export type ability_infoCreateWithoutGenerationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilities: abilityCreateNestedOneWithoutAbilityInfosInput
    effectWithoutFight: effect_outside_fightCreateNestedOneWithoutAbilityInfosInput
  }

  export type ability_infoUncheckedCreateWithoutGenerationInput = {
    id?: number
    abilityId: number
    effectOutsideFightId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type ability_infoCreateOrConnectWithoutGenerationInput = {
    where: ability_infoWhereUniqueInput
    create: XOR<ability_infoCreateWithoutGenerationInput, ability_infoUncheckedCreateWithoutGenerationInput>
  }

  export type ability_infoCreateManyGenerationInputEnvelope = {
    data: ability_infoCreateManyGenerationInput | ability_infoCreateManyGenerationInput[]
    skipDuplicates?: boolean
  }

  export type gameCreateWithoutGenerationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    gameGroupGames?: game_group_gameCreateNestedManyWithoutGameInput
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutGameInput
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutGameInput
  }

  export type gameUncheckedCreateWithoutGenerationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    gameGroupGames?: game_group_gameUncheckedCreateNestedManyWithoutGameInput
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutGameInput
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutGameInput
  }

  export type gameCreateOrConnectWithoutGenerationInput = {
    where: gameWhereUniqueInput
    create: XOR<gameCreateWithoutGenerationInput, gameUncheckedCreateWithoutGenerationInput>
  }

  export type gameCreateManyGenerationInputEnvelope = {
    data: gameCreateManyGenerationInput | gameCreateManyGenerationInput[]
    skipDuplicates?: boolean
  }

  export type pokemonCreateWithoutGenerationInput = {
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    nationalNumbers?: national_numberCreateNestedManyWithoutPokemonInput
    pokemon_category: pokemon_categoryCreateNestedOneWithoutPokemonsInput
    pokemonForms?: pokemon_formCreateNestedManyWithoutPokemonInput
    pokemonInfos?: pokemon_infoCreateNestedManyWithoutPokemonInput
    skillObtations?: skill_obtationCreateNestedManyWithoutPokemonInput
    statisticGroupGames?: statistic_group_gameCreateNestedManyWithoutPokemonInput
  }

  export type pokemonUncheckedCreateWithoutGenerationInput = {
    id?: number
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    pokemonCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    nationalNumbers?: national_numberUncheckedCreateNestedManyWithoutPokemonInput
    pokemonForms?: pokemon_formUncheckedCreateNestedManyWithoutPokemonInput
    pokemonInfos?: pokemon_infoUncheckedCreateNestedManyWithoutPokemonInput
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutPokemonInput
    statisticGroupGames?: statistic_group_gameUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type pokemonCreateOrConnectWithoutGenerationInput = {
    where: pokemonWhereUniqueInput
    create: XOR<pokemonCreateWithoutGenerationInput, pokemonUncheckedCreateWithoutGenerationInput>
  }

  export type pokemonCreateManyGenerationInputEnvelope = {
    data: pokemonCreateManyGenerationInput | pokemonCreateManyGenerationInput[]
    skipDuplicates?: boolean
  }

  export type pokemon_infoCreateWithoutGenerationInput = {
    xpGift: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityOrders?: ability_orderCreateNestedManyWithoutPokemonInfoInput
    eggGroupOrders?: egg_group_orderCreateNestedManyWithoutPokemonInfoInput
    pokemon: pokemonCreateNestedOneWithoutPokemonInfosInput
    typeOrders?: type_orderCreateNestedManyWithoutPokemonInfoInput
  }

  export type pokemon_infoUncheckedCreateWithoutGenerationInput = {
    id?: number
    xpGift: number
    pokemonId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityOrders?: ability_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
    eggGroupOrders?: egg_group_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
    typeOrders?: type_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
  }

  export type pokemon_infoCreateOrConnectWithoutGenerationInput = {
    where: pokemon_infoWhereUniqueInput
    create: XOR<pokemon_infoCreateWithoutGenerationInput, pokemon_infoUncheckedCreateWithoutGenerationInput>
  }

  export type pokemon_infoCreateManyGenerationInputEnvelope = {
    data: pokemon_infoCreateManyGenerationInput | pokemon_infoCreateManyGenerationInput[]
    skipDuplicates?: boolean
  }

  export type abilityUpsertWithWhereUniqueWithoutGenerationInput = {
    where: abilityWhereUniqueInput
    update: XOR<abilityUpdateWithoutGenerationInput, abilityUncheckedUpdateWithoutGenerationInput>
    create: XOR<abilityCreateWithoutGenerationInput, abilityUncheckedCreateWithoutGenerationInput>
  }

  export type abilityUpdateWithWhereUniqueWithoutGenerationInput = {
    where: abilityWhereUniqueInput
    data: XOR<abilityUpdateWithoutGenerationInput, abilityUncheckedUpdateWithoutGenerationInput>
  }

  export type abilityUpdateManyWithWhereWithoutGenerationInput = {
    where: abilityScalarWhereInput
    data: XOR<abilityUpdateManyMutationInput, abilityUncheckedUpdateManyWithoutGenerationInput>
  }

  export type abilityScalarWhereInput = {
    AND?: abilityScalarWhereInput | abilityScalarWhereInput[]
    OR?: abilityScalarWhereInput[]
    NOT?: abilityScalarWhereInput | abilityScalarWhereInput[]
    id?: IntFilter<"ability"> | number
    appearanceGenerationId?: IntFilter<"ability"> | number
    createdAt?: DateTimeFilter<"ability"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ability"> | Date | string | null
    status?: StringFilter<"ability"> | string
  }

  export type ability_infoUpsertWithWhereUniqueWithoutGenerationInput = {
    where: ability_infoWhereUniqueInput
    update: XOR<ability_infoUpdateWithoutGenerationInput, ability_infoUncheckedUpdateWithoutGenerationInput>
    create: XOR<ability_infoCreateWithoutGenerationInput, ability_infoUncheckedCreateWithoutGenerationInput>
  }

  export type ability_infoUpdateWithWhereUniqueWithoutGenerationInput = {
    where: ability_infoWhereUniqueInput
    data: XOR<ability_infoUpdateWithoutGenerationInput, ability_infoUncheckedUpdateWithoutGenerationInput>
  }

  export type ability_infoUpdateManyWithWhereWithoutGenerationInput = {
    where: ability_infoScalarWhereInput
    data: XOR<ability_infoUpdateManyMutationInput, ability_infoUncheckedUpdateManyWithoutGenerationInput>
  }

  export type ability_infoScalarWhereInput = {
    AND?: ability_infoScalarWhereInput | ability_infoScalarWhereInput[]
    OR?: ability_infoScalarWhereInput[]
    NOT?: ability_infoScalarWhereInput | ability_infoScalarWhereInput[]
    id?: IntFilter<"ability_info"> | number
    generationId?: IntFilter<"ability_info"> | number
    abilityId?: IntFilter<"ability_info"> | number
    effectOutsideFightId?: IntFilter<"ability_info"> | number
    createdAt?: DateTimeFilter<"ability_info"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ability_info"> | Date | string | null
    status?: StringFilter<"ability_info"> | string
  }

  export type gameUpsertWithWhereUniqueWithoutGenerationInput = {
    where: gameWhereUniqueInput
    update: XOR<gameUpdateWithoutGenerationInput, gameUncheckedUpdateWithoutGenerationInput>
    create: XOR<gameCreateWithoutGenerationInput, gameUncheckedCreateWithoutGenerationInput>
  }

  export type gameUpdateWithWhereUniqueWithoutGenerationInput = {
    where: gameWhereUniqueInput
    data: XOR<gameUpdateWithoutGenerationInput, gameUncheckedUpdateWithoutGenerationInput>
  }

  export type gameUpdateManyWithWhereWithoutGenerationInput = {
    where: gameScalarWhereInput
    data: XOR<gameUpdateManyMutationInput, gameUncheckedUpdateManyWithoutGenerationInput>
  }

  export type gameScalarWhereInput = {
    AND?: gameScalarWhereInput | gameScalarWhereInput[]
    OR?: gameScalarWhereInput[]
    NOT?: gameScalarWhereInput | gameScalarWhereInput[]
    id?: IntFilter<"game"> | number
    generationId?: IntFilter<"game"> | number
    createdAt?: DateTimeFilter<"game"> | Date | string
    updatedAt?: DateTimeNullableFilter<"game"> | Date | string | null
    status?: StringFilter<"game"> | string
  }

  export type pokemonUpsertWithWhereUniqueWithoutGenerationInput = {
    where: pokemonWhereUniqueInput
    update: XOR<pokemonUpdateWithoutGenerationInput, pokemonUncheckedUpdateWithoutGenerationInput>
    create: XOR<pokemonCreateWithoutGenerationInput, pokemonUncheckedCreateWithoutGenerationInput>
  }

  export type pokemonUpdateWithWhereUniqueWithoutGenerationInput = {
    where: pokemonWhereUniqueInput
    data: XOR<pokemonUpdateWithoutGenerationInput, pokemonUncheckedUpdateWithoutGenerationInput>
  }

  export type pokemonUpdateManyWithWhereWithoutGenerationInput = {
    where: pokemonScalarWhereInput
    data: XOR<pokemonUpdateManyMutationInput, pokemonUncheckedUpdateManyWithoutGenerationInput>
  }

  export type pokemonScalarWhereInput = {
    AND?: pokemonScalarWhereInput | pokemonScalarWhereInput[]
    OR?: pokemonScalarWhereInput[]
    NOT?: pokemonScalarWhereInput | pokemonScalarWhereInput[]
    id?: IntFilter<"pokemon"> | number
    internationalNumber?: IntFilter<"pokemon"> | number
    hatchingCycle?: IntFilter<"pokemon"> | number
    globalXp?: IntFilter<"pokemon"> | number
    captureRate?: IntFilter<"pokemon"> | number
    callHelpRate?: IntFilter<"pokemon"> | number
    size?: DecimalFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    weight?: DecimalFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFilter<"pokemon"> | Decimal | DecimalJsLike | number | string
    pokemonCategoryId?: IntFilter<"pokemon"> | number
    generationId?: IntFilter<"pokemon"> | number
    createdAt?: DateTimeFilter<"pokemon"> | Date | string
    updatedAt?: DateTimeNullableFilter<"pokemon"> | Date | string | null
    status?: StringFilter<"pokemon"> | string
  }

  export type pokemon_infoUpsertWithWhereUniqueWithoutGenerationInput = {
    where: pokemon_infoWhereUniqueInput
    update: XOR<pokemon_infoUpdateWithoutGenerationInput, pokemon_infoUncheckedUpdateWithoutGenerationInput>
    create: XOR<pokemon_infoCreateWithoutGenerationInput, pokemon_infoUncheckedCreateWithoutGenerationInput>
  }

  export type pokemon_infoUpdateWithWhereUniqueWithoutGenerationInput = {
    where: pokemon_infoWhereUniqueInput
    data: XOR<pokemon_infoUpdateWithoutGenerationInput, pokemon_infoUncheckedUpdateWithoutGenerationInput>
  }

  export type pokemon_infoUpdateManyWithWhereWithoutGenerationInput = {
    where: pokemon_infoScalarWhereInput
    data: XOR<pokemon_infoUpdateManyMutationInput, pokemon_infoUncheckedUpdateManyWithoutGenerationInput>
  }

  export type pokemon_infoScalarWhereInput = {
    AND?: pokemon_infoScalarWhereInput | pokemon_infoScalarWhereInput[]
    OR?: pokemon_infoScalarWhereInput[]
    NOT?: pokemon_infoScalarWhereInput | pokemon_infoScalarWhereInput[]
    id?: IntFilter<"pokemon_info"> | number
    xpGift?: IntFilter<"pokemon_info"> | number
    generationId?: IntFilter<"pokemon_info"> | number
    pokemonId?: IntFilter<"pokemon_info"> | number
    createdAt?: DateTimeFilter<"pokemon_info"> | Date | string
    updatedAt?: DateTimeNullableFilter<"pokemon_info"> | Date | string | null
    status?: StringFilter<"pokemon_info"> | string
  }

  export type generationCreateWithoutGamesInput = {
    id: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilities?: abilityCreateNestedManyWithoutGenerationInput
    abilityInfos?: ability_infoCreateNestedManyWithoutGenerationInput
    pokemons?: pokemonCreateNestedManyWithoutGenerationInput
    pokemonInfos?: pokemon_infoCreateNestedManyWithoutGenerationInput
  }

  export type generationUncheckedCreateWithoutGamesInput = {
    id: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilities?: abilityUncheckedCreateNestedManyWithoutGenerationInput
    abilityInfos?: ability_infoUncheckedCreateNestedManyWithoutGenerationInput
    pokemons?: pokemonUncheckedCreateNestedManyWithoutGenerationInput
    pokemonInfos?: pokemon_infoUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type generationCreateOrConnectWithoutGamesInput = {
    where: generationWhereUniqueInput
    create: XOR<generationCreateWithoutGamesInput, generationUncheckedCreateWithoutGamesInput>
  }

  export type game_group_gameCreateWithoutGameInput = {
    groupGame: group_gameCreateNestedOneWithoutGameGroupGamesInput
    land: landCreateNestedOneWithoutGame_group_gameInput
  }

  export type game_group_gameUncheckedCreateWithoutGameInput = {
    groupGameId: number
    landId: number
  }

  export type game_group_gameCreateOrConnectWithoutGameInput = {
    where: game_group_gameWhereUniqueInput
    create: XOR<game_group_gameCreateWithoutGameInput, game_group_gameUncheckedCreateWithoutGameInput>
  }

  export type game_group_gameCreateManyGameInputEnvelope = {
    data: game_group_gameCreateManyGameInput | game_group_gameCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type owned_pokemonCreateWithoutGameInput = {
    id?: bigint | number
    isShiny: boolean
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    shinyHuntingMethod: shiny_hunting_methodCreateNestedOneWithoutOwnedPokemonsInput
    pokemonForms: pokemon_formCreateNestedOneWithoutOwnedPokemonsInput
    users: userCreateNestedOneWithoutOwnedPokemonsInput
    ownedPokemonDetails?: owned_pokemon_detailCreateNestedManyWithoutOwnedPokemonInput
  }

  export type owned_pokemonUncheckedCreateWithoutGameInput = {
    id?: bigint | number
    userId: number
    pokemonFormId: number
    isShiny: boolean
    methodId: number
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemonDetails?: owned_pokemon_detailUncheckedCreateNestedManyWithoutOwnedPokemonInput
  }

  export type owned_pokemonCreateOrConnectWithoutGameInput = {
    where: owned_pokemonWhereUniqueInput
    create: XOR<owned_pokemonCreateWithoutGameInput, owned_pokemonUncheckedCreateWithoutGameInput>
  }

  export type owned_pokemonCreateManyGameInputEnvelope = {
    data: owned_pokemonCreateManyGameInput | owned_pokemonCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type pokemon_game_locationCreateWithoutGameInput = {
    locationZone: location_zoneCreateNestedOneWithoutPokemonRatingGamesInput
    pokemonForm: pokemon_formCreateNestedOneWithoutPokemonRatingGamesInput
    pokemonObtation: pokemon_obtationCreateNestedOneWithoutPokemonRatingGamesInput
    rate: rateCreateNestedOneWithoutPokemonRatingGamesInput
  }

  export type pokemon_game_locationUncheckedCreateWithoutGameInput = {
    rateId: number
    locationZoneId: number
    pokemonObtationId: number
    pokemonFormId: number
    id?: number
  }

  export type pokemon_game_locationCreateOrConnectWithoutGameInput = {
    where: pokemon_game_locationWhereUniqueInput
    create: XOR<pokemon_game_locationCreateWithoutGameInput, pokemon_game_locationUncheckedCreateWithoutGameInput>
  }

  export type pokemon_game_locationCreateManyGameInputEnvelope = {
    data: pokemon_game_locationCreateManyGameInput | pokemon_game_locationCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type generationUpsertWithoutGamesInput = {
    update: XOR<generationUpdateWithoutGamesInput, generationUncheckedUpdateWithoutGamesInput>
    create: XOR<generationCreateWithoutGamesInput, generationUncheckedCreateWithoutGamesInput>
    where?: generationWhereInput
  }

  export type generationUpdateToOneWithWhereWithoutGamesInput = {
    where?: generationWhereInput
    data: XOR<generationUpdateWithoutGamesInput, generationUncheckedUpdateWithoutGamesInput>
  }

  export type generationUpdateWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilities?: abilityUpdateManyWithoutGenerationNestedInput
    abilityInfos?: ability_infoUpdateManyWithoutGenerationNestedInput
    pokemons?: pokemonUpdateManyWithoutGenerationNestedInput
    pokemonInfos?: pokemon_infoUpdateManyWithoutGenerationNestedInput
  }

  export type generationUncheckedUpdateWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilities?: abilityUncheckedUpdateManyWithoutGenerationNestedInput
    abilityInfos?: ability_infoUncheckedUpdateManyWithoutGenerationNestedInput
    pokemons?: pokemonUncheckedUpdateManyWithoutGenerationNestedInput
    pokemonInfos?: pokemon_infoUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type game_group_gameUpsertWithWhereUniqueWithoutGameInput = {
    where: game_group_gameWhereUniqueInput
    update: XOR<game_group_gameUpdateWithoutGameInput, game_group_gameUncheckedUpdateWithoutGameInput>
    create: XOR<game_group_gameCreateWithoutGameInput, game_group_gameUncheckedCreateWithoutGameInput>
  }

  export type game_group_gameUpdateWithWhereUniqueWithoutGameInput = {
    where: game_group_gameWhereUniqueInput
    data: XOR<game_group_gameUpdateWithoutGameInput, game_group_gameUncheckedUpdateWithoutGameInput>
  }

  export type game_group_gameUpdateManyWithWhereWithoutGameInput = {
    where: game_group_gameScalarWhereInput
    data: XOR<game_group_gameUpdateManyMutationInput, game_group_gameUncheckedUpdateManyWithoutGameInput>
  }

  export type game_group_gameScalarWhereInput = {
    AND?: game_group_gameScalarWhereInput | game_group_gameScalarWhereInput[]
    OR?: game_group_gameScalarWhereInput[]
    NOT?: game_group_gameScalarWhereInput | game_group_gameScalarWhereInput[]
    gameId?: IntFilter<"game_group_game"> | number
    groupGameId?: IntFilter<"game_group_game"> | number
    landId?: IntFilter<"game_group_game"> | number
  }

  export type owned_pokemonUpsertWithWhereUniqueWithoutGameInput = {
    where: owned_pokemonWhereUniqueInput
    update: XOR<owned_pokemonUpdateWithoutGameInput, owned_pokemonUncheckedUpdateWithoutGameInput>
    create: XOR<owned_pokemonCreateWithoutGameInput, owned_pokemonUncheckedCreateWithoutGameInput>
  }

  export type owned_pokemonUpdateWithWhereUniqueWithoutGameInput = {
    where: owned_pokemonWhereUniqueInput
    data: XOR<owned_pokemonUpdateWithoutGameInput, owned_pokemonUncheckedUpdateWithoutGameInput>
  }

  export type owned_pokemonUpdateManyWithWhereWithoutGameInput = {
    where: owned_pokemonScalarWhereInput
    data: XOR<owned_pokemonUpdateManyMutationInput, owned_pokemonUncheckedUpdateManyWithoutGameInput>
  }

  export type pokemon_game_locationUpsertWithWhereUniqueWithoutGameInput = {
    where: pokemon_game_locationWhereUniqueInput
    update: XOR<pokemon_game_locationUpdateWithoutGameInput, pokemon_game_locationUncheckedUpdateWithoutGameInput>
    create: XOR<pokemon_game_locationCreateWithoutGameInput, pokemon_game_locationUncheckedCreateWithoutGameInput>
  }

  export type pokemon_game_locationUpdateWithWhereUniqueWithoutGameInput = {
    where: pokemon_game_locationWhereUniqueInput
    data: XOR<pokemon_game_locationUpdateWithoutGameInput, pokemon_game_locationUncheckedUpdateWithoutGameInput>
  }

  export type pokemon_game_locationUpdateManyWithWhereWithoutGameInput = {
    where: pokemon_game_locationScalarWhereInput
    data: XOR<pokemon_game_locationUpdateManyMutationInput, pokemon_game_locationUncheckedUpdateManyWithoutGameInput>
  }

  export type pokemon_game_locationScalarWhereInput = {
    AND?: pokemon_game_locationScalarWhereInput | pokemon_game_locationScalarWhereInput[]
    OR?: pokemon_game_locationScalarWhereInput[]
    NOT?: pokemon_game_locationScalarWhereInput | pokemon_game_locationScalarWhereInput[]
    gameId?: IntFilter<"pokemon_game_location"> | number
    rateId?: IntFilter<"pokemon_game_location"> | number
    locationZoneId?: IntFilter<"pokemon_game_location"> | number
    pokemonObtationId?: IntFilter<"pokemon_game_location"> | number
    pokemonFormId?: IntFilter<"pokemon_game_location"> | number
    id?: IntFilter<"pokemon_game_location"> | number
  }

  export type gameCreateWithoutGameGroupGamesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    generation: generationCreateNestedOneWithoutGamesInput
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutGameInput
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutGameInput
  }

  export type gameUncheckedCreateWithoutGameGroupGamesInput = {
    id?: number
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutGameInput
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutGameInput
  }

  export type gameCreateOrConnectWithoutGameGroupGamesInput = {
    where: gameWhereUniqueInput
    create: XOR<gameCreateWithoutGameGroupGamesInput, gameUncheckedCreateWithoutGameGroupGamesInput>
  }

  export type group_gameCreateWithoutGameGroupGamesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoCreateNestedManyWithoutGroupGameInput
    nationnalNumbers?: national_numberCreateNestedManyWithoutGroupGameInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameCreateNestedManyWithoutGroupGameInput
    skillObtations?: skill_obtationCreateNestedManyWithoutGroupGameInput
    statisticGroupGames?: statistic_group_gameCreateNestedManyWithoutGroupGameInput
  }

  export type group_gameUncheckedCreateWithoutGameGroupGamesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutGroupGameInput
    nationnalNumbers?: national_numberUncheckedCreateNestedManyWithoutGroupGameInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedCreateNestedManyWithoutGroupGameInput
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutGroupGameInput
    statisticGroupGames?: statistic_group_gameUncheckedCreateNestedManyWithoutGroupGameInput
  }

  export type group_gameCreateOrConnectWithoutGameGroupGamesInput = {
    where: group_gameWhereUniqueInput
    create: XOR<group_gameCreateWithoutGameGroupGamesInput, group_gameUncheckedCreateWithoutGameGroupGamesInput>
  }

  export type landCreateWithoutGame_group_gameInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type landUncheckedCreateWithoutGame_group_gameInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type landCreateOrConnectWithoutGame_group_gameInput = {
    where: landWhereUniqueInput
    create: XOR<landCreateWithoutGame_group_gameInput, landUncheckedCreateWithoutGame_group_gameInput>
  }

  export type gameUpsertWithoutGameGroupGamesInput = {
    update: XOR<gameUpdateWithoutGameGroupGamesInput, gameUncheckedUpdateWithoutGameGroupGamesInput>
    create: XOR<gameCreateWithoutGameGroupGamesInput, gameUncheckedCreateWithoutGameGroupGamesInput>
    where?: gameWhereInput
  }

  export type gameUpdateToOneWithWhereWithoutGameGroupGamesInput = {
    where?: gameWhereInput
    data: XOR<gameUpdateWithoutGameGroupGamesInput, gameUncheckedUpdateWithoutGameGroupGamesInput>
  }

  export type gameUpdateWithoutGameGroupGamesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    generation?: generationUpdateOneRequiredWithoutGamesNestedInput
    ownedPokemons?: owned_pokemonUpdateManyWithoutGameNestedInput
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutGameNestedInput
  }

  export type gameUncheckedUpdateWithoutGameGroupGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutGameNestedInput
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutGameNestedInput
  }

  export type group_gameUpsertWithoutGameGroupGamesInput = {
    update: XOR<group_gameUpdateWithoutGameGroupGamesInput, group_gameUncheckedUpdateWithoutGameGroupGamesInput>
    create: XOR<group_gameCreateWithoutGameGroupGamesInput, group_gameUncheckedCreateWithoutGameGroupGamesInput>
    where?: group_gameWhereInput
  }

  export type group_gameUpdateToOneWithWhereWithoutGameGroupGamesInput = {
    where?: group_gameWhereInput
    data: XOR<group_gameUpdateWithoutGameGroupGamesInput, group_gameUncheckedUpdateWithoutGameGroupGamesInput>
  }

  export type group_gameUpdateWithoutGameGroupGamesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUpdateManyWithoutGroupGameNestedInput
    nationnalNumbers?: national_numberUpdateManyWithoutGroupGameNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUpdateManyWithoutGroupGameNestedInput
    skillObtations?: skill_obtationUpdateManyWithoutGroupGameNestedInput
    statisticGroupGames?: statistic_group_gameUpdateManyWithoutGroupGameNestedInput
  }

  export type group_gameUncheckedUpdateWithoutGameGroupGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutGroupGameNestedInput
    nationnalNumbers?: national_numberUncheckedUpdateManyWithoutGroupGameNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedUpdateManyWithoutGroupGameNestedInput
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutGroupGameNestedInput
    statisticGroupGames?: statistic_group_gameUncheckedUpdateManyWithoutGroupGameNestedInput
  }

  export type landUpsertWithoutGame_group_gameInput = {
    update: XOR<landUpdateWithoutGame_group_gameInput, landUncheckedUpdateWithoutGame_group_gameInput>
    create: XOR<landCreateWithoutGame_group_gameInput, landUncheckedCreateWithoutGame_group_gameInput>
    where?: landWhereInput
  }

  export type landUpdateToOneWithWhereWithoutGame_group_gameInput = {
    where?: landWhereInput
    data: XOR<landUpdateWithoutGame_group_gameInput, landUncheckedUpdateWithoutGame_group_gameInput>
  }

  export type landUpdateWithoutGame_group_gameInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type landUncheckedUpdateWithoutGame_group_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capsule_game_capacity_infoCreateWithoutGroupGameInput = {
    capacityInfo: capacity_infoCreateNestedOneWithoutCapsuleGameCapacityInfosInput
    capsule: capsuleCreateNestedOneWithoutCapsule_game_capacity_infoInput
  }

  export type capsule_game_capacity_infoUncheckedCreateWithoutGroupGameInput = {
    capacityInfoId: number
    capsuleId: number
  }

  export type capsule_game_capacity_infoCreateOrConnectWithoutGroupGameInput = {
    where: capsule_game_capacity_infoWhereUniqueInput
    create: XOR<capsule_game_capacity_infoCreateWithoutGroupGameInput, capsule_game_capacity_infoUncheckedCreateWithoutGroupGameInput>
  }

  export type capsule_game_capacity_infoCreateManyGroupGameInputEnvelope = {
    data: capsule_game_capacity_infoCreateManyGroupGameInput | capsule_game_capacity_infoCreateManyGroupGameInput[]
    skipDuplicates?: boolean
  }

  export type game_group_gameCreateWithoutGroupGameInput = {
    game: gameCreateNestedOneWithoutGameGroupGamesInput
    land: landCreateNestedOneWithoutGame_group_gameInput
  }

  export type game_group_gameUncheckedCreateWithoutGroupGameInput = {
    gameId: number
    landId: number
  }

  export type game_group_gameCreateOrConnectWithoutGroupGameInput = {
    where: game_group_gameWhereUniqueInput
    create: XOR<game_group_gameCreateWithoutGroupGameInput, game_group_gameUncheckedCreateWithoutGroupGameInput>
  }

  export type game_group_gameCreateManyGroupGameInputEnvelope = {
    data: game_group_gameCreateManyGroupGameInput | game_group_gameCreateManyGroupGameInput[]
    skipDuplicates?: boolean
  }

  export type national_numberCreateWithoutGroupGameInput = {
    number: number
    pokemon: pokemonCreateNestedOneWithoutNationalNumbersInput
  }

  export type national_numberUncheckedCreateWithoutGroupGameInput = {
    pokemonId: number
    number: number
  }

  export type national_numberCreateOrConnectWithoutGroupGameInput = {
    where: national_numberWhereUniqueInput
    create: XOR<national_numberCreateWithoutGroupGameInput, national_numberUncheckedCreateWithoutGroupGameInput>
  }

  export type national_numberCreateManyGroupGameInputEnvelope = {
    data: national_numberCreateManyGroupGameInput | national_numberCreateManyGroupGameInput[]
    skipDuplicates?: boolean
  }

  export type shiny_hunting_method_gameCreateWithoutGroupGameInput = {
    shinyHuntingMethod: shiny_hunting_methodCreateNestedOneWithoutShinyHuntingMethodGamesInput
  }

  export type shiny_hunting_method_gameUncheckedCreateWithoutGroupGameInput = {
    shinyHuntingMethodId: number
  }

  export type shiny_hunting_method_gameCreateOrConnectWithoutGroupGameInput = {
    where: shiny_hunting_method_gameWhereUniqueInput
    create: XOR<shiny_hunting_method_gameCreateWithoutGroupGameInput, shiny_hunting_method_gameUncheckedCreateWithoutGroupGameInput>
  }

  export type shiny_hunting_method_gameCreateManyGroupGameInputEnvelope = {
    data: shiny_hunting_method_gameCreateManyGroupGameInput | shiny_hunting_method_gameCreateManyGroupGameInput[]
    skipDuplicates?: boolean
  }

  export type skill_obtationCreateWithoutGroupGameInput = {
    detail: string
    capacity: capacityCreateNestedOneWithoutSkillObtationsInput
    pokemon: pokemonCreateNestedOneWithoutSkillObtationsInput
    skillObtationType: skill_obtation_typeCreateNestedOneWithoutSkillObtationsInput
  }

  export type skill_obtationUncheckedCreateWithoutGroupGameInput = {
    capacityId: number
    pokemonId: number
    skillObtationTypeId: number
    detail: string
  }

  export type skill_obtationCreateOrConnectWithoutGroupGameInput = {
    where: skill_obtationWhereUniqueInput
    create: XOR<skill_obtationCreateWithoutGroupGameInput, skill_obtationUncheckedCreateWithoutGroupGameInput>
  }

  export type skill_obtationCreateManyGroupGameInputEnvelope = {
    data: skill_obtationCreateManyGroupGameInput | skill_obtationCreateManyGroupGameInput[]
    skipDuplicates?: boolean
  }

  export type statistic_group_gameCreateWithoutGroupGameInput = {
    pokemon: pokemonCreateNestedOneWithoutStatisticGroupGamesInput
    statistic: statisticCreateNestedOneWithoutStatisticGroupGamesInput
  }

  export type statistic_group_gameUncheckedCreateWithoutGroupGameInput = {
    pokemonId: number
    statisticId: number
  }

  export type statistic_group_gameCreateOrConnectWithoutGroupGameInput = {
    where: statistic_group_gameWhereUniqueInput
    create: XOR<statistic_group_gameCreateWithoutGroupGameInput, statistic_group_gameUncheckedCreateWithoutGroupGameInput>
  }

  export type statistic_group_gameCreateManyGroupGameInputEnvelope = {
    data: statistic_group_gameCreateManyGroupGameInput | statistic_group_gameCreateManyGroupGameInput[]
    skipDuplicates?: boolean
  }

  export type capsule_game_capacity_infoUpsertWithWhereUniqueWithoutGroupGameInput = {
    where: capsule_game_capacity_infoWhereUniqueInput
    update: XOR<capsule_game_capacity_infoUpdateWithoutGroupGameInput, capsule_game_capacity_infoUncheckedUpdateWithoutGroupGameInput>
    create: XOR<capsule_game_capacity_infoCreateWithoutGroupGameInput, capsule_game_capacity_infoUncheckedCreateWithoutGroupGameInput>
  }

  export type capsule_game_capacity_infoUpdateWithWhereUniqueWithoutGroupGameInput = {
    where: capsule_game_capacity_infoWhereUniqueInput
    data: XOR<capsule_game_capacity_infoUpdateWithoutGroupGameInput, capsule_game_capacity_infoUncheckedUpdateWithoutGroupGameInput>
  }

  export type capsule_game_capacity_infoUpdateManyWithWhereWithoutGroupGameInput = {
    where: capsule_game_capacity_infoScalarWhereInput
    data: XOR<capsule_game_capacity_infoUpdateManyMutationInput, capsule_game_capacity_infoUncheckedUpdateManyWithoutGroupGameInput>
  }

  export type capsule_game_capacity_infoScalarWhereInput = {
    AND?: capsule_game_capacity_infoScalarWhereInput | capsule_game_capacity_infoScalarWhereInput[]
    OR?: capsule_game_capacity_infoScalarWhereInput[]
    NOT?: capsule_game_capacity_infoScalarWhereInput | capsule_game_capacity_infoScalarWhereInput[]
    capacityInfoId?: IntFilter<"capsule_game_capacity_info"> | number
    capsuleId?: IntFilter<"capsule_game_capacity_info"> | number
    groupeGameId?: IntFilter<"capsule_game_capacity_info"> | number
  }

  export type game_group_gameUpsertWithWhereUniqueWithoutGroupGameInput = {
    where: game_group_gameWhereUniqueInput
    update: XOR<game_group_gameUpdateWithoutGroupGameInput, game_group_gameUncheckedUpdateWithoutGroupGameInput>
    create: XOR<game_group_gameCreateWithoutGroupGameInput, game_group_gameUncheckedCreateWithoutGroupGameInput>
  }

  export type game_group_gameUpdateWithWhereUniqueWithoutGroupGameInput = {
    where: game_group_gameWhereUniqueInput
    data: XOR<game_group_gameUpdateWithoutGroupGameInput, game_group_gameUncheckedUpdateWithoutGroupGameInput>
  }

  export type game_group_gameUpdateManyWithWhereWithoutGroupGameInput = {
    where: game_group_gameScalarWhereInput
    data: XOR<game_group_gameUpdateManyMutationInput, game_group_gameUncheckedUpdateManyWithoutGroupGameInput>
  }

  export type national_numberUpsertWithWhereUniqueWithoutGroupGameInput = {
    where: national_numberWhereUniqueInput
    update: XOR<national_numberUpdateWithoutGroupGameInput, national_numberUncheckedUpdateWithoutGroupGameInput>
    create: XOR<national_numberCreateWithoutGroupGameInput, national_numberUncheckedCreateWithoutGroupGameInput>
  }

  export type national_numberUpdateWithWhereUniqueWithoutGroupGameInput = {
    where: national_numberWhereUniqueInput
    data: XOR<national_numberUpdateWithoutGroupGameInput, national_numberUncheckedUpdateWithoutGroupGameInput>
  }

  export type national_numberUpdateManyWithWhereWithoutGroupGameInput = {
    where: national_numberScalarWhereInput
    data: XOR<national_numberUpdateManyMutationInput, national_numberUncheckedUpdateManyWithoutGroupGameInput>
  }

  export type national_numberScalarWhereInput = {
    AND?: national_numberScalarWhereInput | national_numberScalarWhereInput[]
    OR?: national_numberScalarWhereInput[]
    NOT?: national_numberScalarWhereInput | national_numberScalarWhereInput[]
    groupGameId?: IntFilter<"national_number"> | number
    pokemonId?: IntFilter<"national_number"> | number
    number?: IntFilter<"national_number"> | number
  }

  export type shiny_hunting_method_gameUpsertWithWhereUniqueWithoutGroupGameInput = {
    where: shiny_hunting_method_gameWhereUniqueInput
    update: XOR<shiny_hunting_method_gameUpdateWithoutGroupGameInput, shiny_hunting_method_gameUncheckedUpdateWithoutGroupGameInput>
    create: XOR<shiny_hunting_method_gameCreateWithoutGroupGameInput, shiny_hunting_method_gameUncheckedCreateWithoutGroupGameInput>
  }

  export type shiny_hunting_method_gameUpdateWithWhereUniqueWithoutGroupGameInput = {
    where: shiny_hunting_method_gameWhereUniqueInput
    data: XOR<shiny_hunting_method_gameUpdateWithoutGroupGameInput, shiny_hunting_method_gameUncheckedUpdateWithoutGroupGameInput>
  }

  export type shiny_hunting_method_gameUpdateManyWithWhereWithoutGroupGameInput = {
    where: shiny_hunting_method_gameScalarWhereInput
    data: XOR<shiny_hunting_method_gameUpdateManyMutationInput, shiny_hunting_method_gameUncheckedUpdateManyWithoutGroupGameInput>
  }

  export type skill_obtationUpsertWithWhereUniqueWithoutGroupGameInput = {
    where: skill_obtationWhereUniqueInput
    update: XOR<skill_obtationUpdateWithoutGroupGameInput, skill_obtationUncheckedUpdateWithoutGroupGameInput>
    create: XOR<skill_obtationCreateWithoutGroupGameInput, skill_obtationUncheckedCreateWithoutGroupGameInput>
  }

  export type skill_obtationUpdateWithWhereUniqueWithoutGroupGameInput = {
    where: skill_obtationWhereUniqueInput
    data: XOR<skill_obtationUpdateWithoutGroupGameInput, skill_obtationUncheckedUpdateWithoutGroupGameInput>
  }

  export type skill_obtationUpdateManyWithWhereWithoutGroupGameInput = {
    where: skill_obtationScalarWhereInput
    data: XOR<skill_obtationUpdateManyMutationInput, skill_obtationUncheckedUpdateManyWithoutGroupGameInput>
  }

  export type skill_obtationScalarWhereInput = {
    AND?: skill_obtationScalarWhereInput | skill_obtationScalarWhereInput[]
    OR?: skill_obtationScalarWhereInput[]
    NOT?: skill_obtationScalarWhereInput | skill_obtationScalarWhereInput[]
    capacityId?: IntFilter<"skill_obtation"> | number
    pokemonId?: IntFilter<"skill_obtation"> | number
    groupGameId?: IntFilter<"skill_obtation"> | number
    skillObtationTypeId?: IntFilter<"skill_obtation"> | number
    detail?: StringFilter<"skill_obtation"> | string
  }

  export type statistic_group_gameUpsertWithWhereUniqueWithoutGroupGameInput = {
    where: statistic_group_gameWhereUniqueInput
    update: XOR<statistic_group_gameUpdateWithoutGroupGameInput, statistic_group_gameUncheckedUpdateWithoutGroupGameInput>
    create: XOR<statistic_group_gameCreateWithoutGroupGameInput, statistic_group_gameUncheckedCreateWithoutGroupGameInput>
  }

  export type statistic_group_gameUpdateWithWhereUniqueWithoutGroupGameInput = {
    where: statistic_group_gameWhereUniqueInput
    data: XOR<statistic_group_gameUpdateWithoutGroupGameInput, statistic_group_gameUncheckedUpdateWithoutGroupGameInput>
  }

  export type statistic_group_gameUpdateManyWithWhereWithoutGroupGameInput = {
    where: statistic_group_gameScalarWhereInput
    data: XOR<statistic_group_gameUpdateManyMutationInput, statistic_group_gameUncheckedUpdateManyWithoutGroupGameInput>
  }

  export type statistic_group_gameScalarWhereInput = {
    AND?: statistic_group_gameScalarWhereInput | statistic_group_gameScalarWhereInput[]
    OR?: statistic_group_gameScalarWhereInput[]
    NOT?: statistic_group_gameScalarWhereInput | statistic_group_gameScalarWhereInput[]
    groupGameId?: IntFilter<"statistic_group_game"> | number
    pokemonId?: IntFilter<"statistic_group_game"> | number
    statisticId?: IntFilter<"statistic_group_game"> | number
  }

  export type capacity_infoCreateWithoutCapsuleGameCapacityInfosInput = {
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityCategory: capacity_categoryCreateNestedOneWithoutCapacityInfosInput
    capacityEffect: capacity_effectCreateNestedOneWithoutCapacityInfosInput
    capacityEffectZ: capacity_effectCreateNestedOneWithoutCapacityZInfosInput
    capacity: capacityCreateNestedOneWithoutCapacityInfosInput
    effectOutsideFight: effect_outside_fightCreateNestedOneWithoutCapacityInfosInput
    target: targetCreateNestedOneWithoutCapacityInfosInput
    type: typeCreateNestedOneWithoutCapacityInfosInput
    capacityInfoInfluences?: capacity_info_influenceCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoUncheckedCreateWithoutCapsuleGameCapacityInfosInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityId: number
    capacityEffectZId: number
    typeId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfoInfluences?: capacity_info_influenceUncheckedCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoCreateOrConnectWithoutCapsuleGameCapacityInfosInput = {
    where: capacity_infoWhereUniqueInput
    create: XOR<capacity_infoCreateWithoutCapsuleGameCapacityInfosInput, capacity_infoUncheckedCreateWithoutCapsuleGameCapacityInfosInput>
  }

  export type capsuleCreateWithoutCapsule_game_capacity_infoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type capsuleUncheckedCreateWithoutCapsule_game_capacity_infoInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type capsuleCreateOrConnectWithoutCapsule_game_capacity_infoInput = {
    where: capsuleWhereUniqueInput
    create: XOR<capsuleCreateWithoutCapsule_game_capacity_infoInput, capsuleUncheckedCreateWithoutCapsule_game_capacity_infoInput>
  }

  export type group_gameCreateWithoutCapsuleGameCapacityIinfosInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    gameGroupGames?: game_group_gameCreateNestedManyWithoutGroupGameInput
    nationnalNumbers?: national_numberCreateNestedManyWithoutGroupGameInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameCreateNestedManyWithoutGroupGameInput
    skillObtations?: skill_obtationCreateNestedManyWithoutGroupGameInput
    statisticGroupGames?: statistic_group_gameCreateNestedManyWithoutGroupGameInput
  }

  export type group_gameUncheckedCreateWithoutCapsuleGameCapacityIinfosInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    gameGroupGames?: game_group_gameUncheckedCreateNestedManyWithoutGroupGameInput
    nationnalNumbers?: national_numberUncheckedCreateNestedManyWithoutGroupGameInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedCreateNestedManyWithoutGroupGameInput
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutGroupGameInput
    statisticGroupGames?: statistic_group_gameUncheckedCreateNestedManyWithoutGroupGameInput
  }

  export type group_gameCreateOrConnectWithoutCapsuleGameCapacityIinfosInput = {
    where: group_gameWhereUniqueInput
    create: XOR<group_gameCreateWithoutCapsuleGameCapacityIinfosInput, group_gameUncheckedCreateWithoutCapsuleGameCapacityIinfosInput>
  }

  export type capacity_infoUpsertWithoutCapsuleGameCapacityInfosInput = {
    update: XOR<capacity_infoUpdateWithoutCapsuleGameCapacityInfosInput, capacity_infoUncheckedUpdateWithoutCapsuleGameCapacityInfosInput>
    create: XOR<capacity_infoCreateWithoutCapsuleGameCapacityInfosInput, capacity_infoUncheckedCreateWithoutCapsuleGameCapacityInfosInput>
    where?: capacity_infoWhereInput
  }

  export type capacity_infoUpdateToOneWithWhereWithoutCapsuleGameCapacityInfosInput = {
    where?: capacity_infoWhereInput
    data: XOR<capacity_infoUpdateWithoutCapsuleGameCapacityInfosInput, capacity_infoUncheckedUpdateWithoutCapsuleGameCapacityInfosInput>
  }

  export type capacity_infoUpdateWithoutCapsuleGameCapacityInfosInput = {
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityCategory?: capacity_categoryUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffect?: capacity_effectUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffectZ?: capacity_effectUpdateOneRequiredWithoutCapacityZInfosNestedInput
    capacity?: capacityUpdateOneRequiredWithoutCapacityInfosNestedInput
    effectOutsideFight?: effect_outside_fightUpdateOneRequiredWithoutCapacityInfosNestedInput
    target?: targetUpdateOneRequiredWithoutCapacityInfosNestedInput
    type?: typeUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityInfoInfluences?: capacity_info_influenceUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateWithoutCapsuleGameCapacityInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfoInfluences?: capacity_info_influenceUncheckedUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capsuleUpsertWithoutCapsule_game_capacity_infoInput = {
    update: XOR<capsuleUpdateWithoutCapsule_game_capacity_infoInput, capsuleUncheckedUpdateWithoutCapsule_game_capacity_infoInput>
    create: XOR<capsuleCreateWithoutCapsule_game_capacity_infoInput, capsuleUncheckedCreateWithoutCapsule_game_capacity_infoInput>
    where?: capsuleWhereInput
  }

  export type capsuleUpdateToOneWithWhereWithoutCapsule_game_capacity_infoInput = {
    where?: capsuleWhereInput
    data: XOR<capsuleUpdateWithoutCapsule_game_capacity_infoInput, capsuleUncheckedUpdateWithoutCapsule_game_capacity_infoInput>
  }

  export type capsuleUpdateWithoutCapsule_game_capacity_infoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capsuleUncheckedUpdateWithoutCapsule_game_capacity_infoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type group_gameUpsertWithoutCapsuleGameCapacityIinfosInput = {
    update: XOR<group_gameUpdateWithoutCapsuleGameCapacityIinfosInput, group_gameUncheckedUpdateWithoutCapsuleGameCapacityIinfosInput>
    create: XOR<group_gameCreateWithoutCapsuleGameCapacityIinfosInput, group_gameUncheckedCreateWithoutCapsuleGameCapacityIinfosInput>
    where?: group_gameWhereInput
  }

  export type group_gameUpdateToOneWithWhereWithoutCapsuleGameCapacityIinfosInput = {
    where?: group_gameWhereInput
    data: XOR<group_gameUpdateWithoutCapsuleGameCapacityIinfosInput, group_gameUncheckedUpdateWithoutCapsuleGameCapacityIinfosInput>
  }

  export type group_gameUpdateWithoutCapsuleGameCapacityIinfosInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameGroupGames?: game_group_gameUpdateManyWithoutGroupGameNestedInput
    nationnalNumbers?: national_numberUpdateManyWithoutGroupGameNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUpdateManyWithoutGroupGameNestedInput
    skillObtations?: skill_obtationUpdateManyWithoutGroupGameNestedInput
    statisticGroupGames?: statistic_group_gameUpdateManyWithoutGroupGameNestedInput
  }

  export type group_gameUncheckedUpdateWithoutCapsuleGameCapacityIinfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameGroupGames?: game_group_gameUncheckedUpdateManyWithoutGroupGameNestedInput
    nationnalNumbers?: national_numberUncheckedUpdateManyWithoutGroupGameNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedUpdateManyWithoutGroupGameNestedInput
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutGroupGameNestedInput
    statisticGroupGames?: statistic_group_gameUncheckedUpdateManyWithoutGroupGameNestedInput
  }

  export type pokemonCreateWithoutPokemon_categoryInput = {
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    nationalNumbers?: national_numberCreateNestedManyWithoutPokemonInput
    generation: generationCreateNestedOneWithoutPokemonsInput
    pokemonForms?: pokemon_formCreateNestedManyWithoutPokemonInput
    pokemonInfos?: pokemon_infoCreateNestedManyWithoutPokemonInput
    skillObtations?: skill_obtationCreateNestedManyWithoutPokemonInput
    statisticGroupGames?: statistic_group_gameCreateNestedManyWithoutPokemonInput
  }

  export type pokemonUncheckedCreateWithoutPokemon_categoryInput = {
    id?: number
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    nationalNumbers?: national_numberUncheckedCreateNestedManyWithoutPokemonInput
    pokemonForms?: pokemon_formUncheckedCreateNestedManyWithoutPokemonInput
    pokemonInfos?: pokemon_infoUncheckedCreateNestedManyWithoutPokemonInput
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutPokemonInput
    statisticGroupGames?: statistic_group_gameUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type pokemonCreateOrConnectWithoutPokemon_categoryInput = {
    where: pokemonWhereUniqueInput
    create: XOR<pokemonCreateWithoutPokemon_categoryInput, pokemonUncheckedCreateWithoutPokemon_categoryInput>
  }

  export type pokemonCreateManyPokemon_categoryInputEnvelope = {
    data: pokemonCreateManyPokemon_categoryInput | pokemonCreateManyPokemon_categoryInput[]
    skipDuplicates?: boolean
  }

  export type pokemonUpsertWithWhereUniqueWithoutPokemon_categoryInput = {
    where: pokemonWhereUniqueInput
    update: XOR<pokemonUpdateWithoutPokemon_categoryInput, pokemonUncheckedUpdateWithoutPokemon_categoryInput>
    create: XOR<pokemonCreateWithoutPokemon_categoryInput, pokemonUncheckedCreateWithoutPokemon_categoryInput>
  }

  export type pokemonUpdateWithWhereUniqueWithoutPokemon_categoryInput = {
    where: pokemonWhereUniqueInput
    data: XOR<pokemonUpdateWithoutPokemon_categoryInput, pokemonUncheckedUpdateWithoutPokemon_categoryInput>
  }

  export type pokemonUpdateManyWithWhereWithoutPokemon_categoryInput = {
    where: pokemonScalarWhereInput
    data: XOR<pokemonUpdateManyMutationInput, pokemonUncheckedUpdateManyWithoutPokemon_categoryInput>
  }

  export type national_numberCreateWithoutPokemonInput = {
    number: number
    groupGame: group_gameCreateNestedOneWithoutNationnalNumbersInput
  }

  export type national_numberUncheckedCreateWithoutPokemonInput = {
    groupGameId: number
    number: number
  }

  export type national_numberCreateOrConnectWithoutPokemonInput = {
    where: national_numberWhereUniqueInput
    create: XOR<national_numberCreateWithoutPokemonInput, national_numberUncheckedCreateWithoutPokemonInput>
  }

  export type national_numberCreateManyPokemonInputEnvelope = {
    data: national_numberCreateManyPokemonInput | national_numberCreateManyPokemonInput[]
    skipDuplicates?: boolean
  }

  export type pokemon_categoryCreateWithoutPokemonsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokemon_categoryUncheckedCreateWithoutPokemonsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokemon_categoryCreateOrConnectWithoutPokemonsInput = {
    where: pokemon_categoryWhereUniqueInput
    create: XOR<pokemon_categoryCreateWithoutPokemonsInput, pokemon_categoryUncheckedCreateWithoutPokemonsInput>
  }

  export type generationCreateWithoutPokemonsInput = {
    id: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilities?: abilityCreateNestedManyWithoutGenerationInput
    abilityInfos?: ability_infoCreateNestedManyWithoutGenerationInput
    games?: gameCreateNestedManyWithoutGenerationInput
    pokemonInfos?: pokemon_infoCreateNestedManyWithoutGenerationInput
  }

  export type generationUncheckedCreateWithoutPokemonsInput = {
    id: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilities?: abilityUncheckedCreateNestedManyWithoutGenerationInput
    abilityInfos?: ability_infoUncheckedCreateNestedManyWithoutGenerationInput
    games?: gameUncheckedCreateNestedManyWithoutGenerationInput
    pokemonInfos?: pokemon_infoUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type generationCreateOrConnectWithoutPokemonsInput = {
    where: generationWhereUniqueInput
    create: XOR<generationCreateWithoutPokemonsInput, generationUncheckedCreateWithoutPokemonsInput>
  }

  export type pokemon_formCreateWithoutPokemonInput = {
    createdAt?: Date | string
    status?: string
    updatedAt?: Date | string | null
    evolutionEnds?: evolutionCreateNestedManyWithoutPokemonEndInput
    evolutionStarts?: evolutionCreateNestedManyWithoutPokemonStartInput
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutPokemonFormsInput
    form: formCreateNestedOneWithoutPokemonFormsInput
    pokemonFormGenders?: pokemon_form_genderCreateNestedManyWithoutPokemon_formInput
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutPokemonFormInput
  }

  export type pokemon_formUncheckedCreateWithoutPokemonInput = {
    formId: number
    createdAt?: Date | string
    id?: number
    status?: string
    updatedAt?: Date | string | null
    evolutionEnds?: evolutionUncheckedCreateNestedManyWithoutPokemonEndInput
    evolutionStarts?: evolutionUncheckedCreateNestedManyWithoutPokemonStartInput
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutPokemonFormsInput
    pokemonFormGenders?: pokemon_form_genderUncheckedCreateNestedManyWithoutPokemon_formInput
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutPokemonFormInput
  }

  export type pokemon_formCreateOrConnectWithoutPokemonInput = {
    where: pokemon_formWhereUniqueInput
    create: XOR<pokemon_formCreateWithoutPokemonInput, pokemon_formUncheckedCreateWithoutPokemonInput>
  }

  export type pokemon_formCreateManyPokemonInputEnvelope = {
    data: pokemon_formCreateManyPokemonInput | pokemon_formCreateManyPokemonInput[]
    skipDuplicates?: boolean
  }

  export type pokemon_infoCreateWithoutPokemonInput = {
    xpGift: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityOrders?: ability_orderCreateNestedManyWithoutPokemonInfoInput
    eggGroupOrders?: egg_group_orderCreateNestedManyWithoutPokemonInfoInput
    generation: generationCreateNestedOneWithoutPokemonInfosInput
    typeOrders?: type_orderCreateNestedManyWithoutPokemonInfoInput
  }

  export type pokemon_infoUncheckedCreateWithoutPokemonInput = {
    id?: number
    xpGift: number
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityOrders?: ability_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
    eggGroupOrders?: egg_group_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
    typeOrders?: type_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
  }

  export type pokemon_infoCreateOrConnectWithoutPokemonInput = {
    where: pokemon_infoWhereUniqueInput
    create: XOR<pokemon_infoCreateWithoutPokemonInput, pokemon_infoUncheckedCreateWithoutPokemonInput>
  }

  export type pokemon_infoCreateManyPokemonInputEnvelope = {
    data: pokemon_infoCreateManyPokemonInput | pokemon_infoCreateManyPokemonInput[]
    skipDuplicates?: boolean
  }

  export type skill_obtationCreateWithoutPokemonInput = {
    detail: string
    capacity: capacityCreateNestedOneWithoutSkillObtationsInput
    groupGame: group_gameCreateNestedOneWithoutSkillObtationsInput
    skillObtationType: skill_obtation_typeCreateNestedOneWithoutSkillObtationsInput
  }

  export type skill_obtationUncheckedCreateWithoutPokemonInput = {
    capacityId: number
    groupGameId: number
    skillObtationTypeId: number
    detail: string
  }

  export type skill_obtationCreateOrConnectWithoutPokemonInput = {
    where: skill_obtationWhereUniqueInput
    create: XOR<skill_obtationCreateWithoutPokemonInput, skill_obtationUncheckedCreateWithoutPokemonInput>
  }

  export type skill_obtationCreateManyPokemonInputEnvelope = {
    data: skill_obtationCreateManyPokemonInput | skill_obtationCreateManyPokemonInput[]
    skipDuplicates?: boolean
  }

  export type statistic_group_gameCreateWithoutPokemonInput = {
    groupGame: group_gameCreateNestedOneWithoutStatisticGroupGamesInput
    statistic: statisticCreateNestedOneWithoutStatisticGroupGamesInput
  }

  export type statistic_group_gameUncheckedCreateWithoutPokemonInput = {
    groupGameId: number
    statisticId: number
  }

  export type statistic_group_gameCreateOrConnectWithoutPokemonInput = {
    where: statistic_group_gameWhereUniqueInput
    create: XOR<statistic_group_gameCreateWithoutPokemonInput, statistic_group_gameUncheckedCreateWithoutPokemonInput>
  }

  export type statistic_group_gameCreateManyPokemonInputEnvelope = {
    data: statistic_group_gameCreateManyPokemonInput | statistic_group_gameCreateManyPokemonInput[]
    skipDuplicates?: boolean
  }

  export type national_numberUpsertWithWhereUniqueWithoutPokemonInput = {
    where: national_numberWhereUniqueInput
    update: XOR<national_numberUpdateWithoutPokemonInput, national_numberUncheckedUpdateWithoutPokemonInput>
    create: XOR<national_numberCreateWithoutPokemonInput, national_numberUncheckedCreateWithoutPokemonInput>
  }

  export type national_numberUpdateWithWhereUniqueWithoutPokemonInput = {
    where: national_numberWhereUniqueInput
    data: XOR<national_numberUpdateWithoutPokemonInput, national_numberUncheckedUpdateWithoutPokemonInput>
  }

  export type national_numberUpdateManyWithWhereWithoutPokemonInput = {
    where: national_numberScalarWhereInput
    data: XOR<national_numberUpdateManyMutationInput, national_numberUncheckedUpdateManyWithoutPokemonInput>
  }

  export type pokemon_categoryUpsertWithoutPokemonsInput = {
    update: XOR<pokemon_categoryUpdateWithoutPokemonsInput, pokemon_categoryUncheckedUpdateWithoutPokemonsInput>
    create: XOR<pokemon_categoryCreateWithoutPokemonsInput, pokemon_categoryUncheckedCreateWithoutPokemonsInput>
    where?: pokemon_categoryWhereInput
  }

  export type pokemon_categoryUpdateToOneWithWhereWithoutPokemonsInput = {
    where?: pokemon_categoryWhereInput
    data: XOR<pokemon_categoryUpdateWithoutPokemonsInput, pokemon_categoryUncheckedUpdateWithoutPokemonsInput>
  }

  export type pokemon_categoryUpdateWithoutPokemonsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_categoryUncheckedUpdateWithoutPokemonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type generationUpsertWithoutPokemonsInput = {
    update: XOR<generationUpdateWithoutPokemonsInput, generationUncheckedUpdateWithoutPokemonsInput>
    create: XOR<generationCreateWithoutPokemonsInput, generationUncheckedCreateWithoutPokemonsInput>
    where?: generationWhereInput
  }

  export type generationUpdateToOneWithWhereWithoutPokemonsInput = {
    where?: generationWhereInput
    data: XOR<generationUpdateWithoutPokemonsInput, generationUncheckedUpdateWithoutPokemonsInput>
  }

  export type generationUpdateWithoutPokemonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilities?: abilityUpdateManyWithoutGenerationNestedInput
    abilityInfos?: ability_infoUpdateManyWithoutGenerationNestedInput
    games?: gameUpdateManyWithoutGenerationNestedInput
    pokemonInfos?: pokemon_infoUpdateManyWithoutGenerationNestedInput
  }

  export type generationUncheckedUpdateWithoutPokemonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilities?: abilityUncheckedUpdateManyWithoutGenerationNestedInput
    abilityInfos?: ability_infoUncheckedUpdateManyWithoutGenerationNestedInput
    games?: gameUncheckedUpdateManyWithoutGenerationNestedInput
    pokemonInfos?: pokemon_infoUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type pokemon_formUpsertWithWhereUniqueWithoutPokemonInput = {
    where: pokemon_formWhereUniqueInput
    update: XOR<pokemon_formUpdateWithoutPokemonInput, pokemon_formUncheckedUpdateWithoutPokemonInput>
    create: XOR<pokemon_formCreateWithoutPokemonInput, pokemon_formUncheckedCreateWithoutPokemonInput>
  }

  export type pokemon_formUpdateWithWhereUniqueWithoutPokemonInput = {
    where: pokemon_formWhereUniqueInput
    data: XOR<pokemon_formUpdateWithoutPokemonInput, pokemon_formUncheckedUpdateWithoutPokemonInput>
  }

  export type pokemon_formUpdateManyWithWhereWithoutPokemonInput = {
    where: pokemon_formScalarWhereInput
    data: XOR<pokemon_formUpdateManyMutationInput, pokemon_formUncheckedUpdateManyWithoutPokemonInput>
  }

  export type pokemon_formScalarWhereInput = {
    AND?: pokemon_formScalarWhereInput | pokemon_formScalarWhereInput[]
    OR?: pokemon_formScalarWhereInput[]
    NOT?: pokemon_formScalarWhereInput | pokemon_formScalarWhereInput[]
    pokemonId?: IntFilter<"pokemon_form"> | number
    formId?: IntFilter<"pokemon_form"> | number
    createdAt?: DateTimeFilter<"pokemon_form"> | Date | string
    id?: IntFilter<"pokemon_form"> | number
    status?: StringFilter<"pokemon_form"> | string
    updatedAt?: DateTimeNullableFilter<"pokemon_form"> | Date | string | null
  }

  export type pokemon_infoUpsertWithWhereUniqueWithoutPokemonInput = {
    where: pokemon_infoWhereUniqueInput
    update: XOR<pokemon_infoUpdateWithoutPokemonInput, pokemon_infoUncheckedUpdateWithoutPokemonInput>
    create: XOR<pokemon_infoCreateWithoutPokemonInput, pokemon_infoUncheckedCreateWithoutPokemonInput>
  }

  export type pokemon_infoUpdateWithWhereUniqueWithoutPokemonInput = {
    where: pokemon_infoWhereUniqueInput
    data: XOR<pokemon_infoUpdateWithoutPokemonInput, pokemon_infoUncheckedUpdateWithoutPokemonInput>
  }

  export type pokemon_infoUpdateManyWithWhereWithoutPokemonInput = {
    where: pokemon_infoScalarWhereInput
    data: XOR<pokemon_infoUpdateManyMutationInput, pokemon_infoUncheckedUpdateManyWithoutPokemonInput>
  }

  export type skill_obtationUpsertWithWhereUniqueWithoutPokemonInput = {
    where: skill_obtationWhereUniqueInput
    update: XOR<skill_obtationUpdateWithoutPokemonInput, skill_obtationUncheckedUpdateWithoutPokemonInput>
    create: XOR<skill_obtationCreateWithoutPokemonInput, skill_obtationUncheckedCreateWithoutPokemonInput>
  }

  export type skill_obtationUpdateWithWhereUniqueWithoutPokemonInput = {
    where: skill_obtationWhereUniqueInput
    data: XOR<skill_obtationUpdateWithoutPokemonInput, skill_obtationUncheckedUpdateWithoutPokemonInput>
  }

  export type skill_obtationUpdateManyWithWhereWithoutPokemonInput = {
    where: skill_obtationScalarWhereInput
    data: XOR<skill_obtationUpdateManyMutationInput, skill_obtationUncheckedUpdateManyWithoutPokemonInput>
  }

  export type statistic_group_gameUpsertWithWhereUniqueWithoutPokemonInput = {
    where: statistic_group_gameWhereUniqueInput
    update: XOR<statistic_group_gameUpdateWithoutPokemonInput, statistic_group_gameUncheckedUpdateWithoutPokemonInput>
    create: XOR<statistic_group_gameCreateWithoutPokemonInput, statistic_group_gameUncheckedCreateWithoutPokemonInput>
  }

  export type statistic_group_gameUpdateWithWhereUniqueWithoutPokemonInput = {
    where: statistic_group_gameWhereUniqueInput
    data: XOR<statistic_group_gameUpdateWithoutPokemonInput, statistic_group_gameUncheckedUpdateWithoutPokemonInput>
  }

  export type statistic_group_gameUpdateManyWithWhereWithoutPokemonInput = {
    where: statistic_group_gameScalarWhereInput
    data: XOR<statistic_group_gameUpdateManyMutationInput, statistic_group_gameUncheckedUpdateManyWithoutPokemonInput>
  }

  export type pokemon_form_genderCreateWithoutGenderInput = {
    pokemon_form: pokemon_formCreateNestedOneWithoutPokemonFormGendersInput
  }

  export type pokemon_form_genderUncheckedCreateWithoutGenderInput = {
    pokemonFormId: number
  }

  export type pokemon_form_genderCreateOrConnectWithoutGenderInput = {
    where: pokemon_form_genderWhereUniqueInput
    create: XOR<pokemon_form_genderCreateWithoutGenderInput, pokemon_form_genderUncheckedCreateWithoutGenderInput>
  }

  export type pokemon_form_genderCreateManyGenderInputEnvelope = {
    data: pokemon_form_genderCreateManyGenderInput | pokemon_form_genderCreateManyGenderInput[]
    skipDuplicates?: boolean
  }

  export type pokemon_form_genderUpsertWithWhereUniqueWithoutGenderInput = {
    where: pokemon_form_genderWhereUniqueInput
    update: XOR<pokemon_form_genderUpdateWithoutGenderInput, pokemon_form_genderUncheckedUpdateWithoutGenderInput>
    create: XOR<pokemon_form_genderCreateWithoutGenderInput, pokemon_form_genderUncheckedCreateWithoutGenderInput>
  }

  export type pokemon_form_genderUpdateWithWhereUniqueWithoutGenderInput = {
    where: pokemon_form_genderWhereUniqueInput
    data: XOR<pokemon_form_genderUpdateWithoutGenderInput, pokemon_form_genderUncheckedUpdateWithoutGenderInput>
  }

  export type pokemon_form_genderUpdateManyWithWhereWithoutGenderInput = {
    where: pokemon_form_genderScalarWhereInput
    data: XOR<pokemon_form_genderUpdateManyMutationInput, pokemon_form_genderUncheckedUpdateManyWithoutGenderInput>
  }

  export type pokemon_form_genderScalarWhereInput = {
    AND?: pokemon_form_genderScalarWhereInput | pokemon_form_genderScalarWhereInput[]
    OR?: pokemon_form_genderScalarWhereInput[]
    NOT?: pokemon_form_genderScalarWhereInput | pokemon_form_genderScalarWhereInput[]
    pokemonFormId?: IntFilter<"pokemon_form_gender"> | number
    genderId?: IntFilter<"pokemon_form_gender"> | number
  }

  export type pokemon_formCreateWithoutFormInput = {
    createdAt?: Date | string
    status?: string
    updatedAt?: Date | string | null
    evolutionEnds?: evolutionCreateNestedManyWithoutPokemonEndInput
    evolutionStarts?: evolutionCreateNestedManyWithoutPokemonStartInput
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutPokemonFormsInput
    pokemon: pokemonCreateNestedOneWithoutPokemonFormsInput
    pokemonFormGenders?: pokemon_form_genderCreateNestedManyWithoutPokemon_formInput
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutPokemonFormInput
  }

  export type pokemon_formUncheckedCreateWithoutFormInput = {
    pokemonId: number
    createdAt?: Date | string
    id?: number
    status?: string
    updatedAt?: Date | string | null
    evolutionEnds?: evolutionUncheckedCreateNestedManyWithoutPokemonEndInput
    evolutionStarts?: evolutionUncheckedCreateNestedManyWithoutPokemonStartInput
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutPokemonFormsInput
    pokemonFormGenders?: pokemon_form_genderUncheckedCreateNestedManyWithoutPokemon_formInput
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutPokemonFormInput
  }

  export type pokemon_formCreateOrConnectWithoutFormInput = {
    where: pokemon_formWhereUniqueInput
    create: XOR<pokemon_formCreateWithoutFormInput, pokemon_formUncheckedCreateWithoutFormInput>
  }

  export type pokemon_formCreateManyFormInputEnvelope = {
    data: pokemon_formCreateManyFormInput | pokemon_formCreateManyFormInput[]
    skipDuplicates?: boolean
  }

  export type pokemon_formUpsertWithWhereUniqueWithoutFormInput = {
    where: pokemon_formWhereUniqueInput
    update: XOR<pokemon_formUpdateWithoutFormInput, pokemon_formUncheckedUpdateWithoutFormInput>
    create: XOR<pokemon_formCreateWithoutFormInput, pokemon_formUncheckedCreateWithoutFormInput>
  }

  export type pokemon_formUpdateWithWhereUniqueWithoutFormInput = {
    where: pokemon_formWhereUniqueInput
    data: XOR<pokemon_formUpdateWithoutFormInput, pokemon_formUncheckedUpdateWithoutFormInput>
  }

  export type pokemon_formUpdateManyWithWhereWithoutFormInput = {
    where: pokemon_formScalarWhereInput
    data: XOR<pokemon_formUpdateManyMutationInput, pokemon_formUncheckedUpdateManyWithoutFormInput>
  }

  export type genderCreateWithoutPokemonFormGendersInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type genderUncheckedCreateWithoutPokemonFormGendersInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type genderCreateOrConnectWithoutPokemonFormGendersInput = {
    where: genderWhereUniqueInput
    create: XOR<genderCreateWithoutPokemonFormGendersInput, genderUncheckedCreateWithoutPokemonFormGendersInput>
  }

  export type pokemon_formCreateWithoutPokemonFormGendersInput = {
    createdAt?: Date | string
    status?: string
    updatedAt?: Date | string | null
    evolutionEnds?: evolutionCreateNestedManyWithoutPokemonEndInput
    evolutionStarts?: evolutionCreateNestedManyWithoutPokemonStartInput
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutPokemonFormsInput
    form: formCreateNestedOneWithoutPokemonFormsInput
    pokemon: pokemonCreateNestedOneWithoutPokemonFormsInput
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutPokemonFormInput
  }

  export type pokemon_formUncheckedCreateWithoutPokemonFormGendersInput = {
    pokemonId: number
    formId: number
    createdAt?: Date | string
    id?: number
    status?: string
    updatedAt?: Date | string | null
    evolutionEnds?: evolutionUncheckedCreateNestedManyWithoutPokemonEndInput
    evolutionStarts?: evolutionUncheckedCreateNestedManyWithoutPokemonStartInput
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutPokemonFormsInput
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutPokemonFormInput
  }

  export type pokemon_formCreateOrConnectWithoutPokemonFormGendersInput = {
    where: pokemon_formWhereUniqueInput
    create: XOR<pokemon_formCreateWithoutPokemonFormGendersInput, pokemon_formUncheckedCreateWithoutPokemonFormGendersInput>
  }

  export type genderUpsertWithoutPokemonFormGendersInput = {
    update: XOR<genderUpdateWithoutPokemonFormGendersInput, genderUncheckedUpdateWithoutPokemonFormGendersInput>
    create: XOR<genderCreateWithoutPokemonFormGendersInput, genderUncheckedCreateWithoutPokemonFormGendersInput>
    where?: genderWhereInput
  }

  export type genderUpdateToOneWithWhereWithoutPokemonFormGendersInput = {
    where?: genderWhereInput
    data: XOR<genderUpdateWithoutPokemonFormGendersInput, genderUncheckedUpdateWithoutPokemonFormGendersInput>
  }

  export type genderUpdateWithoutPokemonFormGendersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type genderUncheckedUpdateWithoutPokemonFormGendersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_formUpsertWithoutPokemonFormGendersInput = {
    update: XOR<pokemon_formUpdateWithoutPokemonFormGendersInput, pokemon_formUncheckedUpdateWithoutPokemonFormGendersInput>
    create: XOR<pokemon_formCreateWithoutPokemonFormGendersInput, pokemon_formUncheckedCreateWithoutPokemonFormGendersInput>
    where?: pokemon_formWhereInput
  }

  export type pokemon_formUpdateToOneWithWhereWithoutPokemonFormGendersInput = {
    where?: pokemon_formWhereInput
    data: XOR<pokemon_formUpdateWithoutPokemonFormGendersInput, pokemon_formUncheckedUpdateWithoutPokemonFormGendersInput>
  }

  export type pokemon_formUpdateWithoutPokemonFormGendersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionEnds?: evolutionUpdateManyWithoutPokemonEndNestedInput
    evolutionStarts?: evolutionUpdateManyWithoutPokemonStartNestedInput
    ownedPokemons?: owned_pokemonUpdateManyWithoutPokemonFormsNestedInput
    form?: formUpdateOneRequiredWithoutPokemonFormsNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutPokemonFormsNestedInput
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutPokemonFormNestedInput
  }

  export type pokemon_formUncheckedUpdateWithoutPokemonFormGendersInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionEnds?: evolutionUncheckedUpdateManyWithoutPokemonEndNestedInput
    evolutionStarts?: evolutionUncheckedUpdateManyWithoutPokemonStartNestedInput
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutPokemonFormsNestedInput
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutPokemonFormNestedInput
  }

  export type evolutionCreateWithoutPokemonEndInput = {
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    evolutionInfo: evolution_infoCreateNestedOneWithoutEvolutionsInput
    evolutionMethod: evolution_methodCreateNestedOneWithoutEvolutionsInput
    pokemonStart: pokemon_formCreateNestedOneWithoutEvolutionStartsInput
  }

  export type evolutionUncheckedCreateWithoutPokemonEndInput = {
    id?: number
    level?: number | null
    evolutionMethodId: number
    pokemonFormStartId: number
    evolutionInfoId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolutionCreateOrConnectWithoutPokemonEndInput = {
    where: evolutionWhereUniqueInput
    create: XOR<evolutionCreateWithoutPokemonEndInput, evolutionUncheckedCreateWithoutPokemonEndInput>
  }

  export type evolutionCreateManyPokemonEndInputEnvelope = {
    data: evolutionCreateManyPokemonEndInput | evolutionCreateManyPokemonEndInput[]
    skipDuplicates?: boolean
  }

  export type evolutionCreateWithoutPokemonStartInput = {
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    evolutionInfo: evolution_infoCreateNestedOneWithoutEvolutionsInput
    evolutionMethod: evolution_methodCreateNestedOneWithoutEvolutionsInput
    pokemonEnd: pokemon_formCreateNestedOneWithoutEvolutionEndsInput
  }

  export type evolutionUncheckedCreateWithoutPokemonStartInput = {
    id?: number
    level?: number | null
    evolutionMethodId: number
    pokemonFormEndId: number
    evolutionInfoId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolutionCreateOrConnectWithoutPokemonStartInput = {
    where: evolutionWhereUniqueInput
    create: XOR<evolutionCreateWithoutPokemonStartInput, evolutionUncheckedCreateWithoutPokemonStartInput>
  }

  export type evolutionCreateManyPokemonStartInputEnvelope = {
    data: evolutionCreateManyPokemonStartInput | evolutionCreateManyPokemonStartInput[]
    skipDuplicates?: boolean
  }

  export type owned_pokemonCreateWithoutPokemonFormsInput = {
    id?: bigint | number
    isShiny: boolean
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    game: gameCreateNestedOneWithoutOwnedPokemonsInput
    shinyHuntingMethod: shiny_hunting_methodCreateNestedOneWithoutOwnedPokemonsInput
    users: userCreateNestedOneWithoutOwnedPokemonsInput
    ownedPokemonDetails?: owned_pokemon_detailCreateNestedManyWithoutOwnedPokemonInput
  }

  export type owned_pokemonUncheckedCreateWithoutPokemonFormsInput = {
    id?: bigint | number
    userId: number
    gameId: number
    isShiny: boolean
    methodId: number
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemonDetails?: owned_pokemon_detailUncheckedCreateNestedManyWithoutOwnedPokemonInput
  }

  export type owned_pokemonCreateOrConnectWithoutPokemonFormsInput = {
    where: owned_pokemonWhereUniqueInput
    create: XOR<owned_pokemonCreateWithoutPokemonFormsInput, owned_pokemonUncheckedCreateWithoutPokemonFormsInput>
  }

  export type owned_pokemonCreateManyPokemonFormsInputEnvelope = {
    data: owned_pokemonCreateManyPokemonFormsInput | owned_pokemonCreateManyPokemonFormsInput[]
    skipDuplicates?: boolean
  }

  export type formCreateWithoutPokemonFormsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type formUncheckedCreateWithoutPokemonFormsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type formCreateOrConnectWithoutPokemonFormsInput = {
    where: formWhereUniqueInput
    create: XOR<formCreateWithoutPokemonFormsInput, formUncheckedCreateWithoutPokemonFormsInput>
  }

  export type pokemonCreateWithoutPokemonFormsInput = {
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    nationalNumbers?: national_numberCreateNestedManyWithoutPokemonInput
    pokemon_category: pokemon_categoryCreateNestedOneWithoutPokemonsInput
    generation: generationCreateNestedOneWithoutPokemonsInput
    pokemonInfos?: pokemon_infoCreateNestedManyWithoutPokemonInput
    skillObtations?: skill_obtationCreateNestedManyWithoutPokemonInput
    statisticGroupGames?: statistic_group_gameCreateNestedManyWithoutPokemonInput
  }

  export type pokemonUncheckedCreateWithoutPokemonFormsInput = {
    id?: number
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    pokemonCategoryId: number
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    nationalNumbers?: national_numberUncheckedCreateNestedManyWithoutPokemonInput
    pokemonInfos?: pokemon_infoUncheckedCreateNestedManyWithoutPokemonInput
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutPokemonInput
    statisticGroupGames?: statistic_group_gameUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type pokemonCreateOrConnectWithoutPokemonFormsInput = {
    where: pokemonWhereUniqueInput
    create: XOR<pokemonCreateWithoutPokemonFormsInput, pokemonUncheckedCreateWithoutPokemonFormsInput>
  }

  export type pokemon_form_genderCreateWithoutPokemon_formInput = {
    gender: genderCreateNestedOneWithoutPokemonFormGendersInput
  }

  export type pokemon_form_genderUncheckedCreateWithoutPokemon_formInput = {
    genderId: number
  }

  export type pokemon_form_genderCreateOrConnectWithoutPokemon_formInput = {
    where: pokemon_form_genderWhereUniqueInput
    create: XOR<pokemon_form_genderCreateWithoutPokemon_formInput, pokemon_form_genderUncheckedCreateWithoutPokemon_formInput>
  }

  export type pokemon_form_genderCreateManyPokemon_formInputEnvelope = {
    data: pokemon_form_genderCreateManyPokemon_formInput | pokemon_form_genderCreateManyPokemon_formInput[]
    skipDuplicates?: boolean
  }

  export type pokemon_game_locationCreateWithoutPokemonFormInput = {
    game: gameCreateNestedOneWithoutPokemonRatingGamesInput
    locationZone: location_zoneCreateNestedOneWithoutPokemonRatingGamesInput
    pokemonObtation: pokemon_obtationCreateNestedOneWithoutPokemonRatingGamesInput
    rate: rateCreateNestedOneWithoutPokemonRatingGamesInput
  }

  export type pokemon_game_locationUncheckedCreateWithoutPokemonFormInput = {
    gameId: number
    rateId: number
    locationZoneId: number
    pokemonObtationId: number
    id?: number
  }

  export type pokemon_game_locationCreateOrConnectWithoutPokemonFormInput = {
    where: pokemon_game_locationWhereUniqueInput
    create: XOR<pokemon_game_locationCreateWithoutPokemonFormInput, pokemon_game_locationUncheckedCreateWithoutPokemonFormInput>
  }

  export type pokemon_game_locationCreateManyPokemonFormInputEnvelope = {
    data: pokemon_game_locationCreateManyPokemonFormInput | pokemon_game_locationCreateManyPokemonFormInput[]
    skipDuplicates?: boolean
  }

  export type evolutionUpsertWithWhereUniqueWithoutPokemonEndInput = {
    where: evolutionWhereUniqueInput
    update: XOR<evolutionUpdateWithoutPokemonEndInput, evolutionUncheckedUpdateWithoutPokemonEndInput>
    create: XOR<evolutionCreateWithoutPokemonEndInput, evolutionUncheckedCreateWithoutPokemonEndInput>
  }

  export type evolutionUpdateWithWhereUniqueWithoutPokemonEndInput = {
    where: evolutionWhereUniqueInput
    data: XOR<evolutionUpdateWithoutPokemonEndInput, evolutionUncheckedUpdateWithoutPokemonEndInput>
  }

  export type evolutionUpdateManyWithWhereWithoutPokemonEndInput = {
    where: evolutionScalarWhereInput
    data: XOR<evolutionUpdateManyMutationInput, evolutionUncheckedUpdateManyWithoutPokemonEndInput>
  }

  export type evolutionScalarWhereInput = {
    AND?: evolutionScalarWhereInput | evolutionScalarWhereInput[]
    OR?: evolutionScalarWhereInput[]
    NOT?: evolutionScalarWhereInput | evolutionScalarWhereInput[]
    id?: IntFilter<"evolution"> | number
    level?: IntNullableFilter<"evolution"> | number | null
    evolutionMethodId?: IntFilter<"evolution"> | number
    pokemonFormStartId?: IntFilter<"evolution"> | number
    pokemonFormEndId?: IntFilter<"evolution"> | number
    evolutionInfoId?: IntFilter<"evolution"> | number
    createdAt?: DateTimeFilter<"evolution"> | Date | string
    updatedAt?: DateTimeNullableFilter<"evolution"> | Date | string | null
    status?: StringFilter<"evolution"> | string
  }

  export type evolutionUpsertWithWhereUniqueWithoutPokemonStartInput = {
    where: evolutionWhereUniqueInput
    update: XOR<evolutionUpdateWithoutPokemonStartInput, evolutionUncheckedUpdateWithoutPokemonStartInput>
    create: XOR<evolutionCreateWithoutPokemonStartInput, evolutionUncheckedCreateWithoutPokemonStartInput>
  }

  export type evolutionUpdateWithWhereUniqueWithoutPokemonStartInput = {
    where: evolutionWhereUniqueInput
    data: XOR<evolutionUpdateWithoutPokemonStartInput, evolutionUncheckedUpdateWithoutPokemonStartInput>
  }

  export type evolutionUpdateManyWithWhereWithoutPokemonStartInput = {
    where: evolutionScalarWhereInput
    data: XOR<evolutionUpdateManyMutationInput, evolutionUncheckedUpdateManyWithoutPokemonStartInput>
  }

  export type owned_pokemonUpsertWithWhereUniqueWithoutPokemonFormsInput = {
    where: owned_pokemonWhereUniqueInput
    update: XOR<owned_pokemonUpdateWithoutPokemonFormsInput, owned_pokemonUncheckedUpdateWithoutPokemonFormsInput>
    create: XOR<owned_pokemonCreateWithoutPokemonFormsInput, owned_pokemonUncheckedCreateWithoutPokemonFormsInput>
  }

  export type owned_pokemonUpdateWithWhereUniqueWithoutPokemonFormsInput = {
    where: owned_pokemonWhereUniqueInput
    data: XOR<owned_pokemonUpdateWithoutPokemonFormsInput, owned_pokemonUncheckedUpdateWithoutPokemonFormsInput>
  }

  export type owned_pokemonUpdateManyWithWhereWithoutPokemonFormsInput = {
    where: owned_pokemonScalarWhereInput
    data: XOR<owned_pokemonUpdateManyMutationInput, owned_pokemonUncheckedUpdateManyWithoutPokemonFormsInput>
  }

  export type formUpsertWithoutPokemonFormsInput = {
    update: XOR<formUpdateWithoutPokemonFormsInput, formUncheckedUpdateWithoutPokemonFormsInput>
    create: XOR<formCreateWithoutPokemonFormsInput, formUncheckedCreateWithoutPokemonFormsInput>
    where?: formWhereInput
  }

  export type formUpdateToOneWithWhereWithoutPokemonFormsInput = {
    where?: formWhereInput
    data: XOR<formUpdateWithoutPokemonFormsInput, formUncheckedUpdateWithoutPokemonFormsInput>
  }

  export type formUpdateWithoutPokemonFormsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type formUncheckedUpdateWithoutPokemonFormsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemonUpsertWithoutPokemonFormsInput = {
    update: XOR<pokemonUpdateWithoutPokemonFormsInput, pokemonUncheckedUpdateWithoutPokemonFormsInput>
    create: XOR<pokemonCreateWithoutPokemonFormsInput, pokemonUncheckedCreateWithoutPokemonFormsInput>
    where?: pokemonWhereInput
  }

  export type pokemonUpdateToOneWithWhereWithoutPokemonFormsInput = {
    where?: pokemonWhereInput
    data: XOR<pokemonUpdateWithoutPokemonFormsInput, pokemonUncheckedUpdateWithoutPokemonFormsInput>
  }

  export type pokemonUpdateWithoutPokemonFormsInput = {
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    nationalNumbers?: national_numberUpdateManyWithoutPokemonNestedInput
    pokemon_category?: pokemon_categoryUpdateOneRequiredWithoutPokemonsNestedInput
    generation?: generationUpdateOneRequiredWithoutPokemonsNestedInput
    pokemonInfos?: pokemon_infoUpdateManyWithoutPokemonNestedInput
    skillObtations?: skill_obtationUpdateManyWithoutPokemonNestedInput
    statisticGroupGames?: statistic_group_gameUpdateManyWithoutPokemonNestedInput
  }

  export type pokemonUncheckedUpdateWithoutPokemonFormsInput = {
    id?: IntFieldUpdateOperationsInput | number
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pokemonCategoryId?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    nationalNumbers?: national_numberUncheckedUpdateManyWithoutPokemonNestedInput
    pokemonInfos?: pokemon_infoUncheckedUpdateManyWithoutPokemonNestedInput
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutPokemonNestedInput
    statisticGroupGames?: statistic_group_gameUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type pokemon_form_genderUpsertWithWhereUniqueWithoutPokemon_formInput = {
    where: pokemon_form_genderWhereUniqueInput
    update: XOR<pokemon_form_genderUpdateWithoutPokemon_formInput, pokemon_form_genderUncheckedUpdateWithoutPokemon_formInput>
    create: XOR<pokemon_form_genderCreateWithoutPokemon_formInput, pokemon_form_genderUncheckedCreateWithoutPokemon_formInput>
  }

  export type pokemon_form_genderUpdateWithWhereUniqueWithoutPokemon_formInput = {
    where: pokemon_form_genderWhereUniqueInput
    data: XOR<pokemon_form_genderUpdateWithoutPokemon_formInput, pokemon_form_genderUncheckedUpdateWithoutPokemon_formInput>
  }

  export type pokemon_form_genderUpdateManyWithWhereWithoutPokemon_formInput = {
    where: pokemon_form_genderScalarWhereInput
    data: XOR<pokemon_form_genderUpdateManyMutationInput, pokemon_form_genderUncheckedUpdateManyWithoutPokemon_formInput>
  }

  export type pokemon_game_locationUpsertWithWhereUniqueWithoutPokemonFormInput = {
    where: pokemon_game_locationWhereUniqueInput
    update: XOR<pokemon_game_locationUpdateWithoutPokemonFormInput, pokemon_game_locationUncheckedUpdateWithoutPokemonFormInput>
    create: XOR<pokemon_game_locationCreateWithoutPokemonFormInput, pokemon_game_locationUncheckedCreateWithoutPokemonFormInput>
  }

  export type pokemon_game_locationUpdateWithWhereUniqueWithoutPokemonFormInput = {
    where: pokemon_game_locationWhereUniqueInput
    data: XOR<pokemon_game_locationUpdateWithoutPokemonFormInput, pokemon_game_locationUncheckedUpdateWithoutPokemonFormInput>
  }

  export type pokemon_game_locationUpdateManyWithWhereWithoutPokemonFormInput = {
    where: pokemon_game_locationScalarWhereInput
    data: XOR<pokemon_game_locationUpdateManyMutationInput, pokemon_game_locationUncheckedUpdateManyWithoutPokemonFormInput>
  }

  export type gameCreateWithoutOwnedPokemonsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    generation: generationCreateNestedOneWithoutGamesInput
    gameGroupGames?: game_group_gameCreateNestedManyWithoutGameInput
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutGameInput
  }

  export type gameUncheckedCreateWithoutOwnedPokemonsInput = {
    id?: number
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    gameGroupGames?: game_group_gameUncheckedCreateNestedManyWithoutGameInput
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutGameInput
  }

  export type gameCreateOrConnectWithoutOwnedPokemonsInput = {
    where: gameWhereUniqueInput
    create: XOR<gameCreateWithoutOwnedPokemonsInput, gameUncheckedCreateWithoutOwnedPokemonsInput>
  }

  export type shiny_hunting_methodCreateWithoutOwnedPokemonsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    shinyHuntingMethodGames?: shiny_hunting_method_gameCreateNestedManyWithoutShinyHuntingMethodInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateCreateNestedManyWithoutShinyHuntingMethodInput
  }

  export type shiny_hunting_methodUncheckedCreateWithoutOwnedPokemonsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedCreateNestedManyWithoutShinyHuntingMethodInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedCreateNestedManyWithoutShinyHuntingMethodInput
  }

  export type shiny_hunting_methodCreateOrConnectWithoutOwnedPokemonsInput = {
    where: shiny_hunting_methodWhereUniqueInput
    create: XOR<shiny_hunting_methodCreateWithoutOwnedPokemonsInput, shiny_hunting_methodUncheckedCreateWithoutOwnedPokemonsInput>
  }

  export type pokemon_formCreateWithoutOwnedPokemonsInput = {
    createdAt?: Date | string
    status?: string
    updatedAt?: Date | string | null
    evolutionEnds?: evolutionCreateNestedManyWithoutPokemonEndInput
    evolutionStarts?: evolutionCreateNestedManyWithoutPokemonStartInput
    form: formCreateNestedOneWithoutPokemonFormsInput
    pokemon: pokemonCreateNestedOneWithoutPokemonFormsInput
    pokemonFormGenders?: pokemon_form_genderCreateNestedManyWithoutPokemon_formInput
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutPokemonFormInput
  }

  export type pokemon_formUncheckedCreateWithoutOwnedPokemonsInput = {
    pokemonId: number
    formId: number
    createdAt?: Date | string
    id?: number
    status?: string
    updatedAt?: Date | string | null
    evolutionEnds?: evolutionUncheckedCreateNestedManyWithoutPokemonEndInput
    evolutionStarts?: evolutionUncheckedCreateNestedManyWithoutPokemonStartInput
    pokemonFormGenders?: pokemon_form_genderUncheckedCreateNestedManyWithoutPokemon_formInput
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutPokemonFormInput
  }

  export type pokemon_formCreateOrConnectWithoutOwnedPokemonsInput = {
    where: pokemon_formWhereUniqueInput
    create: XOR<pokemon_formCreateWithoutOwnedPokemonsInput, pokemon_formUncheckedCreateWithoutOwnedPokemonsInput>
  }

  export type userCreateWithoutOwnedPokemonsInput = {
    discordId?: bigint | number | null
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pseudonym: string
    role?: $Enums.role
    refreshTokens?: refresh_tokenCreateNestedManyWithoutUsersInput
  }

  export type userUncheckedCreateWithoutOwnedPokemonsInput = {
    id?: number
    discordId?: bigint | number | null
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pseudonym: string
    role?: $Enums.role
    refreshTokens?: refresh_tokenUncheckedCreateNestedManyWithoutUsersInput
  }

  export type userCreateOrConnectWithoutOwnedPokemonsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutOwnedPokemonsInput, userUncheckedCreateWithoutOwnedPokemonsInput>
  }

  export type owned_pokemon_detailCreateWithoutOwnedPokemonInput = {
    id?: bigint | number
    nickname: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pokeball: pokeballCreateNestedOneWithoutOwnedPokemonDetailsInput
  }

  export type owned_pokemon_detailUncheckedCreateWithoutOwnedPokemonInput = {
    id?: bigint | number
    nickname: string
    pokeballId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type owned_pokemon_detailCreateOrConnectWithoutOwnedPokemonInput = {
    where: owned_pokemon_detailWhereUniqueInput
    create: XOR<owned_pokemon_detailCreateWithoutOwnedPokemonInput, owned_pokemon_detailUncheckedCreateWithoutOwnedPokemonInput>
  }

  export type owned_pokemon_detailCreateManyOwnedPokemonInputEnvelope = {
    data: owned_pokemon_detailCreateManyOwnedPokemonInput | owned_pokemon_detailCreateManyOwnedPokemonInput[]
    skipDuplicates?: boolean
  }

  export type gameUpsertWithoutOwnedPokemonsInput = {
    update: XOR<gameUpdateWithoutOwnedPokemonsInput, gameUncheckedUpdateWithoutOwnedPokemonsInput>
    create: XOR<gameCreateWithoutOwnedPokemonsInput, gameUncheckedCreateWithoutOwnedPokemonsInput>
    where?: gameWhereInput
  }

  export type gameUpdateToOneWithWhereWithoutOwnedPokemonsInput = {
    where?: gameWhereInput
    data: XOR<gameUpdateWithoutOwnedPokemonsInput, gameUncheckedUpdateWithoutOwnedPokemonsInput>
  }

  export type gameUpdateWithoutOwnedPokemonsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    generation?: generationUpdateOneRequiredWithoutGamesNestedInput
    gameGroupGames?: game_group_gameUpdateManyWithoutGameNestedInput
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutGameNestedInput
  }

  export type gameUncheckedUpdateWithoutOwnedPokemonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameGroupGames?: game_group_gameUncheckedUpdateManyWithoutGameNestedInput
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutGameNestedInput
  }

  export type shiny_hunting_methodUpsertWithoutOwnedPokemonsInput = {
    update: XOR<shiny_hunting_methodUpdateWithoutOwnedPokemonsInput, shiny_hunting_methodUncheckedUpdateWithoutOwnedPokemonsInput>
    create: XOR<shiny_hunting_methodCreateWithoutOwnedPokemonsInput, shiny_hunting_methodUncheckedCreateWithoutOwnedPokemonsInput>
    where?: shiny_hunting_methodWhereInput
  }

  export type shiny_hunting_methodUpdateToOneWithWhereWithoutOwnedPokemonsInput = {
    where?: shiny_hunting_methodWhereInput
    data: XOR<shiny_hunting_methodUpdateWithoutOwnedPokemonsInput, shiny_hunting_methodUncheckedUpdateWithoutOwnedPokemonsInput>
  }

  export type shiny_hunting_methodUpdateWithoutOwnedPokemonsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    shinyHuntingMethodGames?: shiny_hunting_method_gameUpdateManyWithoutShinyHuntingMethodNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUpdateManyWithoutShinyHuntingMethodNestedInput
  }

  export type shiny_hunting_methodUncheckedUpdateWithoutOwnedPokemonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedUpdateManyWithoutShinyHuntingMethodNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedUpdateManyWithoutShinyHuntingMethodNestedInput
  }

  export type pokemon_formUpsertWithoutOwnedPokemonsInput = {
    update: XOR<pokemon_formUpdateWithoutOwnedPokemonsInput, pokemon_formUncheckedUpdateWithoutOwnedPokemonsInput>
    create: XOR<pokemon_formCreateWithoutOwnedPokemonsInput, pokemon_formUncheckedCreateWithoutOwnedPokemonsInput>
    where?: pokemon_formWhereInput
  }

  export type pokemon_formUpdateToOneWithWhereWithoutOwnedPokemonsInput = {
    where?: pokemon_formWhereInput
    data: XOR<pokemon_formUpdateWithoutOwnedPokemonsInput, pokemon_formUncheckedUpdateWithoutOwnedPokemonsInput>
  }

  export type pokemon_formUpdateWithoutOwnedPokemonsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionEnds?: evolutionUpdateManyWithoutPokemonEndNestedInput
    evolutionStarts?: evolutionUpdateManyWithoutPokemonStartNestedInput
    form?: formUpdateOneRequiredWithoutPokemonFormsNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutPokemonFormsNestedInput
    pokemonFormGenders?: pokemon_form_genderUpdateManyWithoutPokemon_formNestedInput
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutPokemonFormNestedInput
  }

  export type pokemon_formUncheckedUpdateWithoutOwnedPokemonsInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionEnds?: evolutionUncheckedUpdateManyWithoutPokemonEndNestedInput
    evolutionStarts?: evolutionUncheckedUpdateManyWithoutPokemonStartNestedInput
    pokemonFormGenders?: pokemon_form_genderUncheckedUpdateManyWithoutPokemon_formNestedInput
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutPokemonFormNestedInput
  }

  export type userUpsertWithoutOwnedPokemonsInput = {
    update: XOR<userUpdateWithoutOwnedPokemonsInput, userUncheckedUpdateWithoutOwnedPokemonsInput>
    create: XOR<userCreateWithoutOwnedPokemonsInput, userUncheckedCreateWithoutOwnedPokemonsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutOwnedPokemonsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutOwnedPokemonsInput, userUncheckedUpdateWithoutOwnedPokemonsInput>
  }

  export type userUpdateWithoutOwnedPokemonsInput = {
    discordId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pseudonym?: StringFieldUpdateOperationsInput | string
    role?: EnumroleFieldUpdateOperationsInput | $Enums.role
    refreshTokens?: refresh_tokenUpdateManyWithoutUsersNestedInput
  }

  export type userUncheckedUpdateWithoutOwnedPokemonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    discordId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pseudonym?: StringFieldUpdateOperationsInput | string
    role?: EnumroleFieldUpdateOperationsInput | $Enums.role
    refreshTokens?: refresh_tokenUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type owned_pokemon_detailUpsertWithWhereUniqueWithoutOwnedPokemonInput = {
    where: owned_pokemon_detailWhereUniqueInput
    update: XOR<owned_pokemon_detailUpdateWithoutOwnedPokemonInput, owned_pokemon_detailUncheckedUpdateWithoutOwnedPokemonInput>
    create: XOR<owned_pokemon_detailCreateWithoutOwnedPokemonInput, owned_pokemon_detailUncheckedCreateWithoutOwnedPokemonInput>
  }

  export type owned_pokemon_detailUpdateWithWhereUniqueWithoutOwnedPokemonInput = {
    where: owned_pokemon_detailWhereUniqueInput
    data: XOR<owned_pokemon_detailUpdateWithoutOwnedPokemonInput, owned_pokemon_detailUncheckedUpdateWithoutOwnedPokemonInput>
  }

  export type owned_pokemon_detailUpdateManyWithWhereWithoutOwnedPokemonInput = {
    where: owned_pokemon_detailScalarWhereInput
    data: XOR<owned_pokemon_detailUpdateManyMutationInput, owned_pokemon_detailUncheckedUpdateManyWithoutOwnedPokemonInput>
  }

  export type owned_pokemonCreateWithoutOwnedPokemonDetailsInput = {
    id?: bigint | number
    isShiny: boolean
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    game: gameCreateNestedOneWithoutOwnedPokemonsInput
    shinyHuntingMethod: shiny_hunting_methodCreateNestedOneWithoutOwnedPokemonsInput
    pokemonForms: pokemon_formCreateNestedOneWithoutOwnedPokemonsInput
    users: userCreateNestedOneWithoutOwnedPokemonsInput
  }

  export type owned_pokemonUncheckedCreateWithoutOwnedPokemonDetailsInput = {
    id?: bigint | number
    userId: number
    pokemonFormId: number
    gameId: number
    isShiny: boolean
    methodId: number
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type owned_pokemonCreateOrConnectWithoutOwnedPokemonDetailsInput = {
    where: owned_pokemonWhereUniqueInput
    create: XOR<owned_pokemonCreateWithoutOwnedPokemonDetailsInput, owned_pokemonUncheckedCreateWithoutOwnedPokemonDetailsInput>
  }

  export type pokeballCreateWithoutOwnedPokemonDetailsInput = {
    picture: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokeballUncheckedCreateWithoutOwnedPokemonDetailsInput = {
    id?: number
    picture: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokeballCreateOrConnectWithoutOwnedPokemonDetailsInput = {
    where: pokeballWhereUniqueInput
    create: XOR<pokeballCreateWithoutOwnedPokemonDetailsInput, pokeballUncheckedCreateWithoutOwnedPokemonDetailsInput>
  }

  export type owned_pokemonUpsertWithoutOwnedPokemonDetailsInput = {
    update: XOR<owned_pokemonUpdateWithoutOwnedPokemonDetailsInput, owned_pokemonUncheckedUpdateWithoutOwnedPokemonDetailsInput>
    create: XOR<owned_pokemonCreateWithoutOwnedPokemonDetailsInput, owned_pokemonUncheckedCreateWithoutOwnedPokemonDetailsInput>
    where?: owned_pokemonWhereInput
  }

  export type owned_pokemonUpdateToOneWithWhereWithoutOwnedPokemonDetailsInput = {
    where?: owned_pokemonWhereInput
    data: XOR<owned_pokemonUpdateWithoutOwnedPokemonDetailsInput, owned_pokemonUncheckedUpdateWithoutOwnedPokemonDetailsInput>
  }

  export type owned_pokemonUpdateWithoutOwnedPokemonDetailsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    game?: gameUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    shinyHuntingMethod?: shiny_hunting_methodUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    pokemonForms?: pokemon_formUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    users?: userUpdateOneRequiredWithoutOwnedPokemonsNestedInput
  }

  export type owned_pokemonUncheckedUpdateWithoutOwnedPokemonDetailsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    methodId?: IntFieldUpdateOperationsInput | number
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokeballUpsertWithoutOwnedPokemonDetailsInput = {
    update: XOR<pokeballUpdateWithoutOwnedPokemonDetailsInput, pokeballUncheckedUpdateWithoutOwnedPokemonDetailsInput>
    create: XOR<pokeballCreateWithoutOwnedPokemonDetailsInput, pokeballUncheckedCreateWithoutOwnedPokemonDetailsInput>
    where?: pokeballWhereInput
  }

  export type pokeballUpdateToOneWithWhereWithoutOwnedPokemonDetailsInput = {
    where?: pokeballWhereInput
    data: XOR<pokeballUpdateWithoutOwnedPokemonDetailsInput, pokeballUncheckedUpdateWithoutOwnedPokemonDetailsInput>
  }

  export type pokeballUpdateWithoutOwnedPokemonDetailsInput = {
    picture?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokeballUncheckedUpdateWithoutOwnedPokemonDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    picture?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type generationCreateWithoutAbilitiesInput = {
    id: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityInfos?: ability_infoCreateNestedManyWithoutGenerationInput
    games?: gameCreateNestedManyWithoutGenerationInput
    pokemons?: pokemonCreateNestedManyWithoutGenerationInput
    pokemonInfos?: pokemon_infoCreateNestedManyWithoutGenerationInput
  }

  export type generationUncheckedCreateWithoutAbilitiesInput = {
    id: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityInfos?: ability_infoUncheckedCreateNestedManyWithoutGenerationInput
    games?: gameUncheckedCreateNestedManyWithoutGenerationInput
    pokemons?: pokemonUncheckedCreateNestedManyWithoutGenerationInput
    pokemonInfos?: pokemon_infoUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type generationCreateOrConnectWithoutAbilitiesInput = {
    where: generationWhereUniqueInput
    create: XOR<generationCreateWithoutAbilitiesInput, generationUncheckedCreateWithoutAbilitiesInput>
  }

  export type ability_infoCreateWithoutAbilitiesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    effectWithoutFight: effect_outside_fightCreateNestedOneWithoutAbilityInfosInput
    generation: generationCreateNestedOneWithoutAbilityInfosInput
  }

  export type ability_infoUncheckedCreateWithoutAbilitiesInput = {
    id?: number
    generationId: number
    effectOutsideFightId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type ability_infoCreateOrConnectWithoutAbilitiesInput = {
    where: ability_infoWhereUniqueInput
    create: XOR<ability_infoCreateWithoutAbilitiesInput, ability_infoUncheckedCreateWithoutAbilitiesInput>
  }

  export type ability_infoCreateManyAbilitiesInputEnvelope = {
    data: ability_infoCreateManyAbilitiesInput | ability_infoCreateManyAbilitiesInput[]
    skipDuplicates?: boolean
  }

  export type ability_orderCreateWithoutAbilityInput = {
    order: number
    isHidden: boolean
    pokemonInfo: pokemon_infoCreateNestedOneWithoutAbilityOrdersInput
  }

  export type ability_orderUncheckedCreateWithoutAbilityInput = {
    pokemonInfoId: number
    order: number
    isHidden: boolean
  }

  export type ability_orderCreateOrConnectWithoutAbilityInput = {
    where: ability_orderWhereUniqueInput
    create: XOR<ability_orderCreateWithoutAbilityInput, ability_orderUncheckedCreateWithoutAbilityInput>
  }

  export type ability_orderCreateManyAbilityInputEnvelope = {
    data: ability_orderCreateManyAbilityInput | ability_orderCreateManyAbilityInput[]
    skipDuplicates?: boolean
  }

  export type generationUpsertWithoutAbilitiesInput = {
    update: XOR<generationUpdateWithoutAbilitiesInput, generationUncheckedUpdateWithoutAbilitiesInput>
    create: XOR<generationCreateWithoutAbilitiesInput, generationUncheckedCreateWithoutAbilitiesInput>
    where?: generationWhereInput
  }

  export type generationUpdateToOneWithWhereWithoutAbilitiesInput = {
    where?: generationWhereInput
    data: XOR<generationUpdateWithoutAbilitiesInput, generationUncheckedUpdateWithoutAbilitiesInput>
  }

  export type generationUpdateWithoutAbilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityInfos?: ability_infoUpdateManyWithoutGenerationNestedInput
    games?: gameUpdateManyWithoutGenerationNestedInput
    pokemons?: pokemonUpdateManyWithoutGenerationNestedInput
    pokemonInfos?: pokemon_infoUpdateManyWithoutGenerationNestedInput
  }

  export type generationUncheckedUpdateWithoutAbilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityInfos?: ability_infoUncheckedUpdateManyWithoutGenerationNestedInput
    games?: gameUncheckedUpdateManyWithoutGenerationNestedInput
    pokemons?: pokemonUncheckedUpdateManyWithoutGenerationNestedInput
    pokemonInfos?: pokemon_infoUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type ability_infoUpsertWithWhereUniqueWithoutAbilitiesInput = {
    where: ability_infoWhereUniqueInput
    update: XOR<ability_infoUpdateWithoutAbilitiesInput, ability_infoUncheckedUpdateWithoutAbilitiesInput>
    create: XOR<ability_infoCreateWithoutAbilitiesInput, ability_infoUncheckedCreateWithoutAbilitiesInput>
  }

  export type ability_infoUpdateWithWhereUniqueWithoutAbilitiesInput = {
    where: ability_infoWhereUniqueInput
    data: XOR<ability_infoUpdateWithoutAbilitiesInput, ability_infoUncheckedUpdateWithoutAbilitiesInput>
  }

  export type ability_infoUpdateManyWithWhereWithoutAbilitiesInput = {
    where: ability_infoScalarWhereInput
    data: XOR<ability_infoUpdateManyMutationInput, ability_infoUncheckedUpdateManyWithoutAbilitiesInput>
  }

  export type ability_orderUpsertWithWhereUniqueWithoutAbilityInput = {
    where: ability_orderWhereUniqueInput
    update: XOR<ability_orderUpdateWithoutAbilityInput, ability_orderUncheckedUpdateWithoutAbilityInput>
    create: XOR<ability_orderCreateWithoutAbilityInput, ability_orderUncheckedCreateWithoutAbilityInput>
  }

  export type ability_orderUpdateWithWhereUniqueWithoutAbilityInput = {
    where: ability_orderWhereUniqueInput
    data: XOR<ability_orderUpdateWithoutAbilityInput, ability_orderUncheckedUpdateWithoutAbilityInput>
  }

  export type ability_orderUpdateManyWithWhereWithoutAbilityInput = {
    where: ability_orderScalarWhereInput
    data: XOR<ability_orderUpdateManyMutationInput, ability_orderUncheckedUpdateManyWithoutAbilityInput>
  }

  export type ability_orderScalarWhereInput = {
    AND?: ability_orderScalarWhereInput | ability_orderScalarWhereInput[]
    OR?: ability_orderScalarWhereInput[]
    NOT?: ability_orderScalarWhereInput | ability_orderScalarWhereInput[]
    pokemonInfoId?: IntFilter<"ability_order"> | number
    abilityId?: IntFilter<"ability_order"> | number
    order?: IntFilter<"ability_order"> | number
    isHidden?: BoolFilter<"ability_order"> | boolean
  }

  export type abilityCreateWithoutAbilityInfosInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    generation: generationCreateNestedOneWithoutAbilitiesInput
    abilityOrders?: ability_orderCreateNestedManyWithoutAbilityInput
  }

  export type abilityUncheckedCreateWithoutAbilityInfosInput = {
    id?: number
    appearanceGenerationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityOrders?: ability_orderUncheckedCreateNestedManyWithoutAbilityInput
  }

  export type abilityCreateOrConnectWithoutAbilityInfosInput = {
    where: abilityWhereUniqueInput
    create: XOR<abilityCreateWithoutAbilityInfosInput, abilityUncheckedCreateWithoutAbilityInfosInput>
  }

  export type effect_outside_fightCreateWithoutAbilityInfosInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoCreateNestedManyWithoutEffectOutsideFightInput
  }

  export type effect_outside_fightUncheckedCreateWithoutAbilityInfosInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoUncheckedCreateNestedManyWithoutEffectOutsideFightInput
  }

  export type effect_outside_fightCreateOrConnectWithoutAbilityInfosInput = {
    where: effect_outside_fightWhereUniqueInput
    create: XOR<effect_outside_fightCreateWithoutAbilityInfosInput, effect_outside_fightUncheckedCreateWithoutAbilityInfosInput>
  }

  export type generationCreateWithoutAbilityInfosInput = {
    id: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilities?: abilityCreateNestedManyWithoutGenerationInput
    games?: gameCreateNestedManyWithoutGenerationInput
    pokemons?: pokemonCreateNestedManyWithoutGenerationInput
    pokemonInfos?: pokemon_infoCreateNestedManyWithoutGenerationInput
  }

  export type generationUncheckedCreateWithoutAbilityInfosInput = {
    id: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilities?: abilityUncheckedCreateNestedManyWithoutGenerationInput
    games?: gameUncheckedCreateNestedManyWithoutGenerationInput
    pokemons?: pokemonUncheckedCreateNestedManyWithoutGenerationInput
    pokemonInfos?: pokemon_infoUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type generationCreateOrConnectWithoutAbilityInfosInput = {
    where: generationWhereUniqueInput
    create: XOR<generationCreateWithoutAbilityInfosInput, generationUncheckedCreateWithoutAbilityInfosInput>
  }

  export type abilityUpsertWithoutAbilityInfosInput = {
    update: XOR<abilityUpdateWithoutAbilityInfosInput, abilityUncheckedUpdateWithoutAbilityInfosInput>
    create: XOR<abilityCreateWithoutAbilityInfosInput, abilityUncheckedCreateWithoutAbilityInfosInput>
    where?: abilityWhereInput
  }

  export type abilityUpdateToOneWithWhereWithoutAbilityInfosInput = {
    where?: abilityWhereInput
    data: XOR<abilityUpdateWithoutAbilityInfosInput, abilityUncheckedUpdateWithoutAbilityInfosInput>
  }

  export type abilityUpdateWithoutAbilityInfosInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    generation?: generationUpdateOneRequiredWithoutAbilitiesNestedInput
    abilityOrders?: ability_orderUpdateManyWithoutAbilityNestedInput
  }

  export type abilityUncheckedUpdateWithoutAbilityInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    appearanceGenerationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityOrders?: ability_orderUncheckedUpdateManyWithoutAbilityNestedInput
  }

  export type effect_outside_fightUpsertWithoutAbilityInfosInput = {
    update: XOR<effect_outside_fightUpdateWithoutAbilityInfosInput, effect_outside_fightUncheckedUpdateWithoutAbilityInfosInput>
    create: XOR<effect_outside_fightCreateWithoutAbilityInfosInput, effect_outside_fightUncheckedCreateWithoutAbilityInfosInput>
    where?: effect_outside_fightWhereInput
  }

  export type effect_outside_fightUpdateToOneWithWhereWithoutAbilityInfosInput = {
    where?: effect_outside_fightWhereInput
    data: XOR<effect_outside_fightUpdateWithoutAbilityInfosInput, effect_outside_fightUncheckedUpdateWithoutAbilityInfosInput>
  }

  export type effect_outside_fightUpdateWithoutAbilityInfosInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUpdateManyWithoutEffectOutsideFightNestedInput
  }

  export type effect_outside_fightUncheckedUpdateWithoutAbilityInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUncheckedUpdateManyWithoutEffectOutsideFightNestedInput
  }

  export type generationUpsertWithoutAbilityInfosInput = {
    update: XOR<generationUpdateWithoutAbilityInfosInput, generationUncheckedUpdateWithoutAbilityInfosInput>
    create: XOR<generationCreateWithoutAbilityInfosInput, generationUncheckedCreateWithoutAbilityInfosInput>
    where?: generationWhereInput
  }

  export type generationUpdateToOneWithWhereWithoutAbilityInfosInput = {
    where?: generationWhereInput
    data: XOR<generationUpdateWithoutAbilityInfosInput, generationUncheckedUpdateWithoutAbilityInfosInput>
  }

  export type generationUpdateWithoutAbilityInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilities?: abilityUpdateManyWithoutGenerationNestedInput
    games?: gameUpdateManyWithoutGenerationNestedInput
    pokemons?: pokemonUpdateManyWithoutGenerationNestedInput
    pokemonInfos?: pokemon_infoUpdateManyWithoutGenerationNestedInput
  }

  export type generationUncheckedUpdateWithoutAbilityInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilities?: abilityUncheckedUpdateManyWithoutGenerationNestedInput
    games?: gameUncheckedUpdateManyWithoutGenerationNestedInput
    pokemons?: pokemonUncheckedUpdateManyWithoutGenerationNestedInput
    pokemonInfos?: pokemon_infoUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type ability_orderCreateWithoutPokemonInfoInput = {
    order: number
    isHidden: boolean
    ability: abilityCreateNestedOneWithoutAbilityOrdersInput
  }

  export type ability_orderUncheckedCreateWithoutPokemonInfoInput = {
    abilityId: number
    order: number
    isHidden: boolean
  }

  export type ability_orderCreateOrConnectWithoutPokemonInfoInput = {
    where: ability_orderWhereUniqueInput
    create: XOR<ability_orderCreateWithoutPokemonInfoInput, ability_orderUncheckedCreateWithoutPokemonInfoInput>
  }

  export type ability_orderCreateManyPokemonInfoInputEnvelope = {
    data: ability_orderCreateManyPokemonInfoInput | ability_orderCreateManyPokemonInfoInput[]
    skipDuplicates?: boolean
  }

  export type egg_group_orderCreateWithoutPokemonInfoInput = {
    order: number
    eggGroup: egg_groupCreateNestedOneWithoutEggGroupOrdersInput
  }

  export type egg_group_orderUncheckedCreateWithoutPokemonInfoInput = {
    eggGroupId: number
    order: number
  }

  export type egg_group_orderCreateOrConnectWithoutPokemonInfoInput = {
    where: egg_group_orderWhereUniqueInput
    create: XOR<egg_group_orderCreateWithoutPokemonInfoInput, egg_group_orderUncheckedCreateWithoutPokemonInfoInput>
  }

  export type egg_group_orderCreateManyPokemonInfoInputEnvelope = {
    data: egg_group_orderCreateManyPokemonInfoInput | egg_group_orderCreateManyPokemonInfoInput[]
    skipDuplicates?: boolean
  }

  export type generationCreateWithoutPokemonInfosInput = {
    id: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilities?: abilityCreateNestedManyWithoutGenerationInput
    abilityInfos?: ability_infoCreateNestedManyWithoutGenerationInput
    games?: gameCreateNestedManyWithoutGenerationInput
    pokemons?: pokemonCreateNestedManyWithoutGenerationInput
  }

  export type generationUncheckedCreateWithoutPokemonInfosInput = {
    id: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilities?: abilityUncheckedCreateNestedManyWithoutGenerationInput
    abilityInfos?: ability_infoUncheckedCreateNestedManyWithoutGenerationInput
    games?: gameUncheckedCreateNestedManyWithoutGenerationInput
    pokemons?: pokemonUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type generationCreateOrConnectWithoutPokemonInfosInput = {
    where: generationWhereUniqueInput
    create: XOR<generationCreateWithoutPokemonInfosInput, generationUncheckedCreateWithoutPokemonInfosInput>
  }

  export type pokemonCreateWithoutPokemonInfosInput = {
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    nationalNumbers?: national_numberCreateNestedManyWithoutPokemonInput
    pokemon_category: pokemon_categoryCreateNestedOneWithoutPokemonsInput
    generation: generationCreateNestedOneWithoutPokemonsInput
    pokemonForms?: pokemon_formCreateNestedManyWithoutPokemonInput
    skillObtations?: skill_obtationCreateNestedManyWithoutPokemonInput
    statisticGroupGames?: statistic_group_gameCreateNestedManyWithoutPokemonInput
  }

  export type pokemonUncheckedCreateWithoutPokemonInfosInput = {
    id?: number
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    pokemonCategoryId: number
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    nationalNumbers?: national_numberUncheckedCreateNestedManyWithoutPokemonInput
    pokemonForms?: pokemon_formUncheckedCreateNestedManyWithoutPokemonInput
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutPokemonInput
    statisticGroupGames?: statistic_group_gameUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type pokemonCreateOrConnectWithoutPokemonInfosInput = {
    where: pokemonWhereUniqueInput
    create: XOR<pokemonCreateWithoutPokemonInfosInput, pokemonUncheckedCreateWithoutPokemonInfosInput>
  }

  export type type_orderCreateWithoutPokemonInfoInput = {
    order: number
    type: typeCreateNestedOneWithoutTypeOrdersInput
  }

  export type type_orderUncheckedCreateWithoutPokemonInfoInput = {
    typeId: number
    order: number
  }

  export type type_orderCreateOrConnectWithoutPokemonInfoInput = {
    where: type_orderWhereUniqueInput
    create: XOR<type_orderCreateWithoutPokemonInfoInput, type_orderUncheckedCreateWithoutPokemonInfoInput>
  }

  export type type_orderCreateManyPokemonInfoInputEnvelope = {
    data: type_orderCreateManyPokemonInfoInput | type_orderCreateManyPokemonInfoInput[]
    skipDuplicates?: boolean
  }

  export type ability_orderUpsertWithWhereUniqueWithoutPokemonInfoInput = {
    where: ability_orderWhereUniqueInput
    update: XOR<ability_orderUpdateWithoutPokemonInfoInput, ability_orderUncheckedUpdateWithoutPokemonInfoInput>
    create: XOR<ability_orderCreateWithoutPokemonInfoInput, ability_orderUncheckedCreateWithoutPokemonInfoInput>
  }

  export type ability_orderUpdateWithWhereUniqueWithoutPokemonInfoInput = {
    where: ability_orderWhereUniqueInput
    data: XOR<ability_orderUpdateWithoutPokemonInfoInput, ability_orderUncheckedUpdateWithoutPokemonInfoInput>
  }

  export type ability_orderUpdateManyWithWhereWithoutPokemonInfoInput = {
    where: ability_orderScalarWhereInput
    data: XOR<ability_orderUpdateManyMutationInput, ability_orderUncheckedUpdateManyWithoutPokemonInfoInput>
  }

  export type egg_group_orderUpsertWithWhereUniqueWithoutPokemonInfoInput = {
    where: egg_group_orderWhereUniqueInput
    update: XOR<egg_group_orderUpdateWithoutPokemonInfoInput, egg_group_orderUncheckedUpdateWithoutPokemonInfoInput>
    create: XOR<egg_group_orderCreateWithoutPokemonInfoInput, egg_group_orderUncheckedCreateWithoutPokemonInfoInput>
  }

  export type egg_group_orderUpdateWithWhereUniqueWithoutPokemonInfoInput = {
    where: egg_group_orderWhereUniqueInput
    data: XOR<egg_group_orderUpdateWithoutPokemonInfoInput, egg_group_orderUncheckedUpdateWithoutPokemonInfoInput>
  }

  export type egg_group_orderUpdateManyWithWhereWithoutPokemonInfoInput = {
    where: egg_group_orderScalarWhereInput
    data: XOR<egg_group_orderUpdateManyMutationInput, egg_group_orderUncheckedUpdateManyWithoutPokemonInfoInput>
  }

  export type egg_group_orderScalarWhereInput = {
    AND?: egg_group_orderScalarWhereInput | egg_group_orderScalarWhereInput[]
    OR?: egg_group_orderScalarWhereInput[]
    NOT?: egg_group_orderScalarWhereInput | egg_group_orderScalarWhereInput[]
    pokemonInfoId?: IntFilter<"egg_group_order"> | number
    eggGroupId?: IntFilter<"egg_group_order"> | number
    order?: IntFilter<"egg_group_order"> | number
  }

  export type generationUpsertWithoutPokemonInfosInput = {
    update: XOR<generationUpdateWithoutPokemonInfosInput, generationUncheckedUpdateWithoutPokemonInfosInput>
    create: XOR<generationCreateWithoutPokemonInfosInput, generationUncheckedCreateWithoutPokemonInfosInput>
    where?: generationWhereInput
  }

  export type generationUpdateToOneWithWhereWithoutPokemonInfosInput = {
    where?: generationWhereInput
    data: XOR<generationUpdateWithoutPokemonInfosInput, generationUncheckedUpdateWithoutPokemonInfosInput>
  }

  export type generationUpdateWithoutPokemonInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilities?: abilityUpdateManyWithoutGenerationNestedInput
    abilityInfos?: ability_infoUpdateManyWithoutGenerationNestedInput
    games?: gameUpdateManyWithoutGenerationNestedInput
    pokemons?: pokemonUpdateManyWithoutGenerationNestedInput
  }

  export type generationUncheckedUpdateWithoutPokemonInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilities?: abilityUncheckedUpdateManyWithoutGenerationNestedInput
    abilityInfos?: ability_infoUncheckedUpdateManyWithoutGenerationNestedInput
    games?: gameUncheckedUpdateManyWithoutGenerationNestedInput
    pokemons?: pokemonUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type pokemonUpsertWithoutPokemonInfosInput = {
    update: XOR<pokemonUpdateWithoutPokemonInfosInput, pokemonUncheckedUpdateWithoutPokemonInfosInput>
    create: XOR<pokemonCreateWithoutPokemonInfosInput, pokemonUncheckedCreateWithoutPokemonInfosInput>
    where?: pokemonWhereInput
  }

  export type pokemonUpdateToOneWithWhereWithoutPokemonInfosInput = {
    where?: pokemonWhereInput
    data: XOR<pokemonUpdateWithoutPokemonInfosInput, pokemonUncheckedUpdateWithoutPokemonInfosInput>
  }

  export type pokemonUpdateWithoutPokemonInfosInput = {
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    nationalNumbers?: national_numberUpdateManyWithoutPokemonNestedInput
    pokemon_category?: pokemon_categoryUpdateOneRequiredWithoutPokemonsNestedInput
    generation?: generationUpdateOneRequiredWithoutPokemonsNestedInput
    pokemonForms?: pokemon_formUpdateManyWithoutPokemonNestedInput
    skillObtations?: skill_obtationUpdateManyWithoutPokemonNestedInput
    statisticGroupGames?: statistic_group_gameUpdateManyWithoutPokemonNestedInput
  }

  export type pokemonUncheckedUpdateWithoutPokemonInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pokemonCategoryId?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    nationalNumbers?: national_numberUncheckedUpdateManyWithoutPokemonNestedInput
    pokemonForms?: pokemon_formUncheckedUpdateManyWithoutPokemonNestedInput
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutPokemonNestedInput
    statisticGroupGames?: statistic_group_gameUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type type_orderUpsertWithWhereUniqueWithoutPokemonInfoInput = {
    where: type_orderWhereUniqueInput
    update: XOR<type_orderUpdateWithoutPokemonInfoInput, type_orderUncheckedUpdateWithoutPokemonInfoInput>
    create: XOR<type_orderCreateWithoutPokemonInfoInput, type_orderUncheckedCreateWithoutPokemonInfoInput>
  }

  export type type_orderUpdateWithWhereUniqueWithoutPokemonInfoInput = {
    where: type_orderWhereUniqueInput
    data: XOR<type_orderUpdateWithoutPokemonInfoInput, type_orderUncheckedUpdateWithoutPokemonInfoInput>
  }

  export type type_orderUpdateManyWithWhereWithoutPokemonInfoInput = {
    where: type_orderScalarWhereInput
    data: XOR<type_orderUpdateManyMutationInput, type_orderUncheckedUpdateManyWithoutPokemonInfoInput>
  }

  export type type_orderScalarWhereInput = {
    AND?: type_orderScalarWhereInput | type_orderScalarWhereInput[]
    OR?: type_orderScalarWhereInput[]
    NOT?: type_orderScalarWhereInput | type_orderScalarWhereInput[]
    typeId?: IntFilter<"type_order"> | number
    pokemonInfoId?: IntFilter<"type_order"> | number
    order?: IntFilter<"type_order"> | number
  }

  export type abilityCreateWithoutAbilityOrdersInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    generation: generationCreateNestedOneWithoutAbilitiesInput
    abilityInfos?: ability_infoCreateNestedManyWithoutAbilitiesInput
  }

  export type abilityUncheckedCreateWithoutAbilityOrdersInput = {
    id?: number
    appearanceGenerationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityInfos?: ability_infoUncheckedCreateNestedManyWithoutAbilitiesInput
  }

  export type abilityCreateOrConnectWithoutAbilityOrdersInput = {
    where: abilityWhereUniqueInput
    create: XOR<abilityCreateWithoutAbilityOrdersInput, abilityUncheckedCreateWithoutAbilityOrdersInput>
  }

  export type pokemon_infoCreateWithoutAbilityOrdersInput = {
    xpGift: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    eggGroupOrders?: egg_group_orderCreateNestedManyWithoutPokemonInfoInput
    generation: generationCreateNestedOneWithoutPokemonInfosInput
    pokemon: pokemonCreateNestedOneWithoutPokemonInfosInput
    typeOrders?: type_orderCreateNestedManyWithoutPokemonInfoInput
  }

  export type pokemon_infoUncheckedCreateWithoutAbilityOrdersInput = {
    id?: number
    xpGift: number
    generationId: number
    pokemonId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    eggGroupOrders?: egg_group_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
    typeOrders?: type_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
  }

  export type pokemon_infoCreateOrConnectWithoutAbilityOrdersInput = {
    where: pokemon_infoWhereUniqueInput
    create: XOR<pokemon_infoCreateWithoutAbilityOrdersInput, pokemon_infoUncheckedCreateWithoutAbilityOrdersInput>
  }

  export type abilityUpsertWithoutAbilityOrdersInput = {
    update: XOR<abilityUpdateWithoutAbilityOrdersInput, abilityUncheckedUpdateWithoutAbilityOrdersInput>
    create: XOR<abilityCreateWithoutAbilityOrdersInput, abilityUncheckedCreateWithoutAbilityOrdersInput>
    where?: abilityWhereInput
  }

  export type abilityUpdateToOneWithWhereWithoutAbilityOrdersInput = {
    where?: abilityWhereInput
    data: XOR<abilityUpdateWithoutAbilityOrdersInput, abilityUncheckedUpdateWithoutAbilityOrdersInput>
  }

  export type abilityUpdateWithoutAbilityOrdersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    generation?: generationUpdateOneRequiredWithoutAbilitiesNestedInput
    abilityInfos?: ability_infoUpdateManyWithoutAbilitiesNestedInput
  }

  export type abilityUncheckedUpdateWithoutAbilityOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    appearanceGenerationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityInfos?: ability_infoUncheckedUpdateManyWithoutAbilitiesNestedInput
  }

  export type pokemon_infoUpsertWithoutAbilityOrdersInput = {
    update: XOR<pokemon_infoUpdateWithoutAbilityOrdersInput, pokemon_infoUncheckedUpdateWithoutAbilityOrdersInput>
    create: XOR<pokemon_infoCreateWithoutAbilityOrdersInput, pokemon_infoUncheckedCreateWithoutAbilityOrdersInput>
    where?: pokemon_infoWhereInput
  }

  export type pokemon_infoUpdateToOneWithWhereWithoutAbilityOrdersInput = {
    where?: pokemon_infoWhereInput
    data: XOR<pokemon_infoUpdateWithoutAbilityOrdersInput, pokemon_infoUncheckedUpdateWithoutAbilityOrdersInput>
  }

  export type pokemon_infoUpdateWithoutAbilityOrdersInput = {
    xpGift?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    eggGroupOrders?: egg_group_orderUpdateManyWithoutPokemonInfoNestedInput
    generation?: generationUpdateOneRequiredWithoutPokemonInfosNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutPokemonInfosNestedInput
    typeOrders?: type_orderUpdateManyWithoutPokemonInfoNestedInput
  }

  export type pokemon_infoUncheckedUpdateWithoutAbilityOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    xpGift?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    eggGroupOrders?: egg_group_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
    typeOrders?: type_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
  }

  export type evolutionCreateWithoutEvolutionMethodInput = {
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    evolutionInfo: evolution_infoCreateNestedOneWithoutEvolutionsInput
    pokemonEnd: pokemon_formCreateNestedOneWithoutEvolutionEndsInput
    pokemonStart: pokemon_formCreateNestedOneWithoutEvolutionStartsInput
  }

  export type evolutionUncheckedCreateWithoutEvolutionMethodInput = {
    id?: number
    level?: number | null
    pokemonFormStartId: number
    pokemonFormEndId: number
    evolutionInfoId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolutionCreateOrConnectWithoutEvolutionMethodInput = {
    where: evolutionWhereUniqueInput
    create: XOR<evolutionCreateWithoutEvolutionMethodInput, evolutionUncheckedCreateWithoutEvolutionMethodInput>
  }

  export type evolutionCreateManyEvolutionMethodInputEnvelope = {
    data: evolutionCreateManyEvolutionMethodInput | evolutionCreateManyEvolutionMethodInput[]
    skipDuplicates?: boolean
  }

  export type evolutionUpsertWithWhereUniqueWithoutEvolutionMethodInput = {
    where: evolutionWhereUniqueInput
    update: XOR<evolutionUpdateWithoutEvolutionMethodInput, evolutionUncheckedUpdateWithoutEvolutionMethodInput>
    create: XOR<evolutionCreateWithoutEvolutionMethodInput, evolutionUncheckedCreateWithoutEvolutionMethodInput>
  }

  export type evolutionUpdateWithWhereUniqueWithoutEvolutionMethodInput = {
    where: evolutionWhereUniqueInput
    data: XOR<evolutionUpdateWithoutEvolutionMethodInput, evolutionUncheckedUpdateWithoutEvolutionMethodInput>
  }

  export type evolutionUpdateManyWithWhereWithoutEvolutionMethodInput = {
    where: evolutionScalarWhereInput
    data: XOR<evolutionUpdateManyMutationInput, evolutionUncheckedUpdateManyWithoutEvolutionMethodInput>
  }

  export type evolution_infoCreateWithoutEvolutionsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolution_infoUncheckedCreateWithoutEvolutionsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolution_infoCreateOrConnectWithoutEvolutionsInput = {
    where: evolution_infoWhereUniqueInput
    create: XOR<evolution_infoCreateWithoutEvolutionsInput, evolution_infoUncheckedCreateWithoutEvolutionsInput>
  }

  export type evolution_methodCreateWithoutEvolutionsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolution_methodUncheckedCreateWithoutEvolutionsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolution_methodCreateOrConnectWithoutEvolutionsInput = {
    where: evolution_methodWhereUniqueInput
    create: XOR<evolution_methodCreateWithoutEvolutionsInput, evolution_methodUncheckedCreateWithoutEvolutionsInput>
  }

  export type pokemon_formCreateWithoutEvolutionEndsInput = {
    createdAt?: Date | string
    status?: string
    updatedAt?: Date | string | null
    evolutionStarts?: evolutionCreateNestedManyWithoutPokemonStartInput
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutPokemonFormsInput
    form: formCreateNestedOneWithoutPokemonFormsInput
    pokemon: pokemonCreateNestedOneWithoutPokemonFormsInput
    pokemonFormGenders?: pokemon_form_genderCreateNestedManyWithoutPokemon_formInput
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutPokemonFormInput
  }

  export type pokemon_formUncheckedCreateWithoutEvolutionEndsInput = {
    pokemonId: number
    formId: number
    createdAt?: Date | string
    id?: number
    status?: string
    updatedAt?: Date | string | null
    evolutionStarts?: evolutionUncheckedCreateNestedManyWithoutPokemonStartInput
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutPokemonFormsInput
    pokemonFormGenders?: pokemon_form_genderUncheckedCreateNestedManyWithoutPokemon_formInput
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutPokemonFormInput
  }

  export type pokemon_formCreateOrConnectWithoutEvolutionEndsInput = {
    where: pokemon_formWhereUniqueInput
    create: XOR<pokemon_formCreateWithoutEvolutionEndsInput, pokemon_formUncheckedCreateWithoutEvolutionEndsInput>
  }

  export type pokemon_formCreateWithoutEvolutionStartsInput = {
    createdAt?: Date | string
    status?: string
    updatedAt?: Date | string | null
    evolutionEnds?: evolutionCreateNestedManyWithoutPokemonEndInput
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutPokemonFormsInput
    form: formCreateNestedOneWithoutPokemonFormsInput
    pokemon: pokemonCreateNestedOneWithoutPokemonFormsInput
    pokemonFormGenders?: pokemon_form_genderCreateNestedManyWithoutPokemon_formInput
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutPokemonFormInput
  }

  export type pokemon_formUncheckedCreateWithoutEvolutionStartsInput = {
    pokemonId: number
    formId: number
    createdAt?: Date | string
    id?: number
    status?: string
    updatedAt?: Date | string | null
    evolutionEnds?: evolutionUncheckedCreateNestedManyWithoutPokemonEndInput
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutPokemonFormsInput
    pokemonFormGenders?: pokemon_form_genderUncheckedCreateNestedManyWithoutPokemon_formInput
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutPokemonFormInput
  }

  export type pokemon_formCreateOrConnectWithoutEvolutionStartsInput = {
    where: pokemon_formWhereUniqueInput
    create: XOR<pokemon_formCreateWithoutEvolutionStartsInput, pokemon_formUncheckedCreateWithoutEvolutionStartsInput>
  }

  export type evolution_infoUpsertWithoutEvolutionsInput = {
    update: XOR<evolution_infoUpdateWithoutEvolutionsInput, evolution_infoUncheckedUpdateWithoutEvolutionsInput>
    create: XOR<evolution_infoCreateWithoutEvolutionsInput, evolution_infoUncheckedCreateWithoutEvolutionsInput>
    where?: evolution_infoWhereInput
  }

  export type evolution_infoUpdateToOneWithWhereWithoutEvolutionsInput = {
    where?: evolution_infoWhereInput
    data: XOR<evolution_infoUpdateWithoutEvolutionsInput, evolution_infoUncheckedUpdateWithoutEvolutionsInput>
  }

  export type evolution_infoUpdateWithoutEvolutionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolution_infoUncheckedUpdateWithoutEvolutionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolution_methodUpsertWithoutEvolutionsInput = {
    update: XOR<evolution_methodUpdateWithoutEvolutionsInput, evolution_methodUncheckedUpdateWithoutEvolutionsInput>
    create: XOR<evolution_methodCreateWithoutEvolutionsInput, evolution_methodUncheckedCreateWithoutEvolutionsInput>
    where?: evolution_methodWhereInput
  }

  export type evolution_methodUpdateToOneWithWhereWithoutEvolutionsInput = {
    where?: evolution_methodWhereInput
    data: XOR<evolution_methodUpdateWithoutEvolutionsInput, evolution_methodUncheckedUpdateWithoutEvolutionsInput>
  }

  export type evolution_methodUpdateWithoutEvolutionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolution_methodUncheckedUpdateWithoutEvolutionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_formUpsertWithoutEvolutionEndsInput = {
    update: XOR<pokemon_formUpdateWithoutEvolutionEndsInput, pokemon_formUncheckedUpdateWithoutEvolutionEndsInput>
    create: XOR<pokemon_formCreateWithoutEvolutionEndsInput, pokemon_formUncheckedCreateWithoutEvolutionEndsInput>
    where?: pokemon_formWhereInput
  }

  export type pokemon_formUpdateToOneWithWhereWithoutEvolutionEndsInput = {
    where?: pokemon_formWhereInput
    data: XOR<pokemon_formUpdateWithoutEvolutionEndsInput, pokemon_formUncheckedUpdateWithoutEvolutionEndsInput>
  }

  export type pokemon_formUpdateWithoutEvolutionEndsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionStarts?: evolutionUpdateManyWithoutPokemonStartNestedInput
    ownedPokemons?: owned_pokemonUpdateManyWithoutPokemonFormsNestedInput
    form?: formUpdateOneRequiredWithoutPokemonFormsNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutPokemonFormsNestedInput
    pokemonFormGenders?: pokemon_form_genderUpdateManyWithoutPokemon_formNestedInput
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutPokemonFormNestedInput
  }

  export type pokemon_formUncheckedUpdateWithoutEvolutionEndsInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionStarts?: evolutionUncheckedUpdateManyWithoutPokemonStartNestedInput
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutPokemonFormsNestedInput
    pokemonFormGenders?: pokemon_form_genderUncheckedUpdateManyWithoutPokemon_formNestedInput
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutPokemonFormNestedInput
  }

  export type pokemon_formUpsertWithoutEvolutionStartsInput = {
    update: XOR<pokemon_formUpdateWithoutEvolutionStartsInput, pokemon_formUncheckedUpdateWithoutEvolutionStartsInput>
    create: XOR<pokemon_formCreateWithoutEvolutionStartsInput, pokemon_formUncheckedCreateWithoutEvolutionStartsInput>
    where?: pokemon_formWhereInput
  }

  export type pokemon_formUpdateToOneWithWhereWithoutEvolutionStartsInput = {
    where?: pokemon_formWhereInput
    data: XOR<pokemon_formUpdateWithoutEvolutionStartsInput, pokemon_formUncheckedUpdateWithoutEvolutionStartsInput>
  }

  export type pokemon_formUpdateWithoutEvolutionStartsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionEnds?: evolutionUpdateManyWithoutPokemonEndNestedInput
    ownedPokemons?: owned_pokemonUpdateManyWithoutPokemonFormsNestedInput
    form?: formUpdateOneRequiredWithoutPokemonFormsNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutPokemonFormsNestedInput
    pokemonFormGenders?: pokemon_form_genderUpdateManyWithoutPokemon_formNestedInput
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutPokemonFormNestedInput
  }

  export type pokemon_formUncheckedUpdateWithoutEvolutionStartsInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionEnds?: evolutionUncheckedUpdateManyWithoutPokemonEndNestedInput
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutPokemonFormsNestedInput
    pokemonFormGenders?: pokemon_form_genderUncheckedUpdateManyWithoutPokemon_formNestedInput
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutPokemonFormNestedInput
  }

  export type evolutionCreateWithoutEvolutionInfoInput = {
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    evolutionMethod: evolution_methodCreateNestedOneWithoutEvolutionsInput
    pokemonEnd: pokemon_formCreateNestedOneWithoutEvolutionEndsInput
    pokemonStart: pokemon_formCreateNestedOneWithoutEvolutionStartsInput
  }

  export type evolutionUncheckedCreateWithoutEvolutionInfoInput = {
    id?: number
    level?: number | null
    evolutionMethodId: number
    pokemonFormStartId: number
    pokemonFormEndId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolutionCreateOrConnectWithoutEvolutionInfoInput = {
    where: evolutionWhereUniqueInput
    create: XOR<evolutionCreateWithoutEvolutionInfoInput, evolutionUncheckedCreateWithoutEvolutionInfoInput>
  }

  export type evolutionCreateManyEvolutionInfoInputEnvelope = {
    data: evolutionCreateManyEvolutionInfoInput | evolutionCreateManyEvolutionInfoInput[]
    skipDuplicates?: boolean
  }

  export type evolutionUpsertWithWhereUniqueWithoutEvolutionInfoInput = {
    where: evolutionWhereUniqueInput
    update: XOR<evolutionUpdateWithoutEvolutionInfoInput, evolutionUncheckedUpdateWithoutEvolutionInfoInput>
    create: XOR<evolutionCreateWithoutEvolutionInfoInput, evolutionUncheckedCreateWithoutEvolutionInfoInput>
  }

  export type evolutionUpdateWithWhereUniqueWithoutEvolutionInfoInput = {
    where: evolutionWhereUniqueInput
    data: XOR<evolutionUpdateWithoutEvolutionInfoInput, evolutionUncheckedUpdateWithoutEvolutionInfoInput>
  }

  export type evolutionUpdateManyWithWhereWithoutEvolutionInfoInput = {
    where: evolutionScalarWhereInput
    data: XOR<evolutionUpdateManyMutationInput, evolutionUncheckedUpdateManyWithoutEvolutionInfoInput>
  }

  export type egg_group_orderCreateWithoutEggGroupInput = {
    order: number
    pokemonInfo: pokemon_infoCreateNestedOneWithoutEggGroupOrdersInput
  }

  export type egg_group_orderUncheckedCreateWithoutEggGroupInput = {
    pokemonInfoId: number
    order: number
  }

  export type egg_group_orderCreateOrConnectWithoutEggGroupInput = {
    where: egg_group_orderWhereUniqueInput
    create: XOR<egg_group_orderCreateWithoutEggGroupInput, egg_group_orderUncheckedCreateWithoutEggGroupInput>
  }

  export type egg_group_orderCreateManyEggGroupInputEnvelope = {
    data: egg_group_orderCreateManyEggGroupInput | egg_group_orderCreateManyEggGroupInput[]
    skipDuplicates?: boolean
  }

  export type egg_group_orderUpsertWithWhereUniqueWithoutEggGroupInput = {
    where: egg_group_orderWhereUniqueInput
    update: XOR<egg_group_orderUpdateWithoutEggGroupInput, egg_group_orderUncheckedUpdateWithoutEggGroupInput>
    create: XOR<egg_group_orderCreateWithoutEggGroupInput, egg_group_orderUncheckedCreateWithoutEggGroupInput>
  }

  export type egg_group_orderUpdateWithWhereUniqueWithoutEggGroupInput = {
    where: egg_group_orderWhereUniqueInput
    data: XOR<egg_group_orderUpdateWithoutEggGroupInput, egg_group_orderUncheckedUpdateWithoutEggGroupInput>
  }

  export type egg_group_orderUpdateManyWithWhereWithoutEggGroupInput = {
    where: egg_group_orderScalarWhereInput
    data: XOR<egg_group_orderUpdateManyMutationInput, egg_group_orderUncheckedUpdateManyWithoutEggGroupInput>
  }

  export type egg_groupCreateWithoutEggGroupOrdersInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type egg_groupUncheckedCreateWithoutEggGroupOrdersInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type egg_groupCreateOrConnectWithoutEggGroupOrdersInput = {
    where: egg_groupWhereUniqueInput
    create: XOR<egg_groupCreateWithoutEggGroupOrdersInput, egg_groupUncheckedCreateWithoutEggGroupOrdersInput>
  }

  export type pokemon_infoCreateWithoutEggGroupOrdersInput = {
    xpGift: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityOrders?: ability_orderCreateNestedManyWithoutPokemonInfoInput
    generation: generationCreateNestedOneWithoutPokemonInfosInput
    pokemon: pokemonCreateNestedOneWithoutPokemonInfosInput
    typeOrders?: type_orderCreateNestedManyWithoutPokemonInfoInput
  }

  export type pokemon_infoUncheckedCreateWithoutEggGroupOrdersInput = {
    id?: number
    xpGift: number
    generationId: number
    pokemonId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityOrders?: ability_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
    typeOrders?: type_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
  }

  export type pokemon_infoCreateOrConnectWithoutEggGroupOrdersInput = {
    where: pokemon_infoWhereUniqueInput
    create: XOR<pokemon_infoCreateWithoutEggGroupOrdersInput, pokemon_infoUncheckedCreateWithoutEggGroupOrdersInput>
  }

  export type egg_groupUpsertWithoutEggGroupOrdersInput = {
    update: XOR<egg_groupUpdateWithoutEggGroupOrdersInput, egg_groupUncheckedUpdateWithoutEggGroupOrdersInput>
    create: XOR<egg_groupCreateWithoutEggGroupOrdersInput, egg_groupUncheckedCreateWithoutEggGroupOrdersInput>
    where?: egg_groupWhereInput
  }

  export type egg_groupUpdateToOneWithWhereWithoutEggGroupOrdersInput = {
    where?: egg_groupWhereInput
    data: XOR<egg_groupUpdateWithoutEggGroupOrdersInput, egg_groupUncheckedUpdateWithoutEggGroupOrdersInput>
  }

  export type egg_groupUpdateWithoutEggGroupOrdersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type egg_groupUncheckedUpdateWithoutEggGroupOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_infoUpsertWithoutEggGroupOrdersInput = {
    update: XOR<pokemon_infoUpdateWithoutEggGroupOrdersInput, pokemon_infoUncheckedUpdateWithoutEggGroupOrdersInput>
    create: XOR<pokemon_infoCreateWithoutEggGroupOrdersInput, pokemon_infoUncheckedCreateWithoutEggGroupOrdersInput>
    where?: pokemon_infoWhereInput
  }

  export type pokemon_infoUpdateToOneWithWhereWithoutEggGroupOrdersInput = {
    where?: pokemon_infoWhereInput
    data: XOR<pokemon_infoUpdateWithoutEggGroupOrdersInput, pokemon_infoUncheckedUpdateWithoutEggGroupOrdersInput>
  }

  export type pokemon_infoUpdateWithoutEggGroupOrdersInput = {
    xpGift?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityOrders?: ability_orderUpdateManyWithoutPokemonInfoNestedInput
    generation?: generationUpdateOneRequiredWithoutPokemonInfosNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutPokemonInfosNestedInput
    typeOrders?: type_orderUpdateManyWithoutPokemonInfoNestedInput
  }

  export type pokemon_infoUncheckedUpdateWithoutEggGroupOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    xpGift?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityOrders?: ability_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
    typeOrders?: type_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
  }

  export type capacity_infoCreateWithoutTypeInput = {
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityCategory: capacity_categoryCreateNestedOneWithoutCapacityInfosInput
    capacityEffect: capacity_effectCreateNestedOneWithoutCapacityInfosInput
    capacityEffectZ: capacity_effectCreateNestedOneWithoutCapacityZInfosInput
    capacity: capacityCreateNestedOneWithoutCapacityInfosInput
    effectOutsideFight: effect_outside_fightCreateNestedOneWithoutCapacityInfosInput
    target: targetCreateNestedOneWithoutCapacityInfosInput
    capacityInfoInfluences?: capacity_info_influenceCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoUncheckedCreateWithoutTypeInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityId: number
    capacityEffectZId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfoInfluences?: capacity_info_influenceUncheckedCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoCreateOrConnectWithoutTypeInput = {
    where: capacity_infoWhereUniqueInput
    create: XOR<capacity_infoCreateWithoutTypeInput, capacity_infoUncheckedCreateWithoutTypeInput>
  }

  export type capacity_infoCreateManyTypeInputEnvelope = {
    data: capacity_infoCreateManyTypeInput | capacity_infoCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type type_orderCreateWithoutTypeInput = {
    order: number
    pokemonInfo: pokemon_infoCreateNestedOneWithoutTypeOrdersInput
  }

  export type type_orderUncheckedCreateWithoutTypeInput = {
    pokemonInfoId: number
    order: number
  }

  export type type_orderCreateOrConnectWithoutTypeInput = {
    where: type_orderWhereUniqueInput
    create: XOR<type_orderCreateWithoutTypeInput, type_orderUncheckedCreateWithoutTypeInput>
  }

  export type type_orderCreateManyTypeInputEnvelope = {
    data: type_orderCreateManyTypeInput | type_orderCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type capacity_infoUpsertWithWhereUniqueWithoutTypeInput = {
    where: capacity_infoWhereUniqueInput
    update: XOR<capacity_infoUpdateWithoutTypeInput, capacity_infoUncheckedUpdateWithoutTypeInput>
    create: XOR<capacity_infoCreateWithoutTypeInput, capacity_infoUncheckedCreateWithoutTypeInput>
  }

  export type capacity_infoUpdateWithWhereUniqueWithoutTypeInput = {
    where: capacity_infoWhereUniqueInput
    data: XOR<capacity_infoUpdateWithoutTypeInput, capacity_infoUncheckedUpdateWithoutTypeInput>
  }

  export type capacity_infoUpdateManyWithWhereWithoutTypeInput = {
    where: capacity_infoScalarWhereInput
    data: XOR<capacity_infoUpdateManyMutationInput, capacity_infoUncheckedUpdateManyWithoutTypeInput>
  }

  export type capacity_infoScalarWhereInput = {
    AND?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
    OR?: capacity_infoScalarWhereInput[]
    NOT?: capacity_infoScalarWhereInput | capacity_infoScalarWhereInput[]
    id?: IntFilter<"capacity_info"> | number
    power?: IntFilter<"capacity_info"> | number
    dynamaxPower?: IntFilter<"capacity_info"> | number
    precision?: IntFilter<"capacity_info"> | number
    pp?: IntFilter<"capacity_info"> | number
    hasBacklash?: BoolFilter<"capacity_info"> | boolean
    targetId?: IntFilter<"capacity_info"> | number
    capacityEffectId?: IntFilter<"capacity_info"> | number
    capacityId?: IntFilter<"capacity_info"> | number
    capacityEffectZId?: IntFilter<"capacity_info"> | number
    typeId?: IntFilter<"capacity_info"> | number
    effectOutsideFightId?: IntFilter<"capacity_info"> | number
    capacityCategoryId?: IntFilter<"capacity_info"> | number
    createdAt?: DateTimeFilter<"capacity_info"> | Date | string
    updatedAt?: DateTimeNullableFilter<"capacity_info"> | Date | string | null
    status?: StringFilter<"capacity_info"> | string
  }

  export type type_orderUpsertWithWhereUniqueWithoutTypeInput = {
    where: type_orderWhereUniqueInput
    update: XOR<type_orderUpdateWithoutTypeInput, type_orderUncheckedUpdateWithoutTypeInput>
    create: XOR<type_orderCreateWithoutTypeInput, type_orderUncheckedCreateWithoutTypeInput>
  }

  export type type_orderUpdateWithWhereUniqueWithoutTypeInput = {
    where: type_orderWhereUniqueInput
    data: XOR<type_orderUpdateWithoutTypeInput, type_orderUncheckedUpdateWithoutTypeInput>
  }

  export type type_orderUpdateManyWithWhereWithoutTypeInput = {
    where: type_orderScalarWhereInput
    data: XOR<type_orderUpdateManyMutationInput, type_orderUncheckedUpdateManyWithoutTypeInput>
  }

  export type pokemon_infoCreateWithoutTypeOrdersInput = {
    xpGift: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityOrders?: ability_orderCreateNestedManyWithoutPokemonInfoInput
    eggGroupOrders?: egg_group_orderCreateNestedManyWithoutPokemonInfoInput
    generation: generationCreateNestedOneWithoutPokemonInfosInput
    pokemon: pokemonCreateNestedOneWithoutPokemonInfosInput
  }

  export type pokemon_infoUncheckedCreateWithoutTypeOrdersInput = {
    id?: number
    xpGift: number
    generationId: number
    pokemonId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityOrders?: ability_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
    eggGroupOrders?: egg_group_orderUncheckedCreateNestedManyWithoutPokemonInfoInput
  }

  export type pokemon_infoCreateOrConnectWithoutTypeOrdersInput = {
    where: pokemon_infoWhereUniqueInput
    create: XOR<pokemon_infoCreateWithoutTypeOrdersInput, pokemon_infoUncheckedCreateWithoutTypeOrdersInput>
  }

  export type typeCreateWithoutTypeOrdersInput = {
    color: string
    iconName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoCreateNestedManyWithoutTypeInput
  }

  export type typeUncheckedCreateWithoutTypeOrdersInput = {
    id?: number
    color: string
    iconName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoUncheckedCreateNestedManyWithoutTypeInput
  }

  export type typeCreateOrConnectWithoutTypeOrdersInput = {
    where: typeWhereUniqueInput
    create: XOR<typeCreateWithoutTypeOrdersInput, typeUncheckedCreateWithoutTypeOrdersInput>
  }

  export type pokemon_infoUpsertWithoutTypeOrdersInput = {
    update: XOR<pokemon_infoUpdateWithoutTypeOrdersInput, pokemon_infoUncheckedUpdateWithoutTypeOrdersInput>
    create: XOR<pokemon_infoCreateWithoutTypeOrdersInput, pokemon_infoUncheckedCreateWithoutTypeOrdersInput>
    where?: pokemon_infoWhereInput
  }

  export type pokemon_infoUpdateToOneWithWhereWithoutTypeOrdersInput = {
    where?: pokemon_infoWhereInput
    data: XOR<pokemon_infoUpdateWithoutTypeOrdersInput, pokemon_infoUncheckedUpdateWithoutTypeOrdersInput>
  }

  export type pokemon_infoUpdateWithoutTypeOrdersInput = {
    xpGift?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityOrders?: ability_orderUpdateManyWithoutPokemonInfoNestedInput
    eggGroupOrders?: egg_group_orderUpdateManyWithoutPokemonInfoNestedInput
    generation?: generationUpdateOneRequiredWithoutPokemonInfosNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutPokemonInfosNestedInput
  }

  export type pokemon_infoUncheckedUpdateWithoutTypeOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    xpGift?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityOrders?: ability_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
    eggGroupOrders?: egg_group_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
  }

  export type typeUpsertWithoutTypeOrdersInput = {
    update: XOR<typeUpdateWithoutTypeOrdersInput, typeUncheckedUpdateWithoutTypeOrdersInput>
    create: XOR<typeCreateWithoutTypeOrdersInput, typeUncheckedCreateWithoutTypeOrdersInput>
    where?: typeWhereInput
  }

  export type typeUpdateToOneWithWhereWithoutTypeOrdersInput = {
    where?: typeWhereInput
    data: XOR<typeUpdateWithoutTypeOrdersInput, typeUncheckedUpdateWithoutTypeOrdersInput>
  }

  export type typeUpdateWithoutTypeOrdersInput = {
    color?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUpdateManyWithoutTypeNestedInput
  }

  export type typeUncheckedUpdateWithoutTypeOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type group_gameCreateWithoutNationnalNumbersInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoCreateNestedManyWithoutGroupGameInput
    gameGroupGames?: game_group_gameCreateNestedManyWithoutGroupGameInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameCreateNestedManyWithoutGroupGameInput
    skillObtations?: skill_obtationCreateNestedManyWithoutGroupGameInput
    statisticGroupGames?: statistic_group_gameCreateNestedManyWithoutGroupGameInput
  }

  export type group_gameUncheckedCreateWithoutNationnalNumbersInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutGroupGameInput
    gameGroupGames?: game_group_gameUncheckedCreateNestedManyWithoutGroupGameInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedCreateNestedManyWithoutGroupGameInput
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutGroupGameInput
    statisticGroupGames?: statistic_group_gameUncheckedCreateNestedManyWithoutGroupGameInput
  }

  export type group_gameCreateOrConnectWithoutNationnalNumbersInput = {
    where: group_gameWhereUniqueInput
    create: XOR<group_gameCreateWithoutNationnalNumbersInput, group_gameUncheckedCreateWithoutNationnalNumbersInput>
  }

  export type pokemonCreateWithoutNationalNumbersInput = {
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pokemon_category: pokemon_categoryCreateNestedOneWithoutPokemonsInput
    generation: generationCreateNestedOneWithoutPokemonsInput
    pokemonForms?: pokemon_formCreateNestedManyWithoutPokemonInput
    pokemonInfos?: pokemon_infoCreateNestedManyWithoutPokemonInput
    skillObtations?: skill_obtationCreateNestedManyWithoutPokemonInput
    statisticGroupGames?: statistic_group_gameCreateNestedManyWithoutPokemonInput
  }

  export type pokemonUncheckedCreateWithoutNationalNumbersInput = {
    id?: number
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    pokemonCategoryId: number
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pokemonForms?: pokemon_formUncheckedCreateNestedManyWithoutPokemonInput
    pokemonInfos?: pokemon_infoUncheckedCreateNestedManyWithoutPokemonInput
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutPokemonInput
    statisticGroupGames?: statistic_group_gameUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type pokemonCreateOrConnectWithoutNationalNumbersInput = {
    where: pokemonWhereUniqueInput
    create: XOR<pokemonCreateWithoutNationalNumbersInput, pokemonUncheckedCreateWithoutNationalNumbersInput>
  }

  export type group_gameUpsertWithoutNationnalNumbersInput = {
    update: XOR<group_gameUpdateWithoutNationnalNumbersInput, group_gameUncheckedUpdateWithoutNationnalNumbersInput>
    create: XOR<group_gameCreateWithoutNationnalNumbersInput, group_gameUncheckedCreateWithoutNationnalNumbersInput>
    where?: group_gameWhereInput
  }

  export type group_gameUpdateToOneWithWhereWithoutNationnalNumbersInput = {
    where?: group_gameWhereInput
    data: XOR<group_gameUpdateWithoutNationnalNumbersInput, group_gameUncheckedUpdateWithoutNationnalNumbersInput>
  }

  export type group_gameUpdateWithoutNationnalNumbersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUpdateManyWithoutGroupGameNestedInput
    gameGroupGames?: game_group_gameUpdateManyWithoutGroupGameNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUpdateManyWithoutGroupGameNestedInput
    skillObtations?: skill_obtationUpdateManyWithoutGroupGameNestedInput
    statisticGroupGames?: statistic_group_gameUpdateManyWithoutGroupGameNestedInput
  }

  export type group_gameUncheckedUpdateWithoutNationnalNumbersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutGroupGameNestedInput
    gameGroupGames?: game_group_gameUncheckedUpdateManyWithoutGroupGameNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedUpdateManyWithoutGroupGameNestedInput
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutGroupGameNestedInput
    statisticGroupGames?: statistic_group_gameUncheckedUpdateManyWithoutGroupGameNestedInput
  }

  export type pokemonUpsertWithoutNationalNumbersInput = {
    update: XOR<pokemonUpdateWithoutNationalNumbersInput, pokemonUncheckedUpdateWithoutNationalNumbersInput>
    create: XOR<pokemonCreateWithoutNationalNumbersInput, pokemonUncheckedCreateWithoutNationalNumbersInput>
    where?: pokemonWhereInput
  }

  export type pokemonUpdateToOneWithWhereWithoutNationalNumbersInput = {
    where?: pokemonWhereInput
    data: XOR<pokemonUpdateWithoutNationalNumbersInput, pokemonUncheckedUpdateWithoutNationalNumbersInput>
  }

  export type pokemonUpdateWithoutNationalNumbersInput = {
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pokemon_category?: pokemon_categoryUpdateOneRequiredWithoutPokemonsNestedInput
    generation?: generationUpdateOneRequiredWithoutPokemonsNestedInput
    pokemonForms?: pokemon_formUpdateManyWithoutPokemonNestedInput
    pokemonInfos?: pokemon_infoUpdateManyWithoutPokemonNestedInput
    skillObtations?: skill_obtationUpdateManyWithoutPokemonNestedInput
    statisticGroupGames?: statistic_group_gameUpdateManyWithoutPokemonNestedInput
  }

  export type pokemonUncheckedUpdateWithoutNationalNumbersInput = {
    id?: IntFieldUpdateOperationsInput | number
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pokemonCategoryId?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pokemonForms?: pokemon_formUncheckedUpdateManyWithoutPokemonNestedInput
    pokemonInfos?: pokemon_infoUncheckedUpdateManyWithoutPokemonNestedInput
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutPokemonNestedInput
    statisticGroupGames?: statistic_group_gameUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type game_group_gameCreateWithoutLandInput = {
    game: gameCreateNestedOneWithoutGameGroupGamesInput
    groupGame: group_gameCreateNestedOneWithoutGameGroupGamesInput
  }

  export type game_group_gameUncheckedCreateWithoutLandInput = {
    gameId: number
    groupGameId: number
  }

  export type game_group_gameCreateOrConnectWithoutLandInput = {
    where: game_group_gameWhereUniqueInput
    create: XOR<game_group_gameCreateWithoutLandInput, game_group_gameUncheckedCreateWithoutLandInput>
  }

  export type game_group_gameCreateManyLandInputEnvelope = {
    data: game_group_gameCreateManyLandInput | game_group_gameCreateManyLandInput[]
    skipDuplicates?: boolean
  }

  export type game_group_gameUpsertWithWhereUniqueWithoutLandInput = {
    where: game_group_gameWhereUniqueInput
    update: XOR<game_group_gameUpdateWithoutLandInput, game_group_gameUncheckedUpdateWithoutLandInput>
    create: XOR<game_group_gameCreateWithoutLandInput, game_group_gameUncheckedCreateWithoutLandInput>
  }

  export type game_group_gameUpdateWithWhereUniqueWithoutLandInput = {
    where: game_group_gameWhereUniqueInput
    data: XOR<game_group_gameUpdateWithoutLandInput, game_group_gameUncheckedUpdateWithoutLandInput>
  }

  export type game_group_gameUpdateManyWithWhereWithoutLandInput = {
    where: game_group_gameScalarWhereInput
    data: XOR<game_group_gameUpdateManyMutationInput, game_group_gameUncheckedUpdateManyWithoutLandInput>
  }

  export type capacity_infoCreateWithoutCapacityInput = {
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityCategory: capacity_categoryCreateNestedOneWithoutCapacityInfosInput
    capacityEffect: capacity_effectCreateNestedOneWithoutCapacityInfosInput
    capacityEffectZ: capacity_effectCreateNestedOneWithoutCapacityZInfosInput
    effectOutsideFight: effect_outside_fightCreateNestedOneWithoutCapacityInfosInput
    target: targetCreateNestedOneWithoutCapacityInfosInput
    type: typeCreateNestedOneWithoutCapacityInfosInput
    capacityInfoInfluences?: capacity_info_influenceCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoUncheckedCreateWithoutCapacityInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityEffectZId: number
    typeId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfoInfluences?: capacity_info_influenceUncheckedCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoCreateOrConnectWithoutCapacityInput = {
    where: capacity_infoWhereUniqueInput
    create: XOR<capacity_infoCreateWithoutCapacityInput, capacity_infoUncheckedCreateWithoutCapacityInput>
  }

  export type capacity_infoCreateManyCapacityInputEnvelope = {
    data: capacity_infoCreateManyCapacityInput | capacity_infoCreateManyCapacityInput[]
    skipDuplicates?: boolean
  }

  export type skill_obtationCreateWithoutCapacityInput = {
    detail: string
    groupGame: group_gameCreateNestedOneWithoutSkillObtationsInput
    pokemon: pokemonCreateNestedOneWithoutSkillObtationsInput
    skillObtationType: skill_obtation_typeCreateNestedOneWithoutSkillObtationsInput
  }

  export type skill_obtationUncheckedCreateWithoutCapacityInput = {
    pokemonId: number
    groupGameId: number
    skillObtationTypeId: number
    detail: string
  }

  export type skill_obtationCreateOrConnectWithoutCapacityInput = {
    where: skill_obtationWhereUniqueInput
    create: XOR<skill_obtationCreateWithoutCapacityInput, skill_obtationUncheckedCreateWithoutCapacityInput>
  }

  export type skill_obtationCreateManyCapacityInputEnvelope = {
    data: skill_obtationCreateManyCapacityInput | skill_obtationCreateManyCapacityInput[]
    skipDuplicates?: boolean
  }

  export type capacity_infoUpsertWithWhereUniqueWithoutCapacityInput = {
    where: capacity_infoWhereUniqueInput
    update: XOR<capacity_infoUpdateWithoutCapacityInput, capacity_infoUncheckedUpdateWithoutCapacityInput>
    create: XOR<capacity_infoCreateWithoutCapacityInput, capacity_infoUncheckedCreateWithoutCapacityInput>
  }

  export type capacity_infoUpdateWithWhereUniqueWithoutCapacityInput = {
    where: capacity_infoWhereUniqueInput
    data: XOR<capacity_infoUpdateWithoutCapacityInput, capacity_infoUncheckedUpdateWithoutCapacityInput>
  }

  export type capacity_infoUpdateManyWithWhereWithoutCapacityInput = {
    where: capacity_infoScalarWhereInput
    data: XOR<capacity_infoUpdateManyMutationInput, capacity_infoUncheckedUpdateManyWithoutCapacityInput>
  }

  export type skill_obtationUpsertWithWhereUniqueWithoutCapacityInput = {
    where: skill_obtationWhereUniqueInput
    update: XOR<skill_obtationUpdateWithoutCapacityInput, skill_obtationUncheckedUpdateWithoutCapacityInput>
    create: XOR<skill_obtationCreateWithoutCapacityInput, skill_obtationUncheckedCreateWithoutCapacityInput>
  }

  export type skill_obtationUpdateWithWhereUniqueWithoutCapacityInput = {
    where: skill_obtationWhereUniqueInput
    data: XOR<skill_obtationUpdateWithoutCapacityInput, skill_obtationUncheckedUpdateWithoutCapacityInput>
  }

  export type skill_obtationUpdateManyWithWhereWithoutCapacityInput = {
    where: skill_obtationScalarWhereInput
    data: XOR<skill_obtationUpdateManyMutationInput, skill_obtationUncheckedUpdateManyWithoutCapacityInput>
  }

  export type capacity_infoCreateWithoutCapacityEffectInput = {
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityCategory: capacity_categoryCreateNestedOneWithoutCapacityInfosInput
    capacityEffectZ: capacity_effectCreateNestedOneWithoutCapacityZInfosInput
    capacity: capacityCreateNestedOneWithoutCapacityInfosInput
    effectOutsideFight: effect_outside_fightCreateNestedOneWithoutCapacityInfosInput
    target: targetCreateNestedOneWithoutCapacityInfosInput
    type: typeCreateNestedOneWithoutCapacityInfosInput
    capacityInfoInfluences?: capacity_info_influenceCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoUncheckedCreateWithoutCapacityEffectInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityId: number
    capacityEffectZId: number
    typeId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfoInfluences?: capacity_info_influenceUncheckedCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoCreateOrConnectWithoutCapacityEffectInput = {
    where: capacity_infoWhereUniqueInput
    create: XOR<capacity_infoCreateWithoutCapacityEffectInput, capacity_infoUncheckedCreateWithoutCapacityEffectInput>
  }

  export type capacity_infoCreateManyCapacityEffectInputEnvelope = {
    data: capacity_infoCreateManyCapacityEffectInput | capacity_infoCreateManyCapacityEffectInput[]
    skipDuplicates?: boolean
  }

  export type capacity_infoCreateWithoutCapacityEffectZInput = {
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityCategory: capacity_categoryCreateNestedOneWithoutCapacityInfosInput
    capacityEffect: capacity_effectCreateNestedOneWithoutCapacityInfosInput
    capacity: capacityCreateNestedOneWithoutCapacityInfosInput
    effectOutsideFight: effect_outside_fightCreateNestedOneWithoutCapacityInfosInput
    target: targetCreateNestedOneWithoutCapacityInfosInput
    type: typeCreateNestedOneWithoutCapacityInfosInput
    capacityInfoInfluences?: capacity_info_influenceCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoUncheckedCreateWithoutCapacityEffectZInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityId: number
    typeId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfoInfluences?: capacity_info_influenceUncheckedCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoCreateOrConnectWithoutCapacityEffectZInput = {
    where: capacity_infoWhereUniqueInput
    create: XOR<capacity_infoCreateWithoutCapacityEffectZInput, capacity_infoUncheckedCreateWithoutCapacityEffectZInput>
  }

  export type capacity_infoCreateManyCapacityEffectZInputEnvelope = {
    data: capacity_infoCreateManyCapacityEffectZInput | capacity_infoCreateManyCapacityEffectZInput[]
    skipDuplicates?: boolean
  }

  export type capacity_infoUpsertWithWhereUniqueWithoutCapacityEffectInput = {
    where: capacity_infoWhereUniqueInput
    update: XOR<capacity_infoUpdateWithoutCapacityEffectInput, capacity_infoUncheckedUpdateWithoutCapacityEffectInput>
    create: XOR<capacity_infoCreateWithoutCapacityEffectInput, capacity_infoUncheckedCreateWithoutCapacityEffectInput>
  }

  export type capacity_infoUpdateWithWhereUniqueWithoutCapacityEffectInput = {
    where: capacity_infoWhereUniqueInput
    data: XOR<capacity_infoUpdateWithoutCapacityEffectInput, capacity_infoUncheckedUpdateWithoutCapacityEffectInput>
  }

  export type capacity_infoUpdateManyWithWhereWithoutCapacityEffectInput = {
    where: capacity_infoScalarWhereInput
    data: XOR<capacity_infoUpdateManyMutationInput, capacity_infoUncheckedUpdateManyWithoutCapacityEffectInput>
  }

  export type capacity_infoUpsertWithWhereUniqueWithoutCapacityEffectZInput = {
    where: capacity_infoWhereUniqueInput
    update: XOR<capacity_infoUpdateWithoutCapacityEffectZInput, capacity_infoUncheckedUpdateWithoutCapacityEffectZInput>
    create: XOR<capacity_infoCreateWithoutCapacityEffectZInput, capacity_infoUncheckedCreateWithoutCapacityEffectZInput>
  }

  export type capacity_infoUpdateWithWhereUniqueWithoutCapacityEffectZInput = {
    where: capacity_infoWhereUniqueInput
    data: XOR<capacity_infoUpdateWithoutCapacityEffectZInput, capacity_infoUncheckedUpdateWithoutCapacityEffectZInput>
  }

  export type capacity_infoUpdateManyWithWhereWithoutCapacityEffectZInput = {
    where: capacity_infoScalarWhereInput
    data: XOR<capacity_infoUpdateManyMutationInput, capacity_infoUncheckedUpdateManyWithoutCapacityEffectZInput>
  }

  export type capacity_infoCreateWithoutCapacityCategoryInput = {
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityEffect: capacity_effectCreateNestedOneWithoutCapacityInfosInput
    capacityEffectZ: capacity_effectCreateNestedOneWithoutCapacityZInfosInput
    capacity: capacityCreateNestedOneWithoutCapacityInfosInput
    effectOutsideFight: effect_outside_fightCreateNestedOneWithoutCapacityInfosInput
    target: targetCreateNestedOneWithoutCapacityInfosInput
    type: typeCreateNestedOneWithoutCapacityInfosInput
    capacityInfoInfluences?: capacity_info_influenceCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoUncheckedCreateWithoutCapacityCategoryInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityId: number
    capacityEffectZId: number
    typeId: number
    effectOutsideFightId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfoInfluences?: capacity_info_influenceUncheckedCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoCreateOrConnectWithoutCapacityCategoryInput = {
    where: capacity_infoWhereUniqueInput
    create: XOR<capacity_infoCreateWithoutCapacityCategoryInput, capacity_infoUncheckedCreateWithoutCapacityCategoryInput>
  }

  export type capacity_infoCreateManyCapacityCategoryInputEnvelope = {
    data: capacity_infoCreateManyCapacityCategoryInput | capacity_infoCreateManyCapacityCategoryInput[]
    skipDuplicates?: boolean
  }

  export type capacity_infoUpsertWithWhereUniqueWithoutCapacityCategoryInput = {
    where: capacity_infoWhereUniqueInput
    update: XOR<capacity_infoUpdateWithoutCapacityCategoryInput, capacity_infoUncheckedUpdateWithoutCapacityCategoryInput>
    create: XOR<capacity_infoCreateWithoutCapacityCategoryInput, capacity_infoUncheckedCreateWithoutCapacityCategoryInput>
  }

  export type capacity_infoUpdateWithWhereUniqueWithoutCapacityCategoryInput = {
    where: capacity_infoWhereUniqueInput
    data: XOR<capacity_infoUpdateWithoutCapacityCategoryInput, capacity_infoUncheckedUpdateWithoutCapacityCategoryInput>
  }

  export type capacity_infoUpdateManyWithWhereWithoutCapacityCategoryInput = {
    where: capacity_infoScalarWhereInput
    data: XOR<capacity_infoUpdateManyMutationInput, capacity_infoUncheckedUpdateManyWithoutCapacityCategoryInput>
  }

  export type capsule_game_capacity_infoCreateWithoutCapsuleInput = {
    capacityInfo: capacity_infoCreateNestedOneWithoutCapsuleGameCapacityInfosInput
    groupGame: group_gameCreateNestedOneWithoutCapsuleGameCapacityIinfosInput
  }

  export type capsule_game_capacity_infoUncheckedCreateWithoutCapsuleInput = {
    capacityInfoId: number
    groupeGameId: number
  }

  export type capsule_game_capacity_infoCreateOrConnectWithoutCapsuleInput = {
    where: capsule_game_capacity_infoWhereUniqueInput
    create: XOR<capsule_game_capacity_infoCreateWithoutCapsuleInput, capsule_game_capacity_infoUncheckedCreateWithoutCapsuleInput>
  }

  export type capsule_game_capacity_infoCreateManyCapsuleInputEnvelope = {
    data: capsule_game_capacity_infoCreateManyCapsuleInput | capsule_game_capacity_infoCreateManyCapsuleInput[]
    skipDuplicates?: boolean
  }

  export type capsule_game_capacity_infoUpsertWithWhereUniqueWithoutCapsuleInput = {
    where: capsule_game_capacity_infoWhereUniqueInput
    update: XOR<capsule_game_capacity_infoUpdateWithoutCapsuleInput, capsule_game_capacity_infoUncheckedUpdateWithoutCapsuleInput>
    create: XOR<capsule_game_capacity_infoCreateWithoutCapsuleInput, capsule_game_capacity_infoUncheckedCreateWithoutCapsuleInput>
  }

  export type capsule_game_capacity_infoUpdateWithWhereUniqueWithoutCapsuleInput = {
    where: capsule_game_capacity_infoWhereUniqueInput
    data: XOR<capsule_game_capacity_infoUpdateWithoutCapsuleInput, capsule_game_capacity_infoUncheckedUpdateWithoutCapsuleInput>
  }

  export type capsule_game_capacity_infoUpdateManyWithWhereWithoutCapsuleInput = {
    where: capsule_game_capacity_infoScalarWhereInput
    data: XOR<capsule_game_capacity_infoUpdateManyMutationInput, capsule_game_capacity_infoUncheckedUpdateManyWithoutCapsuleInput>
  }

  export type rateCreateWithoutConditionRateInput = {
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutRateInput
    detailRate: detailCreateNestedOneWithoutDetailRatesInput
    meteo: meteoCreateNestedOneWithoutRatesInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateCreateNestedManyWithoutRateInput
  }

  export type rateUncheckedCreateWithoutConditionRateInput = {
    id?: number
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    meteoId: number
    detailRateId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutRateInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedCreateNestedManyWithoutRateInput
  }

  export type rateCreateOrConnectWithoutConditionRateInput = {
    where: rateWhereUniqueInput
    create: XOR<rateCreateWithoutConditionRateInput, rateUncheckedCreateWithoutConditionRateInput>
  }

  export type rateCreateManyConditionRateInputEnvelope = {
    data: rateCreateManyConditionRateInput | rateCreateManyConditionRateInput[]
    skipDuplicates?: boolean
  }

  export type rateCreateWithoutDetailRateInput = {
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutRateInput
    conditionRate: detailCreateNestedOneWithoutConditionRatesInput
    meteo: meteoCreateNestedOneWithoutRatesInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateCreateNestedManyWithoutRateInput
  }

  export type rateUncheckedCreateWithoutDetailRateInput = {
    id?: number
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    meteoId: number
    conditionRateId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutRateInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedCreateNestedManyWithoutRateInput
  }

  export type rateCreateOrConnectWithoutDetailRateInput = {
    where: rateWhereUniqueInput
    create: XOR<rateCreateWithoutDetailRateInput, rateUncheckedCreateWithoutDetailRateInput>
  }

  export type rateCreateManyDetailRateInputEnvelope = {
    data: rateCreateManyDetailRateInput | rateCreateManyDetailRateInput[]
    skipDuplicates?: boolean
  }

  export type rateUpsertWithWhereUniqueWithoutConditionRateInput = {
    where: rateWhereUniqueInput
    update: XOR<rateUpdateWithoutConditionRateInput, rateUncheckedUpdateWithoutConditionRateInput>
    create: XOR<rateCreateWithoutConditionRateInput, rateUncheckedCreateWithoutConditionRateInput>
  }

  export type rateUpdateWithWhereUniqueWithoutConditionRateInput = {
    where: rateWhereUniqueInput
    data: XOR<rateUpdateWithoutConditionRateInput, rateUncheckedUpdateWithoutConditionRateInput>
  }

  export type rateUpdateManyWithWhereWithoutConditionRateInput = {
    where: rateScalarWhereInput
    data: XOR<rateUpdateManyMutationInput, rateUncheckedUpdateManyWithoutConditionRateInput>
  }

  export type rateScalarWhereInput = {
    AND?: rateScalarWhereInput | rateScalarWhereInput[]
    OR?: rateScalarWhereInput[]
    NOT?: rateScalarWhereInput | rateScalarWhereInput[]
    id?: IntFilter<"rate"> | number
    rate?: DecimalFilter<"rate"> | Decimal | DecimalJsLike | number | string
    minLevel?: IntFilter<"rate"> | number
    maxLevel?: IntFilter<"rate"> | number
    limit?: IntNullableFilter<"rate"> | number | null
    meteoId?: IntFilter<"rate"> | number
    detailRateId?: IntFilter<"rate"> | number
    conditionRateId?: IntFilter<"rate"> | number
    createdAt?: DateTimeFilter<"rate"> | Date | string
    updatedAt?: DateTimeNullableFilter<"rate"> | Date | string | null
    status?: StringFilter<"rate"> | string
    isAlpha?: BoolFilter<"rate"> | boolean
  }

  export type rateUpsertWithWhereUniqueWithoutDetailRateInput = {
    where: rateWhereUniqueInput
    update: XOR<rateUpdateWithoutDetailRateInput, rateUncheckedUpdateWithoutDetailRateInput>
    create: XOR<rateCreateWithoutDetailRateInput, rateUncheckedCreateWithoutDetailRateInput>
  }

  export type rateUpdateWithWhereUniqueWithoutDetailRateInput = {
    where: rateWhereUniqueInput
    data: XOR<rateUpdateWithoutDetailRateInput, rateUncheckedUpdateWithoutDetailRateInput>
  }

  export type rateUpdateManyWithWhereWithoutDetailRateInput = {
    where: rateScalarWhereInput
    data: XOR<rateUpdateManyMutationInput, rateUncheckedUpdateManyWithoutDetailRateInput>
  }

  export type ability_infoCreateWithoutEffectWithoutFightInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilities: abilityCreateNestedOneWithoutAbilityInfosInput
    generation: generationCreateNestedOneWithoutAbilityInfosInput
  }

  export type ability_infoUncheckedCreateWithoutEffectWithoutFightInput = {
    id?: number
    generationId: number
    abilityId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type ability_infoCreateOrConnectWithoutEffectWithoutFightInput = {
    where: ability_infoWhereUniqueInput
    create: XOR<ability_infoCreateWithoutEffectWithoutFightInput, ability_infoUncheckedCreateWithoutEffectWithoutFightInput>
  }

  export type ability_infoCreateManyEffectWithoutFightInputEnvelope = {
    data: ability_infoCreateManyEffectWithoutFightInput | ability_infoCreateManyEffectWithoutFightInput[]
    skipDuplicates?: boolean
  }

  export type capacity_infoCreateWithoutEffectOutsideFightInput = {
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityCategory: capacity_categoryCreateNestedOneWithoutCapacityInfosInput
    capacityEffect: capacity_effectCreateNestedOneWithoutCapacityInfosInput
    capacityEffectZ: capacity_effectCreateNestedOneWithoutCapacityZInfosInput
    capacity: capacityCreateNestedOneWithoutCapacityInfosInput
    target: targetCreateNestedOneWithoutCapacityInfosInput
    type: typeCreateNestedOneWithoutCapacityInfosInput
    capacityInfoInfluences?: capacity_info_influenceCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoUncheckedCreateWithoutEffectOutsideFightInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityId: number
    capacityEffectZId: number
    typeId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfoInfluences?: capacity_info_influenceUncheckedCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoCreateOrConnectWithoutEffectOutsideFightInput = {
    where: capacity_infoWhereUniqueInput
    create: XOR<capacity_infoCreateWithoutEffectOutsideFightInput, capacity_infoUncheckedCreateWithoutEffectOutsideFightInput>
  }

  export type capacity_infoCreateManyEffectOutsideFightInputEnvelope = {
    data: capacity_infoCreateManyEffectOutsideFightInput | capacity_infoCreateManyEffectOutsideFightInput[]
    skipDuplicates?: boolean
  }

  export type ability_infoUpsertWithWhereUniqueWithoutEffectWithoutFightInput = {
    where: ability_infoWhereUniqueInput
    update: XOR<ability_infoUpdateWithoutEffectWithoutFightInput, ability_infoUncheckedUpdateWithoutEffectWithoutFightInput>
    create: XOR<ability_infoCreateWithoutEffectWithoutFightInput, ability_infoUncheckedCreateWithoutEffectWithoutFightInput>
  }

  export type ability_infoUpdateWithWhereUniqueWithoutEffectWithoutFightInput = {
    where: ability_infoWhereUniqueInput
    data: XOR<ability_infoUpdateWithoutEffectWithoutFightInput, ability_infoUncheckedUpdateWithoutEffectWithoutFightInput>
  }

  export type ability_infoUpdateManyWithWhereWithoutEffectWithoutFightInput = {
    where: ability_infoScalarWhereInput
    data: XOR<ability_infoUpdateManyMutationInput, ability_infoUncheckedUpdateManyWithoutEffectWithoutFightInput>
  }

  export type capacity_infoUpsertWithWhereUniqueWithoutEffectOutsideFightInput = {
    where: capacity_infoWhereUniqueInput
    update: XOR<capacity_infoUpdateWithoutEffectOutsideFightInput, capacity_infoUncheckedUpdateWithoutEffectOutsideFightInput>
    create: XOR<capacity_infoCreateWithoutEffectOutsideFightInput, capacity_infoUncheckedCreateWithoutEffectOutsideFightInput>
  }

  export type capacity_infoUpdateWithWhereUniqueWithoutEffectOutsideFightInput = {
    where: capacity_infoWhereUniqueInput
    data: XOR<capacity_infoUpdateWithoutEffectOutsideFightInput, capacity_infoUncheckedUpdateWithoutEffectOutsideFightInput>
  }

  export type capacity_infoUpdateManyWithWhereWithoutEffectOutsideFightInput = {
    where: capacity_infoScalarWhereInput
    data: XOR<capacity_infoUpdateManyMutationInput, capacity_infoUncheckedUpdateManyWithoutEffectOutsideFightInput>
  }

  export type capacity_info_influenceCreateWithoutInfluenceInput = {
    capacityInfo: capacity_infoCreateNestedOneWithoutCapacityInfoInfluencesInput
  }

  export type capacity_info_influenceUncheckedCreateWithoutInfluenceInput = {
    capacityInfoId: number
  }

  export type capacity_info_influenceCreateOrConnectWithoutInfluenceInput = {
    where: capacity_info_influenceWhereUniqueInput
    create: XOR<capacity_info_influenceCreateWithoutInfluenceInput, capacity_info_influenceUncheckedCreateWithoutInfluenceInput>
  }

  export type capacity_info_influenceCreateManyInfluenceInputEnvelope = {
    data: capacity_info_influenceCreateManyInfluenceInput | capacity_info_influenceCreateManyInfluenceInput[]
    skipDuplicates?: boolean
  }

  export type capacity_info_influenceUpsertWithWhereUniqueWithoutInfluenceInput = {
    where: capacity_info_influenceWhereUniqueInput
    update: XOR<capacity_info_influenceUpdateWithoutInfluenceInput, capacity_info_influenceUncheckedUpdateWithoutInfluenceInput>
    create: XOR<capacity_info_influenceCreateWithoutInfluenceInput, capacity_info_influenceUncheckedCreateWithoutInfluenceInput>
  }

  export type capacity_info_influenceUpdateWithWhereUniqueWithoutInfluenceInput = {
    where: capacity_info_influenceWhereUniqueInput
    data: XOR<capacity_info_influenceUpdateWithoutInfluenceInput, capacity_info_influenceUncheckedUpdateWithoutInfluenceInput>
  }

  export type capacity_info_influenceUpdateManyWithWhereWithoutInfluenceInput = {
    where: capacity_info_influenceScalarWhereInput
    data: XOR<capacity_info_influenceUpdateManyMutationInput, capacity_info_influenceUncheckedUpdateManyWithoutInfluenceInput>
  }

  export type capacity_info_influenceScalarWhereInput = {
    AND?: capacity_info_influenceScalarWhereInput | capacity_info_influenceScalarWhereInput[]
    OR?: capacity_info_influenceScalarWhereInput[]
    NOT?: capacity_info_influenceScalarWhereInput | capacity_info_influenceScalarWhereInput[]
    capacityInfoId?: IntFilter<"capacity_info_influence"> | number
    influenceId?: IntFilter<"capacity_info_influence"> | number
  }

  export type location_zoneCreateWithoutLocationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    zone: zoneCreateNestedOneWithoutLocationZonesInput
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutLocationZoneInput
  }

  export type location_zoneUncheckedCreateWithoutLocationInput = {
    id?: number
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutLocationZoneInput
  }

  export type location_zoneCreateOrConnectWithoutLocationInput = {
    where: location_zoneWhereUniqueInput
    create: XOR<location_zoneCreateWithoutLocationInput, location_zoneUncheckedCreateWithoutLocationInput>
  }

  export type location_zoneCreateManyLocationInputEnvelope = {
    data: location_zoneCreateManyLocationInput | location_zoneCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type location_zoneUpsertWithWhereUniqueWithoutLocationInput = {
    where: location_zoneWhereUniqueInput
    update: XOR<location_zoneUpdateWithoutLocationInput, location_zoneUncheckedUpdateWithoutLocationInput>
    create: XOR<location_zoneCreateWithoutLocationInput, location_zoneUncheckedCreateWithoutLocationInput>
  }

  export type location_zoneUpdateWithWhereUniqueWithoutLocationInput = {
    where: location_zoneWhereUniqueInput
    data: XOR<location_zoneUpdateWithoutLocationInput, location_zoneUncheckedUpdateWithoutLocationInput>
  }

  export type location_zoneUpdateManyWithWhereWithoutLocationInput = {
    where: location_zoneScalarWhereInput
    data: XOR<location_zoneUpdateManyMutationInput, location_zoneUncheckedUpdateManyWithoutLocationInput>
  }

  export type location_zoneScalarWhereInput = {
    AND?: location_zoneScalarWhereInput | location_zoneScalarWhereInput[]
    OR?: location_zoneScalarWhereInput[]
    NOT?: location_zoneScalarWhereInput | location_zoneScalarWhereInput[]
    id?: IntFilter<"location_zone"> | number
    locationId?: IntFilter<"location_zone"> | number
    zoneId?: IntFilter<"location_zone"> | number
    createdAt?: DateTimeFilter<"location_zone"> | Date | string
    updatedAt?: DateTimeNullableFilter<"location_zone"> | Date | string | null
    status?: StringFilter<"location_zone"> | string
  }

  export type location_zoneCreateWithoutZoneInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    location: locationCreateNestedOneWithoutLocationZonesInput
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutLocationZoneInput
  }

  export type location_zoneUncheckedCreateWithoutZoneInput = {
    id?: number
    locationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutLocationZoneInput
  }

  export type location_zoneCreateOrConnectWithoutZoneInput = {
    where: location_zoneWhereUniqueInput
    create: XOR<location_zoneCreateWithoutZoneInput, location_zoneUncheckedCreateWithoutZoneInput>
  }

  export type location_zoneCreateManyZoneInputEnvelope = {
    data: location_zoneCreateManyZoneInput | location_zoneCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type location_zoneUpsertWithWhereUniqueWithoutZoneInput = {
    where: location_zoneWhereUniqueInput
    update: XOR<location_zoneUpdateWithoutZoneInput, location_zoneUncheckedUpdateWithoutZoneInput>
    create: XOR<location_zoneCreateWithoutZoneInput, location_zoneUncheckedCreateWithoutZoneInput>
  }

  export type location_zoneUpdateWithWhereUniqueWithoutZoneInput = {
    where: location_zoneWhereUniqueInput
    data: XOR<location_zoneUpdateWithoutZoneInput, location_zoneUncheckedUpdateWithoutZoneInput>
  }

  export type location_zoneUpdateManyWithWhereWithoutZoneInput = {
    where: location_zoneScalarWhereInput
    data: XOR<location_zoneUpdateManyMutationInput, location_zoneUncheckedUpdateManyWithoutZoneInput>
  }

  export type locationCreateWithoutLocationZonesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type locationUncheckedCreateWithoutLocationZonesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type locationCreateOrConnectWithoutLocationZonesInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutLocationZonesInput, locationUncheckedCreateWithoutLocationZonesInput>
  }

  export type zoneCreateWithoutLocationZonesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type zoneUncheckedCreateWithoutLocationZonesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type zoneCreateOrConnectWithoutLocationZonesInput = {
    where: zoneWhereUniqueInput
    create: XOR<zoneCreateWithoutLocationZonesInput, zoneUncheckedCreateWithoutLocationZonesInput>
  }

  export type pokemon_game_locationCreateWithoutLocationZoneInput = {
    game: gameCreateNestedOneWithoutPokemonRatingGamesInput
    pokemonForm: pokemon_formCreateNestedOneWithoutPokemonRatingGamesInput
    pokemonObtation: pokemon_obtationCreateNestedOneWithoutPokemonRatingGamesInput
    rate: rateCreateNestedOneWithoutPokemonRatingGamesInput
  }

  export type pokemon_game_locationUncheckedCreateWithoutLocationZoneInput = {
    gameId: number
    rateId: number
    pokemonObtationId: number
    pokemonFormId: number
    id?: number
  }

  export type pokemon_game_locationCreateOrConnectWithoutLocationZoneInput = {
    where: pokemon_game_locationWhereUniqueInput
    create: XOR<pokemon_game_locationCreateWithoutLocationZoneInput, pokemon_game_locationUncheckedCreateWithoutLocationZoneInput>
  }

  export type pokemon_game_locationCreateManyLocationZoneInputEnvelope = {
    data: pokemon_game_locationCreateManyLocationZoneInput | pokemon_game_locationCreateManyLocationZoneInput[]
    skipDuplicates?: boolean
  }

  export type locationUpsertWithoutLocationZonesInput = {
    update: XOR<locationUpdateWithoutLocationZonesInput, locationUncheckedUpdateWithoutLocationZonesInput>
    create: XOR<locationCreateWithoutLocationZonesInput, locationUncheckedCreateWithoutLocationZonesInput>
    where?: locationWhereInput
  }

  export type locationUpdateToOneWithWhereWithoutLocationZonesInput = {
    where?: locationWhereInput
    data: XOR<locationUpdateWithoutLocationZonesInput, locationUncheckedUpdateWithoutLocationZonesInput>
  }

  export type locationUpdateWithoutLocationZonesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type locationUncheckedUpdateWithoutLocationZonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type zoneUpsertWithoutLocationZonesInput = {
    update: XOR<zoneUpdateWithoutLocationZonesInput, zoneUncheckedUpdateWithoutLocationZonesInput>
    create: XOR<zoneCreateWithoutLocationZonesInput, zoneUncheckedCreateWithoutLocationZonesInput>
    where?: zoneWhereInput
  }

  export type zoneUpdateToOneWithWhereWithoutLocationZonesInput = {
    where?: zoneWhereInput
    data: XOR<zoneUpdateWithoutLocationZonesInput, zoneUncheckedUpdateWithoutLocationZonesInput>
  }

  export type zoneUpdateWithoutLocationZonesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type zoneUncheckedUpdateWithoutLocationZonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_game_locationUpsertWithWhereUniqueWithoutLocationZoneInput = {
    where: pokemon_game_locationWhereUniqueInput
    update: XOR<pokemon_game_locationUpdateWithoutLocationZoneInput, pokemon_game_locationUncheckedUpdateWithoutLocationZoneInput>
    create: XOR<pokemon_game_locationCreateWithoutLocationZoneInput, pokemon_game_locationUncheckedCreateWithoutLocationZoneInput>
  }

  export type pokemon_game_locationUpdateWithWhereUniqueWithoutLocationZoneInput = {
    where: pokemon_game_locationWhereUniqueInput
    data: XOR<pokemon_game_locationUpdateWithoutLocationZoneInput, pokemon_game_locationUncheckedUpdateWithoutLocationZoneInput>
  }

  export type pokemon_game_locationUpdateManyWithWhereWithoutLocationZoneInput = {
    where: pokemon_game_locationScalarWhereInput
    data: XOR<pokemon_game_locationUpdateManyMutationInput, pokemon_game_locationUncheckedUpdateManyWithoutLocationZoneInput>
  }

  export type rateCreateWithoutMeteoInput = {
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutRateInput
    conditionRate: detailCreateNestedOneWithoutConditionRatesInput
    detailRate: detailCreateNestedOneWithoutDetailRatesInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateCreateNestedManyWithoutRateInput
  }

  export type rateUncheckedCreateWithoutMeteoInput = {
    id?: number
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    detailRateId: number
    conditionRateId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutRateInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedCreateNestedManyWithoutRateInput
  }

  export type rateCreateOrConnectWithoutMeteoInput = {
    where: rateWhereUniqueInput
    create: XOR<rateCreateWithoutMeteoInput, rateUncheckedCreateWithoutMeteoInput>
  }

  export type rateCreateManyMeteoInputEnvelope = {
    data: rateCreateManyMeteoInput | rateCreateManyMeteoInput[]
    skipDuplicates?: boolean
  }

  export type rateUpsertWithWhereUniqueWithoutMeteoInput = {
    where: rateWhereUniqueInput
    update: XOR<rateUpdateWithoutMeteoInput, rateUncheckedUpdateWithoutMeteoInput>
    create: XOR<rateCreateWithoutMeteoInput, rateUncheckedCreateWithoutMeteoInput>
  }

  export type rateUpdateWithWhereUniqueWithoutMeteoInput = {
    where: rateWhereUniqueInput
    data: XOR<rateUpdateWithoutMeteoInput, rateUncheckedUpdateWithoutMeteoInput>
  }

  export type rateUpdateManyWithWhereWithoutMeteoInput = {
    where: rateScalarWhereInput
    data: XOR<rateUpdateManyMutationInput, rateUncheckedUpdateManyWithoutMeteoInput>
  }

  export type pokemon_game_locationCreateWithoutPokemonObtationInput = {
    game: gameCreateNestedOneWithoutPokemonRatingGamesInput
    locationZone: location_zoneCreateNestedOneWithoutPokemonRatingGamesInput
    pokemonForm: pokemon_formCreateNestedOneWithoutPokemonRatingGamesInput
    rate: rateCreateNestedOneWithoutPokemonRatingGamesInput
  }

  export type pokemon_game_locationUncheckedCreateWithoutPokemonObtationInput = {
    gameId: number
    rateId: number
    locationZoneId: number
    pokemonFormId: number
    id?: number
  }

  export type pokemon_game_locationCreateOrConnectWithoutPokemonObtationInput = {
    where: pokemon_game_locationWhereUniqueInput
    create: XOR<pokemon_game_locationCreateWithoutPokemonObtationInput, pokemon_game_locationUncheckedCreateWithoutPokemonObtationInput>
  }

  export type pokemon_game_locationCreateManyPokemonObtationInputEnvelope = {
    data: pokemon_game_locationCreateManyPokemonObtationInput | pokemon_game_locationCreateManyPokemonObtationInput[]
    skipDuplicates?: boolean
  }

  export type pokemon_game_locationUpsertWithWhereUniqueWithoutPokemonObtationInput = {
    where: pokemon_game_locationWhereUniqueInput
    update: XOR<pokemon_game_locationUpdateWithoutPokemonObtationInput, pokemon_game_locationUncheckedUpdateWithoutPokemonObtationInput>
    create: XOR<pokemon_game_locationCreateWithoutPokemonObtationInput, pokemon_game_locationUncheckedCreateWithoutPokemonObtationInput>
  }

  export type pokemon_game_locationUpdateWithWhereUniqueWithoutPokemonObtationInput = {
    where: pokemon_game_locationWhereUniqueInput
    data: XOR<pokemon_game_locationUpdateWithoutPokemonObtationInput, pokemon_game_locationUncheckedUpdateWithoutPokemonObtationInput>
  }

  export type pokemon_game_locationUpdateManyWithWhereWithoutPokemonObtationInput = {
    where: pokemon_game_locationScalarWhereInput
    data: XOR<pokemon_game_locationUpdateManyMutationInput, pokemon_game_locationUncheckedUpdateManyWithoutPokemonObtationInput>
  }

  export type pokemon_game_locationCreateWithoutRateInput = {
    game: gameCreateNestedOneWithoutPokemonRatingGamesInput
    locationZone: location_zoneCreateNestedOneWithoutPokemonRatingGamesInput
    pokemonForm: pokemon_formCreateNestedOneWithoutPokemonRatingGamesInput
    pokemonObtation: pokemon_obtationCreateNestedOneWithoutPokemonRatingGamesInput
  }

  export type pokemon_game_locationUncheckedCreateWithoutRateInput = {
    gameId: number
    locationZoneId: number
    pokemonObtationId: number
    pokemonFormId: number
    id?: number
  }

  export type pokemon_game_locationCreateOrConnectWithoutRateInput = {
    where: pokemon_game_locationWhereUniqueInput
    create: XOR<pokemon_game_locationCreateWithoutRateInput, pokemon_game_locationUncheckedCreateWithoutRateInput>
  }

  export type pokemon_game_locationCreateManyRateInputEnvelope = {
    data: pokemon_game_locationCreateManyRateInput | pokemon_game_locationCreateManyRateInput[]
    skipDuplicates?: boolean
  }

  export type detailCreateWithoutConditionRatesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    detailRates?: rateCreateNestedManyWithoutDetailRateInput
  }

  export type detailUncheckedCreateWithoutConditionRatesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    detailRates?: rateUncheckedCreateNestedManyWithoutDetailRateInput
  }

  export type detailCreateOrConnectWithoutConditionRatesInput = {
    where: detailWhereUniqueInput
    create: XOR<detailCreateWithoutConditionRatesInput, detailUncheckedCreateWithoutConditionRatesInput>
  }

  export type detailCreateWithoutDetailRatesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    conditionRates?: rateCreateNestedManyWithoutConditionRateInput
  }

  export type detailUncheckedCreateWithoutDetailRatesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    conditionRates?: rateUncheckedCreateNestedManyWithoutConditionRateInput
  }

  export type detailCreateOrConnectWithoutDetailRatesInput = {
    where: detailWhereUniqueInput
    create: XOR<detailCreateWithoutDetailRatesInput, detailUncheckedCreateWithoutDetailRatesInput>
  }

  export type meteoCreateWithoutRatesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type meteoUncheckedCreateWithoutRatesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type meteoCreateOrConnectWithoutRatesInput = {
    where: meteoWhereUniqueInput
    create: XOR<meteoCreateWithoutRatesInput, meteoUncheckedCreateWithoutRatesInput>
  }

  export type shiny_hunting_method_rateCreateWithoutRateInput = {
    shinyHuntingMethod: shiny_hunting_methodCreateNestedOneWithoutShinyHuntingMethodRatesInput
  }

  export type shiny_hunting_method_rateUncheckedCreateWithoutRateInput = {
    shinyHuntingMethodId: number
  }

  export type shiny_hunting_method_rateCreateOrConnectWithoutRateInput = {
    where: shiny_hunting_method_rateWhereUniqueInput
    create: XOR<shiny_hunting_method_rateCreateWithoutRateInput, shiny_hunting_method_rateUncheckedCreateWithoutRateInput>
  }

  export type shiny_hunting_method_rateCreateManyRateInputEnvelope = {
    data: shiny_hunting_method_rateCreateManyRateInput | shiny_hunting_method_rateCreateManyRateInput[]
    skipDuplicates?: boolean
  }

  export type pokemon_game_locationUpsertWithWhereUniqueWithoutRateInput = {
    where: pokemon_game_locationWhereUniqueInput
    update: XOR<pokemon_game_locationUpdateWithoutRateInput, pokemon_game_locationUncheckedUpdateWithoutRateInput>
    create: XOR<pokemon_game_locationCreateWithoutRateInput, pokemon_game_locationUncheckedCreateWithoutRateInput>
  }

  export type pokemon_game_locationUpdateWithWhereUniqueWithoutRateInput = {
    where: pokemon_game_locationWhereUniqueInput
    data: XOR<pokemon_game_locationUpdateWithoutRateInput, pokemon_game_locationUncheckedUpdateWithoutRateInput>
  }

  export type pokemon_game_locationUpdateManyWithWhereWithoutRateInput = {
    where: pokemon_game_locationScalarWhereInput
    data: XOR<pokemon_game_locationUpdateManyMutationInput, pokemon_game_locationUncheckedUpdateManyWithoutRateInput>
  }

  export type detailUpsertWithoutConditionRatesInput = {
    update: XOR<detailUpdateWithoutConditionRatesInput, detailUncheckedUpdateWithoutConditionRatesInput>
    create: XOR<detailCreateWithoutConditionRatesInput, detailUncheckedCreateWithoutConditionRatesInput>
    where?: detailWhereInput
  }

  export type detailUpdateToOneWithWhereWithoutConditionRatesInput = {
    where?: detailWhereInput
    data: XOR<detailUpdateWithoutConditionRatesInput, detailUncheckedUpdateWithoutConditionRatesInput>
  }

  export type detailUpdateWithoutConditionRatesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    detailRates?: rateUpdateManyWithoutDetailRateNestedInput
  }

  export type detailUncheckedUpdateWithoutConditionRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    detailRates?: rateUncheckedUpdateManyWithoutDetailRateNestedInput
  }

  export type detailUpsertWithoutDetailRatesInput = {
    update: XOR<detailUpdateWithoutDetailRatesInput, detailUncheckedUpdateWithoutDetailRatesInput>
    create: XOR<detailCreateWithoutDetailRatesInput, detailUncheckedCreateWithoutDetailRatesInput>
    where?: detailWhereInput
  }

  export type detailUpdateToOneWithWhereWithoutDetailRatesInput = {
    where?: detailWhereInput
    data: XOR<detailUpdateWithoutDetailRatesInput, detailUncheckedUpdateWithoutDetailRatesInput>
  }

  export type detailUpdateWithoutDetailRatesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    conditionRates?: rateUpdateManyWithoutConditionRateNestedInput
  }

  export type detailUncheckedUpdateWithoutDetailRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    conditionRates?: rateUncheckedUpdateManyWithoutConditionRateNestedInput
  }

  export type meteoUpsertWithoutRatesInput = {
    update: XOR<meteoUpdateWithoutRatesInput, meteoUncheckedUpdateWithoutRatesInput>
    create: XOR<meteoCreateWithoutRatesInput, meteoUncheckedCreateWithoutRatesInput>
    where?: meteoWhereInput
  }

  export type meteoUpdateToOneWithWhereWithoutRatesInput = {
    where?: meteoWhereInput
    data: XOR<meteoUpdateWithoutRatesInput, meteoUncheckedUpdateWithoutRatesInput>
  }

  export type meteoUpdateWithoutRatesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type meteoUncheckedUpdateWithoutRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type shiny_hunting_method_rateUpsertWithWhereUniqueWithoutRateInput = {
    where: shiny_hunting_method_rateWhereUniqueInput
    update: XOR<shiny_hunting_method_rateUpdateWithoutRateInput, shiny_hunting_method_rateUncheckedUpdateWithoutRateInput>
    create: XOR<shiny_hunting_method_rateCreateWithoutRateInput, shiny_hunting_method_rateUncheckedCreateWithoutRateInput>
  }

  export type shiny_hunting_method_rateUpdateWithWhereUniqueWithoutRateInput = {
    where: shiny_hunting_method_rateWhereUniqueInput
    data: XOR<shiny_hunting_method_rateUpdateWithoutRateInput, shiny_hunting_method_rateUncheckedUpdateWithoutRateInput>
  }

  export type shiny_hunting_method_rateUpdateManyWithWhereWithoutRateInput = {
    where: shiny_hunting_method_rateScalarWhereInput
    data: XOR<shiny_hunting_method_rateUpdateManyMutationInput, shiny_hunting_method_rateUncheckedUpdateManyWithoutRateInput>
  }

  export type group_gameCreateWithoutShinyHuntingMethodGamesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoCreateNestedManyWithoutGroupGameInput
    gameGroupGames?: game_group_gameCreateNestedManyWithoutGroupGameInput
    nationnalNumbers?: national_numberCreateNestedManyWithoutGroupGameInput
    skillObtations?: skill_obtationCreateNestedManyWithoutGroupGameInput
    statisticGroupGames?: statistic_group_gameCreateNestedManyWithoutGroupGameInput
  }

  export type group_gameUncheckedCreateWithoutShinyHuntingMethodGamesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutGroupGameInput
    gameGroupGames?: game_group_gameUncheckedCreateNestedManyWithoutGroupGameInput
    nationnalNumbers?: national_numberUncheckedCreateNestedManyWithoutGroupGameInput
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutGroupGameInput
    statisticGroupGames?: statistic_group_gameUncheckedCreateNestedManyWithoutGroupGameInput
  }

  export type group_gameCreateOrConnectWithoutShinyHuntingMethodGamesInput = {
    where: group_gameWhereUniqueInput
    create: XOR<group_gameCreateWithoutShinyHuntingMethodGamesInput, group_gameUncheckedCreateWithoutShinyHuntingMethodGamesInput>
  }

  export type shiny_hunting_methodCreateWithoutShinyHuntingMethodGamesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutShinyHuntingMethodInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateCreateNestedManyWithoutShinyHuntingMethodInput
  }

  export type shiny_hunting_methodUncheckedCreateWithoutShinyHuntingMethodGamesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutShinyHuntingMethodInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedCreateNestedManyWithoutShinyHuntingMethodInput
  }

  export type shiny_hunting_methodCreateOrConnectWithoutShinyHuntingMethodGamesInput = {
    where: shiny_hunting_methodWhereUniqueInput
    create: XOR<shiny_hunting_methodCreateWithoutShinyHuntingMethodGamesInput, shiny_hunting_methodUncheckedCreateWithoutShinyHuntingMethodGamesInput>
  }

  export type group_gameUpsertWithoutShinyHuntingMethodGamesInput = {
    update: XOR<group_gameUpdateWithoutShinyHuntingMethodGamesInput, group_gameUncheckedUpdateWithoutShinyHuntingMethodGamesInput>
    create: XOR<group_gameCreateWithoutShinyHuntingMethodGamesInput, group_gameUncheckedCreateWithoutShinyHuntingMethodGamesInput>
    where?: group_gameWhereInput
  }

  export type group_gameUpdateToOneWithWhereWithoutShinyHuntingMethodGamesInput = {
    where?: group_gameWhereInput
    data: XOR<group_gameUpdateWithoutShinyHuntingMethodGamesInput, group_gameUncheckedUpdateWithoutShinyHuntingMethodGamesInput>
  }

  export type group_gameUpdateWithoutShinyHuntingMethodGamesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUpdateManyWithoutGroupGameNestedInput
    gameGroupGames?: game_group_gameUpdateManyWithoutGroupGameNestedInput
    nationnalNumbers?: national_numberUpdateManyWithoutGroupGameNestedInput
    skillObtations?: skill_obtationUpdateManyWithoutGroupGameNestedInput
    statisticGroupGames?: statistic_group_gameUpdateManyWithoutGroupGameNestedInput
  }

  export type group_gameUncheckedUpdateWithoutShinyHuntingMethodGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutGroupGameNestedInput
    gameGroupGames?: game_group_gameUncheckedUpdateManyWithoutGroupGameNestedInput
    nationnalNumbers?: national_numberUncheckedUpdateManyWithoutGroupGameNestedInput
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutGroupGameNestedInput
    statisticGroupGames?: statistic_group_gameUncheckedUpdateManyWithoutGroupGameNestedInput
  }

  export type shiny_hunting_methodUpsertWithoutShinyHuntingMethodGamesInput = {
    update: XOR<shiny_hunting_methodUpdateWithoutShinyHuntingMethodGamesInput, shiny_hunting_methodUncheckedUpdateWithoutShinyHuntingMethodGamesInput>
    create: XOR<shiny_hunting_methodCreateWithoutShinyHuntingMethodGamesInput, shiny_hunting_methodUncheckedCreateWithoutShinyHuntingMethodGamesInput>
    where?: shiny_hunting_methodWhereInput
  }

  export type shiny_hunting_methodUpdateToOneWithWhereWithoutShinyHuntingMethodGamesInput = {
    where?: shiny_hunting_methodWhereInput
    data: XOR<shiny_hunting_methodUpdateWithoutShinyHuntingMethodGamesInput, shiny_hunting_methodUncheckedUpdateWithoutShinyHuntingMethodGamesInput>
  }

  export type shiny_hunting_methodUpdateWithoutShinyHuntingMethodGamesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemons?: owned_pokemonUpdateManyWithoutShinyHuntingMethodNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUpdateManyWithoutShinyHuntingMethodNestedInput
  }

  export type shiny_hunting_methodUncheckedUpdateWithoutShinyHuntingMethodGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutShinyHuntingMethodNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedUpdateManyWithoutShinyHuntingMethodNestedInput
  }

  export type rateCreateWithoutShinyHuntingMethodRatesInput = {
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
    pokemonRatingGames?: pokemon_game_locationCreateNestedManyWithoutRateInput
    conditionRate: detailCreateNestedOneWithoutConditionRatesInput
    detailRate: detailCreateNestedOneWithoutDetailRatesInput
    meteo: meteoCreateNestedOneWithoutRatesInput
  }

  export type rateUncheckedCreateWithoutShinyHuntingMethodRatesInput = {
    id?: number
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    meteoId: number
    detailRateId: number
    conditionRateId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
    pokemonRatingGames?: pokemon_game_locationUncheckedCreateNestedManyWithoutRateInput
  }

  export type rateCreateOrConnectWithoutShinyHuntingMethodRatesInput = {
    where: rateWhereUniqueInput
    create: XOR<rateCreateWithoutShinyHuntingMethodRatesInput, rateUncheckedCreateWithoutShinyHuntingMethodRatesInput>
  }

  export type shiny_hunting_methodCreateWithoutShinyHuntingMethodRatesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutShinyHuntingMethodInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameCreateNestedManyWithoutShinyHuntingMethodInput
  }

  export type shiny_hunting_methodUncheckedCreateWithoutShinyHuntingMethodRatesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutShinyHuntingMethodInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedCreateNestedManyWithoutShinyHuntingMethodInput
  }

  export type shiny_hunting_methodCreateOrConnectWithoutShinyHuntingMethodRatesInput = {
    where: shiny_hunting_methodWhereUniqueInput
    create: XOR<shiny_hunting_methodCreateWithoutShinyHuntingMethodRatesInput, shiny_hunting_methodUncheckedCreateWithoutShinyHuntingMethodRatesInput>
  }

  export type rateUpsertWithoutShinyHuntingMethodRatesInput = {
    update: XOR<rateUpdateWithoutShinyHuntingMethodRatesInput, rateUncheckedUpdateWithoutShinyHuntingMethodRatesInput>
    create: XOR<rateCreateWithoutShinyHuntingMethodRatesInput, rateUncheckedCreateWithoutShinyHuntingMethodRatesInput>
    where?: rateWhereInput
  }

  export type rateUpdateToOneWithWhereWithoutShinyHuntingMethodRatesInput = {
    where?: rateWhereInput
    data: XOR<rateUpdateWithoutShinyHuntingMethodRatesInput, rateUncheckedUpdateWithoutShinyHuntingMethodRatesInput>
  }

  export type rateUpdateWithoutShinyHuntingMethodRatesInput = {
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutRateNestedInput
    conditionRate?: detailUpdateOneRequiredWithoutConditionRatesNestedInput
    detailRate?: detailUpdateOneRequiredWithoutDetailRatesNestedInput
    meteo?: meteoUpdateOneRequiredWithoutRatesNestedInput
  }

  export type rateUncheckedUpdateWithoutShinyHuntingMethodRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    meteoId?: IntFieldUpdateOperationsInput | number
    detailRateId?: IntFieldUpdateOperationsInput | number
    conditionRateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutRateNestedInput
  }

  export type shiny_hunting_methodUpsertWithoutShinyHuntingMethodRatesInput = {
    update: XOR<shiny_hunting_methodUpdateWithoutShinyHuntingMethodRatesInput, shiny_hunting_methodUncheckedUpdateWithoutShinyHuntingMethodRatesInput>
    create: XOR<shiny_hunting_methodCreateWithoutShinyHuntingMethodRatesInput, shiny_hunting_methodUncheckedCreateWithoutShinyHuntingMethodRatesInput>
    where?: shiny_hunting_methodWhereInput
  }

  export type shiny_hunting_methodUpdateToOneWithWhereWithoutShinyHuntingMethodRatesInput = {
    where?: shiny_hunting_methodWhereInput
    data: XOR<shiny_hunting_methodUpdateWithoutShinyHuntingMethodRatesInput, shiny_hunting_methodUncheckedUpdateWithoutShinyHuntingMethodRatesInput>
  }

  export type shiny_hunting_methodUpdateWithoutShinyHuntingMethodRatesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemons?: owned_pokemonUpdateManyWithoutShinyHuntingMethodNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUpdateManyWithoutShinyHuntingMethodNestedInput
  }

  export type shiny_hunting_methodUncheckedUpdateWithoutShinyHuntingMethodRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutShinyHuntingMethodNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedUpdateManyWithoutShinyHuntingMethodNestedInput
  }

  export type skill_obtationCreateWithoutSkillObtationTypeInput = {
    detail: string
    capacity: capacityCreateNestedOneWithoutSkillObtationsInput
    groupGame: group_gameCreateNestedOneWithoutSkillObtationsInput
    pokemon: pokemonCreateNestedOneWithoutSkillObtationsInput
  }

  export type skill_obtationUncheckedCreateWithoutSkillObtationTypeInput = {
    capacityId: number
    pokemonId: number
    groupGameId: number
    detail: string
  }

  export type skill_obtationCreateOrConnectWithoutSkillObtationTypeInput = {
    where: skill_obtationWhereUniqueInput
    create: XOR<skill_obtationCreateWithoutSkillObtationTypeInput, skill_obtationUncheckedCreateWithoutSkillObtationTypeInput>
  }

  export type skill_obtationCreateManySkillObtationTypeInputEnvelope = {
    data: skill_obtationCreateManySkillObtationTypeInput | skill_obtationCreateManySkillObtationTypeInput[]
    skipDuplicates?: boolean
  }

  export type skill_obtationUpsertWithWhereUniqueWithoutSkillObtationTypeInput = {
    where: skill_obtationWhereUniqueInput
    update: XOR<skill_obtationUpdateWithoutSkillObtationTypeInput, skill_obtationUncheckedUpdateWithoutSkillObtationTypeInput>
    create: XOR<skill_obtationCreateWithoutSkillObtationTypeInput, skill_obtationUncheckedCreateWithoutSkillObtationTypeInput>
  }

  export type skill_obtationUpdateWithWhereUniqueWithoutSkillObtationTypeInput = {
    where: skill_obtationWhereUniqueInput
    data: XOR<skill_obtationUpdateWithoutSkillObtationTypeInput, skill_obtationUncheckedUpdateWithoutSkillObtationTypeInput>
  }

  export type skill_obtationUpdateManyWithWhereWithoutSkillObtationTypeInput = {
    where: skill_obtationScalarWhereInput
    data: XOR<skill_obtationUpdateManyMutationInput, skill_obtationUncheckedUpdateManyWithoutSkillObtationTypeInput>
  }

  export type statistic_group_gameCreateWithoutStatisticInput = {
    groupGame: group_gameCreateNestedOneWithoutStatisticGroupGamesInput
    pokemon: pokemonCreateNestedOneWithoutStatisticGroupGamesInput
  }

  export type statistic_group_gameUncheckedCreateWithoutStatisticInput = {
    groupGameId: number
    pokemonId: number
  }

  export type statistic_group_gameCreateOrConnectWithoutStatisticInput = {
    where: statistic_group_gameWhereUniqueInput
    create: XOR<statistic_group_gameCreateWithoutStatisticInput, statistic_group_gameUncheckedCreateWithoutStatisticInput>
  }

  export type statistic_group_gameCreateManyStatisticInputEnvelope = {
    data: statistic_group_gameCreateManyStatisticInput | statistic_group_gameCreateManyStatisticInput[]
    skipDuplicates?: boolean
  }

  export type statistic_group_gameUpsertWithWhereUniqueWithoutStatisticInput = {
    where: statistic_group_gameWhereUniqueInput
    update: XOR<statistic_group_gameUpdateWithoutStatisticInput, statistic_group_gameUncheckedUpdateWithoutStatisticInput>
    create: XOR<statistic_group_gameCreateWithoutStatisticInput, statistic_group_gameUncheckedCreateWithoutStatisticInput>
  }

  export type statistic_group_gameUpdateWithWhereUniqueWithoutStatisticInput = {
    where: statistic_group_gameWhereUniqueInput
    data: XOR<statistic_group_gameUpdateWithoutStatisticInput, statistic_group_gameUncheckedUpdateWithoutStatisticInput>
  }

  export type statistic_group_gameUpdateManyWithWhereWithoutStatisticInput = {
    where: statistic_group_gameScalarWhereInput
    data: XOR<statistic_group_gameUpdateManyMutationInput, statistic_group_gameUncheckedUpdateManyWithoutStatisticInput>
  }

  export type group_gameCreateWithoutStatisticGroupGamesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoCreateNestedManyWithoutGroupGameInput
    gameGroupGames?: game_group_gameCreateNestedManyWithoutGroupGameInput
    nationnalNumbers?: national_numberCreateNestedManyWithoutGroupGameInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameCreateNestedManyWithoutGroupGameInput
    skillObtations?: skill_obtationCreateNestedManyWithoutGroupGameInput
  }

  export type group_gameUncheckedCreateWithoutStatisticGroupGamesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutGroupGameInput
    gameGroupGames?: game_group_gameUncheckedCreateNestedManyWithoutGroupGameInput
    nationnalNumbers?: national_numberUncheckedCreateNestedManyWithoutGroupGameInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedCreateNestedManyWithoutGroupGameInput
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutGroupGameInput
  }

  export type group_gameCreateOrConnectWithoutStatisticGroupGamesInput = {
    where: group_gameWhereUniqueInput
    create: XOR<group_gameCreateWithoutStatisticGroupGamesInput, group_gameUncheckedCreateWithoutStatisticGroupGamesInput>
  }

  export type pokemonCreateWithoutStatisticGroupGamesInput = {
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    nationalNumbers?: national_numberCreateNestedManyWithoutPokemonInput
    pokemon_category: pokemon_categoryCreateNestedOneWithoutPokemonsInput
    generation: generationCreateNestedOneWithoutPokemonsInput
    pokemonForms?: pokemon_formCreateNestedManyWithoutPokemonInput
    pokemonInfos?: pokemon_infoCreateNestedManyWithoutPokemonInput
    skillObtations?: skill_obtationCreateNestedManyWithoutPokemonInput
  }

  export type pokemonUncheckedCreateWithoutStatisticGroupGamesInput = {
    id?: number
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    pokemonCategoryId: number
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    nationalNumbers?: national_numberUncheckedCreateNestedManyWithoutPokemonInput
    pokemonForms?: pokemon_formUncheckedCreateNestedManyWithoutPokemonInput
    pokemonInfos?: pokemon_infoUncheckedCreateNestedManyWithoutPokemonInput
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type pokemonCreateOrConnectWithoutStatisticGroupGamesInput = {
    where: pokemonWhereUniqueInput
    create: XOR<pokemonCreateWithoutStatisticGroupGamesInput, pokemonUncheckedCreateWithoutStatisticGroupGamesInput>
  }

  export type statisticCreateWithoutStatisticGroupGamesInput = {
    pv: number
    attack: number
    defense: number
    specialAttack?: number | null
    specialDefense?: number | null
    special?: number | null
    speed: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type statisticUncheckedCreateWithoutStatisticGroupGamesInput = {
    id?: number
    pv: number
    attack: number
    defense: number
    specialAttack?: number | null
    specialDefense?: number | null
    special?: number | null
    speed: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type statisticCreateOrConnectWithoutStatisticGroupGamesInput = {
    where: statisticWhereUniqueInput
    create: XOR<statisticCreateWithoutStatisticGroupGamesInput, statisticUncheckedCreateWithoutStatisticGroupGamesInput>
  }

  export type group_gameUpsertWithoutStatisticGroupGamesInput = {
    update: XOR<group_gameUpdateWithoutStatisticGroupGamesInput, group_gameUncheckedUpdateWithoutStatisticGroupGamesInput>
    create: XOR<group_gameCreateWithoutStatisticGroupGamesInput, group_gameUncheckedCreateWithoutStatisticGroupGamesInput>
    where?: group_gameWhereInput
  }

  export type group_gameUpdateToOneWithWhereWithoutStatisticGroupGamesInput = {
    where?: group_gameWhereInput
    data: XOR<group_gameUpdateWithoutStatisticGroupGamesInput, group_gameUncheckedUpdateWithoutStatisticGroupGamesInput>
  }

  export type group_gameUpdateWithoutStatisticGroupGamesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUpdateManyWithoutGroupGameNestedInput
    gameGroupGames?: game_group_gameUpdateManyWithoutGroupGameNestedInput
    nationnalNumbers?: national_numberUpdateManyWithoutGroupGameNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUpdateManyWithoutGroupGameNestedInput
    skillObtations?: skill_obtationUpdateManyWithoutGroupGameNestedInput
  }

  export type group_gameUncheckedUpdateWithoutStatisticGroupGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutGroupGameNestedInput
    gameGroupGames?: game_group_gameUncheckedUpdateManyWithoutGroupGameNestedInput
    nationnalNumbers?: national_numberUncheckedUpdateManyWithoutGroupGameNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedUpdateManyWithoutGroupGameNestedInput
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutGroupGameNestedInput
  }

  export type pokemonUpsertWithoutStatisticGroupGamesInput = {
    update: XOR<pokemonUpdateWithoutStatisticGroupGamesInput, pokemonUncheckedUpdateWithoutStatisticGroupGamesInput>
    create: XOR<pokemonCreateWithoutStatisticGroupGamesInput, pokemonUncheckedCreateWithoutStatisticGroupGamesInput>
    where?: pokemonWhereInput
  }

  export type pokemonUpdateToOneWithWhereWithoutStatisticGroupGamesInput = {
    where?: pokemonWhereInput
    data: XOR<pokemonUpdateWithoutStatisticGroupGamesInput, pokemonUncheckedUpdateWithoutStatisticGroupGamesInput>
  }

  export type pokemonUpdateWithoutStatisticGroupGamesInput = {
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    nationalNumbers?: national_numberUpdateManyWithoutPokemonNestedInput
    pokemon_category?: pokemon_categoryUpdateOneRequiredWithoutPokemonsNestedInput
    generation?: generationUpdateOneRequiredWithoutPokemonsNestedInput
    pokemonForms?: pokemon_formUpdateManyWithoutPokemonNestedInput
    pokemonInfos?: pokemon_infoUpdateManyWithoutPokemonNestedInput
    skillObtations?: skill_obtationUpdateManyWithoutPokemonNestedInput
  }

  export type pokemonUncheckedUpdateWithoutStatisticGroupGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pokemonCategoryId?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    nationalNumbers?: national_numberUncheckedUpdateManyWithoutPokemonNestedInput
    pokemonForms?: pokemon_formUncheckedUpdateManyWithoutPokemonNestedInput
    pokemonInfos?: pokemon_infoUncheckedUpdateManyWithoutPokemonNestedInput
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type statisticUpsertWithoutStatisticGroupGamesInput = {
    update: XOR<statisticUpdateWithoutStatisticGroupGamesInput, statisticUncheckedUpdateWithoutStatisticGroupGamesInput>
    create: XOR<statisticCreateWithoutStatisticGroupGamesInput, statisticUncheckedCreateWithoutStatisticGroupGamesInput>
    where?: statisticWhereInput
  }

  export type statisticUpdateToOneWithWhereWithoutStatisticGroupGamesInput = {
    where?: statisticWhereInput
    data: XOR<statisticUpdateWithoutStatisticGroupGamesInput, statisticUncheckedUpdateWithoutStatisticGroupGamesInput>
  }

  export type statisticUpdateWithoutStatisticGroupGamesInput = {
    pv?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    specialAttack?: NullableIntFieldUpdateOperationsInput | number | null
    specialDefense?: NullableIntFieldUpdateOperationsInput | number | null
    special?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type statisticUncheckedUpdateWithoutStatisticGroupGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    pv?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    specialAttack?: NullableIntFieldUpdateOperationsInput | number | null
    specialDefense?: NullableIntFieldUpdateOperationsInput | number | null
    special?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_infoCreateWithoutTargetInput = {
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityCategory: capacity_categoryCreateNestedOneWithoutCapacityInfosInput
    capacityEffect: capacity_effectCreateNestedOneWithoutCapacityInfosInput
    capacityEffectZ: capacity_effectCreateNestedOneWithoutCapacityZInfosInput
    capacity: capacityCreateNestedOneWithoutCapacityInfosInput
    effectOutsideFight: effect_outside_fightCreateNestedOneWithoutCapacityInfosInput
    type: typeCreateNestedOneWithoutCapacityInfosInput
    capacityInfoInfluences?: capacity_info_influenceCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoUncheckedCreateWithoutTargetInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    capacityEffectId: number
    capacityId: number
    capacityEffectZId: number
    typeId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfoInfluences?: capacity_info_influenceUncheckedCreateNestedManyWithoutCapacityInfoInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoCreateOrConnectWithoutTargetInput = {
    where: capacity_infoWhereUniqueInput
    create: XOR<capacity_infoCreateWithoutTargetInput, capacity_infoUncheckedCreateWithoutTargetInput>
  }

  export type capacity_infoCreateManyTargetInputEnvelope = {
    data: capacity_infoCreateManyTargetInput | capacity_infoCreateManyTargetInput[]
    skipDuplicates?: boolean
  }

  export type capacity_infoUpsertWithWhereUniqueWithoutTargetInput = {
    where: capacity_infoWhereUniqueInput
    update: XOR<capacity_infoUpdateWithoutTargetInput, capacity_infoUncheckedUpdateWithoutTargetInput>
    create: XOR<capacity_infoCreateWithoutTargetInput, capacity_infoUncheckedCreateWithoutTargetInput>
  }

  export type capacity_infoUpdateWithWhereUniqueWithoutTargetInput = {
    where: capacity_infoWhereUniqueInput
    data: XOR<capacity_infoUpdateWithoutTargetInput, capacity_infoUncheckedUpdateWithoutTargetInput>
  }

  export type capacity_infoUpdateManyWithWhereWithoutTargetInput = {
    where: capacity_infoScalarWhereInput
    data: XOR<capacity_infoUpdateManyMutationInput, capacity_infoUncheckedUpdateManyWithoutTargetInput>
  }

  export type capacity_categoryCreateWithoutCapacityInfosInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type capacity_categoryUncheckedCreateWithoutCapacityInfosInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type capacity_categoryCreateOrConnectWithoutCapacityInfosInput = {
    where: capacity_categoryWhereUniqueInput
    create: XOR<capacity_categoryCreateWithoutCapacityInfosInput, capacity_categoryUncheckedCreateWithoutCapacityInfosInput>
  }

  export type capacity_effectCreateWithoutCapacityInfosInput = {
    zEffect: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityZInfos?: capacity_infoCreateNestedManyWithoutCapacityEffectZInput
  }

  export type capacity_effectUncheckedCreateWithoutCapacityInfosInput = {
    id?: number
    zEffect: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityZInfos?: capacity_infoUncheckedCreateNestedManyWithoutCapacityEffectZInput
  }

  export type capacity_effectCreateOrConnectWithoutCapacityInfosInput = {
    where: capacity_effectWhereUniqueInput
    create: XOR<capacity_effectCreateWithoutCapacityInfosInput, capacity_effectUncheckedCreateWithoutCapacityInfosInput>
  }

  export type capacity_effectCreateWithoutCapacityZInfosInput = {
    zEffect: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoCreateNestedManyWithoutCapacityEffectInput
  }

  export type capacity_effectUncheckedCreateWithoutCapacityZInfosInput = {
    id?: number
    zEffect: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoUncheckedCreateNestedManyWithoutCapacityEffectInput
  }

  export type capacity_effectCreateOrConnectWithoutCapacityZInfosInput = {
    where: capacity_effectWhereUniqueInput
    create: XOR<capacity_effectCreateWithoutCapacityZInfosInput, capacity_effectUncheckedCreateWithoutCapacityZInfosInput>
  }

  export type capacityCreateWithoutCapacityInfosInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    skillObtations?: skill_obtationCreateNestedManyWithoutCapacityInput
  }

  export type capacityUncheckedCreateWithoutCapacityInfosInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    skillObtations?: skill_obtationUncheckedCreateNestedManyWithoutCapacityInput
  }

  export type capacityCreateOrConnectWithoutCapacityInfosInput = {
    where: capacityWhereUniqueInput
    create: XOR<capacityCreateWithoutCapacityInfosInput, capacityUncheckedCreateWithoutCapacityInfosInput>
  }

  export type effect_outside_fightCreateWithoutCapacityInfosInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityInfos?: ability_infoCreateNestedManyWithoutEffectWithoutFightInput
  }

  export type effect_outside_fightUncheckedCreateWithoutCapacityInfosInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    abilityInfos?: ability_infoUncheckedCreateNestedManyWithoutEffectWithoutFightInput
  }

  export type effect_outside_fightCreateOrConnectWithoutCapacityInfosInput = {
    where: effect_outside_fightWhereUniqueInput
    create: XOR<effect_outside_fightCreateWithoutCapacityInfosInput, effect_outside_fightUncheckedCreateWithoutCapacityInfosInput>
  }

  export type targetCreateWithoutCapacityInfosInput = {
    isMultiple: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type targetUncheckedCreateWithoutCapacityInfosInput = {
    id?: number
    isMultiple: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type targetCreateOrConnectWithoutCapacityInfosInput = {
    where: targetWhereUniqueInput
    create: XOR<targetCreateWithoutCapacityInfosInput, targetUncheckedCreateWithoutCapacityInfosInput>
  }

  export type typeCreateWithoutCapacityInfosInput = {
    color: string
    iconName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    typeOrders?: type_orderCreateNestedManyWithoutTypeInput
  }

  export type typeUncheckedCreateWithoutCapacityInfosInput = {
    id?: number
    color: string
    iconName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    typeOrders?: type_orderUncheckedCreateNestedManyWithoutTypeInput
  }

  export type typeCreateOrConnectWithoutCapacityInfosInput = {
    where: typeWhereUniqueInput
    create: XOR<typeCreateWithoutCapacityInfosInput, typeUncheckedCreateWithoutCapacityInfosInput>
  }

  export type capacity_info_influenceCreateWithoutCapacityInfoInput = {
    influence: influenceCreateNestedOneWithoutCapacityInfoInfluencesInput
  }

  export type capacity_info_influenceUncheckedCreateWithoutCapacityInfoInput = {
    influenceId: number
  }

  export type capacity_info_influenceCreateOrConnectWithoutCapacityInfoInput = {
    where: capacity_info_influenceWhereUniqueInput
    create: XOR<capacity_info_influenceCreateWithoutCapacityInfoInput, capacity_info_influenceUncheckedCreateWithoutCapacityInfoInput>
  }

  export type capacity_info_influenceCreateManyCapacityInfoInputEnvelope = {
    data: capacity_info_influenceCreateManyCapacityInfoInput | capacity_info_influenceCreateManyCapacityInfoInput[]
    skipDuplicates?: boolean
  }

  export type capsule_game_capacity_infoCreateWithoutCapacityInfoInput = {
    capsule: capsuleCreateNestedOneWithoutCapsule_game_capacity_infoInput
    groupGame: group_gameCreateNestedOneWithoutCapsuleGameCapacityIinfosInput
  }

  export type capsule_game_capacity_infoUncheckedCreateWithoutCapacityInfoInput = {
    capsuleId: number
    groupeGameId: number
  }

  export type capsule_game_capacity_infoCreateOrConnectWithoutCapacityInfoInput = {
    where: capsule_game_capacity_infoWhereUniqueInput
    create: XOR<capsule_game_capacity_infoCreateWithoutCapacityInfoInput, capsule_game_capacity_infoUncheckedCreateWithoutCapacityInfoInput>
  }

  export type capsule_game_capacity_infoCreateManyCapacityInfoInputEnvelope = {
    data: capsule_game_capacity_infoCreateManyCapacityInfoInput | capsule_game_capacity_infoCreateManyCapacityInfoInput[]
    skipDuplicates?: boolean
  }

  export type capacity_categoryUpsertWithoutCapacityInfosInput = {
    update: XOR<capacity_categoryUpdateWithoutCapacityInfosInput, capacity_categoryUncheckedUpdateWithoutCapacityInfosInput>
    create: XOR<capacity_categoryCreateWithoutCapacityInfosInput, capacity_categoryUncheckedCreateWithoutCapacityInfosInput>
    where?: capacity_categoryWhereInput
  }

  export type capacity_categoryUpdateToOneWithWhereWithoutCapacityInfosInput = {
    where?: capacity_categoryWhereInput
    data: XOR<capacity_categoryUpdateWithoutCapacityInfosInput, capacity_categoryUncheckedUpdateWithoutCapacityInfosInput>
  }

  export type capacity_categoryUpdateWithoutCapacityInfosInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_categoryUncheckedUpdateWithoutCapacityInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_effectUpsertWithoutCapacityInfosInput = {
    update: XOR<capacity_effectUpdateWithoutCapacityInfosInput, capacity_effectUncheckedUpdateWithoutCapacityInfosInput>
    create: XOR<capacity_effectCreateWithoutCapacityInfosInput, capacity_effectUncheckedCreateWithoutCapacityInfosInput>
    where?: capacity_effectWhereInput
  }

  export type capacity_effectUpdateToOneWithWhereWithoutCapacityInfosInput = {
    where?: capacity_effectWhereInput
    data: XOR<capacity_effectUpdateWithoutCapacityInfosInput, capacity_effectUncheckedUpdateWithoutCapacityInfosInput>
  }

  export type capacity_effectUpdateWithoutCapacityInfosInput = {
    zEffect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityZInfos?: capacity_infoUpdateManyWithoutCapacityEffectZNestedInput
  }

  export type capacity_effectUncheckedUpdateWithoutCapacityInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    zEffect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityZInfos?: capacity_infoUncheckedUpdateManyWithoutCapacityEffectZNestedInput
  }

  export type capacity_effectUpsertWithoutCapacityZInfosInput = {
    update: XOR<capacity_effectUpdateWithoutCapacityZInfosInput, capacity_effectUncheckedUpdateWithoutCapacityZInfosInput>
    create: XOR<capacity_effectCreateWithoutCapacityZInfosInput, capacity_effectUncheckedCreateWithoutCapacityZInfosInput>
    where?: capacity_effectWhereInput
  }

  export type capacity_effectUpdateToOneWithWhereWithoutCapacityZInfosInput = {
    where?: capacity_effectWhereInput
    data: XOR<capacity_effectUpdateWithoutCapacityZInfosInput, capacity_effectUncheckedUpdateWithoutCapacityZInfosInput>
  }

  export type capacity_effectUpdateWithoutCapacityZInfosInput = {
    zEffect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUpdateManyWithoutCapacityEffectNestedInput
  }

  export type capacity_effectUncheckedUpdateWithoutCapacityZInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    zEffect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUncheckedUpdateManyWithoutCapacityEffectNestedInput
  }

  export type capacityUpsertWithoutCapacityInfosInput = {
    update: XOR<capacityUpdateWithoutCapacityInfosInput, capacityUncheckedUpdateWithoutCapacityInfosInput>
    create: XOR<capacityCreateWithoutCapacityInfosInput, capacityUncheckedCreateWithoutCapacityInfosInput>
    where?: capacityWhereInput
  }

  export type capacityUpdateToOneWithWhereWithoutCapacityInfosInput = {
    where?: capacityWhereInput
    data: XOR<capacityUpdateWithoutCapacityInfosInput, capacityUncheckedUpdateWithoutCapacityInfosInput>
  }

  export type capacityUpdateWithoutCapacityInfosInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    skillObtations?: skill_obtationUpdateManyWithoutCapacityNestedInput
  }

  export type capacityUncheckedUpdateWithoutCapacityInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutCapacityNestedInput
  }

  export type effect_outside_fightUpsertWithoutCapacityInfosInput = {
    update: XOR<effect_outside_fightUpdateWithoutCapacityInfosInput, effect_outside_fightUncheckedUpdateWithoutCapacityInfosInput>
    create: XOR<effect_outside_fightCreateWithoutCapacityInfosInput, effect_outside_fightUncheckedCreateWithoutCapacityInfosInput>
    where?: effect_outside_fightWhereInput
  }

  export type effect_outside_fightUpdateToOneWithWhereWithoutCapacityInfosInput = {
    where?: effect_outside_fightWhereInput
    data: XOR<effect_outside_fightUpdateWithoutCapacityInfosInput, effect_outside_fightUncheckedUpdateWithoutCapacityInfosInput>
  }

  export type effect_outside_fightUpdateWithoutCapacityInfosInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityInfos?: ability_infoUpdateManyWithoutEffectWithoutFightNestedInput
  }

  export type effect_outside_fightUncheckedUpdateWithoutCapacityInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityInfos?: ability_infoUncheckedUpdateManyWithoutEffectWithoutFightNestedInput
  }

  export type targetUpsertWithoutCapacityInfosInput = {
    update: XOR<targetUpdateWithoutCapacityInfosInput, targetUncheckedUpdateWithoutCapacityInfosInput>
    create: XOR<targetCreateWithoutCapacityInfosInput, targetUncheckedCreateWithoutCapacityInfosInput>
    where?: targetWhereInput
  }

  export type targetUpdateToOneWithWhereWithoutCapacityInfosInput = {
    where?: targetWhereInput
    data: XOR<targetUpdateWithoutCapacityInfosInput, targetUncheckedUpdateWithoutCapacityInfosInput>
  }

  export type targetUpdateWithoutCapacityInfosInput = {
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type targetUncheckedUpdateWithoutCapacityInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type typeUpsertWithoutCapacityInfosInput = {
    update: XOR<typeUpdateWithoutCapacityInfosInput, typeUncheckedUpdateWithoutCapacityInfosInput>
    create: XOR<typeCreateWithoutCapacityInfosInput, typeUncheckedCreateWithoutCapacityInfosInput>
    where?: typeWhereInput
  }

  export type typeUpdateToOneWithWhereWithoutCapacityInfosInput = {
    where?: typeWhereInput
    data: XOR<typeUpdateWithoutCapacityInfosInput, typeUncheckedUpdateWithoutCapacityInfosInput>
  }

  export type typeUpdateWithoutCapacityInfosInput = {
    color?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    typeOrders?: type_orderUpdateManyWithoutTypeNestedInput
  }

  export type typeUncheckedUpdateWithoutCapacityInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    typeOrders?: type_orderUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type capacity_info_influenceUpsertWithWhereUniqueWithoutCapacityInfoInput = {
    where: capacity_info_influenceWhereUniqueInput
    update: XOR<capacity_info_influenceUpdateWithoutCapacityInfoInput, capacity_info_influenceUncheckedUpdateWithoutCapacityInfoInput>
    create: XOR<capacity_info_influenceCreateWithoutCapacityInfoInput, capacity_info_influenceUncheckedCreateWithoutCapacityInfoInput>
  }

  export type capacity_info_influenceUpdateWithWhereUniqueWithoutCapacityInfoInput = {
    where: capacity_info_influenceWhereUniqueInput
    data: XOR<capacity_info_influenceUpdateWithoutCapacityInfoInput, capacity_info_influenceUncheckedUpdateWithoutCapacityInfoInput>
  }

  export type capacity_info_influenceUpdateManyWithWhereWithoutCapacityInfoInput = {
    where: capacity_info_influenceScalarWhereInput
    data: XOR<capacity_info_influenceUpdateManyMutationInput, capacity_info_influenceUncheckedUpdateManyWithoutCapacityInfoInput>
  }

  export type capsule_game_capacity_infoUpsertWithWhereUniqueWithoutCapacityInfoInput = {
    where: capsule_game_capacity_infoWhereUniqueInput
    update: XOR<capsule_game_capacity_infoUpdateWithoutCapacityInfoInput, capsule_game_capacity_infoUncheckedUpdateWithoutCapacityInfoInput>
    create: XOR<capsule_game_capacity_infoCreateWithoutCapacityInfoInput, capsule_game_capacity_infoUncheckedCreateWithoutCapacityInfoInput>
  }

  export type capsule_game_capacity_infoUpdateWithWhereUniqueWithoutCapacityInfoInput = {
    where: capsule_game_capacity_infoWhereUniqueInput
    data: XOR<capsule_game_capacity_infoUpdateWithoutCapacityInfoInput, capsule_game_capacity_infoUncheckedUpdateWithoutCapacityInfoInput>
  }

  export type capsule_game_capacity_infoUpdateManyWithWhereWithoutCapacityInfoInput = {
    where: capsule_game_capacity_infoScalarWhereInput
    data: XOR<capsule_game_capacity_infoUpdateManyMutationInput, capsule_game_capacity_infoUncheckedUpdateManyWithoutCapacityInfoInput>
  }

  export type capacity_infoCreateWithoutCapacityInfoInfluencesInput = {
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityCategory: capacity_categoryCreateNestedOneWithoutCapacityInfosInput
    capacityEffect: capacity_effectCreateNestedOneWithoutCapacityInfosInput
    capacityEffectZ: capacity_effectCreateNestedOneWithoutCapacityZInfosInput
    capacity: capacityCreateNestedOneWithoutCapacityInfosInput
    effectOutsideFight: effect_outside_fightCreateNestedOneWithoutCapacityInfosInput
    target: targetCreateNestedOneWithoutCapacityInfosInput
    type: typeCreateNestedOneWithoutCapacityInfosInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoUncheckedCreateWithoutCapacityInfoInfluencesInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityId: number
    capacityEffectZId: number
    typeId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutCapacityInfoInput
  }

  export type capacity_infoCreateOrConnectWithoutCapacityInfoInfluencesInput = {
    where: capacity_infoWhereUniqueInput
    create: XOR<capacity_infoCreateWithoutCapacityInfoInfluencesInput, capacity_infoUncheckedCreateWithoutCapacityInfoInfluencesInput>
  }

  export type influenceCreateWithoutCapacityInfoInfluencesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type influenceUncheckedCreateWithoutCapacityInfoInfluencesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type influenceCreateOrConnectWithoutCapacityInfoInfluencesInput = {
    where: influenceWhereUniqueInput
    create: XOR<influenceCreateWithoutCapacityInfoInfluencesInput, influenceUncheckedCreateWithoutCapacityInfoInfluencesInput>
  }

  export type capacity_infoUpsertWithoutCapacityInfoInfluencesInput = {
    update: XOR<capacity_infoUpdateWithoutCapacityInfoInfluencesInput, capacity_infoUncheckedUpdateWithoutCapacityInfoInfluencesInput>
    create: XOR<capacity_infoCreateWithoutCapacityInfoInfluencesInput, capacity_infoUncheckedCreateWithoutCapacityInfoInfluencesInput>
    where?: capacity_infoWhereInput
  }

  export type capacity_infoUpdateToOneWithWhereWithoutCapacityInfoInfluencesInput = {
    where?: capacity_infoWhereInput
    data: XOR<capacity_infoUpdateWithoutCapacityInfoInfluencesInput, capacity_infoUncheckedUpdateWithoutCapacityInfoInfluencesInput>
  }

  export type capacity_infoUpdateWithoutCapacityInfoInfluencesInput = {
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityCategory?: capacity_categoryUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffect?: capacity_effectUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffectZ?: capacity_effectUpdateOneRequiredWithoutCapacityZInfosNestedInput
    capacity?: capacityUpdateOneRequiredWithoutCapacityInfosNestedInput
    effectOutsideFight?: effect_outside_fightUpdateOneRequiredWithoutCapacityInfosNestedInput
    target?: targetUpdateOneRequiredWithoutCapacityInfosNestedInput
    type?: typeUpdateOneRequiredWithoutCapacityInfosNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateWithoutCapacityInfoInfluencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutCapacityInfoNestedInput
  }

  export type influenceUpsertWithoutCapacityInfoInfluencesInput = {
    update: XOR<influenceUpdateWithoutCapacityInfoInfluencesInput, influenceUncheckedUpdateWithoutCapacityInfoInfluencesInput>
    create: XOR<influenceCreateWithoutCapacityInfoInfluencesInput, influenceUncheckedCreateWithoutCapacityInfoInfluencesInput>
    where?: influenceWhereInput
  }

  export type influenceUpdateToOneWithWhereWithoutCapacityInfoInfluencesInput = {
    where?: influenceWhereInput
    data: XOR<influenceUpdateWithoutCapacityInfoInfluencesInput, influenceUncheckedUpdateWithoutCapacityInfoInfluencesInput>
  }

  export type influenceUpdateWithoutCapacityInfoInfluencesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type influenceUncheckedUpdateWithoutCapacityInfoInfluencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type gameCreateWithoutPokemonRatingGamesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    generation: generationCreateNestedOneWithoutGamesInput
    gameGroupGames?: game_group_gameCreateNestedManyWithoutGameInput
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutGameInput
  }

  export type gameUncheckedCreateWithoutPokemonRatingGamesInput = {
    id?: number
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    gameGroupGames?: game_group_gameUncheckedCreateNestedManyWithoutGameInput
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutGameInput
  }

  export type gameCreateOrConnectWithoutPokemonRatingGamesInput = {
    where: gameWhereUniqueInput
    create: XOR<gameCreateWithoutPokemonRatingGamesInput, gameUncheckedCreateWithoutPokemonRatingGamesInput>
  }

  export type location_zoneCreateWithoutPokemonRatingGamesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    location: locationCreateNestedOneWithoutLocationZonesInput
    zone: zoneCreateNestedOneWithoutLocationZonesInput
  }

  export type location_zoneUncheckedCreateWithoutPokemonRatingGamesInput = {
    id?: number
    locationId: number
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type location_zoneCreateOrConnectWithoutPokemonRatingGamesInput = {
    where: location_zoneWhereUniqueInput
    create: XOR<location_zoneCreateWithoutPokemonRatingGamesInput, location_zoneUncheckedCreateWithoutPokemonRatingGamesInput>
  }

  export type pokemon_formCreateWithoutPokemonRatingGamesInput = {
    createdAt?: Date | string
    status?: string
    updatedAt?: Date | string | null
    evolutionEnds?: evolutionCreateNestedManyWithoutPokemonEndInput
    evolutionStarts?: evolutionCreateNestedManyWithoutPokemonStartInput
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutPokemonFormsInput
    form: formCreateNestedOneWithoutPokemonFormsInput
    pokemon: pokemonCreateNestedOneWithoutPokemonFormsInput
    pokemonFormGenders?: pokemon_form_genderCreateNestedManyWithoutPokemon_formInput
  }

  export type pokemon_formUncheckedCreateWithoutPokemonRatingGamesInput = {
    pokemonId: number
    formId: number
    createdAt?: Date | string
    id?: number
    status?: string
    updatedAt?: Date | string | null
    evolutionEnds?: evolutionUncheckedCreateNestedManyWithoutPokemonEndInput
    evolutionStarts?: evolutionUncheckedCreateNestedManyWithoutPokemonStartInput
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutPokemonFormsInput
    pokemonFormGenders?: pokemon_form_genderUncheckedCreateNestedManyWithoutPokemon_formInput
  }

  export type pokemon_formCreateOrConnectWithoutPokemonRatingGamesInput = {
    where: pokemon_formWhereUniqueInput
    create: XOR<pokemon_formCreateWithoutPokemonRatingGamesInput, pokemon_formUncheckedCreateWithoutPokemonRatingGamesInput>
  }

  export type pokemon_obtationCreateWithoutPokemonRatingGamesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokemon_obtationUncheckedCreateWithoutPokemonRatingGamesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokemon_obtationCreateOrConnectWithoutPokemonRatingGamesInput = {
    where: pokemon_obtationWhereUniqueInput
    create: XOR<pokemon_obtationCreateWithoutPokemonRatingGamesInput, pokemon_obtationUncheckedCreateWithoutPokemonRatingGamesInput>
  }

  export type rateCreateWithoutPokemonRatingGamesInput = {
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
    conditionRate: detailCreateNestedOneWithoutConditionRatesInput
    detailRate: detailCreateNestedOneWithoutDetailRatesInput
    meteo: meteoCreateNestedOneWithoutRatesInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateCreateNestedManyWithoutRateInput
  }

  export type rateUncheckedCreateWithoutPokemonRatingGamesInput = {
    id?: number
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    meteoId: number
    detailRateId: number
    conditionRateId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedCreateNestedManyWithoutRateInput
  }

  export type rateCreateOrConnectWithoutPokemonRatingGamesInput = {
    where: rateWhereUniqueInput
    create: XOR<rateCreateWithoutPokemonRatingGamesInput, rateUncheckedCreateWithoutPokemonRatingGamesInput>
  }

  export type gameUpsertWithoutPokemonRatingGamesInput = {
    update: XOR<gameUpdateWithoutPokemonRatingGamesInput, gameUncheckedUpdateWithoutPokemonRatingGamesInput>
    create: XOR<gameCreateWithoutPokemonRatingGamesInput, gameUncheckedCreateWithoutPokemonRatingGamesInput>
    where?: gameWhereInput
  }

  export type gameUpdateToOneWithWhereWithoutPokemonRatingGamesInput = {
    where?: gameWhereInput
    data: XOR<gameUpdateWithoutPokemonRatingGamesInput, gameUncheckedUpdateWithoutPokemonRatingGamesInput>
  }

  export type gameUpdateWithoutPokemonRatingGamesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    generation?: generationUpdateOneRequiredWithoutGamesNestedInput
    gameGroupGames?: game_group_gameUpdateManyWithoutGameNestedInput
    ownedPokemons?: owned_pokemonUpdateManyWithoutGameNestedInput
  }

  export type gameUncheckedUpdateWithoutPokemonRatingGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameGroupGames?: game_group_gameUncheckedUpdateManyWithoutGameNestedInput
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutGameNestedInput
  }

  export type location_zoneUpsertWithoutPokemonRatingGamesInput = {
    update: XOR<location_zoneUpdateWithoutPokemonRatingGamesInput, location_zoneUncheckedUpdateWithoutPokemonRatingGamesInput>
    create: XOR<location_zoneCreateWithoutPokemonRatingGamesInput, location_zoneUncheckedCreateWithoutPokemonRatingGamesInput>
    where?: location_zoneWhereInput
  }

  export type location_zoneUpdateToOneWithWhereWithoutPokemonRatingGamesInput = {
    where?: location_zoneWhereInput
    data: XOR<location_zoneUpdateWithoutPokemonRatingGamesInput, location_zoneUncheckedUpdateWithoutPokemonRatingGamesInput>
  }

  export type location_zoneUpdateWithoutPokemonRatingGamesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: locationUpdateOneRequiredWithoutLocationZonesNestedInput
    zone?: zoneUpdateOneRequiredWithoutLocationZonesNestedInput
  }

  export type location_zoneUncheckedUpdateWithoutPokemonRatingGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_formUpsertWithoutPokemonRatingGamesInput = {
    update: XOR<pokemon_formUpdateWithoutPokemonRatingGamesInput, pokemon_formUncheckedUpdateWithoutPokemonRatingGamesInput>
    create: XOR<pokemon_formCreateWithoutPokemonRatingGamesInput, pokemon_formUncheckedCreateWithoutPokemonRatingGamesInput>
    where?: pokemon_formWhereInput
  }

  export type pokemon_formUpdateToOneWithWhereWithoutPokemonRatingGamesInput = {
    where?: pokemon_formWhereInput
    data: XOR<pokemon_formUpdateWithoutPokemonRatingGamesInput, pokemon_formUncheckedUpdateWithoutPokemonRatingGamesInput>
  }

  export type pokemon_formUpdateWithoutPokemonRatingGamesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionEnds?: evolutionUpdateManyWithoutPokemonEndNestedInput
    evolutionStarts?: evolutionUpdateManyWithoutPokemonStartNestedInput
    ownedPokemons?: owned_pokemonUpdateManyWithoutPokemonFormsNestedInput
    form?: formUpdateOneRequiredWithoutPokemonFormsNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutPokemonFormsNestedInput
    pokemonFormGenders?: pokemon_form_genderUpdateManyWithoutPokemon_formNestedInput
  }

  export type pokemon_formUncheckedUpdateWithoutPokemonRatingGamesInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionEnds?: evolutionUncheckedUpdateManyWithoutPokemonEndNestedInput
    evolutionStarts?: evolutionUncheckedUpdateManyWithoutPokemonStartNestedInput
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutPokemonFormsNestedInput
    pokemonFormGenders?: pokemon_form_genderUncheckedUpdateManyWithoutPokemon_formNestedInput
  }

  export type pokemon_obtationUpsertWithoutPokemonRatingGamesInput = {
    update: XOR<pokemon_obtationUpdateWithoutPokemonRatingGamesInput, pokemon_obtationUncheckedUpdateWithoutPokemonRatingGamesInput>
    create: XOR<pokemon_obtationCreateWithoutPokemonRatingGamesInput, pokemon_obtationUncheckedCreateWithoutPokemonRatingGamesInput>
    where?: pokemon_obtationWhereInput
  }

  export type pokemon_obtationUpdateToOneWithWhereWithoutPokemonRatingGamesInput = {
    where?: pokemon_obtationWhereInput
    data: XOR<pokemon_obtationUpdateWithoutPokemonRatingGamesInput, pokemon_obtationUncheckedUpdateWithoutPokemonRatingGamesInput>
  }

  export type pokemon_obtationUpdateWithoutPokemonRatingGamesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_obtationUncheckedUpdateWithoutPokemonRatingGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type rateUpsertWithoutPokemonRatingGamesInput = {
    update: XOR<rateUpdateWithoutPokemonRatingGamesInput, rateUncheckedUpdateWithoutPokemonRatingGamesInput>
    create: XOR<rateCreateWithoutPokemonRatingGamesInput, rateUncheckedCreateWithoutPokemonRatingGamesInput>
    where?: rateWhereInput
  }

  export type rateUpdateToOneWithWhereWithoutPokemonRatingGamesInput = {
    where?: rateWhereInput
    data: XOR<rateUpdateWithoutPokemonRatingGamesInput, rateUncheckedUpdateWithoutPokemonRatingGamesInput>
  }

  export type rateUpdateWithoutPokemonRatingGamesInput = {
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
    conditionRate?: detailUpdateOneRequiredWithoutConditionRatesNestedInput
    detailRate?: detailUpdateOneRequiredWithoutDetailRatesNestedInput
    meteo?: meteoUpdateOneRequiredWithoutRatesNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUpdateManyWithoutRateNestedInput
  }

  export type rateUncheckedUpdateWithoutPokemonRatingGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    meteoId?: IntFieldUpdateOperationsInput | number
    detailRateId?: IntFieldUpdateOperationsInput | number
    conditionRateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedUpdateManyWithoutRateNestedInput
  }

  export type capacityCreateWithoutSkillObtationsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoCreateNestedManyWithoutCapacityInput
  }

  export type capacityUncheckedCreateWithoutSkillObtationsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capacityInfos?: capacity_infoUncheckedCreateNestedManyWithoutCapacityInput
  }

  export type capacityCreateOrConnectWithoutSkillObtationsInput = {
    where: capacityWhereUniqueInput
    create: XOR<capacityCreateWithoutSkillObtationsInput, capacityUncheckedCreateWithoutSkillObtationsInput>
  }

  export type group_gameCreateWithoutSkillObtationsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoCreateNestedManyWithoutGroupGameInput
    gameGroupGames?: game_group_gameCreateNestedManyWithoutGroupGameInput
    nationnalNumbers?: national_numberCreateNestedManyWithoutGroupGameInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameCreateNestedManyWithoutGroupGameInput
    statisticGroupGames?: statistic_group_gameCreateNestedManyWithoutGroupGameInput
  }

  export type group_gameUncheckedCreateWithoutSkillObtationsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUncheckedCreateNestedManyWithoutGroupGameInput
    gameGroupGames?: game_group_gameUncheckedCreateNestedManyWithoutGroupGameInput
    nationnalNumbers?: national_numberUncheckedCreateNestedManyWithoutGroupGameInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedCreateNestedManyWithoutGroupGameInput
    statisticGroupGames?: statistic_group_gameUncheckedCreateNestedManyWithoutGroupGameInput
  }

  export type group_gameCreateOrConnectWithoutSkillObtationsInput = {
    where: group_gameWhereUniqueInput
    create: XOR<group_gameCreateWithoutSkillObtationsInput, group_gameUncheckedCreateWithoutSkillObtationsInput>
  }

  export type pokemonCreateWithoutSkillObtationsInput = {
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    nationalNumbers?: national_numberCreateNestedManyWithoutPokemonInput
    pokemon_category: pokemon_categoryCreateNestedOneWithoutPokemonsInput
    generation: generationCreateNestedOneWithoutPokemonsInput
    pokemonForms?: pokemon_formCreateNestedManyWithoutPokemonInput
    pokemonInfos?: pokemon_infoCreateNestedManyWithoutPokemonInput
    statisticGroupGames?: statistic_group_gameCreateNestedManyWithoutPokemonInput
  }

  export type pokemonUncheckedCreateWithoutSkillObtationsInput = {
    id?: number
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    pokemonCategoryId: number
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    nationalNumbers?: national_numberUncheckedCreateNestedManyWithoutPokemonInput
    pokemonForms?: pokemon_formUncheckedCreateNestedManyWithoutPokemonInput
    pokemonInfos?: pokemon_infoUncheckedCreateNestedManyWithoutPokemonInput
    statisticGroupGames?: statistic_group_gameUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type pokemonCreateOrConnectWithoutSkillObtationsInput = {
    where: pokemonWhereUniqueInput
    create: XOR<pokemonCreateWithoutSkillObtationsInput, pokemonUncheckedCreateWithoutSkillObtationsInput>
  }

  export type skill_obtation_typeCreateWithoutSkillObtationsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type skill_obtation_typeUncheckedCreateWithoutSkillObtationsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type skill_obtation_typeCreateOrConnectWithoutSkillObtationsInput = {
    where: skill_obtation_typeWhereUniqueInput
    create: XOR<skill_obtation_typeCreateWithoutSkillObtationsInput, skill_obtation_typeUncheckedCreateWithoutSkillObtationsInput>
  }

  export type capacityUpsertWithoutSkillObtationsInput = {
    update: XOR<capacityUpdateWithoutSkillObtationsInput, capacityUncheckedUpdateWithoutSkillObtationsInput>
    create: XOR<capacityCreateWithoutSkillObtationsInput, capacityUncheckedCreateWithoutSkillObtationsInput>
    where?: capacityWhereInput
  }

  export type capacityUpdateToOneWithWhereWithoutSkillObtationsInput = {
    where?: capacityWhereInput
    data: XOR<capacityUpdateWithoutSkillObtationsInput, capacityUncheckedUpdateWithoutSkillObtationsInput>
  }

  export type capacityUpdateWithoutSkillObtationsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUpdateManyWithoutCapacityNestedInput
  }

  export type capacityUncheckedUpdateWithoutSkillObtationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfos?: capacity_infoUncheckedUpdateManyWithoutCapacityNestedInput
  }

  export type group_gameUpsertWithoutSkillObtationsInput = {
    update: XOR<group_gameUpdateWithoutSkillObtationsInput, group_gameUncheckedUpdateWithoutSkillObtationsInput>
    create: XOR<group_gameCreateWithoutSkillObtationsInput, group_gameUncheckedCreateWithoutSkillObtationsInput>
    where?: group_gameWhereInput
  }

  export type group_gameUpdateToOneWithWhereWithoutSkillObtationsInput = {
    where?: group_gameWhereInput
    data: XOR<group_gameUpdateWithoutSkillObtationsInput, group_gameUncheckedUpdateWithoutSkillObtationsInput>
  }

  export type group_gameUpdateWithoutSkillObtationsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUpdateManyWithoutGroupGameNestedInput
    gameGroupGames?: game_group_gameUpdateManyWithoutGroupGameNestedInput
    nationnalNumbers?: national_numberUpdateManyWithoutGroupGameNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUpdateManyWithoutGroupGameNestedInput
    statisticGroupGames?: statistic_group_gameUpdateManyWithoutGroupGameNestedInput
  }

  export type group_gameUncheckedUpdateWithoutSkillObtationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capsuleGameCapacityIinfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutGroupGameNestedInput
    gameGroupGames?: game_group_gameUncheckedUpdateManyWithoutGroupGameNestedInput
    nationnalNumbers?: national_numberUncheckedUpdateManyWithoutGroupGameNestedInput
    shinyHuntingMethodGames?: shiny_hunting_method_gameUncheckedUpdateManyWithoutGroupGameNestedInput
    statisticGroupGames?: statistic_group_gameUncheckedUpdateManyWithoutGroupGameNestedInput
  }

  export type pokemonUpsertWithoutSkillObtationsInput = {
    update: XOR<pokemonUpdateWithoutSkillObtationsInput, pokemonUncheckedUpdateWithoutSkillObtationsInput>
    create: XOR<pokemonCreateWithoutSkillObtationsInput, pokemonUncheckedCreateWithoutSkillObtationsInput>
    where?: pokemonWhereInput
  }

  export type pokemonUpdateToOneWithWhereWithoutSkillObtationsInput = {
    where?: pokemonWhereInput
    data: XOR<pokemonUpdateWithoutSkillObtationsInput, pokemonUncheckedUpdateWithoutSkillObtationsInput>
  }

  export type pokemonUpdateWithoutSkillObtationsInput = {
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    nationalNumbers?: national_numberUpdateManyWithoutPokemonNestedInput
    pokemon_category?: pokemon_categoryUpdateOneRequiredWithoutPokemonsNestedInput
    generation?: generationUpdateOneRequiredWithoutPokemonsNestedInput
    pokemonForms?: pokemon_formUpdateManyWithoutPokemonNestedInput
    pokemonInfos?: pokemon_infoUpdateManyWithoutPokemonNestedInput
    statisticGroupGames?: statistic_group_gameUpdateManyWithoutPokemonNestedInput
  }

  export type pokemonUncheckedUpdateWithoutSkillObtationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pokemonCategoryId?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    nationalNumbers?: national_numberUncheckedUpdateManyWithoutPokemonNestedInput
    pokemonForms?: pokemon_formUncheckedUpdateManyWithoutPokemonNestedInput
    pokemonInfos?: pokemon_infoUncheckedUpdateManyWithoutPokemonNestedInput
    statisticGroupGames?: statistic_group_gameUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type skill_obtation_typeUpsertWithoutSkillObtationsInput = {
    update: XOR<skill_obtation_typeUpdateWithoutSkillObtationsInput, skill_obtation_typeUncheckedUpdateWithoutSkillObtationsInput>
    create: XOR<skill_obtation_typeCreateWithoutSkillObtationsInput, skill_obtation_typeUncheckedCreateWithoutSkillObtationsInput>
    where?: skill_obtation_typeWhereInput
  }

  export type skill_obtation_typeUpdateToOneWithWhereWithoutSkillObtationsInput = {
    where?: skill_obtation_typeWhereInput
    data: XOR<skill_obtation_typeUpdateWithoutSkillObtationsInput, skill_obtation_typeUncheckedUpdateWithoutSkillObtationsInput>
  }

  export type skill_obtation_typeUpdateWithoutSkillObtationsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type skill_obtation_typeUncheckedUpdateWithoutSkillObtationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateWithoutRefreshTokensInput = {
    discordId?: bigint | number | null
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pseudonym: string
    role?: $Enums.role
    ownedPokemons?: owned_pokemonCreateNestedManyWithoutUsersInput
  }

  export type userUncheckedCreateWithoutRefreshTokensInput = {
    id?: number
    discordId?: bigint | number | null
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    pseudonym: string
    role?: $Enums.role
    ownedPokemons?: owned_pokemonUncheckedCreateNestedManyWithoutUsersInput
  }

  export type userCreateOrConnectWithoutRefreshTokensInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRefreshTokensInput, userUncheckedCreateWithoutRefreshTokensInput>
  }

  export type userUpsertWithoutRefreshTokensInput = {
    update: XOR<userUpdateWithoutRefreshTokensInput, userUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<userCreateWithoutRefreshTokensInput, userUncheckedCreateWithoutRefreshTokensInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRefreshTokensInput, userUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type userUpdateWithoutRefreshTokensInput = {
    discordId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pseudonym?: StringFieldUpdateOperationsInput | string
    role?: EnumroleFieldUpdateOperationsInput | $Enums.role
    ownedPokemons?: owned_pokemonUpdateManyWithoutUsersNestedInput
  }

  export type userUncheckedUpdateWithoutRefreshTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    discordId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pseudonym?: StringFieldUpdateOperationsInput | string
    role?: EnumroleFieldUpdateOperationsInput | $Enums.role
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type translationCreateManyLangueInput = {
    referenceId: bigint | number
    referenceTable: $Enums.reference_table
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type translationUpdateWithoutLangueInput = {
    referenceId?: BigIntFieldUpdateOperationsInput | bigint | number
    referenceTable?: Enumreference_tableFieldUpdateOperationsInput | $Enums.reference_table
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type translationUncheckedUpdateWithoutLangueInput = {
    referenceId?: BigIntFieldUpdateOperationsInput | bigint | number
    referenceTable?: Enumreference_tableFieldUpdateOperationsInput | $Enums.reference_table
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type translationUncheckedUpdateManyWithoutLangueInput = {
    referenceId?: BigIntFieldUpdateOperationsInput | bigint | number
    referenceTable?: Enumreference_tableFieldUpdateOperationsInput | $Enums.reference_table
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type owned_pokemonCreateManyUsersInput = {
    id?: bigint | number
    pokemonFormId: number
    gameId: number
    isShiny: boolean
    methodId: number
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type refresh_tokenCreateManyUsersInput = {
    id?: number
    token: string
    expiresAt: Date | string
  }

  export type owned_pokemonUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    game?: gameUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    shinyHuntingMethod?: shiny_hunting_methodUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    pokemonForms?: pokemon_formUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    ownedPokemonDetails?: owned_pokemon_detailUpdateManyWithoutOwnedPokemonNestedInput
  }

  export type owned_pokemonUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    methodId?: IntFieldUpdateOperationsInput | number
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemonDetails?: owned_pokemon_detailUncheckedUpdateManyWithoutOwnedPokemonNestedInput
  }

  export type owned_pokemonUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    methodId?: IntFieldUpdateOperationsInput | number
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type refresh_tokenUpdateWithoutUsersInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refresh_tokenUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refresh_tokenUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type owned_pokemonCreateManyShinyHuntingMethodInput = {
    id?: bigint | number
    userId: number
    pokemonFormId: number
    gameId: number
    isShiny: boolean
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type shiny_hunting_method_gameCreateManyShinyHuntingMethodInput = {
    groupGameId: number
  }

  export type shiny_hunting_method_rateCreateManyShinyHuntingMethodInput = {
    rateId: number
  }

  export type owned_pokemonUpdateWithoutShinyHuntingMethodInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    game?: gameUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    pokemonForms?: pokemon_formUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    users?: userUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    ownedPokemonDetails?: owned_pokemon_detailUpdateManyWithoutOwnedPokemonNestedInput
  }

  export type owned_pokemonUncheckedUpdateWithoutShinyHuntingMethodInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemonDetails?: owned_pokemon_detailUncheckedUpdateManyWithoutOwnedPokemonNestedInput
  }

  export type owned_pokemonUncheckedUpdateManyWithoutShinyHuntingMethodInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type shiny_hunting_method_gameUpdateWithoutShinyHuntingMethodInput = {
    groupGame?: group_gameUpdateOneRequiredWithoutShinyHuntingMethodGamesNestedInput
  }

  export type shiny_hunting_method_gameUncheckedUpdateWithoutShinyHuntingMethodInput = {
    groupGameId?: IntFieldUpdateOperationsInput | number
  }

  export type shiny_hunting_method_gameUncheckedUpdateManyWithoutShinyHuntingMethodInput = {
    groupGameId?: IntFieldUpdateOperationsInput | number
  }

  export type shiny_hunting_method_rateUpdateWithoutShinyHuntingMethodInput = {
    rate?: rateUpdateOneRequiredWithoutShinyHuntingMethodRatesNestedInput
  }

  export type shiny_hunting_method_rateUncheckedUpdateWithoutShinyHuntingMethodInput = {
    rateId?: IntFieldUpdateOperationsInput | number
  }

  export type shiny_hunting_method_rateUncheckedUpdateManyWithoutShinyHuntingMethodInput = {
    rateId?: IntFieldUpdateOperationsInput | number
  }

  export type owned_pokemon_detailCreateManyPokeballInput = {
    id?: bigint | number
    nickname: string
    ownedPokemonId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type owned_pokemon_detailUpdateWithoutPokeballInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nickname?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemon?: owned_pokemonUpdateOneRequiredWithoutOwnedPokemonDetailsNestedInput
  }

  export type owned_pokemon_detailUncheckedUpdateWithoutPokeballInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nickname?: StringFieldUpdateOperationsInput | string
    ownedPokemonId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type owned_pokemon_detailUncheckedUpdateManyWithoutPokeballInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nickname?: StringFieldUpdateOperationsInput | string
    ownedPokemonId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type abilityCreateManyGenerationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type ability_infoCreateManyGenerationInput = {
    id?: number
    abilityId: number
    effectOutsideFightId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type gameCreateManyGenerationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokemonCreateManyGenerationInput = {
    id?: number
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    pokemonCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokemon_infoCreateManyGenerationInput = {
    id?: number
    xpGift: number
    pokemonId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type abilityUpdateWithoutGenerationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityInfos?: ability_infoUpdateManyWithoutAbilitiesNestedInput
    abilityOrders?: ability_orderUpdateManyWithoutAbilityNestedInput
  }

  export type abilityUncheckedUpdateWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityInfos?: ability_infoUncheckedUpdateManyWithoutAbilitiesNestedInput
    abilityOrders?: ability_orderUncheckedUpdateManyWithoutAbilityNestedInput
  }

  export type abilityUncheckedUpdateManyWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ability_infoUpdateWithoutGenerationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilities?: abilityUpdateOneRequiredWithoutAbilityInfosNestedInput
    effectWithoutFight?: effect_outside_fightUpdateOneRequiredWithoutAbilityInfosNestedInput
  }

  export type ability_infoUncheckedUpdateWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    abilityId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ability_infoUncheckedUpdateManyWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    abilityId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type gameUpdateWithoutGenerationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameGroupGames?: game_group_gameUpdateManyWithoutGameNestedInput
    ownedPokemons?: owned_pokemonUpdateManyWithoutGameNestedInput
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutGameNestedInput
  }

  export type gameUncheckedUpdateWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameGroupGames?: game_group_gameUncheckedUpdateManyWithoutGameNestedInput
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutGameNestedInput
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutGameNestedInput
  }

  export type gameUncheckedUpdateManyWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemonUpdateWithoutGenerationInput = {
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    nationalNumbers?: national_numberUpdateManyWithoutPokemonNestedInput
    pokemon_category?: pokemon_categoryUpdateOneRequiredWithoutPokemonsNestedInput
    pokemonForms?: pokemon_formUpdateManyWithoutPokemonNestedInput
    pokemonInfos?: pokemon_infoUpdateManyWithoutPokemonNestedInput
    skillObtations?: skill_obtationUpdateManyWithoutPokemonNestedInput
    statisticGroupGames?: statistic_group_gameUpdateManyWithoutPokemonNestedInput
  }

  export type pokemonUncheckedUpdateWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pokemonCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    nationalNumbers?: national_numberUncheckedUpdateManyWithoutPokemonNestedInput
    pokemonForms?: pokemon_formUncheckedUpdateManyWithoutPokemonNestedInput
    pokemonInfos?: pokemon_infoUncheckedUpdateManyWithoutPokemonNestedInput
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutPokemonNestedInput
    statisticGroupGames?: statistic_group_gameUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type pokemonUncheckedUpdateManyWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pokemonCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_infoUpdateWithoutGenerationInput = {
    xpGift?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityOrders?: ability_orderUpdateManyWithoutPokemonInfoNestedInput
    eggGroupOrders?: egg_group_orderUpdateManyWithoutPokemonInfoNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutPokemonInfosNestedInput
    typeOrders?: type_orderUpdateManyWithoutPokemonInfoNestedInput
  }

  export type pokemon_infoUncheckedUpdateWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    xpGift?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityOrders?: ability_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
    eggGroupOrders?: egg_group_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
    typeOrders?: type_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
  }

  export type pokemon_infoUncheckedUpdateManyWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    xpGift?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type game_group_gameCreateManyGameInput = {
    groupGameId: number
    landId: number
  }

  export type owned_pokemonCreateManyGameInput = {
    id?: bigint | number
    userId: number
    pokemonFormId: number
    isShiny: boolean
    methodId: number
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokemon_game_locationCreateManyGameInput = {
    rateId: number
    locationZoneId: number
    pokemonObtationId: number
    pokemonFormId: number
    id?: number
  }

  export type game_group_gameUpdateWithoutGameInput = {
    groupGame?: group_gameUpdateOneRequiredWithoutGameGroupGamesNestedInput
    land?: landUpdateOneRequiredWithoutGame_group_gameNestedInput
  }

  export type game_group_gameUncheckedUpdateWithoutGameInput = {
    groupGameId?: IntFieldUpdateOperationsInput | number
    landId?: IntFieldUpdateOperationsInput | number
  }

  export type game_group_gameUncheckedUpdateManyWithoutGameInput = {
    groupGameId?: IntFieldUpdateOperationsInput | number
    landId?: IntFieldUpdateOperationsInput | number
  }

  export type owned_pokemonUpdateWithoutGameInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    shinyHuntingMethod?: shiny_hunting_methodUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    pokemonForms?: pokemon_formUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    users?: userUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    ownedPokemonDetails?: owned_pokemon_detailUpdateManyWithoutOwnedPokemonNestedInput
  }

  export type owned_pokemonUncheckedUpdateWithoutGameInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    methodId?: IntFieldUpdateOperationsInput | number
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemonDetails?: owned_pokemon_detailUncheckedUpdateManyWithoutOwnedPokemonNestedInput
  }

  export type owned_pokemonUncheckedUpdateManyWithoutGameInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    methodId?: IntFieldUpdateOperationsInput | number
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_game_locationUpdateWithoutGameInput = {
    locationZone?: location_zoneUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    pokemonForm?: pokemon_formUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    pokemonObtation?: pokemon_obtationUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    rate?: rateUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
  }

  export type pokemon_game_locationUncheckedUpdateWithoutGameInput = {
    rateId?: IntFieldUpdateOperationsInput | number
    locationZoneId?: IntFieldUpdateOperationsInput | number
    pokemonObtationId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_game_locationUncheckedUpdateManyWithoutGameInput = {
    rateId?: IntFieldUpdateOperationsInput | number
    locationZoneId?: IntFieldUpdateOperationsInput | number
    pokemonObtationId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type capsule_game_capacity_infoCreateManyGroupGameInput = {
    capacityInfoId: number
    capsuleId: number
  }

  export type game_group_gameCreateManyGroupGameInput = {
    gameId: number
    landId: number
  }

  export type national_numberCreateManyGroupGameInput = {
    pokemonId: number
    number: number
  }

  export type shiny_hunting_method_gameCreateManyGroupGameInput = {
    shinyHuntingMethodId: number
  }

  export type skill_obtationCreateManyGroupGameInput = {
    capacityId: number
    pokemonId: number
    skillObtationTypeId: number
    detail: string
  }

  export type statistic_group_gameCreateManyGroupGameInput = {
    pokemonId: number
    statisticId: number
  }

  export type capsule_game_capacity_infoUpdateWithoutGroupGameInput = {
    capacityInfo?: capacity_infoUpdateOneRequiredWithoutCapsuleGameCapacityInfosNestedInput
    capsule?: capsuleUpdateOneRequiredWithoutCapsule_game_capacity_infoNestedInput
  }

  export type capsule_game_capacity_infoUncheckedUpdateWithoutGroupGameInput = {
    capacityInfoId?: IntFieldUpdateOperationsInput | number
    capsuleId?: IntFieldUpdateOperationsInput | number
  }

  export type capsule_game_capacity_infoUncheckedUpdateManyWithoutGroupGameInput = {
    capacityInfoId?: IntFieldUpdateOperationsInput | number
    capsuleId?: IntFieldUpdateOperationsInput | number
  }

  export type game_group_gameUpdateWithoutGroupGameInput = {
    game?: gameUpdateOneRequiredWithoutGameGroupGamesNestedInput
    land?: landUpdateOneRequiredWithoutGame_group_gameNestedInput
  }

  export type game_group_gameUncheckedUpdateWithoutGroupGameInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    landId?: IntFieldUpdateOperationsInput | number
  }

  export type game_group_gameUncheckedUpdateManyWithoutGroupGameInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    landId?: IntFieldUpdateOperationsInput | number
  }

  export type national_numberUpdateWithoutGroupGameInput = {
    number?: IntFieldUpdateOperationsInput | number
    pokemon?: pokemonUpdateOneRequiredWithoutNationalNumbersNestedInput
  }

  export type national_numberUncheckedUpdateWithoutGroupGameInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
  }

  export type national_numberUncheckedUpdateManyWithoutGroupGameInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
  }

  export type shiny_hunting_method_gameUpdateWithoutGroupGameInput = {
    shinyHuntingMethod?: shiny_hunting_methodUpdateOneRequiredWithoutShinyHuntingMethodGamesNestedInput
  }

  export type shiny_hunting_method_gameUncheckedUpdateWithoutGroupGameInput = {
    shinyHuntingMethodId?: IntFieldUpdateOperationsInput | number
  }

  export type shiny_hunting_method_gameUncheckedUpdateManyWithoutGroupGameInput = {
    shinyHuntingMethodId?: IntFieldUpdateOperationsInput | number
  }

  export type skill_obtationUpdateWithoutGroupGameInput = {
    detail?: StringFieldUpdateOperationsInput | string
    capacity?: capacityUpdateOneRequiredWithoutSkillObtationsNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutSkillObtationsNestedInput
    skillObtationType?: skill_obtation_typeUpdateOneRequiredWithoutSkillObtationsNestedInput
  }

  export type skill_obtationUncheckedUpdateWithoutGroupGameInput = {
    capacityId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    skillObtationTypeId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type skill_obtationUncheckedUpdateManyWithoutGroupGameInput = {
    capacityId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    skillObtationTypeId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type statistic_group_gameUpdateWithoutGroupGameInput = {
    pokemon?: pokemonUpdateOneRequiredWithoutStatisticGroupGamesNestedInput
    statistic?: statisticUpdateOneRequiredWithoutStatisticGroupGamesNestedInput
  }

  export type statistic_group_gameUncheckedUpdateWithoutGroupGameInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    statisticId?: IntFieldUpdateOperationsInput | number
  }

  export type statistic_group_gameUncheckedUpdateManyWithoutGroupGameInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    statisticId?: IntFieldUpdateOperationsInput | number
  }

  export type pokemonCreateManyPokemon_categoryInput = {
    id?: number
    internationalNumber: number
    hatchingCycle: number
    globalXp: number
    captureRate: number
    callHelpRate: number
    size: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    maleRate: Decimal | DecimalJsLike | number | string
    femelleRate: Decimal | DecimalJsLike | number | string
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokemonUpdateWithoutPokemon_categoryInput = {
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    nationalNumbers?: national_numberUpdateManyWithoutPokemonNestedInput
    generation?: generationUpdateOneRequiredWithoutPokemonsNestedInput
    pokemonForms?: pokemon_formUpdateManyWithoutPokemonNestedInput
    pokemonInfos?: pokemon_infoUpdateManyWithoutPokemonNestedInput
    skillObtations?: skill_obtationUpdateManyWithoutPokemonNestedInput
    statisticGroupGames?: statistic_group_gameUpdateManyWithoutPokemonNestedInput
  }

  export type pokemonUncheckedUpdateWithoutPokemon_categoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    nationalNumbers?: national_numberUncheckedUpdateManyWithoutPokemonNestedInput
    pokemonForms?: pokemon_formUncheckedUpdateManyWithoutPokemonNestedInput
    pokemonInfos?: pokemon_infoUncheckedUpdateManyWithoutPokemonNestedInput
    skillObtations?: skill_obtationUncheckedUpdateManyWithoutPokemonNestedInput
    statisticGroupGames?: statistic_group_gameUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type pokemonUncheckedUpdateManyWithoutPokemon_categoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    internationalNumber?: IntFieldUpdateOperationsInput | number
    hatchingCycle?: IntFieldUpdateOperationsInput | number
    globalXp?: IntFieldUpdateOperationsInput | number
    captureRate?: IntFieldUpdateOperationsInput | number
    callHelpRate?: IntFieldUpdateOperationsInput | number
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    femelleRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type national_numberCreateManyPokemonInput = {
    groupGameId: number
    number: number
  }

  export type pokemon_formCreateManyPokemonInput = {
    formId: number
    createdAt?: Date | string
    id?: number
    status?: string
    updatedAt?: Date | string | null
  }

  export type pokemon_infoCreateManyPokemonInput = {
    id?: number
    xpGift: number
    generationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type skill_obtationCreateManyPokemonInput = {
    capacityId: number
    groupGameId: number
    skillObtationTypeId: number
    detail: string
  }

  export type statistic_group_gameCreateManyPokemonInput = {
    groupGameId: number
    statisticId: number
  }

  export type national_numberUpdateWithoutPokemonInput = {
    number?: IntFieldUpdateOperationsInput | number
    groupGame?: group_gameUpdateOneRequiredWithoutNationnalNumbersNestedInput
  }

  export type national_numberUncheckedUpdateWithoutPokemonInput = {
    groupGameId?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
  }

  export type national_numberUncheckedUpdateManyWithoutPokemonInput = {
    groupGameId?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_formUpdateWithoutPokemonInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionEnds?: evolutionUpdateManyWithoutPokemonEndNestedInput
    evolutionStarts?: evolutionUpdateManyWithoutPokemonStartNestedInput
    ownedPokemons?: owned_pokemonUpdateManyWithoutPokemonFormsNestedInput
    form?: formUpdateOneRequiredWithoutPokemonFormsNestedInput
    pokemonFormGenders?: pokemon_form_genderUpdateManyWithoutPokemon_formNestedInput
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutPokemonFormNestedInput
  }

  export type pokemon_formUncheckedUpdateWithoutPokemonInput = {
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionEnds?: evolutionUncheckedUpdateManyWithoutPokemonEndNestedInput
    evolutionStarts?: evolutionUncheckedUpdateManyWithoutPokemonStartNestedInput
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutPokemonFormsNestedInput
    pokemonFormGenders?: pokemon_form_genderUncheckedUpdateManyWithoutPokemon_formNestedInput
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutPokemonFormNestedInput
  }

  export type pokemon_formUncheckedUpdateManyWithoutPokemonInput = {
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pokemon_infoUpdateWithoutPokemonInput = {
    xpGift?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityOrders?: ability_orderUpdateManyWithoutPokemonInfoNestedInput
    eggGroupOrders?: egg_group_orderUpdateManyWithoutPokemonInfoNestedInput
    generation?: generationUpdateOneRequiredWithoutPokemonInfosNestedInput
    typeOrders?: type_orderUpdateManyWithoutPokemonInfoNestedInput
  }

  export type pokemon_infoUncheckedUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    xpGift?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilityOrders?: ability_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
    eggGroupOrders?: egg_group_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
    typeOrders?: type_orderUncheckedUpdateManyWithoutPokemonInfoNestedInput
  }

  export type pokemon_infoUncheckedUpdateManyWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    xpGift?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type skill_obtationUpdateWithoutPokemonInput = {
    detail?: StringFieldUpdateOperationsInput | string
    capacity?: capacityUpdateOneRequiredWithoutSkillObtationsNestedInput
    groupGame?: group_gameUpdateOneRequiredWithoutSkillObtationsNestedInput
    skillObtationType?: skill_obtation_typeUpdateOneRequiredWithoutSkillObtationsNestedInput
  }

  export type skill_obtationUncheckedUpdateWithoutPokemonInput = {
    capacityId?: IntFieldUpdateOperationsInput | number
    groupGameId?: IntFieldUpdateOperationsInput | number
    skillObtationTypeId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type skill_obtationUncheckedUpdateManyWithoutPokemonInput = {
    capacityId?: IntFieldUpdateOperationsInput | number
    groupGameId?: IntFieldUpdateOperationsInput | number
    skillObtationTypeId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type statistic_group_gameUpdateWithoutPokemonInput = {
    groupGame?: group_gameUpdateOneRequiredWithoutStatisticGroupGamesNestedInput
    statistic?: statisticUpdateOneRequiredWithoutStatisticGroupGamesNestedInput
  }

  export type statistic_group_gameUncheckedUpdateWithoutPokemonInput = {
    groupGameId?: IntFieldUpdateOperationsInput | number
    statisticId?: IntFieldUpdateOperationsInput | number
  }

  export type statistic_group_gameUncheckedUpdateManyWithoutPokemonInput = {
    groupGameId?: IntFieldUpdateOperationsInput | number
    statisticId?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_form_genderCreateManyGenderInput = {
    pokemonFormId: number
  }

  export type pokemon_form_genderUpdateWithoutGenderInput = {
    pokemon_form?: pokemon_formUpdateOneRequiredWithoutPokemonFormGendersNestedInput
  }

  export type pokemon_form_genderUncheckedUpdateWithoutGenderInput = {
    pokemonFormId?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_form_genderUncheckedUpdateManyWithoutGenderInput = {
    pokemonFormId?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_formCreateManyFormInput = {
    pokemonId: number
    createdAt?: Date | string
    id?: number
    status?: string
    updatedAt?: Date | string | null
  }

  export type pokemon_formUpdateWithoutFormInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionEnds?: evolutionUpdateManyWithoutPokemonEndNestedInput
    evolutionStarts?: evolutionUpdateManyWithoutPokemonStartNestedInput
    ownedPokemons?: owned_pokemonUpdateManyWithoutPokemonFormsNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutPokemonFormsNestedInput
    pokemonFormGenders?: pokemon_form_genderUpdateManyWithoutPokemon_formNestedInput
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutPokemonFormNestedInput
  }

  export type pokemon_formUncheckedUpdateWithoutFormInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evolutionEnds?: evolutionUncheckedUpdateManyWithoutPokemonEndNestedInput
    evolutionStarts?: evolutionUncheckedUpdateManyWithoutPokemonStartNestedInput
    ownedPokemons?: owned_pokemonUncheckedUpdateManyWithoutPokemonFormsNestedInput
    pokemonFormGenders?: pokemon_form_genderUncheckedUpdateManyWithoutPokemon_formNestedInput
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutPokemonFormNestedInput
  }

  export type pokemon_formUncheckedUpdateManyWithoutFormInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type evolutionCreateManyPokemonEndInput = {
    id?: number
    level?: number | null
    evolutionMethodId: number
    pokemonFormStartId: number
    evolutionInfoId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolutionCreateManyPokemonStartInput = {
    id?: number
    level?: number | null
    evolutionMethodId: number
    pokemonFormEndId: number
    evolutionInfoId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type owned_pokemonCreateManyPokemonFormsInput = {
    id?: bigint | number
    userId: number
    gameId: number
    isShiny: boolean
    methodId: number
    meetingNumber?: number | null
    time?: Date | string | null
    isFinish: boolean
    useCharmChroma: boolean
    creationDate: Date | string
    finishDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type pokemon_form_genderCreateManyPokemon_formInput = {
    genderId: number
  }

  export type pokemon_game_locationCreateManyPokemonFormInput = {
    gameId: number
    rateId: number
    locationZoneId: number
    pokemonObtationId: number
    id?: number
  }

  export type evolutionUpdateWithoutPokemonEndInput = {
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    evolutionInfo?: evolution_infoUpdateOneRequiredWithoutEvolutionsNestedInput
    evolutionMethod?: evolution_methodUpdateOneRequiredWithoutEvolutionsNestedInput
    pokemonStart?: pokemon_formUpdateOneRequiredWithoutEvolutionStartsNestedInput
  }

  export type evolutionUncheckedUpdateWithoutPokemonEndInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableIntFieldUpdateOperationsInput | number | null
    evolutionMethodId?: IntFieldUpdateOperationsInput | number
    pokemonFormStartId?: IntFieldUpdateOperationsInput | number
    evolutionInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolutionUncheckedUpdateManyWithoutPokemonEndInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableIntFieldUpdateOperationsInput | number | null
    evolutionMethodId?: IntFieldUpdateOperationsInput | number
    pokemonFormStartId?: IntFieldUpdateOperationsInput | number
    evolutionInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolutionUpdateWithoutPokemonStartInput = {
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    evolutionInfo?: evolution_infoUpdateOneRequiredWithoutEvolutionsNestedInput
    evolutionMethod?: evolution_methodUpdateOneRequiredWithoutEvolutionsNestedInput
    pokemonEnd?: pokemon_formUpdateOneRequiredWithoutEvolutionEndsNestedInput
  }

  export type evolutionUncheckedUpdateWithoutPokemonStartInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableIntFieldUpdateOperationsInput | number | null
    evolutionMethodId?: IntFieldUpdateOperationsInput | number
    pokemonFormEndId?: IntFieldUpdateOperationsInput | number
    evolutionInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolutionUncheckedUpdateManyWithoutPokemonStartInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableIntFieldUpdateOperationsInput | number | null
    evolutionMethodId?: IntFieldUpdateOperationsInput | number
    pokemonFormEndId?: IntFieldUpdateOperationsInput | number
    evolutionInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type owned_pokemonUpdateWithoutPokemonFormsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    game?: gameUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    shinyHuntingMethod?: shiny_hunting_methodUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    users?: userUpdateOneRequiredWithoutOwnedPokemonsNestedInput
    ownedPokemonDetails?: owned_pokemon_detailUpdateManyWithoutOwnedPokemonNestedInput
  }

  export type owned_pokemonUncheckedUpdateWithoutPokemonFormsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    methodId?: IntFieldUpdateOperationsInput | number
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownedPokemonDetails?: owned_pokemon_detailUncheckedUpdateManyWithoutOwnedPokemonNestedInput
  }

  export type owned_pokemonUncheckedUpdateManyWithoutPokemonFormsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    isShiny?: BoolFieldUpdateOperationsInput | boolean
    methodId?: IntFieldUpdateOperationsInput | number
    meetingNumber?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFinish?: BoolFieldUpdateOperationsInput | boolean
    useCharmChroma?: BoolFieldUpdateOperationsInput | boolean
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_form_genderUpdateWithoutPokemon_formInput = {
    gender?: genderUpdateOneRequiredWithoutPokemonFormGendersNestedInput
  }

  export type pokemon_form_genderUncheckedUpdateWithoutPokemon_formInput = {
    genderId?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_form_genderUncheckedUpdateManyWithoutPokemon_formInput = {
    genderId?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_game_locationUpdateWithoutPokemonFormInput = {
    game?: gameUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    locationZone?: location_zoneUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    pokemonObtation?: pokemon_obtationUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    rate?: rateUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
  }

  export type pokemon_game_locationUncheckedUpdateWithoutPokemonFormInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    locationZoneId?: IntFieldUpdateOperationsInput | number
    pokemonObtationId?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_game_locationUncheckedUpdateManyWithoutPokemonFormInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    locationZoneId?: IntFieldUpdateOperationsInput | number
    pokemonObtationId?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type owned_pokemon_detailCreateManyOwnedPokemonInput = {
    id?: bigint | number
    nickname: string
    pokeballId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type owned_pokemon_detailUpdateWithoutOwnedPokemonInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nickname?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pokeball?: pokeballUpdateOneRequiredWithoutOwnedPokemonDetailsNestedInput
  }

  export type owned_pokemon_detailUncheckedUpdateWithoutOwnedPokemonInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nickname?: StringFieldUpdateOperationsInput | string
    pokeballId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type owned_pokemon_detailUncheckedUpdateManyWithoutOwnedPokemonInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nickname?: StringFieldUpdateOperationsInput | string
    pokeballId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ability_infoCreateManyAbilitiesInput = {
    id?: number
    generationId: number
    effectOutsideFightId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type ability_orderCreateManyAbilityInput = {
    pokemonInfoId: number
    order: number
    isHidden: boolean
  }

  export type ability_infoUpdateWithoutAbilitiesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    effectWithoutFight?: effect_outside_fightUpdateOneRequiredWithoutAbilityInfosNestedInput
    generation?: generationUpdateOneRequiredWithoutAbilityInfosNestedInput
  }

  export type ability_infoUncheckedUpdateWithoutAbilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ability_infoUncheckedUpdateManyWithoutAbilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ability_orderUpdateWithoutAbilityInput = {
    order?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    pokemonInfo?: pokemon_infoUpdateOneRequiredWithoutAbilityOrdersNestedInput
  }

  export type ability_orderUncheckedUpdateWithoutAbilityInput = {
    pokemonInfoId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ability_orderUncheckedUpdateManyWithoutAbilityInput = {
    pokemonInfoId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ability_orderCreateManyPokemonInfoInput = {
    abilityId: number
    order: number
    isHidden: boolean
  }

  export type egg_group_orderCreateManyPokemonInfoInput = {
    eggGroupId: number
    order: number
  }

  export type type_orderCreateManyPokemonInfoInput = {
    typeId: number
    order: number
  }

  export type ability_orderUpdateWithoutPokemonInfoInput = {
    order?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    ability?: abilityUpdateOneRequiredWithoutAbilityOrdersNestedInput
  }

  export type ability_orderUncheckedUpdateWithoutPokemonInfoInput = {
    abilityId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ability_orderUncheckedUpdateManyWithoutPokemonInfoInput = {
    abilityId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type egg_group_orderUpdateWithoutPokemonInfoInput = {
    order?: IntFieldUpdateOperationsInput | number
    eggGroup?: egg_groupUpdateOneRequiredWithoutEggGroupOrdersNestedInput
  }

  export type egg_group_orderUncheckedUpdateWithoutPokemonInfoInput = {
    eggGroupId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type egg_group_orderUncheckedUpdateManyWithoutPokemonInfoInput = {
    eggGroupId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type type_orderUpdateWithoutPokemonInfoInput = {
    order?: IntFieldUpdateOperationsInput | number
    type?: typeUpdateOneRequiredWithoutTypeOrdersNestedInput
  }

  export type type_orderUncheckedUpdateWithoutPokemonInfoInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type type_orderUncheckedUpdateManyWithoutPokemonInfoInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type evolutionCreateManyEvolutionMethodInput = {
    id?: number
    level?: number | null
    pokemonFormStartId: number
    pokemonFormEndId: number
    evolutionInfoId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolutionUpdateWithoutEvolutionMethodInput = {
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    evolutionInfo?: evolution_infoUpdateOneRequiredWithoutEvolutionsNestedInput
    pokemonEnd?: pokemon_formUpdateOneRequiredWithoutEvolutionEndsNestedInput
    pokemonStart?: pokemon_formUpdateOneRequiredWithoutEvolutionStartsNestedInput
  }

  export type evolutionUncheckedUpdateWithoutEvolutionMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableIntFieldUpdateOperationsInput | number | null
    pokemonFormStartId?: IntFieldUpdateOperationsInput | number
    pokemonFormEndId?: IntFieldUpdateOperationsInput | number
    evolutionInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolutionUncheckedUpdateManyWithoutEvolutionMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableIntFieldUpdateOperationsInput | number | null
    pokemonFormStartId?: IntFieldUpdateOperationsInput | number
    pokemonFormEndId?: IntFieldUpdateOperationsInput | number
    evolutionInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolutionCreateManyEvolutionInfoInput = {
    id?: number
    level?: number | null
    evolutionMethodId: number
    pokemonFormStartId: number
    pokemonFormEndId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type evolutionUpdateWithoutEvolutionInfoInput = {
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    evolutionMethod?: evolution_methodUpdateOneRequiredWithoutEvolutionsNestedInput
    pokemonEnd?: pokemon_formUpdateOneRequiredWithoutEvolutionEndsNestedInput
    pokemonStart?: pokemon_formUpdateOneRequiredWithoutEvolutionStartsNestedInput
  }

  export type evolutionUncheckedUpdateWithoutEvolutionInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableIntFieldUpdateOperationsInput | number | null
    evolutionMethodId?: IntFieldUpdateOperationsInput | number
    pokemonFormStartId?: IntFieldUpdateOperationsInput | number
    pokemonFormEndId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type evolutionUncheckedUpdateManyWithoutEvolutionInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableIntFieldUpdateOperationsInput | number | null
    evolutionMethodId?: IntFieldUpdateOperationsInput | number
    pokemonFormStartId?: IntFieldUpdateOperationsInput | number
    pokemonFormEndId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type egg_group_orderCreateManyEggGroupInput = {
    pokemonInfoId: number
    order: number
  }

  export type egg_group_orderUpdateWithoutEggGroupInput = {
    order?: IntFieldUpdateOperationsInput | number
    pokemonInfo?: pokemon_infoUpdateOneRequiredWithoutEggGroupOrdersNestedInput
  }

  export type egg_group_orderUncheckedUpdateWithoutEggGroupInput = {
    pokemonInfoId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type egg_group_orderUncheckedUpdateManyWithoutEggGroupInput = {
    pokemonInfoId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type capacity_infoCreateManyTypeInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityId: number
    capacityEffectZId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type type_orderCreateManyTypeInput = {
    pokemonInfoId: number
    order: number
  }

  export type capacity_infoUpdateWithoutTypeInput = {
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityCategory?: capacity_categoryUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffect?: capacity_effectUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffectZ?: capacity_effectUpdateOneRequiredWithoutCapacityZInfosNestedInput
    capacity?: capacityUpdateOneRequiredWithoutCapacityInfosNestedInput
    effectOutsideFight?: effect_outside_fightUpdateOneRequiredWithoutCapacityInfosNestedInput
    target?: targetUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityInfoInfluences?: capacity_info_influenceUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfoInfluences?: capacity_info_influenceUncheckedUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateManyWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type type_orderUpdateWithoutTypeInput = {
    order?: IntFieldUpdateOperationsInput | number
    pokemonInfo?: pokemon_infoUpdateOneRequiredWithoutTypeOrdersNestedInput
  }

  export type type_orderUncheckedUpdateWithoutTypeInput = {
    pokemonInfoId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type type_orderUncheckedUpdateManyWithoutTypeInput = {
    pokemonInfoId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type game_group_gameCreateManyLandInput = {
    gameId: number
    groupGameId: number
  }

  export type game_group_gameUpdateWithoutLandInput = {
    game?: gameUpdateOneRequiredWithoutGameGroupGamesNestedInput
    groupGame?: group_gameUpdateOneRequiredWithoutGameGroupGamesNestedInput
  }

  export type game_group_gameUncheckedUpdateWithoutLandInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    groupGameId?: IntFieldUpdateOperationsInput | number
  }

  export type game_group_gameUncheckedUpdateManyWithoutLandInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    groupGameId?: IntFieldUpdateOperationsInput | number
  }

  export type capacity_infoCreateManyCapacityInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityEffectZId: number
    typeId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type skill_obtationCreateManyCapacityInput = {
    pokemonId: number
    groupGameId: number
    skillObtationTypeId: number
    detail: string
  }

  export type capacity_infoUpdateWithoutCapacityInput = {
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityCategory?: capacity_categoryUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffect?: capacity_effectUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffectZ?: capacity_effectUpdateOneRequiredWithoutCapacityZInfosNestedInput
    effectOutsideFight?: effect_outside_fightUpdateOneRequiredWithoutCapacityInfosNestedInput
    target?: targetUpdateOneRequiredWithoutCapacityInfosNestedInput
    type?: typeUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityInfoInfluences?: capacity_info_influenceUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateWithoutCapacityInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfoInfluences?: capacity_info_influenceUncheckedUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateManyWithoutCapacityInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type skill_obtationUpdateWithoutCapacityInput = {
    detail?: StringFieldUpdateOperationsInput | string
    groupGame?: group_gameUpdateOneRequiredWithoutSkillObtationsNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutSkillObtationsNestedInput
    skillObtationType?: skill_obtation_typeUpdateOneRequiredWithoutSkillObtationsNestedInput
  }

  export type skill_obtationUncheckedUpdateWithoutCapacityInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    groupGameId?: IntFieldUpdateOperationsInput | number
    skillObtationTypeId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type skill_obtationUncheckedUpdateManyWithoutCapacityInput = {
    pokemonId?: IntFieldUpdateOperationsInput | number
    groupGameId?: IntFieldUpdateOperationsInput | number
    skillObtationTypeId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_infoCreateManyCapacityEffectInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityId: number
    capacityEffectZId: number
    typeId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type capacity_infoCreateManyCapacityEffectZInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityId: number
    typeId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type capacity_infoUpdateWithoutCapacityEffectInput = {
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityCategory?: capacity_categoryUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffectZ?: capacity_effectUpdateOneRequiredWithoutCapacityZInfosNestedInput
    capacity?: capacityUpdateOneRequiredWithoutCapacityInfosNestedInput
    effectOutsideFight?: effect_outside_fightUpdateOneRequiredWithoutCapacityInfosNestedInput
    target?: targetUpdateOneRequiredWithoutCapacityInfosNestedInput
    type?: typeUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityInfoInfluences?: capacity_info_influenceUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateWithoutCapacityEffectInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfoInfluences?: capacity_info_influenceUncheckedUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateManyWithoutCapacityEffectInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_infoUpdateWithoutCapacityEffectZInput = {
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityCategory?: capacity_categoryUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffect?: capacity_effectUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacity?: capacityUpdateOneRequiredWithoutCapacityInfosNestedInput
    effectOutsideFight?: effect_outside_fightUpdateOneRequiredWithoutCapacityInfosNestedInput
    target?: targetUpdateOneRequiredWithoutCapacityInfosNestedInput
    type?: typeUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityInfoInfluences?: capacity_info_influenceUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateWithoutCapacityEffectZInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfoInfluences?: capacity_info_influenceUncheckedUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateManyWithoutCapacityEffectZInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_infoCreateManyCapacityCategoryInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityId: number
    capacityEffectZId: number
    typeId: number
    effectOutsideFightId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type capacity_infoUpdateWithoutCapacityCategoryInput = {
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityEffect?: capacity_effectUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffectZ?: capacity_effectUpdateOneRequiredWithoutCapacityZInfosNestedInput
    capacity?: capacityUpdateOneRequiredWithoutCapacityInfosNestedInput
    effectOutsideFight?: effect_outside_fightUpdateOneRequiredWithoutCapacityInfosNestedInput
    target?: targetUpdateOneRequiredWithoutCapacityInfosNestedInput
    type?: typeUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityInfoInfluences?: capacity_info_influenceUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateWithoutCapacityCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfoInfluences?: capacity_info_influenceUncheckedUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateManyWithoutCapacityCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capsule_game_capacity_infoCreateManyCapsuleInput = {
    capacityInfoId: number
    groupeGameId: number
  }

  export type capsule_game_capacity_infoUpdateWithoutCapsuleInput = {
    capacityInfo?: capacity_infoUpdateOneRequiredWithoutCapsuleGameCapacityInfosNestedInput
    groupGame?: group_gameUpdateOneRequiredWithoutCapsuleGameCapacityIinfosNestedInput
  }

  export type capsule_game_capacity_infoUncheckedUpdateWithoutCapsuleInput = {
    capacityInfoId?: IntFieldUpdateOperationsInput | number
    groupeGameId?: IntFieldUpdateOperationsInput | number
  }

  export type capsule_game_capacity_infoUncheckedUpdateManyWithoutCapsuleInput = {
    capacityInfoId?: IntFieldUpdateOperationsInput | number
    groupeGameId?: IntFieldUpdateOperationsInput | number
  }

  export type rateCreateManyConditionRateInput = {
    id?: number
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    meteoId: number
    detailRateId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
  }

  export type rateCreateManyDetailRateInput = {
    id?: number
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    meteoId: number
    conditionRateId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
  }

  export type rateUpdateWithoutConditionRateInput = {
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutRateNestedInput
    detailRate?: detailUpdateOneRequiredWithoutDetailRatesNestedInput
    meteo?: meteoUpdateOneRequiredWithoutRatesNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUpdateManyWithoutRateNestedInput
  }

  export type rateUncheckedUpdateWithoutConditionRateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    meteoId?: IntFieldUpdateOperationsInput | number
    detailRateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutRateNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedUpdateManyWithoutRateNestedInput
  }

  export type rateUncheckedUpdateManyWithoutConditionRateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    meteoId?: IntFieldUpdateOperationsInput | number
    detailRateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
  }

  export type rateUpdateWithoutDetailRateInput = {
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutRateNestedInput
    conditionRate?: detailUpdateOneRequiredWithoutConditionRatesNestedInput
    meteo?: meteoUpdateOneRequiredWithoutRatesNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUpdateManyWithoutRateNestedInput
  }

  export type rateUncheckedUpdateWithoutDetailRateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    meteoId?: IntFieldUpdateOperationsInput | number
    conditionRateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutRateNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedUpdateManyWithoutRateNestedInput
  }

  export type rateUncheckedUpdateManyWithoutDetailRateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    meteoId?: IntFieldUpdateOperationsInput | number
    conditionRateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ability_infoCreateManyEffectWithoutFightInput = {
    id?: number
    generationId: number
    abilityId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type capacity_infoCreateManyEffectOutsideFightInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    targetId: number
    capacityEffectId: number
    capacityId: number
    capacityEffectZId: number
    typeId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type ability_infoUpdateWithoutEffectWithoutFightInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    abilities?: abilityUpdateOneRequiredWithoutAbilityInfosNestedInput
    generation?: generationUpdateOneRequiredWithoutAbilityInfosNestedInput
  }

  export type ability_infoUncheckedUpdateWithoutEffectWithoutFightInput = {
    id?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    abilityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ability_infoUncheckedUpdateManyWithoutEffectWithoutFightInput = {
    id?: IntFieldUpdateOperationsInput | number
    generationId?: IntFieldUpdateOperationsInput | number
    abilityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_infoUpdateWithoutEffectOutsideFightInput = {
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityCategory?: capacity_categoryUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffect?: capacity_effectUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffectZ?: capacity_effectUpdateOneRequiredWithoutCapacityZInfosNestedInput
    capacity?: capacityUpdateOneRequiredWithoutCapacityInfosNestedInput
    target?: targetUpdateOneRequiredWithoutCapacityInfosNestedInput
    type?: typeUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityInfoInfluences?: capacity_info_influenceUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateWithoutEffectOutsideFightInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfoInfluences?: capacity_info_influenceUncheckedUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateManyWithoutEffectOutsideFightInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    targetId?: IntFieldUpdateOperationsInput | number
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_info_influenceCreateManyInfluenceInput = {
    capacityInfoId: number
  }

  export type capacity_info_influenceUpdateWithoutInfluenceInput = {
    capacityInfo?: capacity_infoUpdateOneRequiredWithoutCapacityInfoInfluencesNestedInput
  }

  export type capacity_info_influenceUncheckedUpdateWithoutInfluenceInput = {
    capacityInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type capacity_info_influenceUncheckedUpdateManyWithoutInfluenceInput = {
    capacityInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type location_zoneCreateManyLocationInput = {
    id?: number
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type location_zoneUpdateWithoutLocationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    zone?: zoneUpdateOneRequiredWithoutLocationZonesNestedInput
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutLocationZoneNestedInput
  }

  export type location_zoneUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutLocationZoneNestedInput
  }

  export type location_zoneUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type location_zoneCreateManyZoneInput = {
    id?: number
    locationId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type location_zoneUpdateWithoutZoneInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: locationUpdateOneRequiredWithoutLocationZonesNestedInput
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutLocationZoneNestedInput
  }

  export type location_zoneUncheckedUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutLocationZoneNestedInput
  }

  export type location_zoneUncheckedUpdateManyWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type pokemon_game_locationCreateManyLocationZoneInput = {
    gameId: number
    rateId: number
    pokemonObtationId: number
    pokemonFormId: number
    id?: number
  }

  export type pokemon_game_locationUpdateWithoutLocationZoneInput = {
    game?: gameUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    pokemonForm?: pokemon_formUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    pokemonObtation?: pokemon_obtationUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    rate?: rateUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
  }

  export type pokemon_game_locationUncheckedUpdateWithoutLocationZoneInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    pokemonObtationId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_game_locationUncheckedUpdateManyWithoutLocationZoneInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    pokemonObtationId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type rateCreateManyMeteoInput = {
    id?: number
    rate: Decimal | DecimalJsLike | number | string
    minLevel: number
    maxLevel: number
    limit?: number | null
    detailRateId: number
    conditionRateId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
    isAlpha: boolean
  }

  export type rateUpdateWithoutMeteoInput = {
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
    pokemonRatingGames?: pokemon_game_locationUpdateManyWithoutRateNestedInput
    conditionRate?: detailUpdateOneRequiredWithoutConditionRatesNestedInput
    detailRate?: detailUpdateOneRequiredWithoutDetailRatesNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUpdateManyWithoutRateNestedInput
  }

  export type rateUncheckedUpdateWithoutMeteoInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    detailRateId?: IntFieldUpdateOperationsInput | number
    conditionRateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
    pokemonRatingGames?: pokemon_game_locationUncheckedUpdateManyWithoutRateNestedInput
    shinyHuntingMethodRates?: shiny_hunting_method_rateUncheckedUpdateManyWithoutRateNestedInput
  }

  export type rateUncheckedUpdateManyWithoutMeteoInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    detailRateId?: IntFieldUpdateOperationsInput | number
    conditionRateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isAlpha?: BoolFieldUpdateOperationsInput | boolean
  }

  export type pokemon_game_locationCreateManyPokemonObtationInput = {
    gameId: number
    rateId: number
    locationZoneId: number
    pokemonFormId: number
    id?: number
  }

  export type pokemon_game_locationUpdateWithoutPokemonObtationInput = {
    game?: gameUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    locationZone?: location_zoneUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    pokemonForm?: pokemon_formUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    rate?: rateUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
  }

  export type pokemon_game_locationUncheckedUpdateWithoutPokemonObtationInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    locationZoneId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_game_locationUncheckedUpdateManyWithoutPokemonObtationInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    locationZoneId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_game_locationCreateManyRateInput = {
    gameId: number
    locationZoneId: number
    pokemonObtationId: number
    pokemonFormId: number
    id?: number
  }

  export type shiny_hunting_method_rateCreateManyRateInput = {
    shinyHuntingMethodId: number
  }

  export type pokemon_game_locationUpdateWithoutRateInput = {
    game?: gameUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    locationZone?: location_zoneUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    pokemonForm?: pokemon_formUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
    pokemonObtation?: pokemon_obtationUpdateOneRequiredWithoutPokemonRatingGamesNestedInput
  }

  export type pokemon_game_locationUncheckedUpdateWithoutRateInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    locationZoneId?: IntFieldUpdateOperationsInput | number
    pokemonObtationId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type pokemon_game_locationUncheckedUpdateManyWithoutRateInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    locationZoneId?: IntFieldUpdateOperationsInput | number
    pokemonObtationId?: IntFieldUpdateOperationsInput | number
    pokemonFormId?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type shiny_hunting_method_rateUpdateWithoutRateInput = {
    shinyHuntingMethod?: shiny_hunting_methodUpdateOneRequiredWithoutShinyHuntingMethodRatesNestedInput
  }

  export type shiny_hunting_method_rateUncheckedUpdateWithoutRateInput = {
    shinyHuntingMethodId?: IntFieldUpdateOperationsInput | number
  }

  export type shiny_hunting_method_rateUncheckedUpdateManyWithoutRateInput = {
    shinyHuntingMethodId?: IntFieldUpdateOperationsInput | number
  }

  export type skill_obtationCreateManySkillObtationTypeInput = {
    capacityId: number
    pokemonId: number
    groupGameId: number
    detail: string
  }

  export type skill_obtationUpdateWithoutSkillObtationTypeInput = {
    detail?: StringFieldUpdateOperationsInput | string
    capacity?: capacityUpdateOneRequiredWithoutSkillObtationsNestedInput
    groupGame?: group_gameUpdateOneRequiredWithoutSkillObtationsNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutSkillObtationsNestedInput
  }

  export type skill_obtationUncheckedUpdateWithoutSkillObtationTypeInput = {
    capacityId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    groupGameId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type skill_obtationUncheckedUpdateManyWithoutSkillObtationTypeInput = {
    capacityId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
    groupGameId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type statistic_group_gameCreateManyStatisticInput = {
    groupGameId: number
    pokemonId: number
  }

  export type statistic_group_gameUpdateWithoutStatisticInput = {
    groupGame?: group_gameUpdateOneRequiredWithoutStatisticGroupGamesNestedInput
    pokemon?: pokemonUpdateOneRequiredWithoutStatisticGroupGamesNestedInput
  }

  export type statistic_group_gameUncheckedUpdateWithoutStatisticInput = {
    groupGameId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
  }

  export type statistic_group_gameUncheckedUpdateManyWithoutStatisticInput = {
    groupGameId?: IntFieldUpdateOperationsInput | number
    pokemonId?: IntFieldUpdateOperationsInput | number
  }

  export type capacity_infoCreateManyTargetInput = {
    id?: number
    power: number
    dynamaxPower: number
    precision: number
    pp: number
    hasBacklash: boolean
    capacityEffectId: number
    capacityId: number
    capacityEffectZId: number
    typeId: number
    effectOutsideFightId: number
    capacityCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string
  }

  export type capacity_infoUpdateWithoutTargetInput = {
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityCategory?: capacity_categoryUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffect?: capacity_effectUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityEffectZ?: capacity_effectUpdateOneRequiredWithoutCapacityZInfosNestedInput
    capacity?: capacityUpdateOneRequiredWithoutCapacityInfosNestedInput
    effectOutsideFight?: effect_outside_fightUpdateOneRequiredWithoutCapacityInfosNestedInput
    type?: typeUpdateOneRequiredWithoutCapacityInfosNestedInput
    capacityInfoInfluences?: capacity_info_influenceUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateWithoutTargetInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    capacityInfoInfluences?: capacity_info_influenceUncheckedUpdateManyWithoutCapacityInfoNestedInput
    capsuleGameCapacityInfos?: capsule_game_capacity_infoUncheckedUpdateManyWithoutCapacityInfoNestedInput
  }

  export type capacity_infoUncheckedUpdateManyWithoutTargetInput = {
    id?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    dynamaxPower?: IntFieldUpdateOperationsInput | number
    precision?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    hasBacklash?: BoolFieldUpdateOperationsInput | boolean
    capacityEffectId?: IntFieldUpdateOperationsInput | number
    capacityId?: IntFieldUpdateOperationsInput | number
    capacityEffectZId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    effectOutsideFightId?: IntFieldUpdateOperationsInput | number
    capacityCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type capacity_info_influenceCreateManyCapacityInfoInput = {
    influenceId: number
  }

  export type capsule_game_capacity_infoCreateManyCapacityInfoInput = {
    capsuleId: number
    groupeGameId: number
  }

  export type capacity_info_influenceUpdateWithoutCapacityInfoInput = {
    influence?: influenceUpdateOneRequiredWithoutCapacityInfoInfluencesNestedInput
  }

  export type capacity_info_influenceUncheckedUpdateWithoutCapacityInfoInput = {
    influenceId?: IntFieldUpdateOperationsInput | number
  }

  export type capacity_info_influenceUncheckedUpdateManyWithoutCapacityInfoInput = {
    influenceId?: IntFieldUpdateOperationsInput | number
  }

  export type capsule_game_capacity_infoUpdateWithoutCapacityInfoInput = {
    capsule?: capsuleUpdateOneRequiredWithoutCapsule_game_capacity_infoNestedInput
    groupGame?: group_gameUpdateOneRequiredWithoutCapsuleGameCapacityIinfosNestedInput
  }

  export type capsule_game_capacity_infoUncheckedUpdateWithoutCapacityInfoInput = {
    capsuleId?: IntFieldUpdateOperationsInput | number
    groupeGameId?: IntFieldUpdateOperationsInput | number
  }

  export type capsule_game_capacity_infoUncheckedUpdateManyWithoutCapacityInfoInput = {
    capsuleId?: IntFieldUpdateOperationsInput | number
    groupeGameId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}